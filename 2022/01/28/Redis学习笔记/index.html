<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="概念​        Redis是一款基于键值对的NoSQL数据库，它的值支持多种数据结构：字符串(strings)、哈希(hashes)、列表(lists)、集合(sets)、有序集合(sorted sets)等。">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis学习笔记">
<meta property="og:url" content="http://example.com/2022/01/28/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="往南">
<meta property="og:description" content="概念​        Redis是一款基于键值对的NoSQL数据库，它的值支持多种数据结构：字符串(strings)、哈希(hashes)、列表(lists)、集合(sets)、有序集合(sorted sets)等。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-01-27T16:17:35.000Z">
<meta property="article:modified_time" content="2022-04-12T13:47:18.663Z">
<meta property="article:author" content="Bonnie">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2022/01/28/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Redis学习笔记 | 往南</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">往南</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/01/28/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bonnie">
      <meta itemprop="description" content="每天都要做个人啊">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="往南">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis学习笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-28 00:17:35" itemprop="dateCreated datePublished" datetime="2022-01-28T00:17:35+08:00">2022-01-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-12 21:47:18" itemprop="dateModified" datetime="2022-04-12T21:47:18+08:00">2022-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">学习笔记</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​        Redis是一款基于键值对的NoSQL数据库，它的值支持多种数据结构：字符串(strings)、哈希(hashes)、列表(lists)、集合(sets)、有序集合(sorted sets)等。</p>
<span id="more"></span>
<p>​        Redis将所有的数据都存放在内存中，所以它的读写性能十分惊人。同时，Redis还可以将内存中的数据以快照或日志的形式保存到硬盘上，以保证数据的安全性。</p>
<p>​        其中快照的形式，也叫RDB的形式，这种形式就是将内存中的数据原原本本存到硬盘上，这种形式的优点是数据体积小，如果想从硬盘恢复数据到内存里，速度会很快；而缺点是，因为是一次性将数据存到硬盘，这个过程会比较耗时，而且在存储的时候会产生阻塞，如果这个时候还在处理其他业务，会对其他业务有影响。所以快照的形式不适合实时的场景，而是适用于隔一段时间做一次备份的场景。</p>
<p>​        以日志的形式存数据到硬盘，这种形式叫AOF。每执行一次redis命令，就会以日志的形式把这个命令存下来。因为一个命令通俗来看就是一句话的记录，所以会比较快，适用于实时的场景。AOF以追加的形式存储，数据的体积会比较大，比较占磁盘空间；另外，如果想从磁盘把数据恢复到内存，就需要将记录的命令从头到尾再跑一遍，所以恢复的速度会比较慢。</p>
<p>​        Redis典型的应用场景包括:缓存、排行榜、计数器、社交网络、消息队列等。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h4 id="windows下安装："><a href="#windows下安装：" class="headerlink" title="windows下安装："></a>windows下安装：</h4><p>网址：<a target="_blank" rel="noopener" href="https://github.com/microsoftarchive/redis/releases">https://github.com/microsoftarchive/redis/releases</a></p>
<p>选择最新版本安装：<code>Redis-x64-3.0.504.msi</code></p>
<p>然后一路 <code>next</code> 默认安装。</p>
<h4 id="linux下安装"><a href="#linux下安装" class="headerlink" title="linux下安装"></a>linux下安装</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39135287/article/details/83474865">https://blog.csdn.net/qq_39135287/article/details/83474865</a></p>
<h3 id="测试是否安装成功（出现的报错）"><a href="#测试是否安装成功（出现的报错）" class="headerlink" title="测试是否安装成功（出现的报错）"></a>测试是否安装成功（出现的报错）</h3><blockquote>
<p>Could not connect to Redis at 127.0.0.1:6379: 由于目标计算机积极拒绝，无法连接。</p>
</blockquote>
<p>问题：没有启动 redis-server.exe</p>
<p>解决：</p>
<ol>
<li>使用两个cmd命令行，第一个输入 <code>redis-server redis.windows.conf</code>；</li>
<li>第二个cmd输入 <code>redis-cli</code></li>
</ol>
<blockquote>
<p> Can’t handle RDB format version 7</p>
</blockquote>
<p>问题：版本无法兼容。</p>
<p>解决：删除redis文件夹下的 <code>dump.rdb</code> 文件。</p>
<h3 id="maven项目-Java连接redis"><a href="#maven项目-Java连接redis" class="headerlink" title="maven项目 Java连接redis"></a>maven项目 Java连接redis</h3><ol>
<li><p>粘贴 <code>dependency</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如下代码完成基本测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.121.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">jedis.auth(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;服务正在运行：&quot;</span> + jedis.ping());</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="redis数据库"><a href="#redis数据库" class="headerlink" title="redis数据库"></a>redis数据库</h3><p>默认有16个内置的库，这些库没有名字，使用 <code>0 ~ databases.size() - 1</code> 的序列号来区分，客户端与redis建立连接后默认选择0号数据库。</p>
<ol>
<li>可以通过 <code>select num</code> 来更换库，其中 <code>num</code> 为库的序列号。</li>
<li>如果想删除一个库中的数据，在该库下执行 <code>flushdb</code> 命令；</li>
</ol>
<h3 id="操作String类型数据"><a href="#操作String类型数据" class="headerlink" title="操作String类型数据"></a>操作String类型数据</h3><p>存：<code>set key value</code></p>
<p>取：<code>get key</code></p>
<p>其中，对于 key，如果是多个单词组成，使用 <code>:</code> 连接。对于 key 和 value，类型都是 String。</p>
<p>让 value 自增1：<code>incr test:count</code>，会自动将 value 转换为 Integer 类型并加一。</p>
<p>让 value 自减1：<code>decr test:count</code>，自动将value减一。</p>
<h3 id="操作哈希类型的数据"><a href="#操作哈希类型的数据" class="headerlink" title="操作哈希类型的数据"></a>操作哈希类型的数据</h3><p>存：<code>hset key field value</code>，此处可以将 key 看成哈希表名称，将 field看成是 key。</p>
<p>取：<code>hget key field</code>。</p>
<p>具体实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hset test:user <span class="built_in">id</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hset test:user name zhangsan</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hget test:user <span class="built_in">id</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hget test:user name</span><br><span class="line"><span class="string">&quot;zhangsan&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="操作列表类型的数据"><a href="#操作列表类型的数据" class="headerlink" title="操作列表类型的数据"></a>操作列表类型的数据</h3><p>按照插入顺序排序，可以从两侧侧插入取出。所以可以实现队列和栈。</p>
<ol>
<li>左侧进：<code>lpush test:ids 101 102 103</code></li>
<li>查看长度：<code>llen test:ids</code></li>
<li>查看某一个索引对应的元素：<code>lindex test:ids 0</code></li>
<li>查看子列表：<code>lrange test:ids 0 2</code></li>
<li>右侧出：<code>rpop test:ids</code></li>
</ol>
<p>具体实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lpush test:ids <span class="number">101</span> <span class="number">102</span> <span class="number">103</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; llen test:ids</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lindex test:ids <span class="number">0</span></span><br><span class="line"><span class="string">&quot;103&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange test:ids <span class="number">0</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;103&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;102&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;101&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; rpop test:ids</span><br><span class="line"><span class="string">&quot;101&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="操作集合类型的数据"><a href="#操作集合类型的数据" class="headerlink" title="操作集合类型的数据"></a>操作集合类型的数据</h3><p>集合中的数据是无序的，不能存在重复数据。</p>
<ol>
<li>增数据：<code>sadd test:teachers aaa bbb ccc ddd</code></li>
<li>查看个数：<code>scard test:teachers</code></li>
<li>从集合随机删除一个元素：<code>spop test:teachers</code>，这个方式可以用于实现抽奖场景</li>
<li>查看集合中具体有哪些元素：<code>smembers test:teachers</code></li>
</ol>
<p>具体实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd test:teachers aaa bbb ccc ddd</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; scard test:teachers</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; spop test:teachers</span><br><span class="line"><span class="string">&quot;aaa&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers test:teachers</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;ddd&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;bbb&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;ccc&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="操作有序集合类型的数据"><a href="#操作有序集合类型的数据" class="headerlink" title="操作有序集合类型的数据"></a>操作有序集合类型的数据</h3><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。</p>
<p>不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。分数可以重复。</p>
<ol>
<li>增数据：<code>zadd test:students 10 aaa 20 bbb 1 ccc 30 ddd</code></li>
<li>查看个数：<code>zcard test:students</code></li>
<li>查看某个元素的分数：<code>zscore test:students ccc</code></li>
<li>查看某个元素的排名，默认从小到大，从0开始：<code>zrank test:students ccc</code></li>
<li>取某个范围内的数据：<code>zrange test:students 0 3</code></li>
</ol>
<p>具体实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd test:students <span class="number">10</span> aaa <span class="number">20</span> bbb <span class="number">1</span> ccc <span class="number">30</span> ddd</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zcard test:students</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zscore test:students ccc</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrank test:students ccc</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange test:students <span class="number">0</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;ccc&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;aaa&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;bbb&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;ddd&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="操作全局，对所有数据都有效"><a href="#操作全局，对所有数据都有效" class="headerlink" title="操作全局，对所有数据都有效"></a>操作全局，对所有数据都有效</h3><ol>
<li>查看库中目前有多少个key：<code>keys *</code></li>
<li>查看库中目前以 test 开头的key有多少个：<code>keys test*</code></li>
<li>查看key对应的值的类型：<code>type test:user</code></li>
<li>查看某个key是否存在：<code>exists test:User</code></li>
<li>删除某个key：<code>del test:user</code></li>
<li>设置key的过期时间，key 过期后将不再可用。单位以秒计：<code>expire test:teachers 5</code></li>
</ol>
<p>具体实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;test:count&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;test:user&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;test:students&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;test:list&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;test:ids&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;test:teachers&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys test*</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;test:count&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;test:user&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;test:students&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;test:list&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;test:ids&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;test:teachers&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">type</span> test:user</span><br><span class="line"><span class="built_in">hash</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; exists test:User</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; exists test:user</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">del</span> test:user</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; exists test:user</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; expire test:students <span class="number">2</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;test:count&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;test:list&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;test:ids&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;test:teachers&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; expire test:teachers <span class="number">5</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;test:count&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;test:list&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;test:ids&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;test:teachers&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;test:count&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;test:list&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;test:ids&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="redis的5种基本数据结构"><a href="#redis的5种基本数据结构" class="headerlink" title="redis的5种基本数据结构"></a>redis的5种基本数据结构</h3><p>​        redis的物种基本数据结构分别是：string、list、hash、set和zset。其中除了string以外的数据结构都是容器型的数据结构，它们共享两条通用规则：</p>
<ol>
<li>容器不存在则创建；</li>
<li>容器中没有元素则删除并释放内存。</li>
</ol>
<p>​        对于string，内部是一个字符数组，是一个动态字符串，允许修改，在结构上类似于Java的arraylist，默认大小为10，如果达到扩容阈值，会遵循扩容规则：如果小于1MB，扩容为原来的两倍（len = len * 2），否则是在原来的长度上增加1MB（len = len + 1MB），字符串的最大长度是512MB。</p>
<p>​        对于list，类似于Java的linkedlist，是一个双向链表的结构。正常的双向链表会有两个指针指向前面和后面，这种方式会带来不小的内存开销，所以在数据量不大的情况下，使用压缩列表作为底层结构。</p>
<p>​        压缩列表的目的是为了节约内存，会占用一块连续的内存空间，通过地址来顺序寻址访问。压缩列表的节点会存储三个部分：前一个结点的长度、当前节点实际数据的类型和长度以及当前节点的实际数据，因为是顺序访问，所以压缩列表不能保存过多元素，否则查询的效率就低了，并且新增或修改某个元素的时候，压缩列表占用的内存空间需要重新分配，可能会引发连锁更新的问题。也就是比如新增某个元素较大时，可能会导致后面的元素所占空间都要发生变化，这就是连锁更新。于是引入了quicklist。</p>
<p>​        quicklist的节点是quicklistnode，一个quicklistnode种会包含一个pre指针和next指针，这样就可以形成一个双向链表，但是节点的元素不是单纯的元素值，而是压缩列表，所以还会存在一个指向压缩列表的指针。但是quicklist并没有解决压缩列表的连锁更新的问题，于是引入一个新的数据结构listpak。</p>
<p>​        listpak和压缩列表的结构类似，都是使用一块连续的内存空间保存数据，不同的是，节点中不会记录前一个节点的长度，而只记录当前节点的长度，从而避免压缩列表的连锁更新问题。</p>
<p>​        对于hash，类似于Java的HashMap，底层也是数组+链表的结构，但是hash存储的value只能是string，并且扩容的方式是渐变的rehash。也就是并不是一次性完成迁移操作，会保留旧的hash结构，分多次迁移，在rehash进行期间，每次增删改查，除了执行对于的操作，还会顺序将旧表中索引位置上的所有数据迁移到新表上。新增的数据会保存到新表，以此来保证旧表的元素只会减少，最终变成一张空表。</p>
<p>​        对于set，类似于Java的HashSet，内部的值无序且唯一。</p>
<p>​        对于zset，类似于Java中SortedSet和HashMap的组合，一方面通过set保证数据的唯一，一方面通过value的score权重值来进行排序，这个排序的功能是通过跳表实现的。</p>
<p>​        跳表是在链表的基础上实现的一种多层的有序链表，能够快速定位数据。层级是zskiplistLevel结构体类型的数组，每一个元素都是一层，结构体中定义了指向下一个跳表节点的指针和跨度，跨度用来记录两个节点之间的距离。层级的设置算法是在<strong>创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</strong>。这样的做法，相当于每增加一层的概率不超过 25%，层数越高，概率越低，层高最大限制是 64。</p>
<p><strong>面试题：为什么zset使用跳表而不是红黑树？</strong></p>
<p>​        首先跳表的实现更加简单，不需要旋转链表，效率更高。</p>
<h3 id="redis使用场景"><a href="#redis使用场景" class="headerlink" title="redis使用场景"></a>redis使用场景</h3><ol>
<li>做缓存。</li>
<li>做计数器，比如电商网站的浏览量这些，为了保证数据的实时性，每次浏览都要加一，redis本身会提供一个incr命令来实现自增自减的功能。</li>
<li>分布式锁。</li>
<li>社交网络，比如点赞、踩、关注和被关注等基本功能，传统的数据库不适合存储这种类型的数据，redis提供的哈希、集合等数据结构可以很方便的实现这些功能。</li>
</ol>
<h3 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h3><p>​        有两种：AOF持久化和RDB快照。</p>
<h4 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h4><p>​        rdb快照就是记录某一时刻内存中的全量数据。rdb快照的持久化就是将这个快照生成rdb文件写入磁盘。有两种生成方式：</p>
<ol>
<li>save，在主进程生成，这种方式因为和执行操作的命令在同一进程，如果快照生成的速度比较慢，就会阻塞主进程；</li>
<li>bgsave，在子进程生成，这种方式就不会阻塞主进程的执行，是redis默认的生成方式。</li>
</ol>
<p>​        由于在生成快照期间，主进程依然可以执行，那么也可以对数据进行修改的，这就是引入了写时复制技术。具体的实现过程是：首先执行bgsave命令时，会通过fork()创建一个子进程，这个子进程会复制主进程的页表，所以它们共享同一块内存。在生成rdb的期间，如果主进程要修改共享内存中的数据，就会将要修改的这一块内存复制一个副本，在副本中进行修改，原本的数据会保持原样写入rdb文件，在本次快照生成过程中进行的修改，会到下次生成快照时再被写入。</p>
<p>​        这就会存在一个风险：如果在下次快照之前服务器宕机了，那么在快照生成期间修改的这部分数据就会丢失。并且在极端情况下，如果生成快照期间所有的共享数据都被修改了，那么此时内存的占用就会是原来的两倍，很容易出现内存溢出的情况。而且由于rdb是全量快照，所以快照的频率不能太高，否则redis的性能会下降；但是也不能太低，否则一旦故障，丢失的数据量就很大了。通常会设置5分钟进行一次快照。</p>
<h4 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h4><p>​        aof持久化就是将redis的写操作命令以追加的方式写入aof文件，然后在redis故障重启的时候只需要重做一次文件的操作就可以恢复数据。具体的执行流程是：当客户端提交写操作时，会先执行这个操作到内存，然后再写入文件。先执行再写入的目的是为了保证写入的命令是正确的，但是如果写操作执行后还没写入日志服务器就宕机，就会出现数据丢失。</p>
<p>​        redis写入日志的过程是：首先会将命令追加到aof缓冲区，然后aof缓冲区会根据写回策略将操作sync同步到磁盘的aof文件中，当磁盘中的aof文件超过指定大小或手动触发重写时，aof文件就会执行rewrite重写，来压缩aof文件，最后当redis重启时，会重做aof文件中的命令来恢复数据。</p>
<p>​        其中，写回策略有三个：always是每次写操作执行完后就会立刻同步写入磁盘，所以可以保证高可靠，但是因为频繁写入，肯定会产生一定的性能消耗；no是将写入的时机交给操作系统决定，是不可预测的，所以当服务器宕机而系统还没写回，就会出现数据丢失；everysec是执行完操作以后会先写入aof缓冲区，每隔一秒将缓冲区的数据写入磁盘，这种方式比较折中，在减少性能开销的同时，能保证就算出现数据丢失，也只是一秒的数据。</p>
<p>​        重写策略是为了避免aof文件过大，导致redis重启时执行的时间过长而产生的。当aof文件默认超过64M，就会触发重写。重写就是读取redis中现有的数据，将这些数据转换为命令写入一个新的aof文件中，等到全部写完，再将新的aof文件替换掉现有的aof文件。之所以使用新的文件而不复用原文件，是防止重写过程失败，污染现有的日志，让它无法用于恢复。</p>
<p>​        由于这个重写的过程是针对整个数据库的，所以会比较耗时。于是redis调用fork()创建一个子进程来专门执行这个操作。但是这就会产生一个问题：和rdb一样，主进程在子进程执行写入的时候，也是可以修改数据的，那么修改之后数据就不一致了。为了解决这个问题，redis设置了一个aof重写缓冲区。在重写过程中，redis执行了一个写命令，会同时将这个命令写入aof缓冲区和aof重写缓冲区。当子进程完成重写之后，会向主进程发送一条信号，主进程接收到信号后会调用一个信号处理函数，将重写缓冲区的记录追加到新的aof文件中，使得新旧数据库的状态保持一致，然后再将新的aof文件覆盖为当前的aof文件。</p>
<p><strong>面试题：如果AOF和RDB同时开启怎么办？</strong></p>
<p>​        如果AOF和RDB同时开启，redis默认会取AOF中的数据，但是数据不会存在丢失，RDB文件依然存在。</p>
<p><strong>面试题：AOF怎么开启</strong></p>
<p>​        AOF默认是不开启的，可以通过修改redis.conf配置文件中的appendonly为true开启AOF，AOF日志保存的路径，和RDB的路径是一致的，都在redis的启动路径下。</p>
<h3 id="淘汰机制（内存回收策略）"><a href="#淘汰机制（内存回收策略）" class="headerlink" title="淘汰机制（内存回收策略）"></a>淘汰机制（内存回收策略）</h3><p>​        首先需要了解淘汰机制出现的原因，因为缓存的容量是有限的，当缓存容量达到上限，就需要删除一些数据来挪空间放新数据。基于这个思想，redis定义了淘汰机制来解决内存被写满的问题。</p>
<p>​        淘汰机制主要考虑两个问题：淘汰哪些数据，以及如何处理淘汰的数据。</p>
<p>​        redis定义了8中内存淘汰的策略：</p>
<ol>
<li>noeviction：不会淘汰任何数据，当内存满了就报错；</li>
<li>volatile-ttl：筛选设置过期时间的键值对，删除最早过期的数据；</li>
<li>volatile-random：筛选设置过期时间的键值对，进行随机删除；</li>
<li>volatile-lru：筛选设置过期时间的键值对，使用lru算法删除；</li>
<li>volatile-lfu：筛选设置过期时间的键值对，使用lfu算法删除；</li>
<li>allkeys-random：对所有键值对进行随即删除；</li>
<li>allkeys-lru：对所有键值对使用lru算法删除；</li>
<li>allkeys-lfu：对所有键值对使用lfu算法删除。</li>
</ol>
<p>​        其中，noeviction是redis默认的淘汰策略，但是实际项目中一般不会使用这种策略。因为业务量通常都是会超过缓存容量的，这个策略步淘汰数据，就失去了使用缓存的初衷。</p>
<p>​        针对volatile相关的四种淘汰策略，设置了过期时间的数据会有两种情况被清理：要么是到了过期时间被删除，要么就是还没有到过期的时间，但是被规则选中，也会被删除。</p>
<p>​        对于allkeys相关的三种策略，与volatile相关的淘汰策略相比，它的范围是所有数据。</p>
<p>​        对于有明显冷热区分的业务数据，建议使用allkeys-lru，可以充分利用lru算法的优势，把最近最常访问的数据留在缓存，提高应用的访问性能；如果数据访问的频率都相差不大，建议使用allkeys-random进行随机淘汰；如果存在置顶需求，可以使用volatile相关的策略，不给置顶的内容设置过期时间，只对其他非置顶的数据进行淘汰。</p>
<p>​        接下来简单的聊一下LRU和LFU算法。</p>
<p>​        LRU是依据最近最少被使用的规则来筛选最不常用的数据进行删除。它将数据组成一个双向链表，然后依照访问顺序排序，也就是每访问一个数据，都会将这个数据移动到表头，那么最近最少被用到的数据就会集中在表尾。Redis中使用一个24bit的lru字段来标明这个数据的访问时间戳，在淘汰数据的时候，第一次会随机选择N个数据，把它们作为一个候选集合，然后比较这N个数据的lru字段，把最小的数据淘汰。这个N由参数maxmemory-samples来设置。然后后续再淘汰的时候，redis会选择lru值小于当前集合中最小lru的数据进入集合。这样，redis缓存不需要为所有数据维护一个链表，也不需要移动链表项，提高了缓存的性能。</p>
<p>​        LFU是在LRU的基础上，给数据增加了一个计时器，来统计数据的访问次数。具体的筛选规则是，先根据访问次数筛选，把访问次数最小的淘汰；如果访问次数相等，再根据访问时间筛选，把访问时间最久的淘汰。Redis中将lru字段切分为两个部分，前16bit存储访问时间戳，后8bit存访问次数。但是8bit的最大值是255，所以如果单纯使用这8个字节来计数最多只能记255次就无法区分了，于是引入一个配置项lfu_log_factor来辅助计数。</p>
<p>​        具体的计数规则是：当数据被访问一次，先用当前的值乘以lfu_log_factor，并加一，再取其倒数，得到一个p值，然后将p值和一个取值范围在(0, 1) 之间的随机数r值比大小，当p&gt;r时，计数器才加一。其中计数器的初始值是5而不是0，可以避免数据刚被写入缓存就因为访问次数少而被淘汰。使用这个规则，就可以通过设置不同的配置项来控制计数器增加的速度。通过redis官网的统计，配置项设置为10的时候，十万级的访问次数对应的计数依然存在明显区分，所以一般可以将配置项设置为10。</p>
<p>​        应用负载的情况是很复杂的，某些业务场景中，有些数据可能在短时间内被大量访问就不会再被访问了。为了避免这些数据的长时间缓存，redis设计了计数器的衰减机制。</p>
<p>​        LFU通过衰减因子配置项lfu_decay_time来控制计数器的衰减。先计算当前时间和数据最近一次被访问的时间的差值，将这个差值换算成分钟除以这个衰减因子，所得结果就是计数器要衰减的值。因为衰减因子是分母，所以值越大，衰减的效果就越弱，所以当业务中存在大量短时高频的数据时，建议设置为1。</p>
<p>​        LFU通常用于解决缓存污染的问题。缓存污染指的是在一些场景下，有些数据被访问的次数很少，当这些数据被访问完后，如果嗐继续留在缓存中，就会白白占用内存空间。缓存污染变得严重，就会有大量不再被访问的数据滞留在缓存，所以引入了LFU算法以访问次数为首要条件对数据进行淘汰。</p>
<p>​        最后说一下如何处理被淘汰的数据。redis选定了淘汰的数据，不会管这个数据是否是脏数据都会删除，那么当这个数据是脏数据时，淘汰就会导致数据丢失。脏数据指的是内存中的这个值于后端数据库对应的数据不一致，因为内存中的值被更新过但是还没被刷到库上。所以使用redis缓存时，一旦修改数据，就需要立刻同步到数据库中，避免数据丢失。</p>
<h3 id="缓存雪崩、穿透、击穿"><a href="#缓存雪崩、穿透、击穿" class="headerlink" title="缓存雪崩、穿透、击穿"></a>缓存雪崩、穿透、击穿</h3><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>​        当大量数据同时过期，或redis宕机时，刚好出现大量请求，此时无法在redis处理，就会全部去访问数据库，造成库的压力过大，导致数据库宕机，从而形成一连串连锁反应，造成整个系统崩溃，就是缓存雪崩。</p>
<p>​        对于大量数据同时过期的场景，可以均匀设置过期时间，给数据的过期时间添加一个随机数，保证数据不会在同一时间过期；也可以设置互斥锁，当线程处理用户请求，发现缓存没有对应数据，需要先获取对应的锁才能访问数据库读取，保证同一时间只会有一个线程构建缓存，不过最好给这个锁设置一个超时时间，否则如果一个请求拿到锁以后因为某种以外一直被阻塞，这个锁一直不释放，会造成整个系统的无响应；也可以使用双key策略，就是给数据设置两个key，主key设置过期时间，备key不设置过期时间，它们只是key不同，value相同，相当于给数据作一个副本，当业务线程访问不到主key的数据，就获取备key的数据，然后在更新缓存的时候，同时更新主key和备key的数据。</p>
<p>​        对于redis宕机的场景，可以设置服务熔断或请求限流机制，服务熔断是在redis宕机时暂停业务对缓存的访问，直接返回错误，等到redis恢复后再允许访问。但是这种方式会导致所有业务都无法正常执行，为了减少对业务的影响，可以使用请求限流机制，只将少部分请求发送到数据库进行处理，再多的请求就在入口处直接拒绝服务，直到redis恢复后在解除请求限流机制。</p>
<p>​        也可以设置redis的高可用集群，当主节点宕机，可以切换到从节点继续执行。</p>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>​        业务场景中通常会有几个数据被频繁访问，这些数据就是热点数据，当热点数据过期，此时大量请求访问该热点数据的线程就会直接访问数据库，数据库很容易就被这些请求冲垮，这就是缓存击穿。它和缓存雪崩很像，可以看成是缓存雪崩的一个子集。</p>
<p>​        解决的方法有两个。可以设置互斥锁，保证同一时间只有一个线程访问数据库更新缓存，其余线程要么等待锁释放再重新读取缓存，要么返回空值或默认值；也可以不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据即将过期前，提前通知后台线程更新缓存并重新设置过期时间。</p>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>​        当大量线程请求获取缓存和数据库中都不存在的数据，造成数据库的压力骤增，就会出现缓存穿透。出现缓存穿透的原因有两种：</p>
<ol>
<li>缓存和数据库中对应的数据都被误删了，导致这个数据不存在；</li>
<li>黑客恶意攻击，故意大量访问某些不存在的数据。</li>
</ol>
<p>​        常见的应对方案有三种：</p>
<ol>
<li>非法请求的限制。在API的入口处判断请求参数是否合理、是否含非法值、以及请求字段是否存在，如果判断出是而已请求就直接返回错误，避免进一步访问缓存和数据库。</li>
<li>缓存空值或默认值。对缓存和数据库都查不到的数据，在缓存中设置一个默认值或空值，这样后续就有可以返回的内容了。</li>
<li>通过布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在。在将数据写入数据库前，使用布隆过滤器对数据做标记，然后接收到请求后，确认不在缓存，就可以通过查询布隆过滤器来判断是否在数据库，如果不在，就可以不要访问数据库了。这样可以保证即便存在大量请求访问不存在的数据，也只会查缓存和过滤器，对数据库不会产生影响。布隆过滤器的实现原理是：布隆过滤器由一个初始值为0的位图数组和N个哈希函数组成，对数据进行标记时，会先使用N个哈希函数分别对数据进行哈希运算，得到N个哈希值，然后将这些哈希值对位图数组的长度取模，然后将每个哈希值对应在数组上的位置置1。不过既然是哈希相关，肯定会存在哈希冲突，所以通过布隆过滤器判断数据是否存在，如果不存在数据库中也一定不存在；但是存在可能数据库中并不存在。</li>
</ol>
<h3 id="Key的过期策略"><a href="#Key的过期策略" class="headerlink" title="Key的过期策略"></a>Key的过期策略</h3><p>​        可以通过 expire key seconds 来指定key的过期时间，返回1表示设置成功。主要是如何清除过期的数据。</p>
<p>​        定时策略是给每个key加一个计时器，这样当到达过期时间就会自动删除，这种方式对内存是友好的，可以及时清理掉过期的key，但是每个带有过期时间的key都进行计时，肯定会消耗一定的cpu。</p>
<p>​        惰性策略是在每次访问一个key的时候才去确认这个key是否过期，过期了就删除。但是如果一直没有访问到过期的key，这些key就会一直存在内存中。</p>
<p>​        也可以使用淘汰机制来处理。</p>
<h3 id="redis为什么这么快"><a href="#redis为什么这么快" class="headerlink" title="redis为什么这么快"></a>redis为什么这么快</h3><ol>
<li><p>基于内存。</p>
</li>
<li><p>高效的数据结构。</p>
</li>
<li><p>合适的线程模型。</p>
<p>​        首先使用IO多路复用模型。在生产环境中通常会有多个客户端连接redis，然后各自发送命令到redis，最后服务器处理完后返回结果。IO多路复用模型会同时监听多个套接字，并将这些请求推送到一个消息队列中，然后逐一执行，最终返回结果给客户端。</p>
<p>​        其次由于redis是单线程的，所以能够避免上下文的切换带来的开销。说redis是单线程是因为IO多路复用程序在接收到用户请求会将其推送到一个消息队列中等待服务器逐一处理，redis是基于这个消息队列工作的，而这个消息队列是单线程的工作方式，所以是单线程的。</p>
</li>
</ol>
<h3 id="redis的主从复制原理"><a href="#redis的主从复制原理" class="headerlink" title="redis的主从复制原理"></a>redis的主从复制原理</h3><p>​        redis的主从节点的实现和MySQL很像，都是主节点负责写，从节点负责读根同步。同步的实现</p>
<h3 id="写操作下数据库和redis的先后顺序问题（数据库和缓存如何保证一致性）"><a href="#写操作下数据库和redis的先后顺序问题（数据库和缓存如何保证一致性）" class="headerlink" title="写操作下数据库和redis的先后顺序问题（数据库和缓存如何保证一致性）"></a>写操作下数据库和redis的先后顺序问题（数据库和缓存如何保证一致性）</h3><p>​        对于数据库和redis，有四种解法：先更新缓存再更新数据库、先更新数据库再更新缓存、先删除缓存再更新数据库和先更新数据库再删除缓存。</p>
<p>​        如果先更新数据库再更新缓存，假设请求A更新数据库的值为1，然后在更新缓存前，请求B将数据库的值更新为2，紧接着将缓存也更新为2，然后A再将缓存更新为1，就会出现不一致现象。</p>
<p>​        如果先更新缓存再更新数据库，假设在请求A更新缓存后，请求B更新了缓存和数据库，然后A再更新数据库，也会出现不一致现象。</p>
<p>​        综上，无论是先更新数据库还是先更新缓存都会导致数据的不一致，于是考虑删除缓存。这里就需要区分读和写的问题了。对于写操作，会更新数据库和删除对应的缓存；对于读操作，如果缓存中存在就返回缓存的结果，否则从数据库读取并写入缓存再返回结果。</p>
<p>​        如果先删缓存再更新数据库，假设此时读写并发，写操作删除了缓存，紧接着读操作没有命中缓存，就回到数据库读取并写入缓存，但是此时数据库还未更新，是旧值，那么写回缓存的依然是旧值，之后写操作更新数据库，就会导致不一致性的出现。</p>
<p>​        如果是先更新数据库再删除缓存，在读写并发的情况下，读操作未命中缓存会到数据库读取，紧接着写操作更新数据库并删除缓存，然后读操作将旧值写入缓存，这样也会导致数据的不一致，但是在实际过程下，这种情况出现的概率并不高，因为缓存的写入往往快于数据库的写入，所以在一般情况下是可以保证数据的一致性的。但是为了防止这种情况的发生，会给缓存的数据添加一个过期时间，这样就能保证即便出现数据的不一致性也是短期的，能够保证数据的最终一致。</p>
<h3 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a>redis分布式锁</h3><p>​        在分布式系统下，会有多台机器同时运行，分布式锁就是保证在多台机器下能够让共享资源依然能互斥使用。</p>
<p>​        具体的实现是：</p>
<ol>
<li>使用 setnx 上锁，del 解锁；</li>
<li>为了防止锁一直不释放的情况，给key设置过期时间，到点自动释放：expire key secs；</li>
<li>如果上锁之后系统突然异常就会导致无法设置过期时间，解决的方法是在上锁的同时设置过期时间：set key val nx ex secs。</li>
</ol>
<h2 id="借鉴"><a href="#借鉴" class="headerlink" title="借鉴"></a>借鉴</h2><p><a target="_blank" rel="noopener" href="https://www.nowcoder.com/study/live/246/4/1">https://www.nowcoder.com/study/live/246/4/1</a></p>

    </div>

    
    
    
	  
	
	 <div>
		<div>
    
        <div style="text-align:center;color: #ccc;font-size:24px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
	 </div>
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/redis/" rel="tag"># redis</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/26/LeetCode-152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/" rel="prev" title="LeetCode - 152. 乘积最大子数组">
      <i class="fa fa-chevron-left"></i> LeetCode - 152. 乘积最大子数组
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/01/28/LeetCode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/" rel="next" title="LeetCode - 160. 相交链表">
      LeetCode - 160. 相交链表 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85"><span class="nav-number">2.</span> <span class="nav-text">安装</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#windows%E4%B8%8B%E5%AE%89%E8%A3%85%EF%BC%9A"><span class="nav-number">2.0.1.</span> <span class="nav-text">windows下安装：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#linux%E4%B8%8B%E5%AE%89%E8%A3%85"><span class="nav-number">2.0.2.</span> <span class="nav-text">linux下安装</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F%EF%BC%88%E5%87%BA%E7%8E%B0%E7%9A%84%E6%8A%A5%E9%94%99%EF%BC%89"><span class="nav-number">2.1.</span> <span class="nav-text">测试是否安装成功（出现的报错）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#maven%E9%A1%B9%E7%9B%AE-Java%E8%BF%9E%E6%8E%A5redis"><span class="nav-number">2.2.</span> <span class="nav-text">maven项目 Java连接redis</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">3.</span> <span class="nav-text">常用命令</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#redis%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">3.1.</span> <span class="nav-text">redis数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9CString%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE"><span class="nav-number">3.2.</span> <span class="nav-text">操作String类型数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E5%93%88%E5%B8%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">3.3.</span> <span class="nav-text">操作哈希类型的数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">3.4.</span> <span class="nav-text">操作列表类型的数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">3.5.</span> <span class="nav-text">操作集合类型的数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="nav-number">3.6.</span> <span class="nav-text">操作有序集合类型的数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E5%85%A8%E5%B1%80%EF%BC%8C%E5%AF%B9%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E9%83%BD%E6%9C%89%E6%95%88"><span class="nav-number">3.7.</span> <span class="nav-text">操作全局，对所有数据都有效</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">4.</span> <span class="nav-text">面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#redis%E7%9A%845%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.1.</span> <span class="nav-text">redis的5种基本数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">4.2.</span> <span class="nav-text">redis使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="nav-number">4.3.</span> <span class="nav-text">持久化方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RDB%E5%BF%AB%E7%85%A7"><span class="nav-number">4.3.1.</span> <span class="nav-text">RDB快照</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">4.3.2.</span> <span class="nav-text">AOF持久化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%EF%BC%88%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5%EF%BC%89"><span class="nav-number">4.4.</span> <span class="nav-text">淘汰机制（内存回收策略）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF"><span class="nav-number">4.5.</span> <span class="nav-text">缓存雪崩、穿透、击穿</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">4.5.1.</span> <span class="nav-text">缓存雪崩</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-number">4.5.2.</span> <span class="nav-text">缓存击穿</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">4.5.3.</span> <span class="nav-text">缓存穿透</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Key%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="nav-number">4.6.</span> <span class="nav-text">Key的过期策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB"><span class="nav-number">4.7.</span> <span class="nav-text">redis为什么这么快</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="nav-number">4.8.</span> <span class="nav-text">redis的主从复制原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E6%93%8D%E4%BD%9C%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8Credis%E7%9A%84%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98%EF%BC%88%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%89"><span class="nav-number">4.9.</span> <span class="nav-text">写操作下数据库和redis的先后顺序问题（数据库和缓存如何保证一致性）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">4.10.</span> <span class="nav-text">redis分布式锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%80%9F%E9%89%B4"><span class="nav-number">5.</span> <span class="nav-text">借鉴</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bonnie"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Bonnie</p>
  <div class="site-description" itemprop="description">每天都要做个人啊</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">122</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">71</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021-05 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bonnie</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
