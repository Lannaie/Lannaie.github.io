<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. Java语言的特点Java语言的主要特点有：">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 面试题">
<meta property="og:url" content="http://example.com/2021/11/15/Java-%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="往南">
<meta property="og:description" content="1. Java语言的特点Java语言的主要特点有：">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-11-15T13:39:32.000Z">
<meta property="article:modified_time" content="2022-02-08T15:11:41.744Z">
<meta property="article:author" content="Bonnie">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2021/11/15/Java-%E9%9D%A2%E8%AF%95%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java 面试题 | 往南</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">往南</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/15/Java-%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bonnie">
      <meta itemprop="description" content="每天都要做个人啊">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="往南">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 面试题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-15 21:39:32" itemprop="dateCreated datePublished" datetime="2021-11-15T21:39:32+08:00">2021-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-08 23:11:41" itemprop="dateModified" datetime="2022-02-08T23:11:41+08:00">2022-02-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1-Java语言的特点"><a href="#1-Java语言的特点" class="headerlink" title="1. Java语言的特点"></a>1. Java语言的特点</h2><p>Java语言的主要特点有：</p>
<span id="more"></span>

<ol>
<li>面向对象：Java是一门面向对象的高级编程语言，所谓的面向对象实际上是一种思考的模式，通过模拟现实世界来解决现实问题。</li>
<li>简单性：首先Java具有自动内存管理机制，比如c语言中会有析构函数如delete、free等，在内存使用完毕需要手动去释放内存，但是Java语言在内存使用完成后就不用再管，内存会被自动回收，这样不容易造成内存溢出；其次，Java借鉴了一些老牌编程语言的特性，简化了流程的处理，同时也简化了Java过程中的语义，比如goto这些在Java中就被顶替掉了，通过其他的方式在语义清晰的情况下达到原有的目的。</li>
<li>跨平台：指的是软件可以在任意计算机环境中正常运行，而不需要考虑计算机硬件和操作系统的约束，实现了Java一次编译到处运行的目标。因为Java会将源码编译为字节码，字节码是无关平台的，任意平台上的JVM都会向Java编译器提供一个相同的接口用来获取字节码，所以Java语言是具有跨平台性的。</li>
</ol>
<p>​        具体说到字节码，就肯定要先知道机器码。我们当前使用的大部分语言都是高级语言，而这些语言使用的源码，都由英文和符号组成，这种代码是无法被计算机直接识别的，我们需要将其翻译为机器码交由计算机执行。翻译的过程有两种形式：编译和解释。编译指的是在程序运行前，将源码全部翻译为机器码，再交由计算机执行；解释指的是在程序运行时，将代码解释一行，交由计算机执行一行。编译的好处是执行的效率会很高，但是由于不同计算机的机器码不同，所以可以执行很低，面对不同的计算机，就需要重新编译源代码，甚至额能要修改部分源码；而解释的效率会比较低，但是可移植性高，不同计算机的解释器和机器码是一致的，所以只需要使用一份源码交给不同的解释器执行就可以。<br>​        而Java语言使用先编译后解释的方式，其中就引出了字节码。Java语言先将源码编译为字节码文件，然后将字节码提交给计算机，在程序运行时解释i解码文件。因为字节码也是二进制文件，与机器码很像，所以从字节码转换为机器码就会更快一点。综上，Java语言相较于纯的编译型语言，可移植性更高，相较于解释型语言，解释的效率也会更高。</p>
<hr>
<h3 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h3><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><p>就是分析出系统中应包含哪些对象，以及它们之间的关系，再用特定的语法来描述这些对象和关系。</p>
<p>比如，使用面向对象的思想来说一下上课的过程。有电瓶车和司机，司机开电瓶车，我要坐电瓶车去上课，然后有学生，上课的点有许多学生要上车，还有教学楼，乘车到目的的教学楼然后下车前往教室上课。</p>
<h2 id="2-JDK、JRE和JVM的区别和联系"><a href="#2-JDK、JRE和JVM的区别和联系" class="headerlink" title="2. JDK、JRE和JVM的区别和联系"></a>2. JDK、JRE和JVM的区别和联系</h2><p>​        JDK是Java标准开发包，包括编译以及运行Java程序所需的各种工具和资源，比如Java编译器、Java运行时环境、常用的Java类库等。</p>
<p>​        JRE是Java运行时环境，用于解释和执行字节码文件，普通用户只需要运行Java程序安装JRE就好，如果要编译和调试程序需要安装JDK。</p>
<p>​        JVM即Java虚拟机，是JRE的一部分，是Java跨平台最核心的部分，用于解释和执行字节码文件。所有平台的JVM虚拟机都向Java编译器提供一个相同的接口，Java编译器只需要面向JVM，生成虚拟机能够识别的字节码，就可以实现跨平台运行。</p>
<h2 id="3-类和对象"><a href="#3-类和对象" class="headerlink" title="3. 类和对象"></a>3. 类和对象</h2><p>类可以相当于设计图，用于描述一批对象的信息，它是抽象的，不是具体的实例；</p>
<p>对象是具体的，是根据类的描述，由JVM创建出来的一个实例，这个过程叫实例化；</p>
<p>类是自定义的数据类型，通过这个类创建对象，实际上就是初始化这种类型的变量。</p>
<h2 id="4-面向对象的三大特征"><a href="#4-面向对象的三大特征" class="headerlink" title="4. 面向对象的三大特征"></a>4. 面向对象的三大特征</h2><p>三大特征为：封装、继承、多态。</p>
<ol>
<li>封装：指属性私有化，隐藏具体实现的细节，仅提供setter和getter方法来访问属性，用于提高数据安全性，类和方法也属于封装；</li>
<li>继承：指将多个相同的属性和方法提取出来，新建为一个父类，子类可以重写其中的方法，用于代码复用；</li>
<li>多态：分为两种，编译时多态和运行时多态，编译时多态即重载，方法名相同而参数不同；运行时多态即重写，子类重写父类方法，用于增强代码的灵活度。</li>
</ol>
<h2 id="5-修饰符"><a href="#5-修饰符" class="headerlink" title="5. 修饰符"></a>5. 修饰符</h2><p>分为访问修饰符和非访问修饰符。</p>
<p><strong>访问修饰符有：</strong></p>
<ol>
<li>public：对所有的类都可见；</li>
<li>protected：对同一个包可见，如果父类和子类不同包，对不同包的子类可见；</li>
<li>default：对同一个包可见；</li>
<li>private：对同一个类可见。</li>
</ol>
<p><strong>非访问修饰符有：</strong></p>
<ol>
<li>static：声明的对象初始化后不能再修改；</li>
<li>final：修饰的类不能被继承，修饰的方法不能重新定义，修饰的变量为常量；</li>
<li>synchronized：用于多线程同步；</li>
<li>abstract：用来创建抽象类和方法。</li>
</ol>
<h2 id="6-Object类的常用方法"><a href="#6-Object类的常用方法" class="headerlink" title="6. Object类的常用方法"></a>6. Object类的常用方法</h2><ol>
<li>equals() - 判断相等</li>
<li>hashCode() - 返回散列值；</li>
<li>toString() - 返回对象的字符串表示；</li>
<li>clone() - 创建并返回对象的克隆对象，一般子类会重写该方法；</li>
<li>finalized() - 当垃圾收集确定对象没有更多的引用时，由该对象的垃圾收集器调用；</li>
<li>getClass() - 返回此对象的运行时class类对象；</li>
<li>notify() - 唤醒正在此对象监视器上等待的某个线程，主要用于多线程通信，需配合wait()方法使用；</li>
<li>notifyAll() - 唤醒正在此对象监视器上等待的全部线程；</li>
<li>wait() - 导致当前线程等待，直到另一个对象调用该对象的notify() 或 notifyAll() 方法；</li>
<li>wait(long timeout) - 导致当前线程等待，直到另一个对象调用该对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法，或经过指定的timeout时间；</li>
<li>wait(long timeout, int nanos) - 导致当前线程等待，直到另一个对象调用当前对象的 <code>notify()</code> 或 <code>notifyAll()</code> 或经过指定的timeout时间或被其他线程中断当前线程。其中timeout参数是毫秒值，nanos参数是毫微秒值，二者之和用于指定超时时间。</li>
</ol>
<h2 id="7-字符型常量和字符串常量的区别"><a href="#7-字符型常量和字符串常量的区别" class="headerlink" title="7. 字符型常量和字符串常量的区别"></a>7. 字符型常量和字符串常量的区别</h2><ol>
<li>字符型用单引号，字符串用双引号；</li>
<li>字符型相当于一个ascii值，可以直接参与计算，字符串是一个地址值，代表该字符串在内存中存放的位置；</li>
<li>Java中字符型占两个字节，字符串占若干字节，其中每个字符占一个字节，字节数由其中的字符数决定。</li>
</ol>
<h2 id="8-常见的关键字"><a href="#8-常见的关键字" class="headerlink" title="8. 常见的关键字"></a>8. 常见的关键字</h2><p>private、default、public、protected、static初始化后不再更改、this表示当前类的对象引用、final避免重写等。</p>
<h2 id="9-标识符和关键字的区别"><a href="#9-标识符和关键字的区别" class="headerlink" title="9. 标识符和关键字的区别"></a>9. 标识符和关键字的区别</h2><p>标识符是用户编程时创建的名称，关键字是具有特殊含义的单词。</p>
<h2 id="10-泛型和泛型擦除"><a href="#10-泛型和泛型擦除" class="headerlink" title="10. 泛型和泛型擦除"></a>10. 泛型和泛型擦除</h2><p>​        参数化类型被称为泛型，泛型允许在创建集合时指定元素的类型，则集合中只保存这种类型的元素。泛型的作用是在发生编译时，提供安全检查机制。</p>
<p>​        泛型类允许在定义接口、类、方法时声明类型形参，该类型形参在整个接口、类、方法中可以作为普通类型使用，直到声明变量、创建对象或调用方法时再动态的指定实际的参数类型。如果要定义泛型类的子类，因为此时是在使用父类了，所以必须传入实参，或者不传参。</p>
<p>​        在定义泛型的时候也可以指定类型形参的上限，如 <code>class A&lt;T extends B&gt;</code> ，该声明表示，传入的实参为类型 <code>B</code> 及其子类。</p>
<p>​        而泛型擦除是指，当把一个具有泛型信息的对象赋值给一个没有泛型的对象，就会把尖括号之间的所有泛型信息都扔掉，比如List&lt;Integer&gt; 类型会转换为 List 类型，则该 List 元素的类型就会变成该类型变量的上限。如果反过来，就是泛型转换。</p>
<h2 id="11-x3D-x3D-和-equals-的区别，以及hashCode-和-euqlas"><a href="#11-x3D-x3D-和-equals-的区别，以及hashCode-和-euqlas" class="headerlink" title="11. &#x3D;&#x3D; 和 equals() 的区别，以及hashCode() 和 euqlas()"></a>11. &#x3D;&#x3D; 和 equals() 的区别，以及hashCode() 和 euqlas()</h2><ol>
<li><p>&#x3D;&#x3D; 和 equals() 的区别：&#x3D;&#x3D;比较基本类型会判断两个值是否相同，比较引用类型会判断两个地址是否相同；equals只会判断引用类型的两个地址是否相同。</p>
</li>
<li><p>hashCode() 和 equals() 的区别和联系：</p>
<p>（1）HashCode()返回的值是一个对象在hash表中的位置，这个位置是依据特定的hash算法得到的，所以，两个不同的对象有可能有相同的hash code；<br>（2）相同的hash code，equals()返回的值不一定是true；equals返回值为true的，hash code一定相同；</p>
</li>
</ol>
<p>（3）hashcode()和equals()常被组合用于排序，在大型排序中，常会重写hashcode()和equals()方法，让具有相同hashcode的对象执行equals()方法，以提高排序的效率。</p>
<h2 id="12-基本的数据类型有哪些？自动装箱和拆箱？"><a href="#12-基本的数据类型有哪些？自动装箱和拆箱？" class="headerlink" title="12. 基本的数据类型有哪些？自动装箱和拆箱？"></a>12. 基本的数据类型有哪些？自动装箱和拆箱？</h2><ol>
<li>Java支持的数据类型有两种：基本数据类型和引用类型。</li>
</ol>
<p>（1）基本数据类型有8个：int、short、double、float、byte、char、long、boolean；</p>
<p>（2）引用类型比如 String、Integer等。</p>
<ol start="2">
<li><p>自动装箱和拆箱：</p>
<p>​        自动装箱和拆箱是基本类型和包装器类型之间的转换，比如是 <code>int</code> 和 <code>Integer</code> 之间的转换，自动装箱将 <code>int</code> 转换为 <code>Integer </code>，拆箱反之。</p>
<p>​        装箱和拆箱的实现过程是：装箱通过调用包装器的 <code>valueOf</code> 方法实现，拆箱通过调用包装器的 <code>xxxValue</code> 实现，如 <code>intValue</code> 。</p>
</li>
<li><p>引申问题①：<strong>Integer i &#x3D; new Integer(10)</strong> 和 <strong>Integer i &#x3D; 10</strong> 的区别</p>
<p>（1）第一种方式不会触发自动装箱，第二种会；</p>
<p>（2）一般情况下，第二种方式的执行效率和资源占比会比第一种方式高，但不是绝对的。</p>
</li>
<li><p>引申问题②：下面程序的输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer i1 = <span class="number">100</span>;</span><br><span class="line">    Integer i2 = <span class="number">100</span>;</span><br><span class="line">    Integer i3 = <span class="number">200</span>;</span><br><span class="line">    Integer i4 = <span class="number">200</span>;</span><br><span class="line">   </span><br><span class="line">    System.out.println(i1 == i2);</span><br><span class="line">    System.out.println(i3 == i4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：</p>
<blockquote>
<p>true</p>
<p>false</p>
</blockquote>
<p><strong>因为Integer的范围是：-128 ~ 127</strong> 。Integer、Short、Byte、Character、Long这几个类的 <code>valueOf</code> 是类似的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Double i1 = <span class="number">100.0</span>;</span><br><span class="line">    Double i2 = <span class="number">100.0</span>;</span><br><span class="line">    Double i3 = <span class="number">200.0</span>;</span><br><span class="line">    Double i4 = <span class="number">200.0</span>;</span><br><span class="line">   </span><br><span class="line">    System.out.println(i1 == i2);</span><br><span class="line">    System.out.println(i3 == i4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：</p>
<blockquote>
<p>false</p>
<p>false</p>
</blockquote>
<p><strong>因为在某个范围整形是有限的，而浮点数不是</strong> 。Double、Float的 <code>valueOf</code> 是类似的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Boolean i1 = <span class="keyword">false</span>;</span><br><span class="line">    Boolean i2 = <span class="keyword">false</span>;</span><br><span class="line">    Boolean i3 = <span class="keyword">true</span>;</span><br><span class="line">    Boolean i4 = <span class="keyword">true</span>;</span><br><span class="line">   </span><br><span class="line">    System.out.println(i1 == i2);</span><br><span class="line">    System.out.println(i3 == i4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：</p>
<blockquote>
<p>true</p>
<p>true</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="number">1</span>;</span><br><span class="line">    Integer b = <span class="number">2</span>;</span><br><span class="line">    Integer c = <span class="number">3</span>;</span><br><span class="line">    Long g = <span class="number">3L</span>;</span><br><span class="line">    Long h = <span class="number">2L</span>;</span><br><span class="line">   </span><br><span class="line">    System.out.println(c==(a+b)); <span class="comment">//1</span></span><br><span class="line">    System.out.println(c.equals(a+b)); <span class="comment">//2</span></span><br><span class="line">    System.out.println(g==(a+b)); <span class="comment">//3</span></span><br><span class="line">    System.out.println(g.equals(a+b)); <span class="comment">//4</span></span><br><span class="line">    System.out.println(g.equals(a+h)); <span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：</p>
<blockquote>
<p>true<br>true<br>true<br>false<br>true</p>
</blockquote>
<p>首先我们需要知道：</p>
<p>（1）算术运算符仅对于基本数据类型，所以包装器类型进行运算的时候会自动拆箱；</p>
<p>（2）<code>equals</code> 会比较两个对象的类型和值。</p>
<p>所以可以得知 <code>1</code> 、<code>2</code> 和 <code>3</code> 都是 <code>true</code> ，<code>4</code> 因为 <code>Integer</code> 和 <code>Long</code> 类型不同所以是 <code>false</code>，<code>5</code> 因为 <code>h</code> 是 <code>Long</code> 类型，<code>Long</code> 比 <code>Integer</code> 的范围广泛，所以相加后自动装箱会转换为 <code>Long</code> ，之后比较值是相等的，所以是相等的。</p>
</li>
</ol>
<h2 id="13-重载和重写？深拷贝和浅拷贝？"><a href="#13-重载和重写？深拷贝和浅拷贝？" class="headerlink" title="13. 重载和重写？深拷贝和浅拷贝？"></a>13. 重载和重写？深拷贝和浅拷贝？</h2><ol>
<li>重载和重写：重载是方法名相同参数不同；重写是继承父类方法并重写它。</li>
<li>深拷贝和浅拷贝：浅拷贝是拷贝原对象的引用值；深拷贝是根据原对象创建一个新对象。</li>
</ol>
<h2 id="14-方法的四种类型"><a href="#14-方法的四种类型" class="headerlink" title="14. 方法的四种类型"></a>14. 方法的四种类型</h2><p>无参无返回值、无参有返回值、有参无返回值、有参有返回值。</p>
<h2 id="15-常见设计模式"><a href="#15-常见设计模式" class="headerlink" title="15. 常见设计模式"></a>15. 常见设计模式</h2><h3 id="设计模式的原则"><a href="#设计模式的原则" class="headerlink" title="设计模式的原则"></a>设计模式的原则</h3><ol>
<li><p>单一原则：</p>
<p>​    即一个类只有一个职责；</p>
</li>
<li><p>开闭原则：</p>
<p>​    软件实体可扩展，但不可修改。</p>
<p>​    就好比“一国两制”，一个国家有两种制度，没有修改原有的管理制度，而是增加了一种新的制度。对于扩展是开放的，对于更改是封闭的。</p>
</li>
<li><p>里氏代换原则：</p>
<p>​    子类型必须能够替换掉它们的父类型。</p>
<p>​    举个例子，假如现在父类是鸟类，有个属性是可以飞，子类有个企鹅类，那么很明显企鹅类不能继承鸟类，因为鸟类有会飞的属性，如果子类企鹅类继承父类鸟类，则企鹅必须会飞。</p>
</li>
<li><p>依赖倒置原则：</p>
<p>​    高层模块不应该依赖底层模块，两个都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象。后面这句话换个方式说就是针对接口编程，不要对实现编程。</p>
<p>​    举个例子，就好比你的电脑，如果CPU、内存、硬盘都需要依赖具体的主板，主板坏了，所有的部件都不能用了，这显然是不合理的。</p>
<p>​    换句话说，即谁也不要依赖谁，除了约定的接口，大家都可以灵活自如。</p>
</li>
<li><p>接口隔离原则：</p>
<p>​    接口尽量细化，使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p>
<p>​    比如有一个学生成绩管理程序，包含插入成绩、删除成绩、修改成绩、打印成绩等功能，这些功能全都放到一个统一的接口中显然是不合理的，正确的作法应该是分为输入、打印等模块进行处理。</p>
</li>
<li><p>迪米特原则：</p>
<p>​    尽量减少对象之间的交互，可以引入一个合理的第三方来降低现有对象之间的耦合度。</p>
<p>​    比如体育老师上课前清点人数，他让体育委员来替他清点人数，之后再由体育委员告知结果即可，老师本身并没有接触到其他学生。</p>
</li>
<li><p>合成&#x2F;聚合复用原则</p>
<p>​    尽量使用合成&#x2F;聚合，尽量不要使用类继承。</p>
<p>​    合成表示一种强的“拥有”关系，体现了严格的部分与整体的关系，他们的生命周期相同；而聚合表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。</p>
<p>​    这里再举个简单的例子，大雁与翅膀是合成关系；而每只大雁都属于一个雁群，即一个雁群可以有多只大雁，所以大雁和雁群是聚合关系。</p>
</li>
</ol>
<h3 id="（1）-单例模式"><a href="#（1）-单例模式" class="headerlink" title="（1） 单例模式"></a>（1） 单例模式</h3><p>使用单一的类创建对象，它只有一个实例，必须自己创建。</p>
<p>懒汉式 - 线程不安全：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton Instance;</span><br><span class="line">    <span class="comment">//私有构造方法，保证外界无法直接实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>( Instance == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            Tnstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式延迟实例化，好处是没有用到该类，就不会实例化Instance，从而节约资源；坏处是线程不安全，多线程情况下会多次创建实例。</p>
<p>懒汉式 - 线程安全：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton Instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( Instance == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            Instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对静态代码 <code>getInstance()</code> 加锁，以确保多线程环境下只会创建一个实例。</p>
<p>饿汉式 - 线程安全：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton Instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接实例化，不会产生线程不安全的问题，但是这也丢失了延迟实例化带来的节约资源的好处。</p>
<p>双重校验锁 - 线程安全：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton Instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( Instance == <span class="keyword">null</span> )<span class="comment">//为了提高代码执行效率，如果已经创建了实例就不需要再竞争锁了。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>( Singleton.class )<span class="comment">// 类锁，表示只能进入一个实例</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( Instance == <span class="keyword">null</span> )<span class="comment">//防止二次创建实例</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>内存中只有一个实例，减少了内存开支。</li>
<li>避免对资源的多重占用，比如写文件操作，只有一个实例时，避免对同一个资源文件同时写操作。</li>
</ul>
<p>缺点：</p>
<ul>
<li>没有接口，不能继承，与单一职责冲突。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>应用程序的日志应用一般使用单例模式实现，因为共享的日志文件一般会一直处于打开状态，所以只能有一个实例取操作，否则内容不好追加；</li>
<li>操作系统的文件系统也是使用单例模式操作的，因为一个操作系统只能有一个文件系统。</li>
</ul>
<h4 id="此处可能会询问volatile的好处"><a href="#此处可能会询问volatile的好处" class="headerlink" title="此处可能会询问volatile的好处"></a>此处可能会询问volatile的好处</h4><p>​        Instance 采用 volatile 关键字修饰也是很有必要的， <code>Instance = new Singleton();</code> 这段代码其实是分为三步执行：分配内存、初始化、指向分配的地址。由于JVM具有指令重排的特性，执行顺序可能会改变，指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 抢占了 T1 的资源，调用 geteInstance() 后发现 Instance 不为空，因此返回 Instance，但此时 Instance 还未被初始化。</p>
<p>​        使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<h3 id="（2）工厂模式"><a href="#（2）工厂模式" class="headerlink" title="（2）工厂模式"></a>（2）工厂模式</h3><h4 id="1-说一说你对工厂模式的理解"><a href="#1-说一说你对工厂模式的理解" class="headerlink" title="1. 说一说你对工厂模式的理解"></a>1. 说一说你对工厂模式的理解</h4><p>工厂模式的用意是定义一个创建产品对象的工厂接口，将实际创建性工作推迟到子类中。工厂模式可分为简单工厂、工厂方法和抽象工厂模式。</p>
<ol>
<li><p>简单工厂</p>
<p>简单工厂的实现思路是，定义一个工厂类，根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或接口。简单工厂的适用场景是：</p>
<ul>
<li>需要创建的对象较少。</li>
<li>客户端不关心对象的创建过程。</li>
</ul>
<p><strong>实例：</strong></p>
<p>创建一个可以绘制不同形状的绘图工具，可以绘制圆形，正方形，三角形，每个图形都会有一个draw()方法用于绘图。</p>
<p>由题可知圆形，正方形，三角形都属于一种图形，并且都具有draw方法，所以首先可以定义一个接口或者抽象类，作为这三个图像的公共父类，并在其中声明一个公共的draw方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承公共父类，编写具体图形：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//圆形</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">circleShape</span> <span class="keyword">implements</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">circleShape</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CircleShape:created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw: circleShape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正方形</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RectShape</span> <span class="keyword">implements</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RectShape</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RectShape: created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw: rectShape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//三角形</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">triangleShape</span> <span class="keyword">implements</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TriangleShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TriangleShape: created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw: TriangleShape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是工厂类的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">shapeFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title">getShape</span><span class="params">( String type )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Shape shape = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>( type.equalsIgnoreCase( <span class="string">&quot;circle&quot;</span> ) )</span><br><span class="line">        &#123;</span><br><span class="line">            shape = <span class="keyword">new</span> circleShape();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( type.equalsIgnoreCase( <span class="string">&quot;rect&quot;</span> ) )</span><br><span class="line">        &#123;</span><br><span class="line">            shape = <span class="keyword">new</span> rectShape();</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            shape = <span class="keyword">new</span> triangleShape();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shape;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>工厂方法</p>
<p>工厂方法模式是简单工厂的进一步深化， 在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说每个对象都有一个与之对应的工厂。</p>
<p>工厂方法的实现思路是，定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。</p>
<p><strong>实例：</strong></p>
<p>以简单工厂的实例来实现工厂方法模式：</p>
<p>首先编写一个公共的接口来draw：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为每个图形实现 draw() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">circleShape</span> <span class="keyword">implements</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw: circleShape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">rectShape</span> <span class="keyword">implements</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw: rectShape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">triangleShape</span> <span class="keyword">implements</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw: triangleShape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着定义一个抽象的工厂接口shapeFactory：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">shapeFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">Shape <span class="title">getShape</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getShape()</code> 方法用于返回shape类，每个</p>
</li>
<li><p>抽象工厂</p>
<p>​    工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。</p>
</li>
</ol>
<h3 id="（3）观察者模式"><a href="#（3）观察者模式" class="headerlink" title="（3）观察者模式"></a>（3）观察者模式</h3><p>观察者模式很好理解，类似于订阅模式，属于行为型模式的一种，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p>
<p>在观察者模式中有如下角色：</p>
<ol>
<li>Subject：抽象主题（抽象被观察者），定义增删观察者接口和通知观察者更新的接口。</li>
<li>ConcreteSubject：具体主题（具体被观察者），创建存储观察者的集合，并实现抽象主题的内容。</li>
<li>Observer：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li>
<li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li>
</ol>
<p>这种发布-订阅的形式我们可以拿微信公众号来举例，假设微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了这个公众号，当这个公众号更新时就会通知这些订阅的微信用户。</p>
<p>具体实例如下：</p>
<ol>
<li>抽象观察者：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>具体观察者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeixinUser</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 微信用户名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeixinUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;-&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>抽象主题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加订阅者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除订阅者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知订阅者更新消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体主题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriptionSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//储存订阅公众号的微信用户</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;WeixinUser&gt; weixinUserlist = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(WeixinUser u)</span> </span>&#123;</span><br><span class="line">        weixinUserlist.add(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(WeixinUser u)</span> </span>&#123;</span><br><span class="line">        weixinUserlist.remove(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (WeixinUser u : weixinUserlist) &#123;</span><br><span class="line">            u.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SubscriptSubject sub = <span class="keyword">new</span> SubscriptSubject();</span><br><span class="line">        WechatUser a = <span class="keyword">new</span> WechatUser(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        WechatUser b = <span class="keyword">new</span> WechatUser(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">        sub.attach(a);</span><br><span class="line">        sub.attach(b);</span><br><span class="line">        sub.notify(<span class="string">&quot;你们订阅的内容更新了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">杨影枫-刘望舒的专栏更新了</span><br><span class="line">   月眉儿-刘望舒的专栏更新了</span><br><span class="line">紫轩-刘望舒的专栏更新了</span><br></pre></td></tr></table></figure></li>
</ol>
<p>优点：</p>
<ul>
<li>观察者和被观察者是抽象耦合的</li>
<li>建立了一套触发机制</li>
</ul>
<p>缺点：</p>
<ul>
<li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间</li>
<li>如果观察者和观察目标间有循环依赖，可能导致系统崩溃</li>
<li>没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的</li>
</ul>
<p>使用场景：</p>
<ul>
<li>关联行为场景</li>
<li>事件多级触发场景</li>
<li>跨系统的消息变换场景，如消息队列的处理机制</li>
</ul>
<h3 id="（4）装饰模式"><a href="#（4）装饰模式" class="headerlink" title="（4）装饰模式"></a>（4）装饰模式</h3><p>定义：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</p>
<p>下面以一个例子来简单说明：</p>
<p>比如我买了一个机器人，它本身有一个对话的功能。我希望它能在此基础上还能帮我扫地。有两种方式实现：</p>
<ol>
<li>第一种方式，可以打电话给厂家，让他们可以研制新的产品，在第一代产品的基础上加两条胳膊，扩展这个功能；</li>
<li>第二种方式是直接给第一代产品加一个箱子，在这个箱子上面加两条胳膊，这样它也拥有了扫地的功能，这种方式更为灵活，不需要去重新研发设计。</li>
</ol>
<p>上述这两种方式都可以实现给一个类或对象增加新的功能，第一种是继承机制，就是继承一个现有的类，然后在子类进行扩展功能；第二种被称为关联机制，是把一个类的对象嵌入到另一个类的对象中，相当于把机器人嵌入到箱子中，给它套一个壳子，扩展出扫地的功能，这个壳子就是装饰器，第二种方式也被称为装饰器模式。</p>
<p>在开发过程中，这两种方式都经常被使用，他们主要的区别在于：对于继承模式来说，这种方式是静态的，一定要实现一个新的子类来对类层级进行扩展；装饰器模式是动态的，我们拿到一个对象就可以对其进行扩展，不需要修改原有类逻辑。</p>
<p>下面使用代码来实现上述例子：</p>
<ol>
<li><p>创建抽象组件，代表被装饰的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建组件实现类，实现第一代机器人：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">firstRobot</span> <span class="keyword">implements</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建装饰器对第一代机器人扩展：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">robotDecorator</span> <span class="keyword">implements</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="comment">//因为要关联使用机器人，所有要定义一个机器人对象</span></span><br><span class="line">    <span class="keyword">private</span> Robot robot;</span><br><span class="line">    <span class="comment">//接着要传这个对象进来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">robotDecorator</span><span class="params">(Robot robot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.robot = robot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接着实现机器人该有的方法，使用机器人对象实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        robot.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//需要扩展功能，新加扫地的功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doMorething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        robot.doSomething();</span><br><span class="line">        System.out.println(<span class="string">&quot;扫地&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> robotDecorator(<span class="keyword">new</span> firstRobot()).doMorething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对话</span><br><span class="line">扫地</span><br></pre></td></tr></table></figure></li>
</ol>
<p>优点：</p>
<ul>
<li>装饰类和被装饰类可以独立发展，而不会相互耦合。它有效地把类的核心职责和装饰功能分开了</li>
<li>装饰模式是继承关系的一个替代方案</li>
<li>装饰模式可以动态地扩展一个实现类的功能</li>
</ul>
<p>缺点：</p>
<p>多层装饰比较复杂。比如我们现在有很多层装饰，出了问题，就需要一层一层检查，工作量很大。</p>
<p>使用场景：</p>
<ul>
<li>需要扩展一个类的功能时</li>
<li>需要动态地给一个对象增加功能，并可以动态地撤销时</li>
<li>需要为一批的兄弟类进行改装或加装功能时</li>
</ul>
<h3 id="（5）代理模式"><a href="#（5）代理模式" class="headerlink" title="（5）代理模式"></a>（5）代理模式</h3><p>代理模式就是为其他对象提供一种代理以控制对这个对象的访问。常见的例子就是Windows的快捷方式，通过快捷方式，我们可以访问某个文件夹下的exe文件，这就是一个典型的代理模式，它将接口提供了出来，我们只需点击快捷方式，它会帮我们运行指定目录下的指定程序。</p>
<p>包括如下角色：</p>
<ul>
<li>Subject是抽象主题角色，定义了RealSubject和Proxy的共同接口，即应该提供什么服务；</li>
<li>RealSubject是具体主题角色，定义了Proxy所代表的真实实体；</li>
<li>Proxy为代理主题角色，保存对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ul>
<p>例子：购买机票不一定要去机场买，可以在相关的代售软件上购买。这里的软件就是代理角色。</p>
<p>下面具体实现这个例子：</p>
<ol>
<li><p>定义公共接口，实现购票方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现具体主题角色，也就是机场：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">realSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;机场买机票&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现代理角色，也就是购票网站：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">proxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> realSubject subject;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxySubject</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        subject = <span class="keyword">new</span> realSubject();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;购票网站购买机票&quot;</span>);</span><br><span class="line">        subject.buyTicket();</span><br><span class="line">        System.out.println(<span class="string">&quot;成功购买&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> proxySubject().buyTicket();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">购票网站购买机票</span><br><span class="line">   机场买机票</span><br><span class="line">   成功购买</span><br></pre></td></tr></table></figure></li>
</ol>
<p>从上述代码中可以看出，代理模式和装饰器模式很像，二者的区别是：装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类（proxy class）可以对它的客户隐藏真实对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建真实对象的实例；当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。</p>
<p>优点：</p>
<ul>
<li>职责清晰。真实的角色就是实现实际的业务逻辑，不用担心其他非本职责的事务</li>
<li>高扩展性。代理类完全可以在不做任何修改的情况下使用</li>
<li>智能化。比如动态代理，动态代理就是使用反射机制在运行时创建代理类</li>
</ul>
<p>缺点：</p>
<ul>
<li>有些类型的代理模式可能会造成请求的处理速度变慢</li>
<li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂</li>
</ul>
<p>使用场景：</p>
<ul>
<li>远程代理。为一个对象在不同的地址空间提供局部代表</li>
<li>虚拟代理。根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象</li>
<li>安全代理。用来控制真实对象访问时的权限</li>
<li>智能指引，当调用真实的对象时，代理处理另外一些事</li>
</ul>
<h4 id="扩展：静态代理和动态代理"><a href="#扩展：静态代理和动态代理" class="headerlink" title="扩展：静态代理和动态代理"></a>扩展：静态代理和动态代理</h4><p>代理模式分为静态代理和动态代理。上述例子实现的是静态代理，下面使用动态代理实现上面的例子：</p>
<p>动态代理是通过实现反射机制下的 <code>InvocationHandler</code> 接口来创建自己的调用处理器。</p>
<ol>
<li><p>实现抽象接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现具体主题角色，也就是机场：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">realSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;机场买机票&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现 InvocationHandler 接口创建一个针对这个具体角色的动态代理调用处理程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">proxySubjectHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    realSubject subject = <span class="keyword">new</span> realSubject();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;购票网站购买机票&quot;</span>);</span><br><span class="line">        Object res = method.invoke(subject, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;成功购买&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Subject <span class="title">getProxyInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Subject)Proxy.newProxyInstance(subject.getClass().getClassLoader(), subject.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        proxySubjectHandler subject = <span class="keyword">new</span> proxySubjectHandler();</span><br><span class="line">        subject.getProxyInstance().buyTicket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">购票网站购买机票</span><br><span class="line">机场买机票</span><br><span class="line">成功购买</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="InvocationHandler-和-Proxy"><a href="#InvocationHandler-和-Proxy" class="headerlink" title="InvocationHandler 和 Proxy"></a>InvocationHandler 和 Proxy</h4><p>InvocationHandler是动态代理类的调用处理程序必须实现的接口。</p>
<p>​        从 <code>Proxy.newProxyInstance</code> 开始方法看，它用来创建一个代理类对象，接收三个参数：具体主题角色的类加载器、具体主题角色实现的所有接口、以及需要关联到的 InvocationHandler 对象实例，也就是上述例子中的 <code>proxySubjectHandler</code> 这个类的实例，如果是在这个类中执行的这个方法，可以使用 <code>this</code> 来表示这个类的实例。</p>
<p>​        这个方法返回的就是一个代理角色，通过这个代理角色调用方法，会被转发到实现 InvocationHandler接口的类的 invoke 方法中调用。</p>
<h2 id="16-List、Set、Map三者的联系和区别"><a href="#16-List、Set、Map三者的联系和区别" class="headerlink" title="16. List、Set、Map三者的联系和区别"></a>16. List、Set、Map三者的联系和区别</h2><p><code>List</code> 和 <code>Set</code> 接口都属于 <code>Collection</code> 接口， <code>Map</code> 接口与 <code>Collection</code> 接口同级。</p>
<p>其中：</p>
<ol>
<li>List中的元素可重复，具有有序性；</li>
<li>Set中的元素不可重复，具有无序性；</li>
<li>Map采用key-value的形式存储元素，key值不可重复。</li>
</ol>
<h2 id="17-HashMap-和-HashTable、HashSet、TreeMap-的区别"><a href="#17-HashMap-和-HashTable、HashSet、TreeMap-的区别" class="headerlink" title="17. HashMap 和 HashTable、HashSet、TreeMap 的区别"></a>17. HashMap 和 HashTable、HashSet、TreeMap 的区别</h2><ol>
<li>HashMap底层由 <code>链表 + 数组 + 红黑树</code> 实现，当链表长度 <code>&gt;=8</code> 、数组长度 <code>超过64</code> 时转换为红黑树，非线程安全，可以存储 <code>null</code> 键和 <code>null</code> 值，初始 <code>size = 16</code> ，扩容方式为 <code>newsize = oldsize * 2</code> 先插入再扩容；</li>
<li>HashTable底层由 <code>链表 + 数组</code> 实现，通过在方法和对象前添加 <code>syncronized</code> 关键字来保证线程安全，不可以存储 <code>null</code> 键 <code>null</code> 值，初始 <code>size = 11</code> ，扩容方式为 <code>newsize = olesize * 2 + 1</code> 先扩容再插入；</li>
<li>HashSet底层由HashMap实现，其中的HashMap仅存在key，value都是同一个object，非线程安全；</li>
<li>TreeMap底层由红黑树实现，是有序的 <code>key-value</code> 组合，非线程安全，存入TreeMap的元素应该实现Comparable或Comparator接口，会按照排序后的顺序迭代元素，元素插入时对元素自动排序，迭代输出就按顺序输出。</li>
</ol>
<h2 id="18-HashMap的底层原理"><a href="#18-HashMap的底层原理" class="headerlink" title="18. HashMap的底层原理"></a>18. HashMap的底层原理</h2><p>HashMap的底层由数组+链表+红黑树的形式实现，数组中的元素为内部类Node节点。</p>
<p>具体实现如下：</p>
<ol>
<li>首先对key值进行二次哈希，然后将结果对数组长度取模，存入对应下标；</li>
<li>如果没有哈希冲突，直接创建Node存入下标对应的位置；</li>
<li>如果存在哈希冲突，先equals查看是否有相同元素，有则更新，没有则判断链表高度插入链表，如果链表高度到8、数组长度超过64转变为红黑树存储，长度低于6转变为链表存储。</li>
</ol>
<p>当数组长度不够，需要进行扩容的时候，会根据扩容因子new一个新的数组，再将旧数组的元素放入新数组使用，扩容因子默认是0.75。</p>
<p>其中提出的二次哈希，是为了对key的hashCode进行扰动计算，防止不同hashCode的高位不同但低位相同导致的hash冲突。简单来说就是把高位的特征和低位的特征组合起来，降低哈希冲突的概率，尽量做到任何一位的变化都对最终的结果产生影响。</p>
<h2 id="19-ConcurrentHashMap与HashTable的区别"><a href="#19-ConcurrentHashMap与HashTable的区别" class="headerlink" title="19. ConcurrentHashMap与HashTable的区别"></a>19. ConcurrentHashMap与HashTable的区别</h2><p>有两个区别：</p>
<ol>
<li><p>底层数据结构：HashTable由 <code>数组 + 链表</code> 组成，ConcurrentHashMap 由 <code>数组 + 链表 + 红黑树</code> 组成；</p>
</li>
<li><p>实现线程安全的方式：</p>
<p>（1）HashTable使用 <code>Syncronized</code> 关键字实现线程安全，将所有方法和对象都上了锁，在高并发的情况下，同一时刻只能有一个线程操作，其他线程会被阻塞等待，并发度低；</p>
<p>（2）ConcurrentHashMap采用了更细粒度的锁来提高并发情况下的效率，ConcurrentHashMap将hash表默认分为16个桶，每个桶可以看作是一个hashtable，诸如get、put、remove等写操作只需要锁当前需要的桶，在理想状态下，原来同一时刻只能进入一个线程，现在能同时进入16个，并发性的提升显而易见；因为在读取的大多数情况不需要锁，所以读取操作几乎是完全的并发操作。</p>
</li>
</ol>
<h2 id="20-ConcurrentHashMap底层原理"><a href="#20-ConcurrentHashMap底层原理" class="headerlink" title="20. ConcurrentHashMap底层原理"></a>20. ConcurrentHashMap底层原理</h2><p>​        首先了解为什么使用ConcurrentHashMap。在并发编程下使用HashMap可能导致死循环，而使用线程安全的HashTable效率又非常低下，于是引出了ConcurrentHashMap。HashTable效率低的原因很明显，因为HashTable使用Synchronized关键字，所以在并发时只能运行一个线程，而将其他线程阻塞等待；HashMap导致死循环的原因是put操作扩容，假设有两个线程A和B要同时进行扩容，此时数组中下标为1对应的链表指向是 a - b - c，扩容需要将他们迁移到新数组，这里假设abc迁移后在同一下标4，进行扩容操作有两个指针 e 和 next，A先执行，假设当 e &#x3D; a，next &#x3D; b 的时候cpu时间片用完，会暂停A的执行，由B开始执行，因为是头插法，插入的顺序是将e.next &#x3D; newtable[4]，newtable[4] &#x3D; e,e &#x3D; next。B会将 abc 全都放到newtable[4]的空间中，然后时间片用完，A继续执行，在B线程将 b 指向 a，在这里又将 a 指向 b，此时就产生了死循环。</p>
<p>​         而ConcurrentHashMap应用在多线程的优点在于它的数据结构。</p>
<p>​        在JDK1.7底层采用：segment + HashEntry数组结构组成，实现的思路是先将数据分成一段一段地存储，然后给每一段数据配一把锁，这样当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，这就是锁分段技术。其中Segment继承了ReetrantLock可重入锁接口，所以自带了锁的功能，让每一个片段都有了锁；HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构。一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁。</p>
<p>​        JDK1.8底层与HashMap底层结构一致，将锁的粒度调整到每个数组元素加锁，并且定位节点的hash算法被简化，导致hash冲突加剧，因此在链表长度大于8时，会将链表转换为红黑树存储，这样一来，查询的时间复杂度就从O(n)转变为O(logn)。</p>
<p>​        对于锁的设计，JDK1.8取消了Segment分段锁，采用了CAS+Synchronized来保证并发安全。当执行<code>put</code>方法插入数据时，定义一个Node节点 <code>f</code>，如果 <code>f == null</code>，则相应位置的<code>Node</code>还未初始化，通过CAS插入相应的数据；如果 <code>f.hash == -1</code>，说明当前有其他线程正在扩容，则一起进行扩容操作；如果是其余情况就是把新的node节点按照链表或红黑树的方式插入到合适的位置，其中有一个binCount变量用于判断当前链表长度是否&gt;&#x3D;8。</p>
<p>​        JDK1.8中还使用一个volatile类型的变量baseCount记录元素的个数，用于判断是否扩容，当插入新数据或删除元素时，会通过 <code>addCount()</code> 方法更新 <code>baseCount</code> 。具体的实现过程是：先利用CAS方法更新baseCount的值，然后检查是否需要扩容，默认check&#x3D;1时需要检查；如果满足扩容条件，即 <code>map.size() &gt;= sizeCTL</code>，此处 <code>sizeCtl</code> 为扩容阈值，判断当前是否正在扩容，如果是正在扩容就一起扩容，如果不在扩容就将 <code>sizeCtl</code> 更新为负数，并进行扩容处理。</p>
<h2 id="21-Comparable-和-Comparator-的区别"><a href="#21-Comparable-和-Comparator-的区别" class="headerlink" title="21. Comparable 和 Comparator 的区别"></a>21. Comparable 和 Comparator 的区别</h2><ol>
<li>Comparable是内部比较器，实现该接口意味着该类支持排序，不需要额外实现比较器，比较简单，但是需要修改源代码；</li>
<li>Comparator是外部比较器，当需要控制某个类的次序，而该类本身不支持排序，可以自定义一个该类的比较器进行排序，好处是不需要修改源代码，只需要自定义一个比较器。</li>
</ol>
<h2 id="22-ArrayList、LinkedList、Vector的区别"><a href="#22-ArrayList、LinkedList、Vector的区别" class="headerlink" title="22. ArrayList、LinkedList、Vector的区别"></a>22. ArrayList、LinkedList、Vector的区别</h2><p>三者都实现了List接口。</p>
<ol>
<li>ArrayList用于处理可变长数组，可存放任意类型的对象，所有方法都默认在单一线程下进行，所以是线程不安全的；</li>
<li>LinkedList相当于双向链表，也是线程不安全的，在内部实现中，使用节点Node存放数据，有一个指向链表头的first和一个指向链表尾的last节点，插入效率高，遍历效率低；</li>
<li>Vector与ArrayList相似，唯一的区别是它是线程安全的，扩容的时候，Vector扩容为原来的2倍，ArrayList扩容为原来的1.5倍。</li>
</ol>
<h2 id="23-HashSet如何检查重复"><a href="#23-HashSet如何检查重复" class="headerlink" title="23. HashSet如何检查重复"></a>23. HashSet如何检查重复</h2><p>当对象 <code>add</code> 到 <code>HashSet</code> 中，首先获取对应的HashCode，判断对象插入的位置，如果没有相同HashCode的对象存在，则成功加入，否则调用 <code>equals</code> 方法判断两个 <code>HashCode</code> 相同的对象是否真的相等，如果相等，加入失败。</p>
<h2 id="24-静态编译和动态编译"><a href="#24-静态编译和动态编译" class="headerlink" title="24. 静态编译和动态编译"></a>24. 静态编译和动态编译</h2><ol>
<li>静态编译：一次编译，在程序运行前将所有模块全都编译进去；</li>
<li>动态编译：按需编译，在程序运行过程中，需要用到哪个模块再编译哪个模块。</li>
</ol>
<h2 id="25-反射机制"><a href="#25-反射机制" class="headerlink" title="25. 反射机制"></a>25. 反射机制</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>反射的概念是在运行状态中，对于任何一个类，都能知道它的所有属性和方法；对于任何一个对象，都能调用它的任意一个方法和属性。这种动态获取信息和动态调用对象方法的功能叫做反射机制。</p>
<h3 id="为什么使用反射"><a href="#为什么使用反射" class="headerlink" title="为什么使用反射"></a>为什么使用反射</h3><p>先抛开概念化的定义，看下面的两段代码：</p>
<p>例子：实现创建一个动物对象 <code>cat</code> 并调用 <code>run</code> 方法计算它跑两公里的距离。</p>
<p>不用反射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal cat = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="keyword">double</span> distance = cat.run(<span class="number">2d</span>);</span><br></pre></td></tr></table></figure>

<p>用反射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取动物类的反射对象</span></span><br><span class="line">Class clz = Class.forName(<span class="string">&quot;com.self.example.Animal&quot;</span>);</span><br><span class="line"><span class="comment">// 获取奔跑方法的反射对象</span></span><br><span class="line">Method met = clz.getMathod(<span class="string">&quot;run&quot;</span>, <span class="keyword">double</span>.class);</span><br><span class="line"><span class="comment">// 获取构造方法的反射对象</span></span><br><span class="line">Constructor cons = clz.getConstructor();</span><br><span class="line"><span class="comment">// 通过反射实例化对象</span></span><br><span class="line">Object obj = cons.newInstance();</span><br><span class="line"><span class="comment">//通过反射调用奔跑方法</span></span><br><span class="line">Object distance = met.invoke(obj, <span class="number">2d</span>);</span><br></pre></td></tr></table></figure>

<p>看起来，反射将两行代码可以解决的问题扩展到了五行代码解决，将简单的事情写复杂化了，但是反射传入的是字符串，如果将字符串提出来，比如放到配置文件中，或者在程序运行的时候传参，这样的程序就会变得非常动态了。</p>
<p>已知Java程序要运行，需要先将源代码通过javac转变为字节码，然后通过Java解释和执行字节码。Java是静态语言，变量的类型在编译前就需要确定，否则编译不能通过，这样限制了程序的灵活性，所以许多静态语言扩展出了动态的反射机制，以能够动态的获取对象信息和调用对象的方法。</p>
<h3 id="反射的基本使用"><a href="#反射的基本使用" class="headerlink" title="反射的基本使用"></a>反射的基本使用</h3><p>首先创建一个 <code>Hello</code> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bonnie.example;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2022/1/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着在 <code>resource</code> 文件夹下创建一个属性文件 <code>property.properties</code> 存放 <code>hello</code> 类的信息，以便能够动态修改：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">className</span>=<span class="string">com.bonnie.example.Hello</span></span><br><span class="line"><span class="attr">methodName</span>=<span class="string">sayHello</span></span><br></pre></td></tr></table></figure>

<p>最后反射该类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bonnie.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2022/1/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reflectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reflect</span><span class="params">(String name )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取配置文件内容</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        ClassLoader classLoader = reflectTest.class.getClassLoader();</span><br><span class="line">        InputStream inputStream = classLoader.getResourceAsStream(<span class="string">&quot;property.properties&quot;</span>);</span><br><span class="line">        pro.load(inputStream);</span><br><span class="line">        String classname = pro.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">        String methodname = pro.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 获取类对象</span></span><br><span class="line">        Class clz = Class.forName(classname);</span><br><span class="line">        <span class="comment">// 3. 获取实例对象</span></span><br><span class="line">        Object obj = clz.getConstructor().newInstance();</span><br><span class="line">        <span class="comment">// 3. 调用set方法存数据</span></span><br><span class="line">        Method set_method = clz.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        set_method.invoke(obj, <span class="keyword">new</span> Object[]&#123;name&#125;);</span><br><span class="line">        <span class="comment">// 4. 调用 methodname 对应的方法显示</span></span><br><span class="line">        Method get_method = clz.getMethod(methodname);</span><br><span class="line">        get_method.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        reflectTest reflect = <span class="keyword">new</span> reflectTest();</span><br><span class="line">        reflect.reflect(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>Class</code> 类是 <code>Reflection API</code> 中的核心类，主要方法如下：</p>
<ul>
<li>getName()：获得类的完整名字。 getFields()：获得类的public类型的属性。</li>
<li>getDeclaredFields()：获得类的所有属性。</li>
<li>getMethods()：获得类的public类型的方法。</li>
<li>getDeclaredMethods()：获得类的所有方法。</li>
<li>getMethod(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes参数指定方法的参数类型。</li>
<li>getConstrutors()：获得类的public类型的构造方法。</li>
<li>getConstrutor(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes参数指定构造方法的参数类型。</li>
<li>newInstance()：通过类的不带参数的构造方法创建这个类的一个对象。</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点有：</p>
<ol>
<li><p>增加程序的灵活性，避免将程序写死在代码里；</p>
<p>比如一个接口中有若干个实现类，这些类在程序中被频繁使用，可以编写配置文件放接口和实现类，如果改动只需要修改配置文件，就可以利用 <code>Class.forName(class_name).newInstance()</code> 反射获取对应实例。</p>
</li>
<li><p>提高代码的复用率，外部调用方便；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.yonyong.reflection.testdemo;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123; <span class="comment">//水果接口</span></span><br><span class="line">　 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>; <span class="comment">//吃水果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123; <span class="comment">//定义苹果</span></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　　　System.out.println(<span class="string">&quot;**吃苹果。&quot;</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　　　System.out.println(<span class="string">&quot;**吃橘子。&quot;</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getInstance</span><span class="params">(String className)</span></span>&#123;</span><br><span class="line">　　　　Fruit fruit = <span class="keyword">null</span> ;</span><br><span class="line">　　　　<span class="keyword">try</span>&#123;</span><br><span class="line">　　　　　　fruit = (Fruit) Class.forName(className).newInstance() ;</span><br><span class="line">　　　　&#125;<span class="keyword">catch</span>(Exception e )&#123;</span><br><span class="line">　　　　　　e.printStackTrace() ;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　<span class="keyword">return</span> fruit ;</span><br><span class="line">　 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryDemo</span></span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">　　<span class="comment">//通过工厂类取得接口实例，传入完整的包.类名称</span></span><br><span class="line">　　　　Fruit f = Factory.getInstance(<span class="string">&quot;cn.yonyong.reflection.testdemo.Apple&quot;</span>) ;</span><br><span class="line">　　　　<span class="keyword">if</span>(f!=<span class="keyword">null</span>)&#123; <span class="comment">//判断是否取得接口实例</span></span><br><span class="line">　　　　　　f.eat() ;</span><br><span class="line">　　　&#125;</span><br><span class="line">　 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要添加一个西瓜类，就只需要在 <code>FactoryDemo</code> 中的 <code>getInstance</code> 反射对应的名称即可。</p>
</li>
<li><p>对于任意一个类，都能知道它的所有属性和方法，对于任意一个对象，都能调用它的所有方法。</p>
</li>
</ol>
<p>缺点如下：</p>
<ol>
<li>性能问题：反射包含了一些动态类型，这些部分是不能被JVM优化的，所以反射操作的效率会比非反射操作的效率低很多，应该避免在经常被执行的代码和对性能要求较高的场景中使用；</li>
<li>安全限制：通常反射需要程序的运行没有安全方面的限制，因为反射可以获取类中的任意信息，包括私有信息；</li>
<li>程序健壮性：反射允许代码执行一些正常情况不被允许的操作，比如访问私有属性和方法，所以使用反射可能会导致代码出现功能上的错误、降低可移植性等副作用。</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>应用于反编译，将.class文件转变为.java文件；</li>
<li>常用的一些框架，如Spring的配置化就是利用反射机制来动态加载对象；</li>
<li>编译器，比如IDEA会有自动联想类的方法或属性的功能。</li>
</ol>
<h2 id="26-Java中的引用类型有哪些？"><a href="#26-Java中的引用类型有哪些？" class="headerlink" title="26. Java中的引用类型有哪些？"></a>26. Java中的引用类型有哪些？</h2><p>Java中对象的引用分为四种级别，这四种级别由高到低依次为:强引用、软引用、弱引用和虚引用。</p>
<ol>
<li><p>强引用</p>
<p>Java中默认声明的就是强引用，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object(); //只要obj还指向Object对象，Object对象就不会被回收</span><br><span class="line">obj = null;  //手动置null</span><br></pre></td></tr></table></figure>

<p>只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显式的将强引用赋值为null。</p>
<p>Java的对象是位于heap 中的, heap中对象从强到弱有强可及对象、软可及对象、弱可及对象、虚可及对象和不可到<br>达对象。对于对象是属于哪种可及的对象，由他的最强的引用决定。看如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String abc=<span class="keyword">new</span> string ( <span class="string">&quot;abc&quot;</span>); <span class="comment">//1</span></span><br><span class="line">SoftReference&lt;string&gt; softRef=<span class="keyword">new</span> SoftReference&lt;string&gt; (abc); <span class="comment">//2</span></span><br><span class="line">WeakReference&lt;string&gt; weakRef = <span class="keyword">new</span> WeakReference&lt;string&gt;(abc); <span class="comment">//3</span></span><br><span class="line">abc=<span class="keyword">null</span>; <span class="comment">//4</span></span><br><span class="line">softRef.clear();<span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<p>第一行在heap堆中创建内容为“abc”的对象，并建立abc到该对象的强引用，该对象是强可及的。<br>第二行和第三行分别建立对 heap中对象的软引用和弱引用，此时 heap 中的abc对象已经有3个用，显然此时abc 对象仍是强可及的。<br>第四行之后heap 中对象不再是强可及的，变成软可及的。<br>第五行执行之后变成弱可及的。</p>
</li>
<li><p>软引用</p>
<p>软引用是用来描述一些非必需但仍有用的对象。<strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong>。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。<br>在 JDK1.2 之后，用java.lang.ref.SoftReference类来表示软引用。垃圾收集器只在真正 “需要” 内存时才收集软引用对象。</p>
</li>
<li><p>弱引用</p>
<p>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong>。在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用。</p>
</li>
<li><p>虚引用</p>
<p>虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，虚引用主要用来跟踪对象被垃圾回收的活动。在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p>
</li>
<li><p>引用队列</p>
<p>引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。</p>
</li>
</ol>
<h2 id="27-JVM内存分配与回收"><a href="#27-JVM内存分配与回收" class="headerlink" title="27. JVM内存分配与回收"></a>27. JVM内存分配与回收</h2><h3 id="1-首先了解一下JVM的内存模型。"><a href="#1-首先了解一下JVM的内存模型。" class="headerlink" title="1. 首先了解一下JVM的内存模型。"></a>1. 首先了解一下JVM的内存模型。</h3><p>​        JVM的整体架构主要分为三个部分：类加载子系统、运行时数据区、执行引擎。其中类加载子系统用于把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型；运行时数据区是将内存划分为若干个区域管理；执行引擎用于执行JVM字节码命令，主要有两种方式：编译执行和解释执行。编译执行是先一次性编译完再执行，启动慢，执行效率高；解释执行是在执行时解释一行执行一行，启动快，执行效率低。垃圾回收器用于自动管理运行时数据区的内存，将无用的内存占用清除，释放内存资源。除了上述三个部分，还有本地方法库和本地库接口，用于调用本地方法。</p>
<p>​        下面仔细说明运行时数据区的内容。</p>
<p>​        JVM启动时会向系统申请一块内存，它将这块内存划分为若干个子区域存放不同形式的数据，大致分为三个大区域：堆、栈、方法区。</p>
<ol>
<li><p>堆</p>
<p>（1）堆用来存储引用类型的数据；</p>
<p>（2）堆中的数据是无序的；</p>
<p>（3）堆中数据可以反复使用，这是设置堆的初衷；</p>
<p>（4）JVM会定时清理堆中的垃圾数据，即不会再被使用的数据，这被称为垃圾回收。</p>
</li>
<li><p>栈</p>
<p>（1）栈以方法为单元存放数据，这样的单元叫做方法栈桢；</p>
<p>（2）栈中存放的数据的有序的，遵循先进后出的规则；</p>
<p>（3）方法调用结束后，它占有的方法会被立即释放。</p>
</li>
<li><p>方法区</p>
<p>方法区是线程共享的，它存储已经被虚拟机加载的类信息如类型标志（该类是类类型还是接口类型）、常量、静态变量、即时编译（也就是静态编译）后的代码等等。</p>
</li>
</ol>
<h3 id="2-JVM内存分配："><a href="#2-JVM内存分配：" class="headerlink" title="2. JVM内存分配："></a>2. JVM内存分配：</h3><p>这里具体以一个例子来说明JVM的内存分配过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Car c = <span class="keyword">new</span> Car();</span><br><span class="line">	c.brand = <span class="string">&quot;奔驰&quot;</span>;</span><br><span class="line">	c.color = <span class="string">&quot;红色&quot;</span>;</span><br><span class="line">	c.maxSpeed = <span class="number">500</span>;</span><br><span class="line">	c.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>main</code> 栈帧入栈；</p>
</li>
<li><p><code>Car c = new Car()</code> ，因为赋值操作从右往左，先执行 <code>new Car()</code> 操作，在堆中开辟一块内存来存储这个对象，然后将变量 <code>c</code> 存储到 <code>main</code> 栈帧中，然后执行 <code>=</code> 操作；</p>
</li>
<li><p>后续三个赋值操作访问了成员变量，通过 <code>c.</code> 找到堆中的相应成员变量，进行赋值；</p>
</li>
<li><p><code>c.sun()</code> 操作将 <code>run()</code> 方法入栈。</p>
</li>
</ol>
<h3 id="3-JVM内存回收"><a href="#3-JVM内存回收" class="headerlink" title="3. JVM内存回收"></a>3. JVM内存回收</h3><h4 id="判断对象是否可以被回收（引用计数法和可达性分析算法）"><a href="#判断对象是否可以被回收（引用计数法和可达性分析算法）" class="headerlink" title="判断对象是否可以被回收（引用计数法和可达性分析算法）"></a>判断对象是否可以被回收（引用计数法和可达性分析算法）</h4><h4 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1. 引用计数法"></a>1. 引用计数法</h4><p>就是给对象添加一个引用计数器，每当有一个地方引用到它就加一，引用失效就减一，任何时刻计数器为0的对象就是不能再被使用的。引用计数法实现简单，判定效率也很高，但是它很难解决对象间循环引用的问题。比如以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigsize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB]; <span class="comment">// 这个成员属性的唯一意义就是占点内存，方便在GC日志冲查看是否被回收过</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        demo objA = <span class="keyword">new</span> demo();</span><br><span class="line">        demo objB = <span class="keyword">new</span> demo();</span><br><span class="line">        </span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中的 <code>objA</code> 和 <code>objB</code> 两个对象实际上已经不可能再被访问，但是由于它们互相引用对方，导致引用计数器都无法归零，于是引用计数器都无法同之GC收集器回收他们。</p>
<h4 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2. 可达性分析算法"></a>2. 可达性分析算法</h4><p>当前主流的商用语言的内存管理子系统，都是 通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。这个算法的基本思路就是通过 一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过 程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
<p>在java语言中，常见的可作为GC Roots的对象包括下面几种：</p>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li>
<li>方法区中类静态属性引用的对象；</li>
<li>方法区中常量引用的对象；</li>
<li>本地方法栈中JNI（即一般所说的Native方法）引用的对象。</li>
</ol>
<p>这种方式可找到所以得垃圾对象，并且完美解决对象之间循环引用的问题。但是不可避免地要遍历全局所有对象，导致搜索效率不高。</p>
<h3 id="4-垃圾收集算法"><a href="#4-垃圾收集算法" class="headerlink" title="4. 垃圾收集算法"></a>4. 垃圾收集算法</h3><p>有四种垃圾收集算法。</p>
<ol>
<li><strong>标记清除算法</strong>：包括“标记”和“清除”两个过程 - 先标记出所有需要回收的对象，再统一清除掉所有被标记的对象。这种方法有两个缺点：（1）标记和清除的过程的效率都不高；（2）标记清除后可能会产生大量不连续的内存，这样在程序运行过程中，需要分配较大的对象时无法找到足够的连续内存而不得不提前触发再一次的垃圾收集操作。</li>
<li><strong>复制算法</strong>：是为了解决标记清除算法的效率问题产生的。它将内存等分为两个部分，每次只使用其中的一块。当这块内存用完了，将还存活的对象复制到另一边，然后把已使用过的这一部分全部清理掉。这种方式因为每次只对一个部分回收，内存分配就不需要考虑内存碎片的复杂情况，只需要移动堆顶指针，按顺序分配内存即可，简单高效；缺点是一次只使用一半的内存，代价太高；</li>
<li><strong>标记整理算法</strong>：如果对象存活率较高，使用复制算法需要进行多次复制，效率不高。可以使用标记整理算法，它的标记过程与标记清除算法一样，只是后续不是直接对可回收对象进行处理，而是先将所有存活对象向一端移动，然后直接清理掉除了端边界以外的所有内存；</li>
<li><strong>分代收集算法</strong>：当代商业虚拟机的垃圾收集都是采用该方法。该算法根据生命周期的不同将内存划分，一般是将堆划分为新生代和老生代，然后根据不同生代的特点选择合适的算法处理。新生代的特点是大批对象死亡，少量对象存活，可以使用复制算法，以少量存活对象的复制成本就可以完成采集；老生代因为存活率较高，没有多余的空间进行分配担保，所以使用标记清除算法或标记整理算法处理。</li>
</ol>
<h3 id="5-垃圾收集器"><a href="#5-垃圾收集器" class="headerlink" title="5. 垃圾收集器"></a>5. 垃圾收集器</h3><p>有七种垃圾收集器，其中，<code>Serial、Parallel Scavenge、Parnew</code> 是新生代收集器，<code>Serial Old、Parallel Old、CMS</code> 是老生代收集器，G1是整堆收集器，对老生代和新生代都适用。</p>
<ol>
<li><p><strong>Serial</strong>：</p>
<p>以串行的方式运行，使用复制算法，是单线程收集器，工作时其他线程会停止工作，使用复制算法收集新生代垃圾。优点是简单高效，在单个CPU环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率，是Client场景下默认的新生代垃圾收集器；</p>
</li>
<li><p><strong>ParNew</strong>：</p>
<p>是Serial的多线程版本，使用复制算法，是Server场景下的默认新生代收集器，除了性能原因外，主要是因为除了Serial，只有ParNew能与CMS配合使用；</p>
</li>
<li><p><strong>Parallel Scavenge</strong>：</p>
<p>​        它的诸多特性与ParNew非常相似，不同的地方在于，它的目标是实现可控制的吞吐量。这里的吞吐量指的是处理器用于运行用户代码的时间与处理器总消耗时间的比值，而处理器总消耗时间是处理器处理用户代码的时间和用于处理垃圾回收的时间之和。<br>$$<br>吞吐量 &#x3D;<br>\frac{处理器运行用户代码的时间}{处理器运行用户代码的时间 + 运行垃圾收集的时间}<br>$$<br>​        高吞吐量可以最高效率的利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。Parallel Scavenge提供了两个参数用于精确控制吞吐量：MaxGCPauseMillis用于控制最大垃圾收集停顿时间、GCTimeRatio用于直接设置吞吐量大小。这里关于MaxGCPauseMillis参数有一个误区，并不是这个参数设置是值越小，就会使得垃圾收集的速度更快，垃圾收集的停顿时间是以吞吐量和新生代空间为代价换取的，系统将新生代空间调小了，垃圾收集的频率也就变高了。</p>
<p>​        Parallel Scavenge还有一个参数是区别于ParNew的重要特性：UseAdeptiveSizePolicy，启动这个参数，虚拟机就可以动态调整相关参数以提供最合适或最大的吞吐量，这种方式被称为自动调节策略，开启这个开关后，只需要设置上述两个参数之一来设置一个优化目标即可。</p>
</li>
<li><p><strong>Serial Old</strong>：</p>
<p>​        Serial Old是Serial收集器的老年代版本，也是单线程收集器，使用标记-整理算法。主要意义也是提供client模式下的虚拟机使用，在server模式下，也有两种用法：可以跟Parallel Scavenge搭配使用，不过它本身就有一个PS MarkSweep收集器供老年代使用，与Serial Old的实现几乎一样；也可以作为CMS收集器失败时的后备预案，在并发收集发生故障时使用。</p>
</li>
<li><p><strong>Parallel Old</strong>：</p>
<p>​        是Parallel Scavenge的老年代版本，支持多线程并发收集，基于标记-整理算法实现，在一些注重吞吐量或处理器资源比较稀缺的场景中，可以使用Parallel Scavenge + Parallel Old的组合。</p>
</li>
<li><p><strong>CMS</strong>：</p>
<p>​        是一种以获取最短回收停顿时间为目标的收集器，主要适用于较为关注服务响应速度、希望系统停顿时间尽可能短、以给用户带来良好的交互体验的应用。它的运作过程分为四个步骤：初始标记、并发标记、重新标记、并发清除。其中初始标记、重新标记仍然需要STW机制（STW机制就是stop the world机制，指GC过程中会产生应用程序的停顿）。</p>
<p><strong>1）初始标记</strong>：</p>
<p>​        用于标记GC Roots以及它们直接关联到的对象，从根节点出发，哪些对象被引用了，我们就认为这些对象是存活的，把它们标记上。</p>
<p>​        在这个过程之前，用户线程在正常运行，如果要GC，由于初始标记的过程是要暂停所有用户线程的，这些用户线程就需要找一个安全点（safepoint）停下来，这个所谓的安全点，就是对象引用关系不会再发生变化，但是如果有的线程正在休眠，比如线程1正在休眠，这个时候就没有办法判断这个线程有没有执行到安全点，这里就引入了安全区的概念，所谓的安全区，就是在这个代码区域内，对象的引用关系都不会发生改变，也就是说如果线程1在休眠之前进入安全区域，会标识自己进入了安全区域，当初始标记时，就不用管这个线程，当线程向从安全区域出去的时候，先看初始标记的过程是否结束，如果没有结束，就等到结束后才能从安全区域出来。</p>
<p>​        常见的GC Roots有五种：Java虚拟机栈所引用的对象、Java native栈锁引用的对象、类静态属性锁引用的对象、常量所引用的对象、以及synchronized锁引用的对象。</p>
<p><strong>2）并发标记</strong>：</p>
<p>​        初始标记阶段结束后，线程继续运行，同时并发标记也在并发运行，这里，我们引出了三色标记法的概念。</p>
<p>​        三色标记法利用三种颜色将GC对象分为三种情况：白色是没有搜索到的对象，会被判定为垃圾对象，灰色是正在搜索的对象，黑色是已经搜索完成的对象，这种对象不会被当成垃圾对象。</p>
<p>​        并发标记的过程从GC Roots直接关联的对象出发，遍历整个对象图，利用三色标记法对对象进行标记。这个过程因为是和用户线程同时跑的，所以不会有停顿现象，但是这个过程会引发另一个问题：用户线程是可以修改引用关系的。这时候，有三种情况，一种是原有的已经被标记成黑色的对象的引用关系断掉了，这种浮动垃圾可以不用管，下次再回收就行；第二种情况是对黑色的对象直接新建了一个引用关系，就做一个记录，表示这个引用是新建立的，不要去收集它；最后一种情况是灰色对象引用的一个还没有遍历到的白色对象，这个引用关系断掉了，然而黑色对象直接引用了这个白色对象，因为黑色对象不会再被遍历，所以这个白色对象被直接认为是垃圾，但是这个白色对象还没有被遍历过。这种情况有两种解决方案：增量，即把这个黑色节点变成灰色节点，重新扫描一次，CMS就是用这个方式；还有一种方式是，因为这个白色对象是从灰色节点断开的，但是我记下了原来的关系，还是按照原来的关联关系去扫描，G1收集器就是用这种方式。</p>
<p>​        并发标记的过程，指的是对这些关系作一个记录，并不会重新扫描它，这个阶段还是一次性扫描完，然后把有更改的部分记录下来，然后在到下一个安全点的时候，开始重新标记更改的部分。</p>
<p><strong>3）重新标记</strong>：</p>
<p>​        这个过程就是重新扫描标记一遍并发标记过程出现变化的对象。</p>
<p><strong>4）并发清除</strong>：</p>
<p>​        重新标记结束后，就启动清理线程，和其他用户线程并发执行，将被标记清除的对象一次性清除掉。</p>
<p><strong>CMS有以下缺点：</strong></p>
<p>1）CMS收集器对CPU资源非常敏感,在并发阶段虽然不会导致用户线程停顿，但是会占用一部分CPU资源，如果在CPU资源不足的情况下应用会有明显的卡顿。</p>
<p>2）无法处理浮动垃圾：在执行‘并发清理’步骤时，用户线程也会同时产生一部分可回收对象，但是这部分可回收对象只能在下次执行清理时才会被回收。如果在清理过程中预留给用户线程的内存不足就会出现‘Concurrent Mode Failure’,一旦出现此错误时便会切换到SerialOld收集方式。<br>3）使用标记清除算法会导致每次垃圾回收后产生大量空间碎片，这给大对象的分配带来很大的问题，往往会出现老年代还有很多剩余空间，但就是不能找到足够的连续空间来存储连续对象。</p>
</li>
<li><p><strong>G1</strong>：</p>
<p>​        为了解决CMS算法产生空间碎片以及一系列的问题，提出了G1收集器，该收集器使用 UseG1GC 参数来启用，主要应用于多CPU大内存的场景，在满足高吞吐量的同时，尽可能的缩短STW的时间，也就是垃圾回收的停顿时间。</p>
<p>​        G1仍然遵循分代收集的理论，但内部不再坚持固定大小和数量的划分，而是把JAVA内存空间划分为多个大小相等的独立区域region，每个region都可以根据需要，扮演新生代的Eden空间、Survivor空间、老年代空间或特殊的Humorous区域，这个Humorous区域用于存储大对象，G1认为只要大小超过一个region容量一半以上的对象就被判定为大对象，直接在新的一至多个region中分配，标记为H区，在大多数情况下，G1会把H区当作O区，也就是老年代空间的一部分看。收集器对不同类型的region采用不同的方式处理，这样无论是新创建的对象还是已经存活一段时间、熬过多次收集的旧对象都能取得很好的收集效果。其中每个region的大小可以通过设置参数 G1HeapRegionSize 设定，取值范围是 1~32MB 的2的幂次方值。</p>
<p>​        G1中的新生代和老年代都是一系列不需要连续的动态集合，它将region作为单次回收的最小单元，这样可以有计划的避免在整个Java堆中进行全区域的垃圾收集。更具体的思路就是让G1跟踪每个region里垃圾堆积的“价值”大小，价值即回收获得的空间大小以及回收所需时间的经验值，然后在后台维护一张优先级列表，每次根据用户设定允许的停顿时间，有限处理回收价值最大的region，这也是G1名字的由来。这种使用region划分内存空间，以及具有优先级的区域回收方式，保证了G1在有限的时间内获取尽可能高的收集效率。</p>
<p>​        G1的运作过程与CMS大致相同，分为以下四个步骤：</p>
<p>1）初始标记：仅标记GC Roots直接关联到的对象，并且修改tams指针的值，让下一阶段用户线程并发运行时，能正确的在可用的region上分配对象。这个阶段需要停顿线程，但耗时较短，而且是借用进行Minor GC的时候同步完成的，所以这个阶段实际上并没有额外的停顿。上述提到的tams指针是为了解决GC与用户线程并发运行时，GC回收过程中产生新对象的问题而设计的，有两个tams指针，从region区域划出一部分空间用于记录并发回收过程中出现的新对象，这样的对象被认为是存活的，不纳入垃圾收集的范围。而MinorGC是新生代的垃圾收集，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</p>
<p>2）并发标记：从GC Roots开始对堆中对象进行可达性分析，递归遍历整个堆的对象，找出要回收的对象，这个阶段与用户程序并发执行；</p>
<p>3）最终标记：对用户线程作一个短暂的停顿，用于标记并发阶段变化的部分；</p>
<p>4）筛选回收：负责更新region的统计数据，对各个region的回收价值和成本进行排序，根据用户所期望的停顿时间来指定回收计划，可以自由选择任意多个region构成回收集，然后把决定回收的这一部分region的存活对象复制到空的region中，再清理整个旧region空间。这里的操作涉及存活对象的移动，必须暂停所有用户线程，由多条收集器线程并发完成。</p>
</li>
</ol>
<p>​        G1和CMS之间的比较如下：</p>
<p>1）与CMS的标记清除算法不同，G1使用标记整理算法，但从局部的两个region上看又是基于复制算法实现的，这两种算法都让G1在运行期间不会产生空间碎片，垃圾收集后能提供规整的可用内存，这种特性有利于程序的长时间运行，不会因为大对象无法得到分配而提前进行下一次垃圾收集。</p>
<p>2）从内存占用上，G1和CMS都使用卡表来处理跨代指针（卡表用于记录年代之间的引用），但G1的卡表更复杂，且每个region都有一份，这导致G1的记忆集可能会占整个堆容量的20%甚至更多空间；而CMS的卡表只有一份，且只需要处理老年代到新生代的引用，反过来不需要，由于新生代具有朝生夕死的不稳定性，引用变化频繁，能省下这个区域的维护开销是划算的。</p>
<p>3）相比起CMS的增量更新算法，原始快照算法能减少并发标记和重新标记阶段的消耗，避免CMS那样在最终标记阶段停顿时间过长的缺点， 但是在用户程序运行过程中确实会产生由跟踪引用变化带来的额外负担。</p>
<h2 id="28-进程和线程的区别和联系"><a href="#28-进程和线程的区别和联系" class="headerlink" title="28. 进程和线程的区别和联系"></a>28. 进程和线程的区别和联系</h2><ol>
<li>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</li>
<li>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的 实时性，实现进程内部的并发；</li>
<li>一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；</li>
<li>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。</li>
</ol>
<h2 id="29-并行与并发"><a href="#29-并行与并发" class="headerlink" title="29. 并行与并发"></a>29. 并行与并发</h2><p><strong>1. 并发：</strong></p>
<p>指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是利用系统CPU的时间分片功能，使多个进程快速交替的执行。</p>
<p><strong>2. 并行：</strong></p>
<p>指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。</p>
<p><strong>3. 场景分析：</strong></p>
<p>一个应用程序可以是并发的，但不能是并行的，这意味着它可以同时处理多个任务，但是没有两个任务可以同时执行。</p>
<p>一个应用程序可以是并行的，但不能是并发的，这意味着它可以同时处理多核CPU中一个任务的多个子任务。</p>
<p>一个应用程序既不能是并行的，也不能是并发的，这意味着它一次顺序地处理所有任务。</p>
<p>一个应用程序可以是并行的，也可以是并发的，这意味着它可以同时在多核CPU中同时处理多个任务。</p>
<h2 id="30-线程的生命周期和状态"><a href="#30-线程的生命周期和状态" class="headerlink" title="30. 线程的生命周期和状态"></a>30. 线程的生命周期和状态</h2><p>线程一共有五种状态：新生态、就绪态、运行态、阻塞态、死亡态。这五种状态统称线程的生命周期。线程在同一时刻只会处于一种状态。下面简述这五种状态：</p>
<ol>
<li><p>新生态：当线程对象创建后，就进入了新生状态：Thread t &#x3D; new Thread();</p>
</li>
<li><p>就绪态：当调用线程对象的 <code>start()</code> 方法，就进入了就绪状态。处于就绪状态的线程，只是说明词线程已经做好准备，随时等待CPU调度执行，并不是说调用了 <code>start()</code> 方法线程就会立即执行；</p>
</li>
<li><p>运行态：当CPU开始调度处于就绪状态的线程时，该线程真正开始执行，想要进入运行态，就绪态是唯一的入口；</p>
</li>
<li><p>阻塞态：处于运行态的线程因为某种原因暂时放弃了CPU的使用权，停止执行，进入阻塞状态，阻塞态可用分为三种：</p>
<p>（1）等待阻塞：运行态中的线程调用 <code>wait()</code> 方法，使线程进入等待阻塞状态；</p>
<p>（2）同步阻塞：线程获取Synchronized锁失败，因为此时该锁被其他线程占用，该线程进入同步阻塞状态；</p>
<p>（3）其他阻塞：调用线程的 <code>sleep()</code> 或 <code>join()</code> 方法或发出I&#x2F;O请求时，会使得线程进入阻塞状态，当 <code>sleep()</code> 超时或 <code>join()</code> 等待线程终止或超时、或I&#x2F;O处理完毕，线程会重新进入就绪态；</p>
</li>
<li><p>死亡态：线程执行完毕或异常退出，该线程结束生命周期。</p>
</li>
</ol>
<p><strong>允许状态的转换：</strong></p>
<ol>
<li>就绪态转换为运行态：线程得到CPU资源；</li>
<li>运行态转换为就绪态：线程主动调用 <code>yield()</code> 方法或在运行过程中失去CPU资源；</li>
<li>运行态转换为死亡态：线程执行完毕或出现异常</li>
</ol>
<h2 id="31-线程死锁"><a href="#31-线程死锁" class="headerlink" title="31. 线程死锁"></a>31. 线程死锁</h2><ol>
<li><p>概念：死锁指的是两个线程互相拥有对方所需要的资源，由于synchronized的特性，一个线程持有一个资源，或者说获得了一个锁，在该线程释放这个锁之前，其他线程是获取不到这个锁的，并会一直等下去，这就造成了死锁。</p>
</li>
<li><p>死锁产生的必要条件：</p>
<p>（1）互斥条件：一个锁只能被一个线程占用，当一个线程占用一个锁，该锁在被该线程释放前，其他线程都不能获取这个锁；</p>
<p>（2）不剥夺条件：锁只能由当前占用的线程释放，不能由其他的线程强行剥夺；</p>
<p>（3）请求和保持条件：线程已经获得一个锁，再获取另一个锁的过程中，即使获取不到也不会释放已经获得的锁；</p>
<p>（4）循环等待条件：两个线程互相拥有对方需要的锁。</p>
</li>
<li><p>如何避免死锁：</p>
<p>（1）加锁顺序：线程按照相同的顺序加锁；</p>
<p>（2）加锁时限：线程获取锁的过程限制等待的时间，这需要用到锁的一些API。</p>
<p>（3）死锁检测：是一种更好的死锁预防机制，针对前两种方法解决不了的情况。当一个线程获得了锁，会在线程和锁相关的数据结构中记下，比如map，除此之外，每当有线程请求锁，也会记录在这个数据结构中，当一个线程获取锁失败，就可以遍历这个数据结构查看是否有死锁发生。</p>
</li>
</ol>
<h2 id="32-线程池的原理及使用"><a href="#32-线程池的原理及使用" class="headerlink" title="32. 线程池的原理及使用"></a>32. 线程池的原理及使用</h2><p>​        线程池就是在系统启动或者实例化线程池的时候创建一些空间线程，等待工作调度，执行完任务后，这些线程不会被立即销毁，而是重新处于空闲状态，等待下一次调度。由于线程的创建和销毁需要消耗大量资源，这种方式就可以节省很多不必要的花销，而且响应快，不用等待创建，需要的时候自取就可以了。</p>
<p>​        Java中常见的线程池有四种：</p>
<ol>
<li>newSingleThreadExecutor()单一线程池：内部只有一个线程工作，可用保证程序的执行顺序；</li>
<li>newCachedThreadExecutor()可缓存线程池：如果线程池中有可用的线程，就使用，没有就新建。可缓存线程池的最大线程数是Integer类型变量的最大值，通常用它来运行一些执行时间较短且经常用到的任务；</li>
<li>newFixedThreadPool(int nThread)定长线程池：可用控制线程的最大并发数，超出的线程在队列等待；</li>
<li>newScheduledThreadPool(int corePoolSize)定长线程池：支持定时及周期性任务执行；</li>
<li>也可以创建一个自定义线程池，使用ThreadPoolExecutor类创建。</li>
</ol>
<p>​        线程池的工作机制是：任务首先提交给线程池，由线程池寻找空闲的线程来执行任务，如果没有空闲的线程，就将任务放进等待队列中，等待空闲线程，如果超出了线程池最大接受的工作量，就会触发拒绝策略。</p>
<p>​        其中拒绝策略有四个：</p>
<ol>
<li>AbortPolicy()：直接抛出RejectedExecutionException异常；</li>
<li>CallerRunsPolicy()：调用run方法阻塞执行；</li>
<li>DiscardPolicy()：直接丢弃后来的任务；</li>
<li>DiscardOldestPolicy()：丢弃队列中队首的任务。</li>
</ol>
<p>线程池具体的执行流程如下：</p>
<p>​        提交任务以后，首先查看线程池内的核心线程数有没有满，这个核心线程数指的是线程池中即使没有任何任务也会有指定数量的线程在等待调度，没有满就创建线程执行任务；如果满了，就判断等待队列有没有满，没有满就将任务放进等待队列等待；如果满了，再判断线程池有没有满，没有满，就创建线程执行任务；如果还是满了，就启动拒绝策略处理。</p>
<p>​        线程池的具体使用如下：</p>
<p>先创建一个 <code>myThread</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bonnie;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2022/1/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在进行......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如使用 newCachedThreadExecutor 线程池处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bonnie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2022/1/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cachedThreadExecutorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> myThread();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> myThread();</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> myThread();</span><br><span class="line"></span><br><span class="line">        pool.execute(t1);</span><br><span class="line">        pool.execute(t2);</span><br><span class="line">        pool.execute(t3);</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-2正在进行......</span><br><span class="line">pool-1-thread-3正在进行......</span><br><span class="line">pool-1-thread-1正在进行......</span><br></pre></td></tr></table></figure>



<h2 id="33-互斥、自旋、读写、悲观、乐观锁"><a href="#33-互斥、自旋、读写、悲观、乐观锁" class="headerlink" title="33. 互斥、自旋、读写、悲观、乐观锁"></a>33. 互斥、自旋、读写、悲观、乐观锁</h2><ol>
<li>互斥锁：一个线程访问共享资源前会对线程访问的这段代码加锁，加锁之后没有释放锁，其他想要访问临界资源的线程会被阻塞睡眠，直到解锁，如果阻塞了多个线程，解锁的时候，这些线程都转换为就绪状态，第一个变为就绪态的线程获取资源的使用权，其他线程继续阻塞等待；</li>
<li>读写锁：也叫共享互斥锁，读模式共享，写模式互斥，即只有一个线程能占有写模式的读写锁，可以有多个线程占用读模式的读写锁。在写加锁模式下，任何线程进行写加锁操作都会被阻塞，直到解锁；在读加锁模式下，任何线程都可以进行读加锁操作，但全部试图进行写加锁的线程都会被阻塞，直到全部读加锁的线程释放锁，可是当读线程太多，写线程一直被阻塞也不行，因此一个线程想加锁的时候，会阻塞之后的读加锁的请求，让写线程先加锁；</li>
<li>自旋锁：自旋锁和互斥锁很像，唯一不同的是自旋锁访问加锁资源时，会循环查看是否释放锁，这种方式比互斥锁更有效率，但是有两个问题：一是会一直占用CPU的资源，所以适用于多核的CPU；二是自旋锁递归调用容易造成死锁，所以得慎重使用自旋锁；</li>
<li>乐观锁：总是假设最好的情况，每次拿数据都认为其他线程不会修改，所以不会上锁，但在更新的时候会判断一下在词期间其他线程有没有更新这个数据，可用使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可用提高吞吐量；</li>
<li>悲观锁：总是假设最坏的情况，每次拿数据都会认为其他线程会修改，所以在拿数据的时候都会上锁，想获取这个锁的线程会被阻塞直到当前线程释放锁。</li>
</ol>
<h2 id="34-Synchronized锁源码"><a href="#34-Synchronized锁源码" class="headerlink" title="34. Synchronized锁源码"></a>34. Synchronized锁源码</h2><p>首先介绍两个概念：</p>
<h4 id="1-cas"><a href="#1-cas" class="headerlink" title="1. cas"></a>1. cas</h4><p>CAS算法的原理：</p>
<p>​        CAS算法的全称是比较和交换，可以看成是一个自旋锁。下面以一个例子来说明：</p>
<p>​        假设有多线程任务，2个线程同时完成对一个共享变量 <code>i</code> 的减法，假设该算法只有三个步骤：<code>get共享变量的值、更新值、将更新的值put回共享变量</code>，不使用CAS算法的运行过程中，可能将前两个步骤完成，然后在要执行第三个步骤的时候被CPU的时间片切出去，第二个线程开始执行，这时候由于两个线程 <code>get</code> 的值一样，最终所得的结果肯定也是一样的；如果使用CAS算法，可以简单的使用 <code>atomic</code> 变量来保证多线程环境下能无锁进行原子操作，接着在 <code>get</code> 方法设置一个E值，即旧的值，计算步骤完成后，将E值和共享变量内的值比较，如果相同，交换共享变量内的值为更新的值，否则线程再运行一遍，重新获取值进行运算，这也可以称为自旋锁。这个atomic变量保证了这个CAS算法不会存在多线程问题，因为这个变量的核心函数是CPU本地提供的，而CPU都是一行一行执行的，不会存在并行过程。</p>
<p>CAS机制的问题：</p>
<p>​        ABA问题 - 即假设有两个线程对一个共享变量进行操作，这个值初始为A，第一个线程首先将值修改成了B，然后又改回了A，第二个线程因为比较慢，它获取的E值是A，最后比较的时候第一个线程已经完成了两次修改，共享变量的值还是A，所以对第二个线程来说，共享变量值没有被其他线程改动，是安全的。</p>
<p>​        这种可能有两种情况：如果共享变量是基本数据类型，是否改动是不重要的；如果是引用类型，其中的属性可能会发生变化。</p>
<p>​        解决方案：加版本号或时间戳来区分。</p>
<p>​        但是这种方式比较繁琐，不如使用加锁机制。比如有多个线程要进行一个业务操作，只要有一个线程获得这个锁进行业务操作，其他线程发现这个锁被占用了，就会阻塞，但是不是让线程自旋等待，而是等到这个锁被释放了，这个锁会通知所有等待该锁的线程它被释放了。</p>
<p>​        目前CAS在jdk中主要应用于Atomic相关类中，比如AtomicInteger、AtomicLong等。</p>
<h4 id="2-对象头"><a href="#2-对象头" class="headerlink" title="2. 对象头"></a>2. 对象头</h4><p>虚拟机中，对象在内存中存储的布局分为三个部分：对象头、实例数据和对齐填充。</p>
<p>其中对象头包含两部分信息：</p>
<p>（1）mark word：用于存储运行时数据，比如hashcode、GC分代年龄等；</p>
<p>（2）klass pointer：是对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p>当对象是数组时，对象头中还需要包含数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但无法确定数组长度的大小。</p>
<p>Synchronized源码使用mark word来标识对象的加锁状态。</p>
<h4 id="synchronized锁实现原理"><a href="#synchronized锁实现原理" class="headerlink" title="synchronized锁实现原理"></a>synchronized锁实现原理</h4><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，临界区指的是一个用于访问共享资源的代码块，它保证同一时刻只有一个线程访问，同时synchronized关键字还可以保证共享变量的内存可见性。</p>
<p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p>
<ol>
<li><strong>普通同步方法，锁是当前实例对象；</strong></li>
<li><strong>静态同步方法，锁是当前类的class对象；</strong></li>
<li><strong>同步方法块，锁是括号里面的对象。</strong></li>
</ol>
<p>其中同步代码块是使用monitorenter和monitorexit指令实现的，同步方法依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。</p>
<p><strong>同步代码块：</strong></p>
<p>　　monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；</p>
<p><strong>同步方法</strong></p>
<p>　　会被翻译成普通方法的调用和返回指令，在JVM字节码层面并没有任何特别的指令来表示这个方法被synchronized修饰的方法，而是在Class文件的方法表中将该方法的<strong>accessflags字段中的synchronized标志位置1</strong>。</p>
<p>JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。 </p>
<p>首先是自旋锁，列举一个场景，如果线程频繁的进行阻塞和唤醒，会给系统带来很大的压力，同时很多锁的持有状态只会存在很短的一段时间，为了这一段很短的时间频繁的阻塞和唤醒线程是不值得的，于是引入了自旋锁。就是让一个线程去等待一段时间，这段时间内会进行无意义的循环操作，而不会立即被挂起，会不断查看持有锁的线程有没有释放，如果释放了就可以尝试获得锁。自旋锁在jdk1.4中引用，是默认关闭的，可以使用参数开启，在jdk1.6中默认开启，同时自旋次数默认是十次，这个也可以通过参数调整。</p>
<p>​        但是无论怎么调整，都不可能知道具体是多少次，不可能满足所有的情况，所以jdk1.6引入了适应性自旋。适应性自旋锁与自旋锁的区别在于它的自旋次数是会变的，如果线程上次自旋成功了，获得了锁，那么这次自旋的次数就会增加，因为虚拟机认为如果上次成功了，这次成功的可能性会很大；反之如果自旋成功的次数很少，那么之后的自旋次数就会减少，甚至直接忽略掉自旋的过程，以免浪费处理器的资源。</p>
<p>​        接着是锁消除。比如在一个方法里用了锁，但是JVM检测到这个方法里面不存在共享数据竞争的问题，也就是共享数据在这个方法里面是线程安全的，所以就没有必要加锁，加了锁反而会影响程序的性能。所以JVM检测到这个问题之后，就会将这个锁消除。</p>
<p>​        然后是锁粗化，在使用锁的时候，应该要让锁作用的程序范围越小越好，这是为了让在锁内执行的代码尽可能少，缩短持有锁的时间，让等待锁的线程能尽快拿到锁，在大多数情况下，这样的作法是正确的，但是在某些情况下，这样的做法是不对的。比如在一段程序内，持续的进行加锁，这个时候它的加锁操作和解锁操作就会特别频繁，而且被锁住的代码都是在一块的，就会导致很多没必要的性能消耗。比如是在一个for循环内加锁，那么每次for循环都要去抢锁和释放锁，那对性能的影响是非常大的，这个时候如果把锁放到for循环外，这个时候，只要抢到锁就可以进入for循环，存粹的for循环和在for循环内加锁，二者的效率肯定会差很多。这就是锁粗化的作用。</p>
<p>​        下面说明一下synchronized锁升级的过程。从无锁状态会升级到偏向锁状态，当我们创建一个对象的时候，这个对象有一个mark word，里面存储一些数据，比如是否是偏向锁，以及它的锁标志位等，如果锁的标志位是0，说明这个对象没有被加上偏向锁，如果是1，就说明这个对象被加上了偏向锁。偏向锁可以理解成是一个偏心的锁，意思就是这个锁会偏向于第一个获得它的线程，然后在接下来的执行过程中，假如这个锁没有被其他线程竞争，那么持有偏向锁的线程就永远不需要进行同步操作；一旦有其他线程进入锁，这个时候才会撤销这个偏向锁。</p>
<p>​        偏向锁的撤销，会先到达一个全局的安全点，也就是当前没有字节码运行的一个状态，然后暂停拥有偏向锁的线程，然后判断这个线程是否存活，如果这个线程不存活，或者这个线程存活，但是已经执行完同步代码，就会将对象恢复成无锁状态；否则就将对象升级为轻量级锁状态。线程是否存活可以查看JVM中的所有线程，如果存在这个线程，这个线程就是存活的。偏向锁的撤销过程会使锁的效率大大降低，所以如果运行时存在大量多线程竞争，偏向锁会导致性能下降。这个时候应该要禁用这个偏向锁，如果不禁用，它的抢锁和撤销锁的过程会非常消耗资源。可以使用 UsebiasedLocking参数关闭偏向锁。</p>
<p>​        然后是轻量级锁。偏向锁升级之后会变成轻量级锁，轻量级锁的竞争方式是在这个mark word中使用cas算法竞争这个锁。轻量级锁就是自旋锁和适应性自旋锁，如果在自旋的这段时间里，没有获得这个锁，就会升级成重量级锁，也就是锁膨胀。</p>
<p>​        重量级锁依赖于对象内部的monitor，而monitor依赖于操作系统的互斥锁实现，所以重量级锁也被称为互斥锁。互斥锁的开销非常大，主要是因为当系统检测到这个锁是重量级锁后，会把想要获取这个锁的其他线程阻塞，被阻塞的线程是不会消耗cpu的，但是阻塞和唤醒的过程都需要操作系统帮忙，这个时候就需要从用户态转换为内核态，转换状态是非常耗时的，有可能比用户执行代码的时间还要长，所以重量级锁的开销非常大。</p>
<p>​        总结上述整个流程，偏向锁和轻量级锁都是乐观锁，而重量级锁是悲观锁，一个对象刚开始实例化的时候是没有任何线程访问的，它可以是偏向的，所以当第一个线程访问的时候，它就获得了一个偏向锁，一旦有第二个线程来访问这个对象，因为偏向锁不会主动释放，所以第二个线程就可以看到这个对象是偏向锁的状态，表明这个时候已经存在锁竞争的问题了。要竞争锁的线程，需要检查原持有锁的线程是否存活，如果不存活，就将对象转换为无锁状态，重新进行偏向锁的持有，如果原来的线程存活，就马上执行线程的操作栈，检查这个对象的使用情况，如果仍然需要持有这个偏向锁，这个时候偏向锁就会升级为轻量级锁，如果不存在这个对象的使用，就可以把这个对象恢复成无锁状态，重新进行偏向锁的竞争，然后轻量级锁会进行自旋的操作，如果超出了一定的自旋次数，还没有获取到这个锁，就会升级到重量级锁，此时除了拥有锁的这个线程的其他线程都是阻塞状态。</p>
<p>​        锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<h2 id="35-volatile、threadlocal"><a href="#35-volatile、threadlocal" class="headerlink" title="35. volatile、threadlocal"></a>35. volatile、threadlocal</h2><p> 首先应该知道并发编程的三个概念：</p>
<ol>
<li>原子性：即一个或多个操作，要不全部执行，要不全部不执行；</li>
<li>可见性：即多个线程访问一个变量，一个线程修改了这个变量，其他线程能够立即看到这个修改；</li>
<li>有序性：即程序执行的顺序按照代码的先后顺序执行。</li>
</ol>
<h3 id="1-ThreadLocal"><a href="#1-ThreadLocal" class="headerlink" title="1. ThreadLocal"></a>1. ThreadLocal</h3><p>ThreadLocal是局部变量，是线程内独享的，在进程中定义的一个变量需要在每个线程中进行拷贝，独立操作，互不干扰。</p>
<p>线程内部有个ThreadLocalMap变量，首先根据当前线程对象get到该线程的ThreadLocalMap对象，这个map定义了Entry，用于存储ThreadLocal对象以及对应的值。</p>
<p>一个线程拥有一个ThreadLocalMap对象，一个ThreadLocalMap对象可用存储多个线程的局部变量。</p>
<h3 id="2-volatile"><a href="#2-volatile" class="headerlink" title="2. volatile"></a>2. volatile</h3><p>volatile是修饰符关键字，用于修饰变量，被volatile修饰的变量意味着：</p>
<ol>
<li>一个线程对于这个变量的修改，对其他线程来说是可见的；</li>
<li>禁止编译器的重排序，对于该变量操作之前和操作之后的代码顺序不会变；</li>
<li>volatile关键字只能保变量的可见性，不能保证针对该变量的原子性。</li>
</ol>
<h2 id="36-String-和StringBuffer和-StringBuilder的区别"><a href="#36-String-和StringBuffer和-StringBuilder的区别" class="headerlink" title="36. String 和StringBuffer和 StringBuilder的区别"></a>36. String 和StringBuffer和 StringBuilder的区别</h2><p>String是字符串常量，长度不可变，用于存放字符的数组是 final 类型，所以只能赋值一次，每次更改都是new了一个对象，操作频繁会带来比较大的开销；</p>
<p>StringBuffer是线程安全的字符串变量，可以对内容进行修改，但由于使用Synchronized锁，会产生不可避免的开销；</p>
<p>StringBuilder是线程不安全的字符串变量，也可以对内容进行修改，但是非线程安全，所以可以避免锁的开销。</p>
<h2 id="37-几种线程创建方式"><a href="#37-几种线程创建方式" class="headerlink" title="37. 几种线程创建方式"></a>37. 几种线程创建方式</h2><h2 id="38-NIO和BIO"><a href="#38-NIO和BIO" class="headerlink" title="38. NIO和BIO"></a>38. NIO和BIO</h2><h3 id="39-wait和sleep用法异同"><a href="#39-wait和sleep用法异同" class="headerlink" title="39. wait和sleep用法异同"></a>39. wait和sleep用法异同</h3><h3 id="40-java中char能存放汉字吗"><a href="#40-java中char能存放汉字吗" class="headerlink" title="40. java中char能存放汉字吗"></a>40. java中char能存放汉字吗</h3><p>能。在Java中，默认使用Unicode编码方式，及每个字符占两个字节，所以可以存储中文。</p>
<p>String是由char组成，但是它采用更为灵活的方式存储：英文占一个字节，中文占两个字节。这种存储方式可以减少存储的空间，提高存储效率。</p>
<p>所以可以使用如下方式判断String中是否包含中文：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (str.getBytes().length == str.length()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;无汉字&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;有汉字&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="41-HashMap在多线程怎么实现线程安全"><a href="#41-HashMap在多线程怎么实现线程安全" class="headerlink" title="41. HashMap在多线程怎么实现线程安全"></a>41. HashMap在多线程怎么实现线程安全</h3><p>可以使用ConcurrentHashMap。</p>
<h3 id="42-String可以继承吗"><a href="#42-String可以继承吗" class="headerlink" title="42. String可以继承吗"></a>42. String可以继承吗</h3><p>不可以，因为String有final修饰符。</p>
<h3 id="43-接口中可以有构造函数吗"><a href="#43-接口中可以有构造函数吗" class="headerlink" title="43. 接口中可以有构造函数吗"></a>43. 接口中可以有构造函数吗</h3><p>因为接口不允许实例化，所以不可以有构造函数。接口只能实现，不能继承。</p>
<h3 id="44-线程安全的理解和实现"><a href="#44-线程安全的理解和实现" class="headerlink" title="44. 线程安全的理解和实现"></a>44. 线程安全的理解和实现</h3><p>​        当多个线程访问一个对象时，如果不要进行额外的同步控制或协调操作，调用这个对象的行为都可以获得正确的结果，我们就说这个对象是线程安全的。</p>
<p>​        实现线程安全的方式有很多种，常见的方式就是使用synchronized关键字给代码块或方法加锁，如StringBuffer内部就使用了Synchronized修饰。</p>

    </div>

    
    
    
	  
	
	 <div>
		<div>
    
        <div style="text-align:center;color: #ccc;font-size:24px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
	 </div>
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/12/LeetCode-1370-%E4%B8%8A%E5%8D%87%E4%B8%8B%E9%99%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="prev" title="LeetCode - 1370. 上升下降字符串">
      <i class="fa fa-chevron-left"></i> LeetCode - 1370. 上升下降字符串
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/11/18/LeetCode-%E5%89%91%E6%8C%87-Offer-44-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/" rel="next" title="LeetCode - 剑指 Offer 44. 数字序列中某一位的数字">
      LeetCode - 剑指 Offer 44. 数字序列中某一位的数字 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Java%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.</span> <span class="nav-text">1. Java语言的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E5%B1%95%EF%BC%9A"><span class="nav-number">1.1.</span> <span class="nav-text">拓展：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">面向对象编程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-JDK%E3%80%81JRE%E5%92%8CJVM%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-number">2.</span> <span class="nav-text">2. JDK、JRE和JVM的区别和联系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.</span> <span class="nav-text">3. 类和对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="nav-number">4.</span> <span class="nav-text">4. 面向对象的三大特征</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">5.</span> <span class="nav-text">5. 修饰符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Object%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">6.</span> <span class="nav-text">6. Object类的常用方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">7.</span> <span class="nav-text">7. 字符型常量和字符串常量的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">8.</span> <span class="nav-text">8. 常见的关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E6%A0%87%E8%AF%86%E7%AC%A6%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">9.</span> <span class="nav-text">9. 标识符和关键字的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E6%B3%9B%E5%9E%8B%E5%92%8C%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4"><span class="nav-number">10.</span> <span class="nav-text">10. 泛型和泛型擦除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-x3D-x3D-%E5%92%8C-equals-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8AhashCode-%E5%92%8C-euqlas"><span class="nav-number">11.</span> <span class="nav-text">11. &#x3D;&#x3D; 和 equals() 的区别，以及hashCode() 和 euqlas()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">12. 基本的数据类型有哪些？自动装箱和拆箱？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%EF%BC%9F%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="nav-number">13.</span> <span class="nav-text">13. 重载和重写？深拷贝和浅拷贝？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%E6%96%B9%E6%B3%95%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="nav-number">14.</span> <span class="nav-text">14. 方法的四种类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E5%B8%B8%E8%A7%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">15.</span> <span class="nav-text">15. 常见设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99"><span class="nav-number">15.1.</span> <span class="nav-text">设计模式的原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">15.2.</span> <span class="nav-text">（1） 单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A4%E5%A4%84%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%AF%A2%E9%97%AEvolatile%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">15.2.1.</span> <span class="nav-text">此处可能会询问volatile的好处</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">15.3.</span> <span class="nav-text">（2）工厂模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%AF%B4%E4%B8%80%E8%AF%B4%E4%BD%A0%E5%AF%B9%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">15.3.1.</span> <span class="nav-text">1. 说一说你对工厂模式的理解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">15.4.</span> <span class="nav-text">（3）观察者模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F"><span class="nav-number">15.5.</span> <span class="nav-text">（4）装饰模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">15.6.</span> <span class="nav-text">（5）代理模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">15.6.1.</span> <span class="nav-text">扩展：静态代理和动态代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InvocationHandler-%E5%92%8C-Proxy"><span class="nav-number">15.6.2.</span> <span class="nav-text">InvocationHandler 和 Proxy</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-List%E3%80%81Set%E3%80%81Map%E4%B8%89%E8%80%85%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-number">16.</span> <span class="nav-text">16. List、Set、Map三者的联系和区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-HashMap-%E5%92%8C-HashTable%E3%80%81HashSet%E3%80%81TreeMap-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">17.</span> <span class="nav-text">17. HashMap 和 HashTable、HashSet、TreeMap 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">18.</span> <span class="nav-text">18. HashMap的底层原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-ConcurrentHashMap%E4%B8%8EHashTable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">19.</span> <span class="nav-text">19. ConcurrentHashMap与HashTable的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-ConcurrentHashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">20.</span> <span class="nav-text">20. ConcurrentHashMap底层原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-Comparable-%E5%92%8C-Comparator-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">21.</span> <span class="nav-text">21. Comparable 和 Comparator 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-ArrayList%E3%80%81LinkedList%E3%80%81Vector%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">22.</span> <span class="nav-text">22. ArrayList、LinkedList、Vector的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-HashSet%E5%A6%82%E4%BD%95%E6%A3%80%E6%9F%A5%E9%87%8D%E5%A4%8D"><span class="nav-number">23.</span> <span class="nav-text">23. HashSet如何检查重复</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E5%92%8C%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91"><span class="nav-number">24.</span> <span class="nav-text">24. 静态编译和动态编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="nav-number">25.</span> <span class="nav-text">25. 反射机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84"><span class="nav-number">25.1.</span> <span class="nav-text">什么是反射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84"><span class="nav-number">25.2.</span> <span class="nav-text">为什么使用反射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">25.3.</span> <span class="nav-text">反射的基本使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">25.4.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">25.5.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-Java%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">26.</span> <span class="nav-text">26. Java中的引用类型有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="nav-number">27.</span> <span class="nav-text">27. JVM内存分配与回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E9%A6%96%E5%85%88%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8BJVM%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E3%80%82"><span class="nav-number">27.1.</span> <span class="nav-text">1. 首先了解一下JVM的内存模型。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%9A"><span class="nav-number">27.2.</span> <span class="nav-text">2. JVM内存分配：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-JVM%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="nav-number">27.3.</span> <span class="nav-text">3. JVM内存回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%88%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95%E5%92%8C%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">27.3.1.</span> <span class="nav-text">判断对象是否可以被回收（引用计数法和可达性分析算法）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="nav-number">27.3.2.</span> <span class="nav-text">1. 引用计数法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="nav-number">27.3.3.</span> <span class="nav-text">2. 可达性分析算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">27.4.</span> <span class="nav-text">4. 垃圾收集算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">27.5.</span> <span class="nav-text">5. 垃圾收集器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-number">28.</span> <span class="nav-text">28. 进程和线程的区别和联系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="nav-number">29.</span> <span class="nav-text">29. 并行与并发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81"><span class="nav-number">30.</span> <span class="nav-text">30. 线程的生命周期和状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="nav-number">31.</span> <span class="nav-text">31. 线程死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8"><span class="nav-number">32.</span> <span class="nav-text">32. 线程池的原理及使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-%E4%BA%92%E6%96%A5%E3%80%81%E8%87%AA%E6%97%8B%E3%80%81%E8%AF%BB%E5%86%99%E3%80%81%E6%82%B2%E8%A7%82%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-number">33.</span> <span class="nav-text">33. 互斥、自旋、读写、悲观、乐观锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-Synchronized%E9%94%81%E6%BA%90%E7%A0%81"><span class="nav-number">34.</span> <span class="nav-text">34. Synchronized锁源码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-cas"><span class="nav-number">34.0.1.</span> <span class="nav-text">1. cas</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="nav-number">34.0.2.</span> <span class="nav-text">2. 对象头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">34.0.3.</span> <span class="nav-text">synchronized锁实现原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-volatile%E3%80%81threadlocal"><span class="nav-number">35.</span> <span class="nav-text">35. volatile、threadlocal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-ThreadLocal"><span class="nav-number">35.1.</span> <span class="nav-text">1. ThreadLocal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-volatile"><span class="nav-number">35.2.</span> <span class="nav-text">2. volatile</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#36-String-%E5%92%8CStringBuffer%E5%92%8C-StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">36.</span> <span class="nav-text">36. String 和StringBuffer和 StringBuilder的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37-%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="nav-number">37.</span> <span class="nav-text">37. 几种线程创建方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38-NIO%E5%92%8CBIO"><span class="nav-number">38.</span> <span class="nav-text">38. NIO和BIO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#39-wait%E5%92%8Csleep%E7%94%A8%E6%B3%95%E5%BC%82%E5%90%8C"><span class="nav-number">38.1.</span> <span class="nav-text">39. wait和sleep用法异同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40-java%E4%B8%ADchar%E8%83%BD%E5%AD%98%E6%94%BE%E6%B1%89%E5%AD%97%E5%90%97"><span class="nav-number">38.2.</span> <span class="nav-text">40. java中char能存放汉字吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#41-HashMap%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">38.3.</span> <span class="nav-text">41. HashMap在多线程怎么实现线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-String%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E5%90%97"><span class="nav-number">38.4.</span> <span class="nav-text">42. String可以继承吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#43-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%90%97"><span class="nav-number">38.5.</span> <span class="nav-text">43. 接口中可以有构造函数吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#44-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-number">38.6.</span> <span class="nav-text">44. 线程安全的理解和实现</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bonnie"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Bonnie</p>
  <div class="site-description" itemprop="description">每天都要做个人啊</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">97</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">58</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021-05 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bonnie</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
