<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Java语言的特点Java语言的主要特点有：">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 面试题">
<meta property="og:url" content="http://example.com/2021/11/15/Java-%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="往南">
<meta property="og:description" content="Java语言的特点Java语言的主要特点有：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/Java-%E9%9D%A2%E8%AF%95%E9%A2%98.assets/bb2f637c254a208f400fe260d97183d5.png">
<meta property="og:image" content="http://example.com/Java-%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220312203227049.png">
<meta property="og:image" content="http://example.com/Java-%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220315170028772.png">
<meta property="article:published_time" content="2021-11-15T13:39:32.000Z">
<meta property="article:modified_time" content="2022-03-23T16:58:36.369Z">
<meta property="article:author" content="Bonnie">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/Java-%E9%9D%A2%E8%AF%95%E9%A2%98.assets/bb2f637c254a208f400fe260d97183d5.png">

<link rel="canonical" href="http://example.com/2021/11/15/Java-%E9%9D%A2%E8%AF%95%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java 面试题 | 往南</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">往南</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="download fa-fw"></i>资源</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/15/Java-%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Bonnie">
      <meta itemprop="description" content="每天都要做个人啊">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="往南">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 面试题
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-15 21:39:32" itemprop="dateCreated datePublished" datetime="2021-11-15T21:39:32+08:00">2021-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-24 00:58:36" itemprop="dateModified" datetime="2022-03-24T00:58:36+08:00">2022-03-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Java语言的特点"><a href="#Java语言的特点" class="headerlink" title="Java语言的特点"></a>Java语言的特点</h2><p>Java语言的主要特点有：</p>
<span id="more"></span>

<ol>
<li>面向对象：Java是一门面向对象的高级编程语言，所谓的面向对象实际上是一种思考的模式，通过模拟现实世界来解决现实问题。</li>
<li>简单性：首先Java具有自动内存管理机制，比如c语言中会有析构函数如delete、free等，在内存使用完毕需要手动去释放内存，但是Java语言在内存使用完成后就不用再管，内存会被自动回收，这样不容易造成内存溢出；其次，Java借鉴了一些老牌编程语言的特性，简化了流程的处理，同时也简化了Java过程中的语义，比如goto这些在Java中就被顶替掉了，通过其他的方式在语义清晰的情况下达到原有的目的。</li>
<li>跨平台：指的是软件可以在任意计算机环境中正常运行，而不需要考虑计算机硬件和操作系统的约束，实现了Java一次编译到处运行的目标。因为Java会将源码编译为字节码，字节码是无关平台的，任意平台上的JVM都会向Java编译器提供一个相同的接口用来获取字节码，所以Java语言是具有跨平台性的。</li>
</ol>
<p>​        具体说到字节码，就肯定要先知道机器码。我们当前使用的大部分语言都是高级语言，而这些语言使用的源码，都由英文和符号组成，这种代码是无法被计算机直接识别的，我们需要将其翻译为机器码交由计算机执行。翻译的过程有两种形式：编译和解释。编译指的是在程序运行前，将源码全部翻译为机器码，再交由计算机执行；解释指的是在程序运行时，将代码解释一行，交由计算机执行一行。编译的好处是执行的效率会很高，但是由于不同计算机的机器码不同，所以可以执行很低，面对不同的计算机，就需要重新编译源代码，甚至额能要修改部分源码；而解释的效率会比较低，但是可移植性高，不同计算机的解释器和机器码是一致的，所以只需要使用一份源码交给不同的解释器执行就可以。<br>​        而Java语言使用先编译后解释的方式，其中就引出了字节码。Java语言先将源码编译为字节码文件，然后将字节码提交给计算机，在程序运行时解释i解码文件。因为字节码也是二进制文件，与机器码很像，所以从字节码转换为机器码就会更快一点。综上，Java语言相较于纯的编译型语言，可移植性更高，相较于解释型语言，解释的效率也会更高。</p>
<hr>
<h3 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h3><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><p>就是分析出系统中应包含哪些对象，以及它们之间的关系，再用特定的语法来描述这些对象和关系。</p>
<p>比如，使用面向对象的思想来说一下上课的过程。有电瓶车和司机，司机开电瓶车，我要坐电瓶车去上课，然后有学生，上课的点有许多学生要上车，还有教学楼，乘车到目的的教学楼然后下车前往教室上课。</p>
<h2 id="JDK、JRE和JVM的区别和联系"><a href="#JDK、JRE和JVM的区别和联系" class="headerlink" title="JDK、JRE和JVM的区别和联系"></a>JDK、JRE和JVM的区别和联系</h2><p>​        JDK是Java标准开发包，包括编译以及运行Java程序所需的各种工具和资源，比如Java编译器、Java运行时环境、常用的Java类库等。</p>
<p>​        JRE是Java运行时环境，用于解释和执行字节码文件，普通用户只需要运行Java程序安装JRE就好，如果要编译和调试程序需要安装JDK。</p>
<p>​        JVM即Java虚拟机，是JRE的一部分，是Java跨平台最核心的部分，用于解释和执行字节码文件。也就是说JVM相当于一个字节码翻译器，将字节码翻译成各个系统对应的机器码，确保字节码文件能在不同系统正常执行。</p>
<h2 id="JVM相关"><a href="#JVM相关" class="headerlink" title="JVM相关"></a>JVM相关</h2><h3 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h3><p>​        JVM是运行在操作系统上的，可以看成是一个软件，它上面跑的都是Java程序，其他的程序和JVM可以看成是并列的软件</p>
<p><img src="/Java-%E9%9D%A2%E8%AF%95%E9%A2%98.assets/bb2f637c254a208f400fe260d97183d5.png"></p>
<h3 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a>JVM体系结构</h3><p>​        首先简单了解一个Java程序的运行过程：</p>
<ol>
<li>一个 <code>.java</code> 文件首先会通过 <code>javac</code> 命令转换为字节码文件 <code>.class</code> ，接着这个 <code>.class</code> 会加载到类加载器，类加载器把字节码文件加载到运行时数据区，一般我们的runtime异常都是在这个地方产生的。</li>
<li>运行时数据区里包括方法区（Method Area）、本地方法栈（Native Method Stack）、栈（Stack）、堆（Heap）、程序计数器。</li>
<li>对于本地方法的调用，本地方法栈会通过一个本地接口调用本地方法库的方法，所以会有一个本地接口和运行时数据区交互。</li>
<li>如果是执行Java程序，是使用执行引擎和运行时数据区交互执行。</li>
</ol>
<p>​        在运行时数据区中，栈、本地方法栈和程序计数器都是线程私有的，这部分内容不会出现垃圾收集，垃圾收集的部分是线程共享的堆和方法区，这两个地方也是JVM调优的地方，其中99%的调优都是针对堆来进行的。</p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><pre><code>     类加载器的作用是加载class类，这里的这个class类可以看成是一个模板，后续要比较两个实例是否相等肯定要比较他们的类加载器是否相等，一个模板类肯定是由一个类加载器来加载的。类加载器会将这个class类加载并初始化成一个反射的class对象，由这个对象进行实例化的操作。
</code></pre>
<h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p>​        在JVM的层面，类加载器有两种：一种是由C++语言编写的启动类（根）加载器，一种是由Java语言编写的其他所有类加载器。</p>
<p>​        这些类加载器在Java层面构成了一个三层类加载器模型，也叫双亲委派模型：最上面一层是启动类（根）加载器，存放在jre&#x2F;lib下的rt.jar包中，因为是用C++实现，无法被Java程序直接调用的，所以到这个层面一般会返回null；下面一层是扩展类加载器，存放在 jre&#x2F;lib&#x2F;ext 目录下，由于是使用Java语言编写，所以可以显示；再下一层是应用程序（系统类）加载器，负责加载用户类路径上的类。</p>
<p>​        双亲委派机制的原理是：一个类加载器收到类加载的请求，先层层向上委托给父类加载器加载，直到顶层的根加载器，根加载器会检查能否加载这个类，能就在根加载器加载，不能就抛出异常再逐层往下找，如果所有的类加载器都找不到这个类，就会报错 Class Not Found。</p>
<p>​        双亲委派机制的目的是保证安全，如果不使用双亲委派机制，那么假设用户也编写一个java.lang.String类，不同的类加载器会加载出不同的类型，导致程序变得混乱。一个类的类型是由该类和加载它的类加载器唯一确定的。</p>
<h3 id="Native-Method-Stack本地方法栈"><a href="#Native-Method-Stack本地方法栈" class="headerlink" title="Native Method Stack本地方法栈"></a>Native Method Stack本地方法栈</h3><p>​        首先说明一下natve关键字，由这个关键字修饰的内容，就说明是Java范围内无法达到的，这就会取调用底层c语言的库。</p>
<p>​        class文件经过类加载器到运行时数据区将关于Java的内容都分配完成，会进入本地方法栈，通过调用本地方法接口JNI来使用本地方法库。JNI的作用是融合不同编程语言为Java所用，这个不同的编程语言最初就包含了C和C++。因为Java在刚诞生的时候是C和C++普遍流行的时候，想要立足就必须能调用C和C++的程序，于是，它在内存中开辟了一块标记区域：本地方法栈，用来标记 native 方法，并在最终执行的时候去加载本地方法库的方法。</p>
<h3 id="PC寄存器（程序计数器）"><a href="#PC寄存器（程序计数器）" class="headerlink" title="PC寄存器（程序计数器）"></a>PC寄存器（程序计数器）</h3><p>​        程序计数器就是一个指针，用来存储指向下一条指令的地址，是一个非常小的内存空间，几乎可以忽略不计。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>​        方法区是存放在堆的永久代中的，里面存储 static 静态变量、final 常量、类信息（类加载的信息、构造方法、接口定义）、运行时常量池。为了区分方法区和堆，也叫方法区为非堆。</p>
<p>比如要对下述代码进行内存分配：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    String name = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test t = <span class="keyword">new</span> test();</span><br><span class="line">        t.a = <span class="number">1</span>;</span><br><span class="line">        t.name = <span class="string">&quot;bcd&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/Java-%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220312203227049.png" alt="image-20220312203227049"></p>
<h3 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h3><p>​        主管程序的运行，生命周期和线程是同步的。当线程结束，这个栈内存就会释放，所以不会存在垃圾回收的问题。</p>
<p>​        栈用于存储基本数据类型、对象的引用（reference）以及实例的方法等。运行原理就是栈帧。一个栈帧中包含方法索引、输入输出参数、本地变量、class的引用、指向上一个栈帧的父帧和指向下一个栈帧的子帧。因为栈的内存容量是有限的，所以一旦栈帧的数量超出了栈的内存，就会报错栈溢出：StackOverFlowError。</p>
<h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h3><p>​        一个JVM只会生成一个堆内存，堆内存的大小是可以调节的。堆内存中会存储对象的实例、。这个字符串常量池中存储的是字符串的常量值。</p>
<p>​        对堆内存细分，可以分为三块区域：新生代、老年代和永久代，其中新生代又会被细分为伊甸园区和幸存区。</p>
<p>​        新生代是一个对象诞生、成长甚至死亡的地方。new一个对象，首先会存放到伊甸园区，当伊甸园区的内存满了，就会触发一次轻GC，在这个阶段，如果有对象还存在引用就存活，否则就回收这块内存。存活的对象会被放到幸存区。如果幸存区也满了，就会触发一次重GC，也就是full GC，这次垃圾回收会清理整个新生代的内存，然后将存活的对象放到老年代。如果老年代也满了，就会触发对内存溢出的错误。不过在日常使用中，99%的对象都是临时对象，也就是只使用一次后面就不再使用的对象，所以其实进入老年代的对象并不多。</p>
<p>​        对于永久代，这个区域是常驻内存的，用来存放JDK自身携带的Class对象，也就是Java运行时的一些环境、类信息等，这个区域不存在垃圾回收，关闭虚拟机才会释放这个内存。在jdk1.6之前，这块区域被称作永久代，常量池是存在方法区的；jdk1.7的时候，出现了去永久代，也就是慢慢的退化了这个永久代，这个时候常量池存放在堆中；jdk1.8之后，永久代改名为元空间，常量池在元空间。</p>
<p>​        这块内存一般不会溢出，但是如果一个启动类加载了大量的jar包、或者Tomcat上部署了大量的应用等，这些情况是会撑爆元空间的，就会出现OOM的错误。</p>
<p>​        OOM解决的措施：</p>
<ol>
<li>首先扩大内存：<code>-Xms1024m -Xmx1024m -XX:+PrintGCDetails</code> ；</li>
<li>如果扩大之后还是出现堆内存溢出的情况，就需要使用专业工具分析内存，查哪个地方出现了问题。专业的内存快照分析工具包括MAT、JProfiler。</li>
</ol>
<h3 id="面试问题：堆空间一定是所有线程共享的么？"><a href="#面试问题：堆空间一定是所有线程共享的么？" class="headerlink" title="面试问题：堆空间一定是所有线程共享的么？"></a>面试问题：堆空间一定是所有线程共享的么？</h3><p>不是，TLAB线程在堆中独有的。</p>
<h3 id="JVM内存的回收GC"><a href="#JVM内存的回收GC" class="headerlink" title="JVM内存的回收GC"></a>JVM内存的回收GC</h3><p>​        JVM进行GC的区域包括：伊甸园区、幸存区和老年代，大部分时候，回收的都是伊甸园区。</p>
<p>​        GC有两类：轻GC，也就是普通的GC；重GC，也就是全局GC。轻GC是针对新生代的，重GC是针对老年代的。</p>
<p>​        新生代的幸存区分为两个部分：from区和to区，这两个区是动态的，from和to就是从哪个区到哪个区的关系，哪个区的空的，这个区就是to区，会接收from区传过来的对象。设置两个幸存区的目的是解决内存碎片化，假设只有一个幸存区，那么当伊甸园区进行GC并将存活对象存入幸存区之后，如果幸存区中也包含存活对象，这两部分的对象所在的内存空间就不是连续的，很容易产生内存碎片；如果使用两个幸存区，那么就可以将伊甸园区中的存活对象和幸存区中包含存活对象的from区一起复制给to区，也就是没有任何对象的幸存区，接着将from区和伊甸园区的内存清空，就能保证每次至少都会有一个空的幸存区作为to区。</p>
<p>​        默认当一个对象在幸存区经历了15次GC依然存活，就会进入老年代。</p>
<p>​        GC中常见的算法有四种：引用计数法、标记清除算法、标记复制算法和标记整理算法。</p>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>​        给每个对象创建一个计数器，如果这个对象存在引用就加一，引用失效就减一，直到这个计数器的值为0，就将这个对象清除掉。这种方法并不高效，如果存在很多对象，就会创建很多计数器，这个计数器本身也是消耗内存的，在Java中不会使用。</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>​        新生代主要使用的就是复制算法。复制算法就是将伊甸园区和from区的存活对象放到to区，然后将伊甸园区和from区都清空。</p>
<p>​        好处是不会产生内存碎片；坏处是浪费了幸存区的空间，必须要保证始终有一个to区存在。在100%存活率的极端情况下，这种弊端带来的影响是很严重的，甚至会出现OOM的错误。</p>
<h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>​        会进行两次扫描，第一次标记存活对象，第二次清除没有标记的对象。</p>
<p>​        这种算法的弊端显而易见，对对象的标记肯定要占一部分内存，并且两次扫描也会消耗时间，而且存活对象不一定是连续的，这就会产生内存碎片；但是它不需要额外的空间。</p>
<h4 id="标记压缩算法"><a href="#标记压缩算法" class="headerlink" title="标记压缩算法"></a>标记压缩算法</h4><p>​        是在标记清除算法之后，将存活的对象移动到内存的一端存储，这样虽然增加了一个移动成本，但是可以避免产生内存碎片。</p>
<h3 id="JVM配置参数"><a href="#JVM配置参数" class="headerlink" title="JVM配置参数"></a>JVM配置参数</h3><ol>
<li><code>-Xms</code> 设置初始化内存分配大小，默认是1&#x2F;64；</li>
<li><code>-Xmx</code> 设置最大分配的内存大小，默认是1&#x2F;4；</li>
<li><code>-XX:+PrintGCDetails</code> 打印GC垃圾回收的信息；</li>
<li><code>-XX:+HeapDumpOnOutOfMemoryError</code> 生成OOM的dump文件；</li>
<li><code>-XX:MaxTenuringThresold</code> 设置进入老年代前要经历的GC次数，默认是15次。</li>
</ol>
<h3 id="JVM内存的泄漏、溢出、抖动以及相关的监控问题"><a href="#JVM内存的泄漏、溢出、抖动以及相关的监控问题" class="headerlink" title="JVM内存的泄漏、溢出、抖动以及相关的监控问题"></a>JVM内存的泄漏、溢出、抖动以及相关的监控问题</h3><p>​        内存溢出，指的是程序申请的资源超出了堆内存的容量，就会造成OOM内存溢出；内存泄漏，指的是本该在GC时候被回收的对象，被其他存活对象所持有，导致无法回收，内存写漏最终也会导致内存溢出；内存抖动就是短时间大量的创建仅使用一次的对象，从而导致需要频繁的进行GC操作，造成系统卡顿。</p>
<p>​        这些问题可以使用JProfiler来监控。</p>
<h3 id="JMM-Java内存模型（Java-Memory-Modal）"><a href="#JMM-Java内存模型（Java-Memory-Modal）" class="headerlink" title="JMM - Java内存模型（Java Memory Modal）"></a>JMM - Java内存模型（Java Memory Modal）</h3><p>​        JMM是缓存一致性协议，用于定义数据读写的规则。</p>
<p>​        JMM定义了线程工作内存和主内存之间的抽象关系：每个线程都有一个自己的工作内存，负责拷贝主内存的共享变量到本地使用。</p>
<p>​        解决的问题：</p>
<ol>
<li>可见性：假设有两个线程，线程A从主存拷贝对象count，并将count &#x3D; 1，这个变更对线程B是不可见的，因为次数A还没有将这个修改刷到主存中。解决的方式：volatile、synchronized。</li>
<li>竞争问题：假设两个线程都要读取count对象进行加一操作，如果是串行，这个对象会加2，如果是并行，那么无论哪个线程先将结果刷到主存，都是加一的操作。解决的方式：synchronized。</li>
</ol>
<p>面试的思路：</p>
<ol>
<li><p>说说看线程之间的通信机制有哪些呢？Java的并发采用的是哪种？</p>
<p>​        线程的通信机制有两种：共享内存和消息传递，目前Java使用的是共享内存的方式。</p>
</li>
<li><p>说说看什么是JMM内存模型？有什么存在作用？</p>
<p>​        JMM是一种抽象的规范。在不同操作系统或硬件下，对内存的访问逻辑是会存在一定差异的，一套代码在不同的系统中可能会出现不一样的结果，JMM的作用就是解决这种不一致性。</p>
</li>
<li><p>说说JMM对内存的划分？</p>
<p>​        JMM规定内存分为主内存和工作内存。主内存可以看成是JVM中的堆内存，里面存储的是共享变量；工作内存可以看成是JVM中栈的部分区域，是每个线程中都独有的一块内存，线程会拷贝主内存中要用的共享变量到本地的工作内存进行操作，而不是直接读写主内存。</p>
<p><img src="/Java-%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220315170028772.png" alt="image-20220315170028772"></p>
</li>
<li><p>说说JMM定义了哪些操作来完成主内存和工作内存的交互操作？</p>
<p>​        有8个，lock会给主存对应的变量上锁；read将主存对应变量的值传给线程工作内存；load工作内存加载read传过来的变量值到本地；use把工作内存的变量值给执行引擎；assign把从执行引擎传过来的值赋值给工作内存的变量；store把工作内存的变量值传回给主内存；write把store传来的值放入主内存的变量；unlock对主内存的这个变量解锁。</p>
</li>
<li><p>说说对内存交互基本操作的三个特性的理解？</p>
<p>​        三个特性是原子性、一致性和有序性。</p>
<p>​        原子性要求这一个或一组操作要么全部执行要么全部不执行，中间不能被打断。CPU有一个时间分片的概念，也就是一个线程执行完这个时间片后会被中断运行，直到再次获得时间片才能继续，这样就会产生原子性问题。</p>
<p>​        一致性指的是当多个线程访问一个共享变量，某一个线程对其进行修改，其他线程能够马上看到。比如有多个线程同时拷贝了一个共享变量，因为线程之间是看不到的，那么如果都执行了加一的操作，无论哪个先传回给主存，都只执行了一次加一的操作，这样就产生了一致性问题。</p>
<p>​        有序性是程序执行的顺序应该与代码顺序一致。但是指令重排等优化，也就会导致乱序问题。</p>
</li>
<li><p>以下几种情况中，哪几个操作是原子性操作？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">20</span>;    </span><br><span class="line">b = a;</span><br></pre></td></tr></table></figure>

<p>​        第一个操作是原子操作，第二个不是。因为第二个操作可以拆分为两个：获取a的值和将a的值赋给b，那么如果中间线程被中断，就不是原子性操作了。</p>
</li>
<li><p>java如何来保证原子性操作呢？</p>
<p>​        可以使用synchronized或lock关键字实现，这两个关键字都能够锁住整个代码块，只让一个线程进入。</p>
</li>
<li><p>说说看java用什么来保证可见性的？</p>
<p>​        可以使用volatile关键字保证可见性，或者synchronized和lock也可以。</p>
</li>
<li><p>说说看volatile如何生效的？</p>
<p>​        volatile有两个特殊的限定：（1）保证use前必须经过read和load；（2）保证assign后必须经过store和write。</p>
<p>​        这样就使得当一个共享变量被volatile修饰时，它会保证修改的值被立刻更新到主存，以此来保证共享变量的可见性。</p>
</li>
<li><p>说说看Java是如何保证有序性的？</p>
<p>​        可以通过synchronized或lock关键字，限制只让一个线程执行这个代码块；volatile也具有禁止指令重排的功能。这里有一个内存屏障的概念，就是一个cpu指令，8个指令操作中的store和 load 分别是写操作和读操作的两个内存屏障，能够禁止前后的指令执行重排序的优化；JMM也通过happens-before原则来保证有序性。</p>
</li>
<li><p>happens-before原则，说说看对它的理解？</p>
<p>​    首先简单的说明这个指令重排的含义，它就是在数据之间不存在依赖性的情况下，做出的优化。而happend-before原则是保证前一个操作的结果对后一个操作是可见的。以下面的例子来说：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">++i; <span class="comment">// A操作</span></span><br><span class="line">System.out.println(i); <span class="comment">// B操作</span></span><br></pre></td></tr></table></figure>

<p>​        在单线程的情况下，这两个操作因为是在一个工作内存中执行，所以不存在一致性的问题；又因为B操作对A操作的结果具有依赖性，所以单线程下，是天然支持happens-before的思想的。如果是在多线程下，由于每个线程都会拷贝一份共享变量，如果不对这个共享变量做同步处理，那么线程1执行操作A后，线程2执行操作B，此时A操作的结果不一定对B操作可见。</p>
<p>​        为了解决这个问题，JMM通过happens-before的规则来提供多线程下的内存可见性保证，也就是如果线程1的A操作对线程2的B操作存在happens-before的关系，尽管两个操作在不同线程执行，也会保证A操作的结果对B操作是可见的。</p>
<p>​        这并不是说happens-before禁止了重排序，事实上，JMM遵循一个基本原则，只要不改变程序的执行结果，怎么优化都可以。</p>
</li>
</ol>
<h2 id="数据类型和基本语法"><a href="#数据类型和基本语法" class="headerlink" title="数据类型和基本语法"></a>数据类型和基本语法</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>​        包括基本类型和引用类型。</p>
<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>分为三类：</p>
<ol>
<li><p>整型：byte、short、int、long、char；</p>
<p>（1）byte：在内存中占8位，也就是一个字节，取值范围在 <code>-2^7 ~ (2^7 - 1)</code>，也就是-128-127；</p>
<p>（2）short：占16位，取值在 <code>-2^15 ~ (2^16 - 1)</code>；</p>
<p>（3）int：占32位，取值在 <code>-2^31 ~ (2^31 - 1)</code>；</p>
<p>（4）long：占64位，取值在 <code>-2^63 ~ (2^63 - 1)</code>；</p>
<p>（5）char：占16位，取值在 <code>0 ~ 2^16</code> 。</p>
</li>
<li><p>浮点型：float、double；</p>
<p>（1）单精度float：占32位；</p>
<p>（2）双精度double：占64位。</p>
</li>
<li><p>boolean。</p>
<p>布尔值，占1个字节。</p>
</li>
</ol>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>Java中对象的引用分为四种级别，这四种级别由高到低依次为:强引用、软引用、弱引用和虚引用。</p>
<ol>
<li><p>强引用</p>
<p>Java中默认声明的就是强引用，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object(); //只要obj还指向Object对象，Object对象就不会被回收</span><br><span class="line">obj = null;  //手动置null</span><br></pre></td></tr></table></figure>

<p>只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显式的将强引用赋值为null。</p>
<p>Java的对象是位于heap 中的, heap中对象从强到弱有强可及对象、软可及对象、弱可及对象、虚可及对象和不可到<br>达对象。对于对象是属于哪种可及的对象，由他的最强的引用决定。看如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String abc=<span class="keyword">new</span> string ( <span class="string">&quot;abc&quot;</span>); <span class="comment">//1</span></span><br><span class="line">SoftReference&lt;string&gt; softRef=<span class="keyword">new</span> SoftReference&lt;string&gt; (abc); <span class="comment">//2</span></span><br><span class="line">WeakReference&lt;string&gt; weakRef = <span class="keyword">new</span> WeakReference&lt;string&gt;(abc); <span class="comment">//3</span></span><br><span class="line">abc=<span class="keyword">null</span>; <span class="comment">//4</span></span><br><span class="line">softRef.clear();<span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<p>第一行在heap堆中创建内容为“abc”的对象，并建立abc到该对象的强引用，该对象是强可及的。<br>第二行和第三行分别建立对 heap中对象的软引用和弱引用，此时 heap 中的abc对象已经有3个用，显然此时abc 对象仍是强可及的。<br>第四行之后heap 中对象不再是强可及的，变成软可及的。<br>第五行执行之后变成弱可及的。</p>
</li>
<li><p>软引用</p>
<p>软引用是用来描述一些非必需但仍有用的对象。<strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong>。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。<br>在 JDK1.2 之后，用java.lang.ref.SoftReference类来表示软引用。垃圾收集器只在真正 “需要” 内存时才收集软引用对象。</p>
</li>
<li><p>弱引用</p>
<p>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong>。在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用。</p>
</li>
<li><p>虚引用</p>
<p>虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，虚引用主要用来跟踪对象被垃圾回收的活动。在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p>
</li>
<li><p>引用队列</p>
<p>引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。</p>
</li>
</ol>
<h4 id="基本数据类型和引用类型的区别"><a href="#基本数据类型和引用类型的区别" class="headerlink" title="基本数据类型和引用类型的区别"></a>基本数据类型和引用类型的区别</h4><p>​        二者的区别主要是在内存上的存储不同。首先明确一下，JVM内存中，实际的常量值是存储在常量池中的，如果是基本数据类型，栈中会存储常量池中对应数据值的引用；如果是引用类型，会先在堆中存放这个引用的对象，然后在栈中存储这个变量和这个变量的对象在堆中的地址，堆中的对象才会存储到常量池的引用。</p>
<h4 id="x3D-x3D-和equals的区别"><a href="#x3D-x3D-和equals的区别" class="headerlink" title="&#x3D;&#x3D;和equals的区别"></a>&#x3D;&#x3D;和equals的区别</h4><p>​        &#x3D;&#x3D;会比较栈中存放的变量对应的值是否相等，因为基本数据类型会直接存储值在常量池中的位置，当值相等时，肯定是指向同一个位置；而对于引用类型，如果两个比较的变量都没有使用new来创建，那么当这个变量创建的时候，会先在常量池中寻找这个值，如果有就返回在堆中的对象，如果没有才会在堆中创建新的对象，所以这个时候两个变量会指向同一个地址；如果这两个变量有一个使用了new来创建，那么无论如何都会新建一个对象来存放这个实际值在常量池的位置，这两个变量就不可能相等。</p>
<p>​        equals是引用类型比较的函数，比较堆中对象指向的常量池中的实际值，所以无论new不new，都会返回实际值的比较。</p>
<h4 id="equals和hashCode的联系和区别"><a href="#equals和hashCode的联系和区别" class="headerlink" title="equals和hashCode的联系和区别"></a>equals和hashCode的联系和区别</h4><p>​        equals比较的是两个引用类型的实际值，hashCode是比较两个引用类型的hash值，这个hash值是将实际值依据某种算法计算得到的一个结果，所以两个不同的数值可能会得到相同的hash值。所以hash值相同的equals不一定为true，但是equals为true的，hash值一定相等。</p>
<h4 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h4><p>​        指的是基本数据类型和引用类型直接的转换。装箱指的是将int转换为Integer，使用Integer.valueOf()来实现；拆箱指的是将Integer转换为int，使用intValue来实现。</p>
<ol>
<li>引申问题①：<strong>Integer i &#x3D; new Integer(10)</strong> 和 <strong>Integer i &#x3D; 10</strong> 的区别</li>
</ol>
<p>（1）第一种方式不会触发自动装箱，第二种会；</p>
<p>（2）一般情况下，第二种方式的执行效率和资源占比会比第一种方式高，但不是绝对的。</p>
<ol start="2">
<li>引申问题②：下面程序的输出结果：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer i1 = <span class="number">100</span>;</span><br><span class="line">    Integer i2 = <span class="number">100</span>;</span><br><span class="line">    Integer i3 = <span class="number">200</span>;</span><br><span class="line">    Integer i4 = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(i1 == i2);</span><br><span class="line">    System.out.println(i3 == i4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：</p>
<blockquote>
<p>true</p>
<p>false</p>
</blockquote>
<p><strong>因为Integer的范围是：-128 ~ 127</strong> 。Integer、Short、Byte、Character、Long这几个类的 <code>valueOf</code> 是类似的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Double i1 = <span class="number">100.0</span>;</span><br><span class="line">    Double i2 = <span class="number">100.0</span>;</span><br><span class="line">    Double i3 = <span class="number">200.0</span>;</span><br><span class="line">    Double i4 = <span class="number">200.0</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(i1 == i2);</span><br><span class="line">    System.out.println(i3 == i4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：</p>
<blockquote>
<p>false</p>
<p>false</p>
</blockquote>
<p><strong>因为在某个范围整形是有限的，而浮点数不是</strong> 。Double、Float的 <code>valueOf</code> 是类似的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Boolean i1 = <span class="keyword">false</span>;</span><br><span class="line">    Boolean i2 = <span class="keyword">false</span>;</span><br><span class="line">    Boolean i3 = <span class="keyword">true</span>;</span><br><span class="line">    Boolean i4 = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(i1 == i2);</span><br><span class="line">    System.out.println(i3 == i4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：</p>
<blockquote>
<p>true</p>
<p>true</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="number">1</span>;</span><br><span class="line">    Integer b = <span class="number">2</span>;</span><br><span class="line">    Integer c = <span class="number">3</span>;</span><br><span class="line">    Long g = <span class="number">3L</span>;</span><br><span class="line">    Long h = <span class="number">2L</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(c==(a+b)); <span class="comment">//1</span></span><br><span class="line">    System.out.println(c.equals(a+b)); <span class="comment">//2</span></span><br><span class="line">    System.out.println(g==(a+b)); <span class="comment">//3</span></span><br><span class="line">    System.out.println(g.equals(a+b)); <span class="comment">//4</span></span><br><span class="line">    System.out.println(g.equals(a+h)); <span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：</p>
<blockquote>
<p>true<br>true<br>true<br>false<br>true</p>
</blockquote>
<p>首先我们需要知道：</p>
<p>（1）算术运算符仅对于基本数据类型，所以包装器类型进行运算的时候会自动拆箱；</p>
<p>（2）<code>equals</code> 会比较两个对象的类型和值。</p>
<p>所以可以得知 <code>1</code> 、<code>2</code> 和 <code>3</code> 都是 <code>true</code> ，<code>4</code> 因为 <code>Integer</code> 和 <code>Long</code> 类型不同所以是 <code>false</code>，<code>5</code> 因为 <code>h</code> 是 <code>Long</code> 类型，<code>Long</code> 比 <code>Integer</code> 的范围广泛，所以相加后自动装箱会转换为 <code>Long</code> ，之后比较值是相等的，所以是相等的。</p>
<h4 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h4><ol>
<li>字符型常量使用单引号，字符串常量使用双引号；</li>
<li>字符型常量使用2个字节存储，字符串常量的字节数与字符串的长度有有关，其中的每个字符都占一个字节；</li>
<li>字符型常量在ascii码表中都能找到对应的数值，而字符串常量是指向堆中的一个地址值。</li>
</ol>
<h4 id="String、StringBuffer和StringBuilder的区别"><a href="#String、StringBuffer和StringBuilder的区别" class="headerlink" title="String、StringBuffer和StringBuilder的区别"></a>String、StringBuffer和StringBuilder的区别</h4><p>​        String是字符串常量，底层存储的字符数组使用final修饰，所以每次的重新赋值都是在new一个对象，频繁的操作会消耗比较大的内存；Stringbuffer是线程安全的字符串变量，可以修改其中的字符，但是由于使用synchronized关键字来实现线程安全，所以会产生不可避免的开销；StringBuilder是线程不安全的字符串变量，相较于StringBuffer，可以避免锁的开销。</p>
<h4 id="java中char能存放汉字吗"><a href="#java中char能存放汉字吗" class="headerlink" title="java中char能存放汉字吗"></a>java中char能存放汉字吗</h4><p>能。在Java中，默认使用Unicode编码方式，及每个字符占两个字节，所以可以存储中文。</p>
<p>String是由char组成，但是它采用更为灵活的方式存储：英文占一个字节，中文占两个字节。这种存储方式可以减少存储的空间，提高存储效率。</p>
<p>所以可以使用如下方式判断String中是否包含中文：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (str.getBytes().length == str.length()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;无汉字&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;有汉字&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h4><ol>
<li><p>String</p>
<p>（1）构造函数：可以传入byte数组、char数组和String类型，同时对于数组，可以传入开始下表和长度来构造一个子数组的字符串；</p>
<p>（2）length()：返回长度；</p>
<p>（3）substring()：返回子串，可以传入开始下标和结束下标来指定子串的开始和结束，包左不包右；</p>
<p>（4）startsWith、endsWith：传入String类型的参数，返回该字符串是否以这个字符串为前缀或后缀；</p>
<p>（5）contains：返回该字符串是否包含传入的字符串；</p>
<p>（6）indexOf：返回传入的字符串参数在该字符串中第一次出现的开始下标。</p>
</li>
<li><p>Date</p>
<p>（1）构造函数：无参返回当前日期，有参传入int类型的年月日，也可以再传入小时、分钟、秒，最后使用想要的get方法取出，比如getYear；</p>
<p>（2）after、before：传入一个Date参数，判断当前日期是否在传入日期的之前或之后；</p>
<p>（3）compareTo：比较两个日期的顺序，0是相等，小于0是在参数之前，大于0是在参数之后；</p>
<p>（4）getTime：返回当前日期到基准时间的毫秒值，基准时间是 1970年1月1日0时0分0秒。</p>
</li>
</ol>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>有四种修饰符可以限制访问的权限：</p>
<ol>
<li>public：对所有类可见；</li>
<li>protected：对同一个包可见，如果父类和子类不在一个包，对不同包的子类可见；</li>
<li>default：对同一个包可见；</li>
<li>private：对同一个类可见。</li>
</ol>
<h4 id="循环，条件"><a href="#循环，条件" class="headerlink" title="循环，条件"></a>循环，条件</h4><p>while、for、break、continue；if、switch。</p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><h5 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h5><p>反射的概念是在运行状态中，对于任何一个类，都能知道它的所有属性和方法；对于任何一个对象，都能调用它的任意一个方法和属性。这种动态获取信息和动态调用对象方法的功能叫做反射机制。</p>
<h5 id="为什么使用反射"><a href="#为什么使用反射" class="headerlink" title="为什么使用反射"></a>为什么使用反射</h5><p>先抛开概念化的定义，看下面的两段代码：</p>
<p>例子：实现创建一个动物对象 <code>cat</code> 并调用 <code>run</code> 方法计算它跑两公里的距离。</p>
<p>不用反射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal cat = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="keyword">double</span> distance = cat.run(<span class="number">2d</span>);</span><br></pre></td></tr></table></figure>

<p>用反射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取动物类的反射对象</span></span><br><span class="line">Class clz = Class.forName(<span class="string">&quot;com.self.example.Animal&quot;</span>);</span><br><span class="line"><span class="comment">// 获取奔跑方法的反射对象</span></span><br><span class="line">Method met = clz.getMathod(<span class="string">&quot;run&quot;</span>, <span class="keyword">double</span>.class);</span><br><span class="line"><span class="comment">// 获取构造方法的反射对象</span></span><br><span class="line">Constructor cons = clz.getConstructor();</span><br><span class="line"><span class="comment">// 通过反射实例化对象</span></span><br><span class="line">Object obj = cons.newInstance();</span><br><span class="line"><span class="comment">//通过反射调用奔跑方法</span></span><br><span class="line">Object distance = met.invoke(obj, <span class="number">2d</span>);</span><br></pre></td></tr></table></figure>

<p>看起来，反射将两行代码可以解决的问题扩展到了五行代码解决，将简单的事情写复杂化了，但是反射传入的是字符串，如果将字符串提出来，比如放到配置文件中，或者在程序运行的时候传参，这样的程序就会变得非常动态了。</p>
<p>已知Java程序要运行，需要先将源代码通过javac转变为字节码，然后通过Java解释和执行字节码。Java是静态语言，变量的类型在编译前就需要确定，否则编译不能通过，这样限制了程序的灵活性，所以许多静态语言扩展出了动态的反射机制，以能够动态的获取对象信息和调用对象的方法。</p>
<h5 id="反射的基本使用"><a href="#反射的基本使用" class="headerlink" title="反射的基本使用"></a>反射的基本使用</h5><p>首先创建一个 <code>Hello</code> 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bonnie.example;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2022/1/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着在 <code>resource</code> 文件夹下创建一个属性文件 <code>property.properties</code> 存放 <code>hello</code> 类的信息，以便能够动态修改：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">className</span>=<span class="string">com.bonnie.example.Hello</span></span><br><span class="line"><span class="attr">methodName</span>=<span class="string">sayHello</span></span><br></pre></td></tr></table></figure>

<p>最后反射该类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bonnie.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2022/1/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reflectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reflect</span><span class="params">(String name )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取配置文件内容</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        ClassLoader classLoader = reflectTest.class.getClassLoader();</span><br><span class="line">        InputStream inputStream = classLoader.getResourceAsStream(<span class="string">&quot;property.properties&quot;</span>);</span><br><span class="line">        pro.load(inputStream);</span><br><span class="line">        String classname = pro.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">        String methodname = pro.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 获取类对象</span></span><br><span class="line">        Class clz = Class.forName(classname);</span><br><span class="line">        <span class="comment">// 3. 获取实例对象</span></span><br><span class="line">        Object obj = clz.getConstructor().newInstance();</span><br><span class="line">        <span class="comment">// 3. 调用set方法存数据</span></span><br><span class="line">        Method set_method = clz.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        set_method.invoke(obj, <span class="keyword">new</span> Object[]&#123;name&#125;);</span><br><span class="line">        <span class="comment">// 4. 调用 methodname 对应的方法显示</span></span><br><span class="line">        Method get_method = clz.getMethod(methodname);</span><br><span class="line">        get_method.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        reflectTest reflect = <span class="keyword">new</span> reflectTest();</span><br><span class="line">        reflect.reflect(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>Class</code> 类是 <code>Reflection API</code> 中的核心类，主要方法如下：</p>
<ul>
<li>getName()：获得类的完整名字。 getFields()：获得类的public类型的属性。</li>
<li>getDeclaredFields()：获得类的所有属性。</li>
<li>getMethods()：获得类的public类型的方法。</li>
<li>getDeclaredMethods()：获得类的所有方法。</li>
<li>getMethod(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes参数指定方法的参数类型。</li>
<li>getConstrutors()：获得类的public类型的构造方法。</li>
<li>getConstrutor(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes参数指定构造方法的参数类型。</li>
<li>newInstance()：通过类的不带参数的构造方法创建这个类的一个对象。</li>
</ul>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>优点有：</p>
<ol>
<li><p>增加程序的灵活性，避免将程序写死在代码里；</p>
<p>比如一个接口中有若干个实现类，这些类在程序中被频繁使用，可以编写配置文件放接口和实现类，如果改动只需要修改配置文件，就可以利用 <code>Class.forName(class_name).newInstance()</code> 反射获取对应实例。</p>
</li>
<li><p>提高代码的复用率，外部调用方便；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.yonyong.reflection.testdemo;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123; <span class="comment">//水果接口</span></span><br><span class="line">　 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>; <span class="comment">//吃水果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123; <span class="comment">//定义苹果</span></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　　　System.out.println(<span class="string">&quot;**吃苹果。&quot;</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　　　System.out.println(<span class="string">&quot;**吃橘子。&quot;</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getInstance</span><span class="params">(String className)</span></span>&#123;</span><br><span class="line">　　　　Fruit fruit = <span class="keyword">null</span> ;</span><br><span class="line">　　　　<span class="keyword">try</span>&#123;</span><br><span class="line">　　　　　　fruit = (Fruit) Class.forName(className).newInstance() ;</span><br><span class="line">　　　　&#125;<span class="keyword">catch</span>(Exception e )&#123;</span><br><span class="line">　　　　　　e.printStackTrace() ;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　<span class="keyword">return</span> fruit ;</span><br><span class="line">　 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryDemo</span></span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">　　<span class="comment">//通过工厂类取得接口实例，传入完整的包.类名称</span></span><br><span class="line">　　　　Fruit f = Factory.getInstance(<span class="string">&quot;cn.yonyong.reflection.testdemo.Apple&quot;</span>) ;</span><br><span class="line">　　　　<span class="keyword">if</span>(f!=<span class="keyword">null</span>)&#123; <span class="comment">//判断是否取得接口实例</span></span><br><span class="line">　　　　　　f.eat() ;</span><br><span class="line">　　　&#125;</span><br><span class="line">　 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要添加一个西瓜类，就只需要在 <code>FactoryDemo</code> 中的 <code>getInstance</code> 反射对应的名称即可。</p>
</li>
<li><p>对于任意一个类，都能知道它的所有属性和方法，对于任意一个对象，都能调用它的所有方法。</p>
</li>
</ol>
<p>缺点如下：</p>
<ol>
<li>性能问题：反射包含了一些动态类型，这些部分是不能被JVM优化的，所以反射操作的效率会比非反射操作的效率低很多，应该避免在经常被执行的代码和对性能要求较高的场景中使用；</li>
<li>安全限制：通常反射需要程序的运行没有安全方面的限制，因为反射可以获取类中的任意信息，包括私有信息；</li>
<li>程序健壮性：反射允许代码执行一些正常情况不被允许的操作，比如访问私有属性和方法，所以使用反射可能会导致代码出现功能上的错误、降低可移植性等副作用。</li>
</ol>
<h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><ol>
<li>应用于反编译，将.class文件转变为.java文件；</li>
<li>常用的一些框架，如Spring的配置化就是利用反射机制来动态加载对象；</li>
<li>编译器，比如IDEA会有自动联想类的方法或属性的功能。</li>
</ol>
<h4 id="正则表达"><a href="#正则表达" class="headerlink" title="正则表达"></a>正则表达</h4><ol>
<li><p><code>.</code> 表示匹配任意单个字符；</p>
</li>
<li><p><code>[]</code> 表示方括号内的字符才参与匹配，仅匹配其中的一个字符；</p>
</li>
<li><p><code>|</code> 表示或的关系，<code>(|)</code> 与 <code>[]</code> 类似，但是它可以指定匹配多个字符，如 <code>(a|b|cc)</code> ；</p>
</li>
<li><p>匹配次数：</p>
<p>（1）<code>*</code> 匹配0至多次；</p>
<p>（2）<code>+</code> 匹配1至多次；</p>
<p>（3）<code>?</code> 匹配0次或1次；</p>
<p>（4）<code>&#123;n&#125;</code> 匹配恰好n次；</p>
<p>（5）<code>&#123;n, m&#125;</code> 匹配n次到m次；</p>
</li>
<li><p><code>^</code> 写在 <code>[]</code> 里面表示否，表示不想匹配其中的字符；写在 <code>[]</code> 外表示匹配开始位置；</p>
</li>
<li><p><code>$</code> 表示匹配结束位置；</p>
</li>
<li><p><code>\S</code> 匹配非空字符；</p>
</li>
<li><p><code>\s</code> 匹配一个空字符，如空格、制表符、回车、换页等；</p>
</li>
<li><p><code>\r</code> 空格符，与 <code>\n</code>、<code>\tab</code> 相同。</p>
</li>
</ol>
<h2 id="面向对象相关"><a href="#面向对象相关" class="headerlink" title="面向对象相关"></a>面向对象相关</h2><h3 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h3><p>三大特征为：封装、继承、多态。</p>
<ol>
<li>封装：指属性私有化，隐藏具体实现的细节，仅提供setter和getter方法来访问属性，用于提高数据安全性，类和方法也属于封装；</li>
<li>继承：指将多个相同的属性和方法提取出来，新建为一个父类，子类可以重写其中的方法，用于代码复用；</li>
<li>多态：分为两种，编译时多态和运行时多态，编译时多态即重载，方法名相同而参数不同；运行时多态即重写，子类重写父类方法，用于增强代码的灵活度。</li>
</ol>
<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>​        类和对象之间的关系就好比造车，需要先画图纸，定义好车的属性，比如颜色、大小等，以及车的行为，是要能跑。那么类就相当于图纸，其中包含了这一类事物的公共属性和行为；对象是使用这个类创建的具体的一个实例。</p>
<p>​        类是自定义的数据类型，通过这个类创建对象，实际上就是初始化这种类型的变量。</p>
<h3 id="枚举类-enum"><a href="#枚举类-enum" class="headerlink" title="枚举类 enum"></a>枚举类 enum</h3><p>​        枚举类不能使用new来创建，也不能被继承和实现。</p>
<h3 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h3><p>​        包括List、Map、Set和Queue。</p>
<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>​        包含ArrayList和LinkedList。二者都用于存储任何类型的可变长数组，不同的是，ArrayList的底层是数组；LinkedList的底层是链表。</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>​        包含HashMap、LinkedHashMap和TreeMap。都用于存储key-value形式的数据，其中键值不可重复。</p>
<p>​        不同的是，HashMap中存储的数据是无序的，底层使用数组+链表的形式存储，当数组长度超过64，链表长度大于等于8时，会转变为红黑树存储。</p>
<p>​        LinkedHashMap的数据可以按照插入顺序或访问顺序排序，默认是插入顺序，可以修改参数accessOrder为true使用访问顺序排序，底层基于HashMap和双向链表实现的，如果使用访问顺序，那么put或get一个已经存在的Entry时，会将这个entry移动到双向链表的表尾。</p>
<p>​        TreeMap的底层是红黑树的结构，可以通过指定比较器Comparator来指定排序的策略，如果没有指定，默认是升序。</p>
<p><strong>面试题：HashMap的底层原理</strong></p>
<p>HashMap的底层由数组+链表+红黑树的形式实现，数组中的元素为内部类Node节点。</p>
<p>具体实现如下：</p>
<ol>
<li>首先对key值进行二次哈希，然后将结果对数组长度取模，存入对应下标；</li>
<li>如果没有哈希冲突，直接创建Node存入下标对应的位置；</li>
<li>如果存在哈希冲突，先equals查看是否有相同元素，有则更新，没有则判断链表高度插入链表，如果链表高度到8、数组长度超过64转变为红黑树存储，长度低于6转变为链表存储。</li>
</ol>
<p>当数组长度不够，需要进行扩容的时候，会根据扩容因子new一个新的数组，再将旧数组的元素放入新数组使用，扩容因子默认是0.75。</p>
<p>其中提出的二次哈希，是为了对key的hashCode进行扰动计算，防止不同hashCode的高位不同但低位相同导致的hash冲突。简单来说就是把高位的特征和低位的特征组合起来，降低哈希冲突的概率，尽量做到任何一位的变化都对最终的结果产生影响。</p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>​        包含HashSet、LinkedHashSet、TreeSet。这三者的异同与HashMap、LinkedHashMap和TreeMap的是一致的。</p>
<p><strong>面试题：HashSet如何检查重复</strong></p>
<p>当对象 <code>add</code> 到 <code>HashSet</code> 中，首先获取对应的HashCode，判断对象插入的位置，如果没有相同HashCode的对象存在，则成功加入，否则调用 <code>equals</code> 方法判断两个 <code>HashCode</code> 相同的对象是否真的相等，如果相等，加入失败。</p>
<h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>​        包含LinkedList、ArrayDeque、ConcurrentLinkedQueue和ConcurrentLinkedDeque。</p>
<p>​        其中，LinkedList底层一个链表结构，一般用它来实现Queue。</p>
<p>​        ArrayDeque的底层和ArrayList一样，都是使用数组存储，二者的区别在于删除尾部元素的方式不同。ArrayList会使用System.copyArray()方法将尾部 index 之后的 index + 1 的位置开始的子数组copy到 index 这个位置，也就是通过复制的方式覆盖掉要删除的内容，会比较耗时；ArrayQueue维护了一个tail元素，也就是记录了尾部元素的位置，因此删除的时候只需要 -1 即可。所以<strong>算法中需要频繁删除尾部元素的，可以使用ArrayDeque来代替ArrayList。</strong></p>
<p>​        ConcurrentLinkedQueue 和 ConcurrentLinkedDeque 都是并发类，使用cas算法来保证无锁情况下的线程安全。不同在于，ConCurrentLinkedQueue是单向链表，元素操作的顺序是FIFO；ConcurrentLinkedDeque是双向链表，操作顺序可以是FIFO或FILO。二者的实现过程非常类似，下面以ConcurrentLinkedQueue为例说明offer操作和poll操作。</p>
<p>​        其实实现过程与Queue的过程是相似的，不同在于，ConcurrentLinkedQueue使用cas算法执行，并且为了减少cas更新的次数，会设置一个hops&#x3D;2的常量值，允许head和tail节点在这个范围内不更新到现有的头尾节点，直到head和tail节点距离现有的头尾节点的长度超过hops的值，才会进行更新。这个hops的值不能设置的太大，否则也会增加寻找现有头尾节点的时间。</p>
<p>​        要找尾节点，是从当前的tail节点开始往后遍历到null的前一个节点；要找头节点，是从当前head节点开始往后遍历到值不为null的节点，因为如果不更新head，为了区分，就需要将已经poll出去的节点的值设置为null。</p>
<h3 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>​        继承是从已有的类中派生出新的类，好处是能够减少重复代码。使用extends关键字实现，一个类只能有一个父类，但是一个类可以有多个子类。</p>
<p>​        <a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenmingjun/p/8449506.html">面试题1（程序题）</a></p>
<ol>
<li><p>为什么Java中不支持多重继承？</p>
<p>​        容易产生歧义。假设继承的多个父类中有相同的方法f，那么一旦调用，就不知道是要调用哪个父类中的f。在C++中使用多类继承避免歧义的方式是在调用前指定类名，它在支持多重继承的角度上也是建议要把这种多个父类中出现同名方法的情况给避免掉，所以为了避免二义性，Java不支持多重继承。</p>
</li>
<li><p>为什么 String 在 Java 中是不可变的？</p>
<p>（1）因为字符串是存储在字符串常量池的，为多个线程共享，如果将它设置为可变的，那么其中一个线程修改了它的值，其他线程也会被迫修改，可能发生错误；</p>
<p>（2）Java中反射的参数也是String，如果字符串可变会产生安全问题。</p>
</li>
<li><p>为什么 char 数组比 Java 中的 String 更适合存储密码？</p>
<p>​        由于String是存放在常量池中以保证重用，那么这个字符串就会一直保存在这个池中直到GC回收，这个存放的时间可能会很长那么任何有访问权限的人都可以以明文的形式找到密码；而char[]数组可以将元素置为0或空，来降低密码被窃取的风险。</p>
</li>
</ol>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>​        多态指为不同数据类型的实体提供统一的接口。</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>​        参数化类型被称为泛型，泛型允许在创建集合时指定元素的类型，则集合中只保存这种类型的元素。泛型的作用是在发生编译时，提供安全检查机制。</p>
<p>​        泛型类允许在定义接口、类、方法时声明类型形参，该类型形参在整个接口、类、方法中可以作为普通类型使用，直到声明变量、创建对象或调用方法时再动态的指定实际的参数类型。如果要定义泛型类的子类，因为此时是在使用父类了，所以必须传入实参，或者不传参。</p>
<p>​        在定义泛型的时候也可以指定类型形参的上限，如 <code>class A&lt;T extends B&gt;</code> ，该声明表示，传入的实参为类型 <code>B</code> 及其子类。</p>
<p>​        而泛型擦除是指，当把一个具有泛型信息的对象赋值给一个没有泛型的对象，就会把尖括号之间的所有泛型信息都扔掉，比如List&lt;Integer&gt; 类型会转换为 List 类型，则该 List 元素的类型就会变成该类型变量的上限。如果反过来，就是泛型转换。</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>​        没有用 static 关键字来声明的嵌套类，就是内部类。主要用于解决Java中没有多重继承的情况。</p>
<p>​        作用：每个内部类都能独立的继承一个类，无论外部类是否已经继承了某个类，对内部类是没有影响的。内部类可以访问创建它的外部类的内容，包括私有变量。</p>
<p>​        内部类有四种：</p>
<ol>
<li>成员内部类：就是普通的内部类，位于另一个类的内部，当它与外部类有同名的成员变量活方法时，默认会使用内部类的，可以使用外部类.this.xxx 来实现外部类的同名变量或方法；</li>
<li>局部内部类：定义在一个方法或作用域里，与成员内部类的区别在于它的访问权限仅限于这个方法或作用域，局部内部类可以看成是一个局部变量，不能使用public、protected、private、static等修饰；</li>
<li>匿名内部类：</li>
</ol>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>​        </p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><h3 id="异常和错误"><a href="#异常和错误" class="headerlink" title="异常和错误"></a>异常和错误</h3><h2 id="3-数据结构相关"><a href="#3-数据结构相关" class="headerlink" title="3. 数据结构相关"></a>3. 数据结构相关</h2><h3 id="常见的8种数据结构"><a href="#常见的8种数据结构" class="headerlink" title="常见的8种数据结构"></a>常见的8种数据结构</h3><h4 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 Array"></a>数组 Array</h4><p>数组在内存中使用连续空间存储，因为使用下标定位元素，所以查询和遍历都很方便，缺点是创建之后无法扩容，只能存储一种类型的元素，插入和删除元素比较耗时。</p>
<h4 id="链表-Linked-List（ArrayList的底层是数组，本身不属于数据结构）"><a href="#链表-Linked-List（ArrayList的底层是数组，本身不属于数据结构）" class="headerlink" title="链表 Linked List（ArrayList的底层是数组，本身不属于数据结构）"></a>链表 Linked List（ArrayList的底层是数组，本身不属于数据结构）</h4><p>包含单向链表和双向链表，和数组相比，在内存中不需要连续的空间存储，只需要每个节点能够记录下一个节点的引用，就可以通过指针查找下一个节点。所以对链表进行插入和删除的时间复杂度都是O(1)的，不需要确定容量大小，可以添加任何类型的元素。缺点是大量的引用会占用大量的堆空间，并且执行查找需要遍历整个链表。</p>
<h4 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h4><p>依据先进后出的原则存储数据。</p>
<h4 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h4><p>依据先进先出的原则存储数据。</p>
<p>栈和队列的底层都是数组。</p>
<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>是有限个节点组成的具有层次关系的集合，每个节点有有限个子节点或没有子节点，有且仅有一个没有父节点的节点，叫根节点，每个非根节点只有一个父节点。可以使用链表或数组来存储。常见的就是二叉树，最多只有两个子节点。</p>
<p>二叉树中特殊的，包括满二叉树，叶子节点都在最底层；完全二叉树，叶子节点都在最底的两层，且最底层的叶子节点都在左侧；平衡二叉树，左右子树的高度差不超过1；二叉查找树，左子节点的值不会大于当前节点，右子节点的值不会小于当前节点。</p>
<p>其中，平衡二叉树因为要保证左右子树的高度差不超过1，经常需要通过左旋或右旋的方式保持平衡。</p>
<p>B树和B+树也比较常见，可以看成是平衡二叉树的矮胖版本。</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>可以看成是存储结构为数组的完全二叉树，每个节点的值都不大于或不小于它的父节点。根节点最大的堆叫大根堆，根节点最小的堆叫小根堆。</p>
<h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><p>是复杂的非线性结构，由顶点和边组成，节点之间的关系是任意的。这个数据结构没有使用过。</p>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>使用键值对的形式存储数据，可以快速的实现元素的查找、插入和删除。</p>
<h3 id="常见的算法"><a href="#常见的算法" class="headerlink" title="常见的算法"></a>常见的算法</h3><p>常见的算法包括快速排序、归并排序、堆排序、冒泡排序、深度优先遍历、广度优先遍历、动态规划、二分查找、贪心法等。</p>
<h2 id="4-设计模式相关"><a href="#4-设计模式相关" class="headerlink" title="4. 设计模式相关"></a>4. 设计模式相关</h2><h3 id="设计模式的原则"><a href="#设计模式的原则" class="headerlink" title="设计模式的原则"></a>设计模式的原则</h3><ol>
<li><p>单一原则：</p>
<p>​    即一个类只有一个职责；</p>
</li>
<li><p>开闭原则：</p>
<p>​    软件实体可扩展，但不可修改。</p>
<p>​    就好比“一国两制”，一个国家有两种制度，没有修改原有的管理制度，而是增加了一种新的制度。对于扩展是开放的，对于更改是封闭的。</p>
</li>
<li><p>里氏代换原则：</p>
<p>​    子类型必须能够替换掉它们的父类型。</p>
<p>​    举个例子，假如现在父类是鸟类，有个属性是可以飞，子类有个企鹅类，那么很明显企鹅类不能继承鸟类，因为鸟类有会飞的属性，如果子类企鹅类继承父类鸟类，则企鹅必须会飞。</p>
</li>
<li><p>依赖倒置原则：</p>
<p>​    针对接口编程，不要针对实现编程。</p>
<p>​    举个例子，就好比你的电脑，如果CPU、内存、硬盘都需要依赖具体的主板，主板坏了，所有的部件都不能用了，这显然是不合理的。</p>
<p>​    换句话说，即谁也不要依赖谁，除了约定的接口，大家都可以灵活自如。</p>
</li>
<li><p>接口隔离原则：</p>
<p>​    应该使用多个专门的接口，而不使用单一的总接口。</p>
<p>​    比如有一个学生成绩管理程序，包含插入成绩、删除成绩、修改成绩、打印成绩等功能，这些功能全都放到一个统一的接口中显然是不合理的，正确的作法应该是分为输入、打印等模块进行处理。</p>
</li>
<li><p>迪米特原则：</p>
<p>​    尽量减少对象之间的交互，可以引入一个合理的第三方来降低现有对象之间的耦合度。</p>
<p>​    比如体育老师上课前清点人数，他让体育委员来替他清点人数，之后再由体育委员告知结果即可，老师本身并没有接触到其他学生。</p>
</li>
<li><p>合成&#x2F;聚合复用原则</p>
<p>​    尽量使用合成&#x2F;聚合，尽量不要使用类继承。</p>
<p>​    合成表示一种强的“拥有”关系，体现了严格的部分与整体的关系，他们的生命周期相同；而聚合表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。</p>
<p>​    这里再举个简单的例子，大雁与翅膀是合成关系；而每只大雁都属于一个雁群，即一个雁群可以有多只大雁，所以大雁和雁群是聚合关系。</p>
</li>
</ol>
<h3 id="（1）-单例模式"><a href="#（1）-单例模式" class="headerlink" title="（1） 单例模式"></a>（1） 单例模式</h3><p>使用单一的类创建对象，它只有一个实例，必须自己创建。</p>
<p>懒汉式 - 线程不安全：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton Instance;</span><br><span class="line">    <span class="comment">//私有构造方法，保证外界无法直接实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>( Instance == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            Tnstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式延迟实例化，好处是没有用到该类，就不会实例化Instance，从而节约资源；坏处是线程不安全，多线程情况下会多次创建实例。</p>
<p>懒汉式 - 线程安全：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton Instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( Instance == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            Instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对静态代码 <code>getInstance()</code> 加锁，以确保多线程环境下只会创建一个实例。</p>
<p>饿汉式 - 线程安全：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton Instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接实例化，不会产生线程不安全的问题，但是这也丢失了延迟实例化带来的节约资源的好处。</p>
<p>双重校验锁 - 线程安全：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton Instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( Instance == <span class="keyword">null</span> )<span class="comment">//为了提高代码执行效率，如果已经创建了实例就不需要再竞争锁了。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>( Singleton.class )<span class="comment">// 类锁，表示只能进入一个实例</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( Instance == <span class="keyword">null</span> )<span class="comment">//防止二次创建实例</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>内存中只有一个实例，减少了内存开支。</li>
<li>避免对资源的多重占用，比如写文件操作，只有一个实例时，避免对同一个资源文件同时写操作。</li>
</ul>
<p>缺点：</p>
<ul>
<li>没有接口，不能继承，与单一职责冲突。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>应用程序的日志应用一般使用单例模式实现，因为共享的日志文件一般会一直处于打开状态，所以只能有一个实例取操作，否则内容不好追加；</li>
<li>操作系统的文件系统也是使用单例模式操作的，因为一个操作系统只能有一个文件系统。</li>
</ul>
<h4 id="此处可能会询问volatile的好处"><a href="#此处可能会询问volatile的好处" class="headerlink" title="此处可能会询问volatile的好处"></a>此处可能会询问volatile的好处</h4><p>​        Instance 采用 volatile 关键字修饰也是很有必要的， <code>Instance = new Singleton();</code> 这段代码其实是分为三步执行：分配内存、初始化、指向分配的地址。由于JVM具有指令重排的特性，执行顺序可能会改变，指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 抢占了 T1 的资源，调用 geteInstance() 后发现 Instance 不为空，因此返回 Instance，但此时 Instance 还未被初始化。</p>
<p>​        使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<h3 id="（2）观察者模式"><a href="#（2）观察者模式" class="headerlink" title="（2）观察者模式"></a>（2）观察者模式</h3><p>观察者模式很好理解，类似于订阅模式，属于行为型模式的一种，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p>
<p>在观察者模式中有如下角色：</p>
<ol>
<li>Subject：抽象主题（抽象被观察者），定义增删观察者接口和通知观察者更新的接口。</li>
<li>ConcreteSubject：具体主题（具体被观察者），创建存储观察者的集合，并实现抽象主题的内容。</li>
<li>Observer：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li>
<li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li>
</ol>
<p>这种发布-订阅的形式我们可以拿微信公众号来举例，假设微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了这个公众号，当这个公众号更新时就会通知这些订阅的微信用户。</p>
<p>具体实例如下：</p>
<ol>
<li>抽象观察者：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>具体观察者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeixinUser</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 微信用户名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeixinUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;-&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>抽象主题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加订阅者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除订阅者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知订阅者更新消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体主题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriptionSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//储存订阅公众号的微信用户</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;WeixinUser&gt; weixinUserlist = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(WeixinUser u)</span> </span>&#123;</span><br><span class="line">        weixinUserlist.add(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(WeixinUser u)</span> </span>&#123;</span><br><span class="line">        weixinUserlist.remove(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (WeixinUser u : weixinUserlist) &#123;</span><br><span class="line">            u.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SubscriptSubject sub = <span class="keyword">new</span> SubscriptSubject();</span><br><span class="line">        WechatUser a = <span class="keyword">new</span> WechatUser(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        WechatUser b = <span class="keyword">new</span> WechatUser(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">        sub.attach(a);</span><br><span class="line">        sub.attach(b);</span><br><span class="line">        sub.notify(<span class="string">&quot;你们订阅的内容更新了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">杨影枫-刘望舒的专栏更新了</span><br><span class="line">月眉儿-刘望舒的专栏更新了</span><br><span class="line">紫轩-刘望舒的专栏更新了</span><br></pre></td></tr></table></figure></li>
</ol>
<p>优点：</p>
<ul>
<li>观察者和被观察者是抽象耦合的</li>
<li>建立了一套触发机制</li>
</ul>
<p>缺点：</p>
<ul>
<li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间</li>
<li>如果观察者和观察目标间有循环依赖，可能导致系统崩溃</li>
<li>没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的</li>
</ul>
<p>使用场景：</p>
<ul>
<li>关联行为场景</li>
<li>事件多级触发场景</li>
<li>跨系统的消息变换场景，如消息队列的处理机制</li>
</ul>
<h3 id="（3）装饰模式"><a href="#（3）装饰模式" class="headerlink" title="（3）装饰模式"></a>（3）装饰模式</h3><p>定义：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</p>
<p>下面以一个例子来简单说明：</p>
<p>比如我买了一个机器人，它本身有一个对话的功能。我希望它能在此基础上还能帮我扫地。有两种方式实现：</p>
<ol>
<li>第一种方式，可以打电话给厂家，让他们可以研制新的产品，在第一代产品的基础上加两条胳膊，扩展这个功能；</li>
<li>第二种方式是直接给第一代产品加一个箱子，在这个箱子上面加两条胳膊，这样它也拥有了扫地的功能，这种方式更为灵活，不需要去重新研发设计。</li>
</ol>
<p>上述这两种方式都可以实现给一个类或对象增加新的功能，第一种是继承机制，就是继承一个现有的类，然后在子类进行扩展功能；第二种被称为关联机制，是把一个类的对象嵌入到另一个类的对象中，相当于把机器人嵌入到箱子中，给它套一个壳子，扩展出扫地的功能，这个壳子就是装饰器，第二种方式也被称为装饰器模式。</p>
<p>在开发过程中，这两种方式都经常被使用，他们主要的区别在于：对于继承模式来说，这种方式是静态的，一定要实现一个新的子类来对类层级进行扩展；装饰器模式是动态的，我们拿到一个对象就可以对其进行扩展，不需要修改原有类逻辑。</p>
<p>下面使用代码来实现上述例子：</p>
<ol>
<li><p>创建抽象组件，代表被装饰的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建组件实现类，实现第一代机器人：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">firstRobot</span> <span class="keyword">implements</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建装饰器对第一代机器人扩展：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">robotDecorator</span> <span class="keyword">implements</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="comment">//因为要关联使用机器人，所有要定义一个机器人对象</span></span><br><span class="line">    <span class="keyword">private</span> Robot robot;</span><br><span class="line">    <span class="comment">//接着要传这个对象进来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">robotDecorator</span><span class="params">(Robot robot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.robot = robot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接着实现机器人该有的方法，使用机器人对象实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        robot.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//需要扩展功能，新加扫地的功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doMorething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        robot.doSomething();</span><br><span class="line">        System.out.println(<span class="string">&quot;扫地&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> robotDecorator(<span class="keyword">new</span> firstRobot()).doMorething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对话</span><br><span class="line">扫地</span><br></pre></td></tr></table></figure></li>
</ol>
<p>优点：</p>
<ul>
<li>装饰类和被装饰类可以独立发展，而不会相互耦合。它有效地把类的核心职责和装饰功能分开了</li>
<li>装饰模式是继承关系的一个替代方案</li>
<li>装饰模式可以动态地扩展一个实现类的功能</li>
</ul>
<p>缺点：</p>
<p>多层装饰比较复杂。比如我们现在有很多层装饰，出了问题，就需要一层一层检查，工作量很大。</p>
<p>使用场景：</p>
<ul>
<li>需要扩展一个类的功能时</li>
<li>需要动态地给一个对象增加功能，并可以动态地撤销时</li>
<li>需要为一批的兄弟类进行改装或加装功能时</li>
</ul>
<h2 id="5-修饰符"><a href="#5-修饰符" class="headerlink" title="5. 修饰符"></a>5. 修饰符</h2><p>分为访问修饰符和非访问修饰符。</p>
<p><strong>访问修饰符有：</strong></p>
<ol>
<li>public：对所有的类都可见；</li>
<li>protected：对同一个包可见，如果父类和子类不同包，对不同包的子类可见；</li>
<li>default：对同一个包可见；</li>
<li>private：对同一个类可见。</li>
</ol>
<p><strong>非访问修饰符有：</strong></p>
<ol>
<li>static：声明的对象初始化后不能再修改；</li>
<li>final：修饰的类不能被继承，修饰的方法不能重新定义，修饰的变量为常量；</li>
<li>synchronized：用于多线程同步；</li>
<li>abstract：用来创建抽象类和方法。</li>
</ol>
<h2 id="6-Object类的常用方法"><a href="#6-Object类的常用方法" class="headerlink" title="6. Object类的常用方法"></a>6. Object类的常用方法</h2><ol>
<li>equals() - 判断相等</li>
<li>hashCode() - 返回散列值；</li>
<li>toString() - 返回对象的字符串表示；</li>
<li>clone() - 创建并返回对象的克隆对象，一般子类会重写该方法；</li>
<li>finalized() - 当垃圾收集确定对象没有更多的引用时，由该对象的垃圾收集器调用；</li>
<li>getClass() - 返回此对象的运行时class类对象；</li>
<li>notify() - 唤醒正在此对象监视器上等待的某个线程，主要用于多线程通信，需配合wait()方法使用；</li>
<li>notifyAll() - 唤醒正在此对象监视器上等待的全部线程；</li>
<li>wait() - 导致当前线程等待，直到另一个对象调用该对象的notify() 或 notifyAll() 方法；</li>
<li>wait(long timeout) - 导致当前线程等待，直到另一个对象调用该对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法，或经过指定的timeout时间；</li>
<li>wait(long timeout, int nanos) - 导致当前线程等待，直到另一个对象调用当前对象的 <code>notify()</code> 或 <code>notifyAll()</code> 或经过指定的timeout时间或被其他线程中断当前线程。其中timeout参数是毫秒值，nanos参数是毫微秒值，二者之和用于指定超时时间。</li>
</ol>
<h2 id="8-常见的关键字"><a href="#8-常见的关键字" class="headerlink" title="8. 常见的关键字"></a>8. 常见的关键字</h2><p>private、default、public、protected、static初始化后不再更改、this表示当前类的对象引用、final避免重写等。</p>
<h2 id="9-标识符和关键字的区别"><a href="#9-标识符和关键字的区别" class="headerlink" title="9. 标识符和关键字的区别"></a>9. 标识符和关键字的区别</h2><p>标识符是用户编程时创建的名称，关键字是具有特殊含义的单词。</p>
<h2 id="13-重载和重写？深拷贝和浅拷贝？"><a href="#13-重载和重写？深拷贝和浅拷贝？" class="headerlink" title="13. 重载和重写？深拷贝和浅拷贝？"></a>13. 重载和重写？深拷贝和浅拷贝？</h2><ol>
<li>重载和重写：重载是方法名相同参数不同；重写是继承父类方法并重写它。</li>
<li>深拷贝和浅拷贝：浅拷贝是拷贝原对象的引用值；深拷贝是根据原对象创建一个新对象。</li>
</ol>
<h2 id="14-方法的四种类型"><a href="#14-方法的四种类型" class="headerlink" title="14. 方法的四种类型"></a>14. 方法的四种类型</h2><p>无参无返回值、无参有返回值、有参无返回值、有参有返回值。</p>
<h2 id="17-HashMap-和-HashTable、HashSet、TreeMap-的区别"><a href="#17-HashMap-和-HashTable、HashSet、TreeMap-的区别" class="headerlink" title="17. HashMap 和 HashTable、HashSet、TreeMap 的区别"></a>17. HashMap 和 HashTable、HashSet、TreeMap 的区别</h2><ol>
<li>HashMap底层由 <code>链表 + 数组 + 红黑树</code> 实现，当链表长度 <code>&gt;=8</code> 、数组长度 <code>超过64</code> 时转换为红黑树，非线程安全，可以存储 <code>null</code> 键和 <code>null</code> 值，初始 <code>size = 16</code> ，扩容方式为 <code>newsize = oldsize * 2</code> 先插入再扩容；</li>
<li>HashTable底层由 <code>链表 + 数组</code> 实现，通过在方法和对象前添加 <code>syncronized</code> 关键字来保证线程安全，不可以存储 <code>null</code> 键 <code>null</code> 值，初始 <code>size = 11</code> ，扩容方式为 <code>newsize = olesize * 2 + 1</code> 先扩容再插入；</li>
<li>HashSet底层由HashMap实现，其中的HashMap仅存在key，value都是同一个object，非线程安全；</li>
<li>TreeMap底层由红黑树实现，是有序的 <code>key-value</code> 组合，非线程安全，存入TreeMap的元素应该实现Comparable或Comparator接口，会按照排序后的顺序迭代元素，元素插入时对元素自动排序，迭代输出就按顺序输出。</li>
</ol>
<h2 id="19-ConcurrentHashMap与HashTable的区别"><a href="#19-ConcurrentHashMap与HashTable的区别" class="headerlink" title="19. ConcurrentHashMap与HashTable的区别"></a>19. ConcurrentHashMap与HashTable的区别</h2><p>有两个区别：</p>
<ol>
<li><p>底层数据结构：HashTable由 <code>数组 + 链表</code> 组成，ConcurrentHashMap 由 <code>数组 + 链表 + 红黑树</code> 组成；</p>
</li>
<li><p>实现线程安全的方式：</p>
<p>（1）HashTable使用 <code>Syncronized</code> 关键字实现线程安全，将所有方法和对象都上了锁，在高并发的情况下，同一时刻只能有一个线程操作，其他线程会被阻塞等待，并发度低；</p>
<p>（2）ConcurrentHashMap采用了更细粒度的锁来提高并发情况下的效率，ConcurrentHashMap将hash表默认分为16个桶，每个桶可以看作是一个hashtable，诸如get、put、remove等写操作只需要锁当前需要的桶，在理想状态下，原来同一时刻只能进入一个线程，现在能同时进入16个，并发性的提升显而易见；因为在读取的大多数情况不需要锁，所以读取操作几乎是完全的并发操作。</p>
</li>
</ol>
<h2 id="20-ConcurrentHashMap底层原理"><a href="#20-ConcurrentHashMap底层原理" class="headerlink" title="20. ConcurrentHashMap底层原理"></a>20. ConcurrentHashMap底层原理</h2><p>​        首先了解为什么使用ConcurrentHashMap。在并发编程下使用HashMap可能导致死循环，而使用线程安全的HashTable效率又非常低下，于是引出了ConcurrentHashMap。HashTable效率低的原因很明显，因为HashTable使用Synchronized关键字，所以在并发时只能运行一个线程，而将其他线程阻塞等待；HashMap导致死循环的原因是put操作扩容，假设有两个线程A和B要同时进行扩容，此时数组中下标为1对应的链表指向是 a - b - c，扩容需要将他们迁移到新数组，这里假设abc迁移后在同一下标4，进行扩容操作有两个指针 e 和 next，A先执行，假设当 e &#x3D; a，next &#x3D; b 的时候cpu时间片用完，会暂停A的执行，由B开始执行，因为是头插法，插入的顺序是将e.next &#x3D; newtable[4]，newtable[4] &#x3D; e,e &#x3D; next。B会将 abc 全都放到newtable[4]的空间中，然后时间片用完，A继续执行，在B线程将 b 指向 a，在这里又将 a 指向 b，此时就产生了死循环。</p>
<p>​         而ConcurrentHashMap应用在多线程的优点在于它的数据结构。</p>
<p>​        在JDK1.7底层采用：segment + HashEntry数组结构组成，实现的思路是先将数据分成一段一段地存储，然后给每一段数据配一把锁，这样当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，这就是锁分段技术。其中Segment继承了ReetrantLock可重入锁接口，所以自带了锁的功能，让每一个片段都有了锁；HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构。一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁。</p>
<p>​        JDK1.8底层与HashMap底层结构一致，将锁的粒度调整到每个数组元素加锁，并且定位节点的hash算法被简化，导致hash冲突加剧，因此在链表长度大于8时，会将链表转换为红黑树存储，这样一来，查询的时间复杂度就从O(n)转变为O(logn)。</p>
<p>​        对于锁的设计，JDK1.8取消了Segment分段锁，采用了CAS+Synchronized来保证并发安全。当执行<code>put</code>方法插入数据时，定义一个Node节点 <code>f</code>，如果 <code>f == null</code>，则相应位置的<code>Node</code>还未初始化，通过CAS插入相应的数据；如果 <code>f.hash == -1</code>，说明当前有其他线程正在扩容，则一起进行扩容操作；如果是其余情况就是把新的node节点按照链表或红黑树的方式插入到合适的位置，其中有一个binCount变量用于判断当前链表长度是否&gt;&#x3D;8。</p>
<p>​        JDK1.8中还使用一个volatile类型的变量baseCount记录元素的个数，用于判断是否扩容，当插入新数据或删除元素时，会通过 <code>addCount()</code> 方法更新 <code>baseCount</code> 。具体的实现过程是：先利用CAS方法更新baseCount的值，然后检查是否需要扩容，默认check&#x3D;1时需要检查；如果满足扩容条件，即 <code>map.size() &gt;= sizeCTL</code>，此处 <code>sizeCtl</code> 为扩容阈值，判断当前是否正在扩容，如果是正在扩容就一起扩容，如果不在扩容就将 <code>sizeCtl</code> 更新为负数，并进行扩容处理。</p>
<h2 id="21-Comparable-和-Comparator-的区别"><a href="#21-Comparable-和-Comparator-的区别" class="headerlink" title="21. Comparable 和 Comparator 的区别"></a>21. Comparable 和 Comparator 的区别</h2><ol>
<li>Comparable是内部比较器，实现该接口意味着该类支持排序，不需要额外实现比较器，比较简单，但是需要修改源代码；</li>
<li>Comparator是外部比较器，当需要控制某个类的次序，而该类本身不支持排序，可以自定义一个该类的比较器进行排序，好处是不需要修改源代码，只需要自定义一个比较器。</li>
</ol>
<h2 id="24-静态编译和动态编译"><a href="#24-静态编译和动态编译" class="headerlink" title="24. 静态编译和动态编译"></a>24. 静态编译和动态编译</h2><ol>
<li>静态编译：一次编译，在程序运行前将所有模块全都编译进去；</li>
<li>动态编译：按需编译，在程序运行过程中，需要用到哪个模块再编译哪个模块。</li>
</ol>
<h2 id="28-进程和线程的区别和联系"><a href="#28-进程和线程的区别和联系" class="headerlink" title="28. 进程和线程的区别和联系"></a>28. 进程和线程的区别和联系</h2><ol>
<li>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</li>
<li>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的 实时性，实现进程内部的并发；</li>
<li>一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；</li>
<li>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。</li>
</ol>
<h2 id="29-并行与并发"><a href="#29-并行与并发" class="headerlink" title="29. 并行与并发"></a>29. 并行与并发</h2><p><strong>1. 并发：</strong></p>
<p>指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是利用系统CPU的时间分片功能，使多个进程快速交替的执行。</p>
<p><strong>2. 并行：</strong></p>
<p>指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。</p>
<p><strong>3. 场景分析：</strong></p>
<p>一个应用程序可以是并发的，但不能是并行的，这意味着它可以同时处理多个任务，但是没有两个任务可以同时执行。</p>
<p>一个应用程序可以是并行的，但不能是并发的，这意味着它可以同时处理多核CPU中一个任务的多个子任务。</p>
<p>一个应用程序既不能是并行的，也不能是并发的，这意味着它一次顺序地处理所有任务。</p>
<p>一个应用程序可以是并行的，也可以是并发的，这意味着它可以同时在多核CPU中同时处理多个任务。</p>
<h2 id="30-线程的生命周期和状态"><a href="#30-线程的生命周期和状态" class="headerlink" title="30. 线程的生命周期和状态"></a>30. 线程的生命周期和状态</h2><p>线程一共有五种状态：新生态、就绪态、运行态、阻塞态、死亡态。这五种状态统称线程的生命周期。线程在同一时刻只会处于一种状态。下面简述这五种状态：</p>
<ol>
<li><p>新生态：当线程对象创建后，就进入了新生状态：Thread t &#x3D; new Thread();</p>
</li>
<li><p>就绪态：当调用线程对象的 <code>start()</code> 方法，就进入了就绪状态。处于就绪状态的线程，只是说明词线程已经做好准备，随时等待CPU调度执行，并不是说调用了 <code>start()</code> 方法线程就会立即执行；</p>
</li>
<li><p>运行态：当CPU开始调度处于就绪状态的线程时，该线程真正开始执行，想要进入运行态，就绪态是唯一的入口；</p>
</li>
<li><p>阻塞态：处于运行态的线程因为某种原因暂时放弃了CPU的使用权，停止执行，进入阻塞状态，阻塞态可用分为三种：</p>
<p>（1）等待阻塞：运行态中的线程调用 <code>wait()</code> 方法，使线程进入等待阻塞状态；</p>
<p>（2）同步阻塞：线程获取Synchronized锁失败，因为此时该锁被其他线程占用，该线程进入同步阻塞状态；</p>
<p>（3）其他阻塞：调用线程的 <code>sleep()</code> 或 <code>join()</code> 方法或发出I&#x2F;O请求时，会使得线程进入阻塞状态，当 <code>sleep()</code> 超时或 <code>join()</code> 等待线程终止或超时、或I&#x2F;O处理完毕，线程会重新进入就绪态；</p>
</li>
<li><p>死亡态：线程执行完毕或异常退出，该线程结束生命周期。</p>
</li>
</ol>
<p><strong>允许状态的转换：</strong></p>
<ol>
<li>就绪态转换为运行态：线程得到CPU资源；</li>
<li>运行态转换为就绪态：线程主动调用 <code>yield()</code> 方法或在运行过程中失去CPU资源；</li>
<li>运行态转换为死亡态：线程执行完毕或出现异常</li>
</ol>
<h2 id="31-线程死锁"><a href="#31-线程死锁" class="headerlink" title="31. 线程死锁"></a>31. 线程死锁</h2><ol>
<li><p>概念：死锁指的是两个线程互相拥有对方所需要的资源，由于synchronized的特性，一个线程持有一个资源，或者说获得了一个锁，在该线程释放这个锁之前，其他线程是获取不到这个锁的，并会一直等下去，这就造成了死锁。</p>
</li>
<li><p>死锁产生的必要条件：</p>
<p>（1）互斥条件：一个锁只能被一个线程占用，当一个线程占用一个锁，该锁在被该线程释放前，其他线程都不能获取这个锁；</p>
<p>（2）不剥夺条件：锁只能由当前占用的线程释放，不能由其他的线程强行剥夺；</p>
<p>（3）请求和保持条件：线程已经获得一个锁，再获取另一个锁的过程中，即使获取不到也不会释放已经获得的锁；</p>
<p>（4）循环等待条件：两个线程互相拥有对方需要的锁。</p>
</li>
<li><p>如何避免死锁：</p>
<p>（1）加锁顺序：线程按照相同的顺序加锁；</p>
<p>（2）加锁时限：线程获取锁的过程限制等待的时间，这需要用到锁的一些API。</p>
<p>（3）死锁检测：是一种更好的死锁预防机制，针对前两种方法解决不了的情况。当一个线程获得了锁，会在线程和锁相关的数据结构中记下，比如map，除此之外，每当有线程请求锁，也会记录在这个数据结构中，当一个线程获取锁失败，就可以遍历这个数据结构查看是否有死锁发生。</p>
</li>
</ol>
<h2 id="32-线程池的原理及使用"><a href="#32-线程池的原理及使用" class="headerlink" title="32. 线程池的原理及使用"></a>32. 线程池的原理及使用</h2><p>​        线程池就是在系统启动或者实例化线程池的时候创建一些空间线程，等待工作调度，执行完任务后，这些线程不会被立即销毁，而是重新处于空闲状态，等待下一次调度。由于线程的创建和销毁需要消耗大量资源，这种方式就可以节省很多不必要的花销，而且响应快，不用等待创建，需要的时候自取就可以了。</p>
<p>​        Java中常见的线程池有四种：</p>
<ol>
<li>newSingleThreadExecutor()单一线程池：内部只有一个线程工作，可用保证程序的执行顺序；</li>
<li>newCachedThreadExecutor()可缓存线程池：如果线程池中有可用的线程，就使用，没有就新建。可缓存线程池的最大线程数是Integer类型变量的最大值，通常用它来运行一些执行时间较短且经常用到的任务；</li>
<li>newFixedThreadPool(int nThread)定长线程池：可用控制线程的最大并发数，超出的线程在队列等待；</li>
<li>newScheduledThreadPool(int corePoolSize)定长线程池：支持定时及周期性任务执行；</li>
<li>也可以创建一个自定义线程池，使用ThreadPoolExecutor类创建。</li>
</ol>
<p>​        线程池的工作机制是：任务首先提交给线程池，由线程池寻找空闲的线程来执行任务，如果没有空闲的线程，就将任务放进等待队列中，等待空闲线程，如果超出了线程池最大接受的工作量，就会触发拒绝策略。</p>
<p>​        其中拒绝策略有四个：</p>
<ol>
<li>AbortPolicy()：直接抛出RejectedExecutionException异常；</li>
<li>CallerRunsPolicy()：调用run方法阻塞执行；</li>
<li>DiscardPolicy()：直接丢弃后来的任务；</li>
<li>DiscardOldestPolicy()：丢弃队列中队首的任务。</li>
</ol>
<p>线程池具体的执行流程如下：</p>
<p>​        提交任务以后，首先查看线程池内的核心线程数有没有满，这个核心线程数指的是线程池中即使没有任何任务也会有指定数量的线程在等待调度，没有满就创建线程执行任务；如果满了，就判断等待队列有没有满，没有满就将任务放进等待队列等待；如果满了，再判断线程池有没有满，没有满，就创建线程执行任务；如果还是满了，就启动拒绝策略处理。</p>
<p>​        线程池的具体使用如下：</p>
<p>先创建一个 <code>myThread</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bonnie;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2022/1/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在进行......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如使用 newCachedThreadExecutor 线程池处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bonnie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2022/1/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cachedThreadExecutorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> myThread();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> myThread();</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> myThread();</span><br><span class="line"></span><br><span class="line">        pool.execute(t1);</span><br><span class="line">        pool.execute(t2);</span><br><span class="line">        pool.execute(t3);</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-2正在进行......</span><br><span class="line">pool-1-thread-3正在进行......</span><br><span class="line">pool-1-thread-1正在进行......</span><br></pre></td></tr></table></figure>



<h2 id="33-互斥、自旋、读写、悲观、乐观锁"><a href="#33-互斥、自旋、读写、悲观、乐观锁" class="headerlink" title="33. 互斥、自旋、读写、悲观、乐观锁"></a>33. 互斥、自旋、读写、悲观、乐观锁</h2><ol>
<li>互斥锁：一个线程访问共享资源前会对线程访问的这段代码加锁，加锁之后没有释放锁，其他想要访问临界资源的线程会被阻塞睡眠，直到解锁，如果阻塞了多个线程，解锁的时候，这些线程都转换为就绪状态，第一个变为就绪态的线程获取资源的使用权，其他线程继续阻塞等待；</li>
<li>读写锁：也叫共享互斥锁，读模式共享，写模式互斥，即只有一个线程能占有写模式的读写锁，可以有多个线程占用读模式的读写锁。在写加锁模式下，任何线程进行写加锁操作都会被阻塞，直到解锁；在读加锁模式下，任何线程都可以进行读加锁操作，但全部试图进行写加锁的线程都会被阻塞，直到全部读加锁的线程释放锁，可是当读线程太多，写线程一直被阻塞也不行，因此一个线程想加锁的时候，会阻塞之后的读加锁的请求，让写线程先加锁；</li>
<li>自旋锁：自旋锁和互斥锁很像，唯一不同的是自旋锁访问加锁资源时，会循环查看是否释放锁，这种方式比互斥锁更有效率，但是有两个问题：一是会一直占用CPU的资源，所以适用于多核的CPU；二是自旋锁递归调用容易造成死锁，所以得慎重使用自旋锁；</li>
<li>乐观锁：总是假设最好的情况，每次拿数据都认为其他线程不会修改，所以不会上锁，但在更新的时候会判断一下在词期间其他线程有没有更新这个数据，可用使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可用提高吞吐量；</li>
<li>悲观锁：总是假设最坏的情况，每次拿数据都会认为其他线程会修改，所以在拿数据的时候都会上锁，想获取这个锁的线程会被阻塞直到当前线程释放锁。</li>
</ol>
<h2 id="34-Synchronized锁源码"><a href="#34-Synchronized锁源码" class="headerlink" title="34. Synchronized锁源码"></a>34. Synchronized锁源码</h2><p>首先介绍两个概念：</p>
<h4 id="1-cas"><a href="#1-cas" class="headerlink" title="1. cas"></a>1. cas</h4><p>CAS算法的原理：</p>
<p>​        CAS算法的全称是比较和交换，可以看成是一个自旋锁。下面以一个例子来说明：</p>
<p>​        假设有多线程任务，2个线程同时完成对一个共享变量 <code>i</code> 的减法，假设该算法只有三个步骤：<code>get共享变量的值、更新值、将更新的值put回共享变量</code>，不使用CAS算法的运行过程中，可能将前两个步骤完成，然后在要执行第三个步骤的时候被CPU的时间片切出去，第二个线程开始执行，这时候由于两个线程 <code>get</code> 的值一样，最终所得的结果肯定也是一样的；如果使用CAS算法，可以简单的使用 <code>atomic</code> 变量来保证多线程环境下能无锁进行原子操作，接着在 <code>get</code> 方法设置一个E值，即旧的值，计算步骤完成后，将E值和共享变量内的值比较，如果相同，交换共享变量内的值为更新的值，否则线程再运行一遍，重新获取值进行运算，这也可以称为自旋锁。这个atomic变量保证了这个CAS算法不会存在多线程问题，因为这个变量的核心函数是CPU本地提供的，而CPU都是一行一行执行的，不会存在并行过程。</p>
<p>CAS机制的问题：</p>
<p>​        ABA问题 - 即假设有两个线程对一个共享变量进行操作，这个值初始为A，第一个线程首先将值修改成了B，然后又改回了A，第二个线程因为比较慢，它获取的E值是A，最后比较的时候第一个线程已经完成了两次修改，共享变量的值还是A，所以对第二个线程来说，共享变量值没有被其他线程改动，是安全的。</p>
<p>​        这种可能有两种情况：如果共享变量是基本数据类型，是否改动是不重要的；如果是引用类型，其中的属性可能会发生变化。</p>
<p>​        解决方案：加版本号或时间戳来区分。</p>
<p>​        在Java中，CAS是由Java本地接口来实现的。</p>
<h4 id="2-对象头"><a href="#2-对象头" class="headerlink" title="2. 对象头"></a>2. 对象头</h4><p>虚拟机中，对象在内存中存储的布局分为三个部分：对象头、实例数据和对齐填充。</p>
<p>其中对象头包含两部分信息：</p>
<p>（1）mark word：用于存储运行时数据，比如hashcode、GC分代年龄等；</p>
<p>（2）klass pointer：是对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p>当对象是数组时，对象头中还需要包含数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但无法确定数组长度的大小。</p>
<p>Synchronized源码使用mark word来标识对象的加锁状态。</p>
<h4 id="synchronized锁实现原理"><a href="#synchronized锁实现原理" class="headerlink" title="synchronized锁实现原理"></a>synchronized锁实现原理</h4><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，临界区指的是一个用于访问共享资源的代码块，它保证同一时刻只有一个线程访问，同时synchronized关键字还可以保证共享变量的内存可见性。</p>
<p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p>
<ol>
<li><strong>普通同步方法，锁是当前实例对象；</strong></li>
<li><strong>静态同步方法，锁是当前类的class对象；</strong></li>
<li><strong>同步方法块，锁是括号里面的对象。</strong></li>
</ol>
<p>其中同步代码块是使用monitorenter和monitorexit指令实现的，同步方法依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。</p>
<p><strong>同步代码块：</strong></p>
<p>　　monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；</p>
<p><strong>同步方法</strong></p>
<p>　　会被翻译成普通方法的调用和返回指令，在JVM字节码层面并没有任何特别的指令来表示这个方法被synchronized修饰的方法，而是在Class文件的方法表中将该方法的<strong>accessflags字段中的synchronized标志位置1</strong>。</p>
<p><strong>JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</strong> </p>
<p>首先是自旋锁，列举一个场景，如果线程频繁的进行阻塞和唤醒，会给系统带来很大的压力，同时很多锁的持有状态只会存在很短的一段时间，为了这一段很短的时间频繁的阻塞和唤醒线程是不值得的，于是引入了自旋锁。就是让一个线程去等待一段时间，这段时间内会进行无意义的循环操作，而不会立即被挂起，会不断查看持有锁的线程有没有释放，如果释放了就可以尝试获得锁。自旋锁在jdk1.4中引用，是默认关闭的，可以使用参数开启，在jdk1.6中默认开启，同时自旋次数默认是十次，这个也可以通过参数调整。</p>
<p>​        但是无论怎么调整，都不可能知道具体是多少次，不可能满足所有的情况，所以jdk1.6引入了适应性自旋。适应性自旋锁与自旋锁的区别在于它的自旋次数是会变的，如果线程上次自旋成功了，获得了锁，那么这次自旋的次数就会增加，因为虚拟机认为如果上次成功了，这次成功的可能性会很大；反之如果自旋成功的次数很少，那么之后的自旋次数就会减少，甚至直接忽略掉自旋的过程，以免浪费处理器的资源。</p>
<p>​        接着是锁消除。比如在一个方法里用了锁，但是JVM检测到这个方法里面不存在共享数据竞争的问题，也就是共享数据在这个方法里面是线程安全的，所以就没有必要加锁，加了锁反而会影响程序的性能。所以JVM检测到这个问题之后，就会将这个锁消除。</p>
<p>​        然后是锁粗化，在使用锁的时候，应该要让锁作用的程序范围越小越好，这是为了让在锁内执行的代码尽可能少，缩短持有锁的时间，让等待锁的线程能尽快拿到锁，在大多数情况下，这样的作法是正确的，但是在某些情况下，这样的做法是不对的。比如在一段程序内，持续的进行加锁，这个时候它的加锁操作和解锁操作就会特别频繁，而且被锁住的代码都是在一块的，就会导致很多没必要的性能消耗。比如是在一个for循环内加锁，那么每次for循环都要去抢锁和释放锁，那对性能的影响是非常大的，这个时候如果把锁放到for循环外，这个时候，只要抢到锁就可以进入for循环，存粹的for循环和在for循环内加锁，二者的效率肯定会差很多。这就是锁粗化的作用。</p>
<p>​        下面说明一下synchronized锁升级的过程。从无锁状态会升级到偏向锁状态，当我们创建一个对象的时候，这个对象有一个mark word，里面存储一些数据，比如是否是偏向锁，以及它的锁标志位等，如果锁的标志位是0，说明这个对象没有被加上偏向锁，如果是1，就说明这个对象被加上了偏向锁。偏向锁可以理解成是一个偏心的锁，意思就是这个锁会偏向于第一个获得它的线程，然后在接下来的执行过程中，假如这个锁没有被其他线程竞争，那么持有偏向锁的线程就永远不需要进行同步操作；一旦有其他线程进入锁，这个时候才会撤销这个偏向锁。</p>
<p>​        偏向锁的撤销，会先到达一个全局的安全点，也就是当前没有字节码运行的一个状态，然后暂停拥有偏向锁的线程，然后判断这个线程是否存活，如果这个线程不存活，或者这个线程存活，但是已经执行完同步代码，就会将对象恢复成无锁状态；否则就将对象升级为轻量级锁状态。线程是否存活可以查看JVM中的所有线程，如果存在这个线程，这个线程就是存活的。偏向锁的撤销过程会使锁的效率大大降低，所以如果运行时存在大量多线程竞争，偏向锁会导致性能下降。这个时候应该要禁用这个偏向锁，如果不禁用，它的抢锁和撤销锁的过程会非常消耗资源。可以使用 UsebiasedLocking参数关闭偏向锁。</p>
<p>​        然后是轻量级锁。偏向锁升级之后会变成轻量级锁，轻量级锁的竞争方式是在这个mark word中使用cas算法竞争这个锁。轻量级锁就是自旋锁和适应性自旋锁，如果在自旋的这段时间里，没有获得这个锁，就会升级成重量级锁，也就是锁膨胀。</p>
<p>​        重量级锁依赖于对象内部的monitor，而monitor依赖于操作系统的互斥锁实现，所以重量级锁也被称为互斥锁。互斥锁的开销非常大，主要是因为当系统检测到这个锁是重量级锁后，会把想要获取这个锁的其他线程阻塞，被阻塞的线程是不会消耗cpu的，但是阻塞和唤醒的过程都需要操作系统帮忙，这个时候就需要从用户态转换为内核态，转换状态是非常耗时的，有可能比用户执行代码的时间还要长，所以重量级锁的开销非常大。</p>
<p>​        总结上述整个流程，偏向锁和轻量级锁都是乐观锁，而重量级锁是悲观锁，一个对象刚开始实例化的时候是没有任何线程访问的，它可以是偏向的，所以当第一个线程访问的时候，它就获得了一个偏向锁，一旦有第二个线程来访问这个对象，因为偏向锁不会主动释放，所以第二个线程就可以看到这个对象是偏向锁的状态，表明这个时候已经存在锁竞争的问题了。要竞争锁的线程，需要检查原持有锁的线程是否存活，如果不存活，就将对象转换为无锁状态，重新进行偏向锁的持有，如果原来的线程存活，就马上执行线程的操作栈，检查这个对象的使用情况，如果仍然需要持有这个偏向锁，这个时候偏向锁就会升级为轻量级锁，如果不存在这个对象的使用，就可以把这个对象恢复成无锁状态，重新进行偏向锁的竞争，然后轻量级锁会进行自旋的操作，如果超出了一定的自旋次数，还没有获取到这个锁，就会升级到重量级锁，此时除了拥有锁的这个线程的其他线程都是阻塞状态。</p>
<p>​        锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<h2 id="35-volatile、threadlocal"><a href="#35-volatile、threadlocal" class="headerlink" title="35. volatile、threadlocal"></a>35. volatile、threadlocal</h2><p> 首先应该知道并发编程的三个概念：</p>
<ol>
<li>原子性：即一个或多个操作，要不全部执行，要不全部不执行；</li>
<li>可见性：即多个线程访问一个变量，一个线程修改了这个变量，其他线程能够立即看到这个修改；</li>
<li>有序性：即程序执行的顺序按照代码的先后顺序执行。</li>
</ol>
<h3 id="1-ThreadLocal"><a href="#1-ThreadLocal" class="headerlink" title="1. ThreadLocal"></a>1. ThreadLocal</h3><p>ThreadLocal是局部变量，是线程内独享的，在进程中定义的一个变量需要在每个线程中进行拷贝，独立操作，互不干扰。</p>
<p>线程内部有个ThreadLocalMap变量，首先根据当前线程对象get到该线程的ThreadLocalMap对象，这个map定义了Entry，用于存储ThreadLocal对象以及对应的值。</p>
<p>一个线程拥有一个ThreadLocalMap对象，一个ThreadLocalMap对象可用存储多个线程的局部变量。</p>
<h3 id="2-volatile"><a href="#2-volatile" class="headerlink" title="2. volatile"></a>2. volatile</h3><p>​        是一个特征修饰符，作用是防止编译器对代码进行优化。volatile修饰的变量对所有线程的可见性。</p>
<p>volatile是修饰符关键字，用于修饰变量，被volatile修饰的变量意味着：</p>
<ol>
<li>一个线程对于这个变量的修改，对其他线程来说是可见的；</li>
<li>禁止编译器的重排序，对于该变量操作之前和操作之后的代码顺序不会变；</li>
<li>volatile关键字只能保变量的可见性，不能保证针对该变量的原子性。</li>
</ol>
<h2 id="37-几种线程创建方式"><a href="#37-几种线程创建方式" class="headerlink" title="37. 几种线程创建方式"></a>37. 几种线程创建方式</h2><h2 id="38-NIO和BIO"><a href="#38-NIO和BIO" class="headerlink" title="38. NIO和BIO"></a>38. NIO和BIO</h2><h2 id="39-wait和sleep用法异同"><a href="#39-wait和sleep用法异同" class="headerlink" title="39. wait和sleep用法异同"></a>39. wait和sleep用法异同</h2><h3 id="41-HashMap在多线程怎么实现线程安全"><a href="#41-HashMap在多线程怎么实现线程安全" class="headerlink" title="41. HashMap在多线程怎么实现线程安全"></a>41. HashMap在多线程怎么实现线程安全</h3><p>可以使用ConcurrentHashMap。</p>
<h3 id="42-String可以继承吗"><a href="#42-String可以继承吗" class="headerlink" title="42. String可以继承吗"></a>42. String可以继承吗</h3><p>不可以，因为String有final修饰符。</p>
<h3 id="43-接口中可以有构造函数吗"><a href="#43-接口中可以有构造函数吗" class="headerlink" title="43. 接口中可以有构造函数吗"></a>43. 接口中可以有构造函数吗</h3><p>因为接口不允许实例化，所以不可以有构造函数。接口只能实现，不能继承。</p>
<h3 id="44-线程安全的理解和实现"><a href="#44-线程安全的理解和实现" class="headerlink" title="44. 线程安全的理解和实现"></a>44. 线程安全的理解和实现</h3><p>​        当多个线程访问一个对象时，如果不要进行额外的同步控制或协调操作，调用这个对象的行为都可以获得正确的结果，我们就说这个对象是线程安全的。</p>
<p>​        实现线程安全的方式有很多种，常见的方式就是使用synchronized关键字给代码块或方法加锁，如StringBuffer内部就使用了Synchronized修饰。</p>
<h2 id="ReentrantLock的底层原理"><a href="#ReentrantLock的底层原理" class="headerlink" title="ReentrantLock的底层原理"></a>ReentrantLock的底层原理</h2><p>ReentrantLock的底层使用CAS+AQS队列来实现，它支持公平锁和非公平锁。</p>
<p>CAS算法不再赘述，接下来了解一下AQS队列。</p>
<p>​        AQS队列是一个FIFO队列，队列的头节点是一个哨兵节点，不不与任何线程关联。其他节点会与等待线程关联，每个节点会维护一个等待状态waitStatus。</p>
<p>ReentrantLock具体的流程是：</p>
<p>​        先通过CAS算法获得锁，如果此时锁被占用，则线程进入队列并挂起；当锁被释放，队首的线程会被唤醒然后通过CAS尝试获取锁，假设此时还有另一个线程也在尝试获取锁：</p>
<ol>
<li>如果是公平锁：当这个线程发现自己不在队首，会进入队列，让队首的线程获取锁；</li>
<li>如果是非公平锁：那么有可能让不是队首的这个线程抢先获取。</li>
</ol>

    </div>

    
    
    
	  
	
	 <div>
		<div>
    
        <div style="text-align:center;color: #ccc;font-size:24px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
	 </div>
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/12/LeetCode-1370-%E4%B8%8A%E5%8D%87%E4%B8%8B%E9%99%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="prev" title="LeetCode - 1370. 上升下降字符串">
      <i class="fa fa-chevron-left"></i> LeetCode - 1370. 上升下降字符串
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/11/18/LeetCode-%E5%89%91%E6%8C%87-Offer-44-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/" rel="next" title="LeetCode - 剑指 Offer 44. 数字序列中某一位的数字">
      LeetCode - 剑指 Offer 44. 数字序列中某一位的数字 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.</span> <span class="nav-text">Java语言的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%93%E5%B1%95%EF%BC%9A"><span class="nav-number">1.1.</span> <span class="nav-text">拓展：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">面向对象编程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK%E3%80%81JRE%E5%92%8CJVM%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-number">2.</span> <span class="nav-text">JDK、JRE和JVM的区别和联系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM%E7%9B%B8%E5%85%B3"><span class="nav-number">3.</span> <span class="nav-text">JVM相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-number">3.1.</span> <span class="nav-text">JVM的位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.</span> <span class="nav-text">JVM体系结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">3.3.</span> <span class="nav-text">类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="nav-number">3.3.1.</span> <span class="nav-text">双亲委派机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Native-Method-Stack%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="nav-number">3.4.</span> <span class="nav-text">Native Method Stack本地方法栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PC%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%89"><span class="nav-number">3.5.</span> <span class="nav-text">PC寄存器（程序计数器）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">3.6.</span> <span class="nav-text">方法区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E5%86%85%E5%AD%98"><span class="nav-number">3.7.</span> <span class="nav-text">栈内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98"><span class="nav-number">3.8.</span> <span class="nav-text">堆内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%EF%BC%9A%E5%A0%86%E7%A9%BA%E9%97%B4%E4%B8%80%E5%AE%9A%E6%98%AF%E6%89%80%E6%9C%89%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E7%9A%84%E4%B9%88%EF%BC%9F"><span class="nav-number">3.9.</span> <span class="nav-text">面试问题：堆空间一定是所有线程共享的么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E5%86%85%E5%AD%98%E7%9A%84%E5%9B%9E%E6%94%B6GC"><span class="nav-number">3.10.</span> <span class="nav-text">JVM内存的回收GC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="nav-number">3.10.1.</span> <span class="nav-text">引用计数法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">3.10.2.</span> <span class="nav-text">复制算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">3.10.3.</span> <span class="nav-text">标记清除算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95"><span class="nav-number">3.10.4.</span> <span class="nav-text">标记压缩算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="nav-number">3.11.</span> <span class="nav-text">JVM配置参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E5%86%85%E5%AD%98%E7%9A%84%E6%B3%84%E6%BC%8F%E3%80%81%E6%BA%A2%E5%87%BA%E3%80%81%E6%8A%96%E5%8A%A8%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%9A%84%E7%9B%91%E6%8E%A7%E9%97%AE%E9%A2%98"><span class="nav-number">3.12.</span> <span class="nav-text">JVM内存的泄漏、溢出、抖动以及相关的监控问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JMM-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88Java-Memory-Modal%EF%BC%89"><span class="nav-number">3.13.</span> <span class="nav-text">JMM - Java内存模型（Java Memory Modal）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">数据类型和基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.1.</span> <span class="nav-text">基本类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.2.</span> <span class="nav-text">引用类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.3.</span> <span class="nav-text">基本数据类型和引用类型的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#x3D-x3D-%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.4.</span> <span class="nav-text">&#x3D;&#x3D;和equals的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#equals%E5%92%8ChashCode%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.5.</span> <span class="nav-text">equals和hashCode的联系和区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%92%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1"><span class="nav-number">4.1.6.</span> <span class="nav-text">自动装箱和自动拆箱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E5%9E%8B%E5%B8%B8%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.7.</span> <span class="nav-text">字符型常量和字符串常量的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E3%80%81StringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.1.8.</span> <span class="nav-text">String、StringBuffer和StringBuilder的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#java%E4%B8%ADchar%E8%83%BD%E5%AD%98%E6%94%BE%E6%B1%89%E5%AD%97%E5%90%97"><span class="nav-number">4.1.9.</span> <span class="nav-text">java中char能存放汉字吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="nav-number">4.1.10.</span> <span class="nav-text">常用类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text">基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-number">4.2.1.</span> <span class="nav-text">访问控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%EF%BC%8C%E6%9D%A1%E4%BB%B6"><span class="nav-number">4.2.2.</span> <span class="nav-text">循环，条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">4.2.3.</span> <span class="nav-text">异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number">4.2.4.</span> <span class="nav-text">反射</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84"><span class="nav-number">4.2.4.1.</span> <span class="nav-text">什么是反射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84"><span class="nav-number">4.2.4.2.</span> <span class="nav-text">为什么使用反射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-number">4.2.4.3.</span> <span class="nav-text">反射的基本使用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">4.2.4.4.</span> <span class="nav-text">优缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">4.2.4.5.</span> <span class="nav-text">应用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE"><span class="nav-number">4.2.5.</span> <span class="nav-text">正则表达</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3"><span class="nav-number">5.</span> <span class="nav-text">面向对象相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="nav-number">5.1.</span> <span class="nav-text">面向对象的三大特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.2.</span> <span class="nav-text">类和对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB-enum"><span class="nav-number">5.3.</span> <span class="nav-text">枚举类 enum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB"><span class="nav-number">5.4.</span> <span class="nav-text">集合类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#List"><span class="nav-number">5.4.1.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map"><span class="nav-number">5.4.2.</span> <span class="nav-text">Map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Set"><span class="nav-number">5.4.3.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Queue"><span class="nav-number">5.4.4.</span> <span class="nav-text">Queue</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81"><span class="nav-number">5.5.</span> <span class="nav-text">继承和多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">5.5.1.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">5.5.2.</span> <span class="nav-text">多态</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number">5.6.</span> <span class="nav-text">泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">5.7.</span> <span class="nav-text">内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-number">5.8.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E9%87%8A"><span class="nav-number">5.9.</span> <span class="nav-text">注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%92%8C%E9%94%99%E8%AF%AF"><span class="nav-number">5.10.</span> <span class="nav-text">异常和错误</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3"><span class="nav-number">6.</span> <span class="nav-text">3. 数据结构相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%848%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">6.1.</span> <span class="nav-text">常见的8种数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E7%BB%84-Array"><span class="nav-number">6.1.1.</span> <span class="nav-text">数组 Array</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8-Linked-List%EF%BC%88ArrayList%E7%9A%84%E5%BA%95%E5%B1%82%E6%98%AF%E6%95%B0%E7%BB%84%EF%BC%8C%E6%9C%AC%E8%BA%AB%E4%B8%8D%E5%B1%9E%E4%BA%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89"><span class="nav-number">6.1.2.</span> <span class="nav-text">链表 Linked List（ArrayList的底层是数组，本身不属于数据结构）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88-Stack"><span class="nav-number">6.1.3.</span> <span class="nav-text">栈 Stack</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97-Queue"><span class="nav-number">6.1.4.</span> <span class="nav-text">队列 Queue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">6.1.5.</span> <span class="nav-text">树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">6.1.6.</span> <span class="nav-text">堆</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BE"><span class="nav-number">6.1.7.</span> <span class="nav-text">图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">6.1.8.</span> <span class="nav-text">哈希表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">6.2.</span> <span class="nav-text">常见的算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9B%B8%E5%85%B3"><span class="nav-number">7.</span> <span class="nav-text">4. 设计模式相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E5%88%99"><span class="nav-number">7.1.</span> <span class="nav-text">设计模式的原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.2.</span> <span class="nav-text">（1） 单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A4%E5%A4%84%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%AF%A2%E9%97%AEvolatile%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">7.2.1.</span> <span class="nav-text">此处可能会询问volatile的好处</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.3.</span> <span class="nav-text">（2）观察者模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F"><span class="nav-number">7.4.</span> <span class="nav-text">（3）装饰模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-number">8.</span> <span class="nav-text">5. 修饰符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Object%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">9.</span> <span class="nav-text">6. Object类的常用方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">10.</span> <span class="nav-text">8. 常见的关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E6%A0%87%E8%AF%86%E7%AC%A6%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">11.</span> <span class="nav-text">9. 标识符和关键字的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%EF%BC%9F%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">13. 重载和重写？深拷贝和浅拷贝？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%E6%96%B9%E6%B3%95%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="nav-number">13.</span> <span class="nav-text">14. 方法的四种类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-HashMap-%E5%92%8C-HashTable%E3%80%81HashSet%E3%80%81TreeMap-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">14.</span> <span class="nav-text">17. HashMap 和 HashTable、HashSet、TreeMap 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-ConcurrentHashMap%E4%B8%8EHashTable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">15.</span> <span class="nav-text">19. ConcurrentHashMap与HashTable的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-ConcurrentHashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">16.</span> <span class="nav-text">20. ConcurrentHashMap底层原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-Comparable-%E5%92%8C-Comparator-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">17.</span> <span class="nav-text">21. Comparable 和 Comparator 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E5%92%8C%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91"><span class="nav-number">18.</span> <span class="nav-text">24. 静态编译和动态编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="nav-number">19.</span> <span class="nav-text">28. 进程和线程的区别和联系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="nav-number">20.</span> <span class="nav-text">29. 并行与并发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81"><span class="nav-number">21.</span> <span class="nav-text">30. 线程的生命周期和状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="nav-number">22.</span> <span class="nav-text">31. 线程死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8"><span class="nav-number">23.</span> <span class="nav-text">32. 线程池的原理及使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-%E4%BA%92%E6%96%A5%E3%80%81%E8%87%AA%E6%97%8B%E3%80%81%E8%AF%BB%E5%86%99%E3%80%81%E6%82%B2%E8%A7%82%E3%80%81%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-number">24.</span> <span class="nav-text">33. 互斥、自旋、读写、悲观、乐观锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-Synchronized%E9%94%81%E6%BA%90%E7%A0%81"><span class="nav-number">25.</span> <span class="nav-text">34. Synchronized锁源码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-cas"><span class="nav-number">25.0.1.</span> <span class="nav-text">1. cas</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="nav-number">25.0.2.</span> <span class="nav-text">2. 对象头</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">25.0.3.</span> <span class="nav-text">synchronized锁实现原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-volatile%E3%80%81threadlocal"><span class="nav-number">26.</span> <span class="nav-text">35. volatile、threadlocal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-ThreadLocal"><span class="nav-number">26.1.</span> <span class="nav-text">1. ThreadLocal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-volatile"><span class="nav-number">26.2.</span> <span class="nav-text">2. volatile</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37-%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="nav-number">27.</span> <span class="nav-text">37. 几种线程创建方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38-NIO%E5%92%8CBIO"><span class="nav-number">28.</span> <span class="nav-text">38. NIO和BIO</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#39-wait%E5%92%8Csleep%E7%94%A8%E6%B3%95%E5%BC%82%E5%90%8C"><span class="nav-number">29.</span> <span class="nav-text">39. wait和sleep用法异同</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#41-HashMap%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">29.1.</span> <span class="nav-text">41. HashMap在多线程怎么实现线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-String%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E5%90%97"><span class="nav-number">29.2.</span> <span class="nav-text">42. String可以继承吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#43-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%8F%AF%E4%BB%A5%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%90%97"><span class="nav-number">29.3.</span> <span class="nav-text">43. 接口中可以有构造函数吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#44-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-number">29.4.</span> <span class="nav-text">44. 线程安全的理解和实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantLock%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="nav-number">30.</span> <span class="nav-text">ReentrantLock的底层原理</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Bonnie"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Bonnie</p>
  <div class="site-description" itemprop="description">每天都要做个人啊</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">111</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021-05 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Bonnie</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
