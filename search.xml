<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>20210721 - sum函数由于优先级计算错误 项目小记</title>
    <url>/2021/07/21/20210721-sum%E5%87%BD%E6%95%B0%E7%94%B1%E4%BA%8E%E4%BC%98%E5%85%88%E7%BA%A7%E8%AE%A1%E7%AE%97%E9%94%99%E8%AF%AF-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="摘自"><a href="#摘自" class="headerlink" title="摘自"></a>摘自</h2><p><a href="https://blog.csdn.net/a158123/article/details/91051636">传送门</a></p>
<span id="more"></span>
<h2 id="1-具体错误结果"><a href="#1-具体错误结果" class="headerlink" title="1. 具体错误结果"></a>1. 具体错误结果</h2><p>希望能通过 <code>sum</code> 函数累加表中某个字段的第一行 <code>limit 1</code>；</p>
<p>期望结果是：<code>0.0</code>；</p>
<p>得到结果是：<code>22178</code>。</p>
<p> 下面给出错误代码：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="built_in">SUM</span>(`amount`)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    `<span class="keyword">order</span>`</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> `id`</span><br><span class="line">LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<h2 id="2-问题所在"><a href="#2-问题所在" class="headerlink" title="2. 问题所在"></a>2. 问题所在</h2><p>没有意识到这个是优先级别的问题：</p>
<ol>
<li>FROM：FROM子句是最先执行的，确定了查询的是order这张表</li>
<li>SELECT：SELECT子句是第二个执行的子句，同时SUM()函数也在此时执行了。</li>
<li>ORDER BY：ORDER BY子句是第三个执行的子句，其处理的结果只有一个，就是订单总金额</li>
<li>LIMIT：LIMIT子句是最后执行的，此时结果集中只有一个结果（订单总金额）</li>
</ol>
<h2 id="3-具体解决"><a href="#3-具体解决" class="headerlink" title="3. 具体解决"></a>3. 具体解决</h2><p>使用子查询的方式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="built_in">SUM</span>(o.amount)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (<span class="keyword">SELECT</span> </span><br><span class="line">        `amount`</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        `<span class="keyword">order</span>`</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> `id`</span><br><span class="line">    LIMIT <span class="number">5</span>) <span class="keyword">AS</span> o;</span><br></pre></td></tr></table></figure>
<h2 id="4-select语句的执行顺序"><a href="#4-select语句的执行顺序" class="headerlink" title="4. select语句的执行顺序"></a>4. select语句的执行顺序</h2><blockquote>
<ol>
<li>FROM <left_table></li>
<li>ON <join_condition></li>
<li><join_type> JOIN <right_table></li>
<li>WHERE <where_condition></li>
<li>GROUP BY <group_by_list></li>
<li>HAVING <having_condition></li>
<li>SELECT</li>
<li>DISTINCT <select_list></li>
<li>ORDER BY <order_by_condition></li>
<li>LIMIT <limit_number></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>项目小记</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>Flume &amp; Sqoop资源</title>
    <url>/2021/06/26/Flume-Sqoop%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<p><a href="http://lannaie.top/resources/Flume.pdf">Flume.pdf</a></p>
<p><a href="http://lannaie.top/resources/Flume%201.9%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C.pdf">Flume 1.9用户手册.pdf</a></p>
<p><a href="http://lannaie.top/resources/Flume题库.pdf">Flume题库.pdf</a></p>
<p><a href="http://lannaie.top/resources/Sqoop用户指南（v1.4.7）.pdf">Sqoop用户指南（v1.4.7）.pdf</a></p>
<p><a href="http://lannaie.top/resources/SQOOP%20%E7%AE%80%E4%BB%8B-%E5%AD%A6%E7%94%9F%E6%8C%87%E5%8D%97.pdf">SQOOP%简介-学生指南.pdf</a></p>
<p><a href="http://lannaie.top/2021/06/27/Sqoop50%E9%A2%98/">sqoop50题</a></p>
<p><a href="http://lannaie.top/resources/Flume简介-学生指南.pdf">Flume 简介-学生指南.pdf</a></p>
]]></content>
  </entry>
  <entry>
    <title>LeetCode-121-买卖股票的最佳时机</title>
    <url>/2021/10/21/LeetCode-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p>
<span id="more"></span>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>该题是比较明确的动态规划实例，所以需要考虑如何进行动态规划。</p>
<h3 id="一-传统动态规划形式"><a href="#一-传统动态规划形式" class="headerlink" title="一. 传统动态规划形式"></a>一. 传统动态规划形式</h3><p>创建一个二维数组 <code>dp[len + 1][len + 1]</code> 来存储当前元素 <code>i - 1</code> 和 <code>j - 1</code> 之间的差值（因为多出一行一列用来存储0值，以防止越界，所以当前的两个元素需要 <code>-1</code> 来获取），然后嵌套遍历数组，如果当前差值比 <code>dp[i-1][j]</code> 和 <code>dp[i][j-1]</code> 大，则取当前差值，否则取其余两个值的最大值。最终返回 <code>dp[len - 1][len]</code> 。</p>
<p>具体代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len+<span class="number">1</span>; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = prices[j-<span class="number">1</span>] - prices[i-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>( tmp &gt; dp[i-<span class="number">1</span>] &amp;&amp; tmp &gt; dp[i] )</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = tmp;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i-<span class="number">1</span>], dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len-<span class="number">1</span>][len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将代码改进为只需要遍历一次即可"><a href="#将代码改进为只需要遍历一次即可" class="headerlink" title="将代码改进为只需要遍历一次即可"></a>将代码改进为只需要遍历一次即可</h3><p>仔细分析上述代码，发现三个值 <code>dp[i][j]</code> 、<code>dp[i-1][j]</code> 和 <code>dp[i][j-1]</code> 之间的关系是最值之间的比较，所以只需要标记两个最值 <code>minprice</code> 和 <code>maxprofit</code> 即可，存储到当前元素为止的最值，如果比最小值小，则替换最小值，否则比较最大值和当前差值的大小，取其中的最大值。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minprice = prices[<span class="number">0</span>], maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( prices[i] &lt; minprice )</span><br><span class="line">            &#123;</span><br><span class="line">                minprice = prices[i];</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                maxprofit = Math.max(maxprofit, (prices[i] - minprice));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 11. 盛最多水的容器</title>
    <url>/2022/01/03/LeetCode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/container-with-most-water/">https://leetcode-cn.com/problems/container-with-most-water/</a></p>
<span id="more"></span>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>双指针是立刻能想到的方向，只是可能无法运用。</p>
<p>可以这样思考：最终需要的结果 <code>容纳最多的水</code> 的计算公式是：</p>
<script type="math/tex; mode=display">
容纳的水量 = min(height[left], height[right]) * (right - left)</script><p>即容纳的水量是由两个端点中的较小值和两个端点的距离决定的，所以要么扩大扩大两个端点的距离，要么增大较小值。</p>
<p>这里可以使用 <code>left = 0, right = height.length - 1</code> 两个指针来指定初始的两个端点，因为在距离稳定减少的情况下，如果我们移动数字较大的那个指针，那么前者「两个指针指向的数字中较小值」不会增加，后者「指针之间的距离」会减小，那么这个乘积会减小。因此，我们移动数字较大的那个指针是不合理的。因此，我们移动 数字较小的那个指针。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxwater = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( left &lt; right )</span><br><span class="line">        &#123;</span><br><span class="line">            maxwater = Math.max(Math.min(height[left], height[right]) * (right - left), maxwater);</span><br><span class="line">            <span class="keyword">if</span>( height[left] &lt; height[right] )</span><br><span class="line">            &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxwater;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 15. 三数之和</title>
    <url>/2022/01/04/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/3sum/">https://leetcode-cn.com/problems/3sum/</a></p>
<span id="more"></span>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用双指针解决该题，问题是这个双指针该怎么用，因为需要获取所有满足为0的三元数组，所以固定一个元素，取头尾指针的方法行不通，可以考虑固定两个元素，然后动态遍历第三个元素。即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; ++i )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>( i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] )</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n - <span class="number">1</span>; ++j )</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>( j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>] )</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">int</span> k = j + <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">while</span>( k &lt; len )</span><br><span class="line">           &#123;</span><br><span class="line">               ......</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，因为相同元素回得到相同的答案，所以需要对每个固定元素去重，即上述代码中的 <code>if语句</code> 。</p>
<p>但是这种方式还是会超出时间限制，所以需要对循环进行优化。因为前两个固定元素没有优化的空间，所以需要考虑第三个元素的优化。</p>
<p>通过观察可以知道，在非降序数组中，固定了第一个元素，第二个元素越大，所需要的第三个元素理应更小，且会比上一个确定的第三个元素更小，所以可以优化第三个元素在遍历一次 <code>i</code> 的时候，<code>k</code> 也只遍历一次。即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; ++i )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>( i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] )</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 将 k 提出来，在本次j遍历完，k也只遍历一次</span></span><br><span class="line">       <span class="keyword">int</span> k = n - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n - <span class="number">1</span>; ++j )</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>( j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>] )</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span>( j &lt; k )</span><br><span class="line">           &#123;</span><br><span class="line">               ......</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>( len &lt; <span class="number">3</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> k = len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len - <span class="number">1</span>; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>] )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>( j &lt; k &amp;&amp; nums[i] + nums[j] + nums[k] &gt; <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    --k;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( j &gt;= k )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( nums[i] + nums[j] + nums[k] == <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(nums[i], nums[j], nums[k])));</span><br><span class="line">                    <span class="comment">// break;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 39. 组合总和</title>
    <url>/2022/01/08/LeetCode-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/combination-sum/">https://leetcode-cn.com/problems/combination-sum/</a></p>
<span id="more"></span>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这里简单的区分一下递归和回溯：递归就是直接或间接的调用自己，回溯相较于递归的区别，就是它有剪枝的功能，知道这条路走不通，会换另一条路走。</p>
<p>我一开始使用递归的思路解决：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        getCombination(candidates, target, res, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCombination</span><span class="params">( <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tmp )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( target &lt;= <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( target == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmp));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> can : candidates )</span><br><span class="line">        &#123;</span><br><span class="line">            tmp.add(can);</span><br><span class="line">            getCombination(candidates, target - can, res, tmp);</span><br><span class="line">            tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这种方法的结果是错的，相当于将结果内部全排序了。所以必须用到<strong>剪枝的思想</strong>。</p>
<p>应该对 <code>candidates</code> 数组升序排序，然后为了防止全排序，又因为元素可以重复，所以应该从当前下标开始遍历。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        getCombination(candidates, target, res, <span class="keyword">new</span> ArrayList&lt;&gt;(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCombination</span><span class="params">( <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tmp, <span class="keyword">int</span> idx )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( target == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( ; idx &lt; candidates.length; ++idx )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( target - candidates[idx] &lt; <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.add(candidates[idx]);</span><br><span class="line">            getCombination(candidates, target - candidates[idx], res, tmp, idx);</span><br><span class="line">            tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵快速幂</title>
    <url>/2021/12/09/LeetCode-509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</url>
    <content><![CDATA[<h2 id="一-引入整数快速幂"><a href="#一-引入整数快速幂" class="headerlink" title="一. 引入整数快速幂"></a>一. 引入整数快速幂</h2><span id="more"></span>
<p>比如计算 <strong>X <sup>19</sup></strong>。</p>
<p>可以使用二进制运算：<code>19 = 1 0 0 1 1</code> ，可以得出：<strong>X <sup>19</sup> = X <sup>16 + 2 + 1</sup> = X <sup>16</sup> <em> X <sup>2</sup> </em> X <sup>1</sup></strong> 。</p>
<p>这种计算方法可以减少循环的次数。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickPow</span><span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = x;</span><br><span class="line">    <span class="keyword">while</span>( N &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( (N &amp; <span class="number">1</span>) == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            res = res * x;</span><br><span class="line">        &#125;</span><br><span class="line">        x *= x;</span><br><span class="line">        N &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>和上面的思想是一样的，只是整数的次幂变成了矩阵的次幂。</p>
<p>回顾一下矩阵乘法的思想：</p>
<p><img src="LeetCode-509-斐波那契数.assets/1149206-20170603085219993-768167045.png" alt="矩阵乘法"></p>
<p>下面使用具体的情景。</p>
<h3 id="具体实例分析-斐波那契数列"><a href="#具体实例分析-斐波那契数列" class="headerlink" title="具体实例分析 - 斐波那契数列"></a>具体实例分析 - 斐波那契数列</h3><p>已知递推序列：<code>F(n) = F(n-1) + F(n-2)</code> ，可以知道 <code>F(n-1) = F(n-1)</code> ，或者可以换算成：</p>
<p><code>F(n) = 1 * F(n-1) + 1 * F(n-2)</code> ，</p>
<p><code>F(n-1) = 1 * F(n-1) + 0 * F(n-2)</code> ，</p>
<p>则可以逆推出矩阵序列：</p>
<script type="math/tex; mode=display">
\left(
\matrix{
F(n)\\
F(n-1)
}
\right)
=
\left(
\matrix{
  1 & 1\\
  1 & 0
}
\right)
*
\left(
\matrix{
F(n)\\
F(n-1)
}
\right)</script><p>根据上述矩阵公式，得到斐波那契数列的一般式：</p>
<script type="math/tex; mode=display">
\left(
\matrix{
F(n)\\
F(n-1)
}
\right)
=
\left(
\matrix{
1 & 1\\
1 & 0
}
\right) ^ {n-1}
*
\left(
\matrix{
F(1) = 1\\
F(0) = 0
}
\right)</script><p>得到具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] mat = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] res = &#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        n -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( n != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( (n &amp; <span class="number">1</span>) == <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                matrixSquare(mat, res);</span><br><span class="line">            &#125;</span><br><span class="line">            matrixSquare(mat, mat);</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">matrixSquare</span><span class="params">(<span class="keyword">int</span>[][] mat1, <span class="keyword">int</span>[][] mat2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = mat2.length, m = mat2[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] new_mat = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k )</span><br><span class="line">                &#123;</span><br><span class="line">                    new_mat[i][j] += mat1[i][k] * mat2[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                mat2[i][j] = new_mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/cmmdc/p/6936196.html">矩阵快速幂基础讲解</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 918. 环形子数组的最大和</title>
    <url>/2021/12/13/LeetCode-918-%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/">https://leetcode-cn.com/problems/maximum-sum-circular-subarray/</a></p>
<span id="more"></span>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>对于环形数组，一般解的思路是将数组分成三个部分：[max1,min,max2]。有以下的推导关系：</p>
<blockquote>
<p>max(前缀数组 + 后缀数组)<br>= max(数组总和 - 中间数组)<br>= 数组总和 + max(- 中间数组)<br>= 数组总和 - min(中间数组)</p>
</blockquote>
<p>上述的 <code>min(中间数组)</code> 即取数组的最小值。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxsum = nums[<span class="number">0</span>], curmax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minsum = nums[<span class="number">0</span>], curmin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> num : nums )</span><br><span class="line">        &#123;</span><br><span class="line">            curmax = Math.max(curmax + num, num);</span><br><span class="line">            maxsum = Math.max(curmax, maxsum);</span><br><span class="line">            curmin = Math.min(curmin + num, num);</span><br><span class="line">            minsum = Math.min(curmin, minsum);</span><br><span class="line">            tot += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxsum &gt; <span class="number">0</span> ? Math.max(maxsum, tot - minsum) : maxsum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>这脑回路我是想不到</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - JZ46 把数字翻译成字符串</title>
    <url>/2021/11/30/LeetCode-JZ46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.nowcoder.com/practice/046a55e6cd274cffb88fc32dba695668?tpId=13&amp;tqId=1024831&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/046a55e6cd274cffb88fc32dba695668?tpId=13&amp;tqId=1024831&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<span id="more"></span>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>数字转变为字母的可能是一位数和两位数，可以联想到 <a href="[http://lannaie.top/2021/07/09/LeetCode-NC68-%E8%B7%B3%E5%8F%B0%E9%98%B6/](http://lannaie.top/2021/07/09/LeetCode-NC68-跳台阶/">爬楼梯相关题目</a>) ，只是多了一些筛选条件，接下来，按照这个思路解决该题。</p>
<p>已知爬楼梯的递归条件是 <code>f[n] = f[n-1] + f[n-2]</code> ，此处也同样适用，前提条件是当前数值是合法的两位数才能这样计算，如果不合法，只能取 <code>f[n] = f[n-1]</code> 的结果。</p>
<p>除此之外，本题的难点在于对 <code>0</code> 的处理：</p>
<ol>
<li>涉及到 <code>0</code> 的数值仅有 <code>10</code> 和 <code>20</code> ，如果存在诸如 <code>002</code>、<code>200</code> 、<code>603</code> 等都是不合法的数值，返回 <code>0</code> ；</li>
<li>不过在循环中不需要考虑为0的情况，只需要考虑 <strong>当前元素是否在一位数区间</strong> 和 <strong>与前一元素构成的两位数是否在两位数的区间内</strong> 的情况，其余情况都是不合法的情况，为 <code>0</code> 即可；</li>
<li>在两位数的区间判断中，还有一个小的判断，如果当前元素下标为 <code>1</code> ，没有 <code>f[n-2]</code> ，只需要在原来的 <code>f[n] = f[n-1]</code> 上 <code>+1</code> 即可，否则 <code>f[n] = f[n-1] + f[n-2]</code> 。</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums string字符串 数字串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(String nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( nums == <span class="keyword">null</span> || nums.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//         char[] num = nums.toCharArray();</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length()];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length(); ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( nums.charAt(i) != <span class="string">&#x27;0&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp_num = (nums.charAt(i - <span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (nums.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>( tmp_num &gt;= <span class="number">10</span> &amp;&amp; tmp_num &lt;= <span class="number">26</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( i == <span class="number">1</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] += <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>爬楼梯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC137 表达式求值</title>
    <url>/2021/07/22/LeetCode-NC137-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/c215ba61c8b1443b996351df929dc4d4?tpId=188&amp;&amp;tqId=38548&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/c215ba61c8b1443b996351df929dc4d4?tpId=188&amp;&amp;tqId=38548&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking</a></p>
<span id="more"></span>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="1-设测试用例"><a href="#1-设测试用例" class="headerlink" title="1. 设测试用例"></a>1. 设测试用例</h3><p>通过题目可以知道，该题解决的是简易计算器问题。</p>
<p>结合题目和用例，可以得出5个测试维度：<code>+ 、- 、 * 、 ( 、)</code></p>
<p>分析几个维度之间的联系：</p>
<ol>
<li>使用 <code>-</code> ，则后面一个计算符号为 <code>-</code> 或 <code>+</code> 会变号；</li>
<li>使用 <code>*</code> ，该符号的优先级应高于 <code>+</code> 和 <code>-</code> ；</li>
<li>使用 <code>(</code> ，该符号的优先级应该最高，不对数据做任何改变；</li>
<li>使用 <code>)</code> ，此时应该优先将 <code>()</code> 中的算式进行计算。</li>
</ol>
<p>通过上述描述，得到如下测试用例：</p>
<blockquote>
<ol>
<li><p>全是 +<br>“1+2”</p>
</li>
<li><p>全是 -<br>“1-2-2”</p>
</li>
<li><p>加减乘</p>
<p>“1-2 <em> 3 </em> 4+2”</p>
</li>
<li><p>加减在括号里面 </p>
<p>“2*(1+2)”</p>
</li>
<li><p>混合</p>
<p>“2 <em> (1+2</em>4)+1”</p>
</li>
<li><p>负数计算</p>
<p>“-2+1”</p>
</li>
</ol>
</blockquote>
<h3 id="2-代码思路"><a href="#2-代码思路" class="headerlink" title="2. 代码思路"></a>2. 代码思路</h3><ol>
<li><p>存储：应该使用两个容器分别将数字和运算符号存储起来，因为并不一定是在当前获取的时候进行运算。此处使用两个栈进行存储：</p>
</li>
<li><p>遍历字符串：</p>
<p><strong>2.1</strong> 先判断是数字还是字符串，如果是数字，要注意，数字不一定只有一位，需要使用一个变量来获取完整的数字；</p>
<p><strong>2.2</strong> 如果是运算符，则先判断 <code>+</code> 或 <code>-</code> 的情况，它们只有一种需要验证的可能，即优先级。比二者大的只有 <code>*</code> 和 <code>(</code> ，因为 <code>(</code> 不做处理，所以只判断是否存在 <code>*</code> ，如果存在，取出来运算。</p>
<p><strong>2.3</strong> 然后判断 <code>)</code> 的情况，不需要验证，直接取运算符进行计算，直到遇到 <code>(</code> ；</p>
<p><strong>2.4</strong> 最后如果是 <code>*</code> 和 <code>(</code> ，直接进行存储。</p>
</li>
<li><p>最后查看两个栈中是否还存在元素，如果存在：</p>
<p><strong>2.1</strong> 如果是 <code>+</code> 或 <code>-</code> ：判断前一个运算符是否是 <code>-</code> ，是则变号，不是不变号；</p>
<p><strong>2.2</strong> 如果是 <code>*</code> ，直接运算；</p>
<p><strong>2.3</strong> 这里不会存在 <code>()</code> ，因为在遍历时已经清除了 -  <code>)</code> 不进栈。</p>
</li>
<li><p>最终输出位于 <code>num</code> 数字元素栈的最后一个元素，即最终结果。</p>
</li>
</ol>
<h3 id="3-具体代码"><a href="#3-具体代码" class="headerlink" title="3. 具体代码"></a>3. 具体代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 返回表达式的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 待计算的表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; num = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;Character&gt; ope = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; ++ i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>( i &lt; str.length &amp;&amp; str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                n = n * <span class="number">10</span> + str[i] - <span class="number">48</span>;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//             System.out.println(n);</span></span><br><span class="line">            <span class="keyword">if</span>( n!=<span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                num.push(n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( i &gt;= str.length )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( str[i] == <span class="string">&#x27;+&#x27;</span> || str[i] == <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( !ope.isEmpty() &amp;&amp; ope.peek() == <span class="string">&#x27;*&#x27;</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span>( !ope.isEmpty() &amp;&amp;  ope.peek() == <span class="string">&#x27;*&#x27;</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> a = num.pop();</span><br><span class="line">                        <span class="keyword">int</span> b = num.pop();</span><br><span class="line">                        ope.pop();</span><br><span class="line">                        num.push(a * b);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ope.push(str[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( str[i] == <span class="string">&#x27;*&#x27;</span> || str[i] == <span class="string">&#x27;(&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                ope.push(str[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>( ope.peek() != <span class="string">&#x27;(&#x27;</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>( !num.isEmpty() )</span><br><span class="line">                    &#123;</span><br><span class="line">                        b = num.pop();</span><br><span class="line">                    &#125;<span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>( !num.isEmpty())</span><br><span class="line">                    &#123;</span><br><span class="line">                        a = num.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">char</span> c = ope.pop();</span><br><span class="line">                    <span class="keyword">if</span>( c == <span class="string">&#x27;+&#x27;</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        num.push(a + b);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>( c == <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        num.push(a - b);</span><br><span class="line">                    &#125;<span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        num.push(a * b);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ope.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( !ope.isEmpty() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>( !num.isEmpty() )</span><br><span class="line">            &#123;</span><br><span class="line">                b = num.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( !num.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                a = num.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> c = ope.pop();</span><br><span class="line"><span class="comment">//             System.out.println(a+&quot; &quot;+b+&quot; &quot;+c);</span></span><br><span class="line">            <span class="keyword">if</span>( c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>( !ope.isEmpty() &amp;&amp; ope.peek() == <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>( c == <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">					&#123;</span><br><span class="line">						num.push(a + b);</span><br><span class="line">					&#125;<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						num.push(a - b);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>( c == <span class="string">&#x27;+&#x27;</span> )</span><br><span class="line">					&#123;</span><br><span class="line">						num.push(a + b);</span><br><span class="line">					&#125;<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						num.push(a - b);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				num.push(a * b);</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC15 求二叉树的层序遍历</title>
    <url>/2021/07/08/LeetCode-NC15-%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3?tpId=188&amp;&amp;tqId=38595&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3?tpId=188&amp;&amp;tqId=38595&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking</a></p>
<span id="more"></span>
<h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><p>使用迭代和递归的方式进行处理。</p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder (TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tmp.add(root);</span><br><span class="line">        <span class="keyword">while</span>( tmp.size() &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; r = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> t_size = tmp.size();</span><br><span class="line">            <span class="keyword">while</span>( t_size -- &gt; <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode t = tmp.remove(<span class="number">0</span>);</span><br><span class="line">                r.add(t.val);</span><br><span class="line">                <span class="keyword">if</span>( t.left != <span class="keyword">null</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp.add(t.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( t.right != <span class="keyword">null</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp.add(t.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一个常见的小坑：<code>if( root == null )</code>的处理 - </p>
<p>不能直接返回<code>null</code>，而是要返回一个空的结果：<code>new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;()</code></p>
<p>否则会报错。</p>
<p>python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param root TreeNode类 </span></span><br><span class="line"><span class="comment"># @return int整型二维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self , root </span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        tmp = [root]</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(tmp) != <span class="number">0</span>:</span><br><span class="line">            r = []</span><br><span class="line">            size = <span class="built_in">len</span>(tmp)</span><br><span class="line">            <span class="keyword">while</span> size &gt; <span class="number">0</span>:</span><br><span class="line">                t = tmp.pop(<span class="number">0</span>)</span><br><span class="line">                r.append(t.val)</span><br><span class="line">                <span class="keyword">if</span> t.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    tmp.append(t.left)</span><br><span class="line">                <span class="keyword">if</span> t.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    tmp.append(t.right)</span><br><span class="line">                size -= <span class="number">1</span></span><br><span class="line">            res.append(r)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder (TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.add(root);</span><br><span class="line">        <span class="keyword">return</span> getList(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; getList(ArrayList&lt;TreeNode&gt; tmp)&#123;</span><br><span class="line">        <span class="keyword">if</span>( tmp.size() == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; r = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> size = tmp.size();</span><br><span class="line">        <span class="keyword">while</span>( size -- &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode t = tmp.remove(<span class="number">0</span>);</span><br><span class="line">            r.add(t.val);</span><br><span class="line">            <span class="keyword">if</span>( t.left != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.add(t.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( t.right != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.add(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(r);</span><br><span class="line">        <span class="keyword">return</span> getList(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param root TreeNode类 </span></span><br><span class="line"><span class="comment"># @return int整型二维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self , root</span>):</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getList</span>(<span class="params">tmp</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(tmp) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            r = []</span><br><span class="line">            size = <span class="built_in">len</span>(tmp)</span><br><span class="line">            <span class="keyword">while</span> size &gt; <span class="number">0</span>:</span><br><span class="line">                t = tmp.pop(<span class="number">0</span>)</span><br><span class="line">                r.append(t.val)</span><br><span class="line">                <span class="keyword">if</span> t.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    tmp.append(t.left)</span><br><span class="line">                <span class="keyword">if</span> t.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    tmp.append(t.right)</span><br><span class="line">                size -= <span class="number">1</span></span><br><span class="line">            res.append(r)</span><br><span class="line">            <span class="keyword">return</span> getList(tmp)</span><br><span class="line">        tmp = [root]</span><br><span class="line">        <span class="keyword">return</span> getList(tmp)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>java, python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC102 在二叉树中找到两个节点的最近公共祖先</title>
    <url>/2021/07/10/LeetCode-NC102-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/e0cc33a83afe4530bcec46eba3325116?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/e0cc33a83afe4530bcec46eba3325116?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<span id="more"></span>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>可以有两种思路：</p>
<h3 id="1-从局部看：看两个值和公共节点的关系"><a href="#1-从局部看：看两个值和公共节点的关系" class="headerlink" title="1. 从局部看：看两个值和公共节点的关系"></a>1. 从局部看：看两个值和公共节点的关系</h3><p>有三种关系：</p>
<ol>
<li>o1和o2在公共节点的两边；</li>
<li>o1是公共节点；</li>
<li>o2是公共节点。</li>
</ol>
<p>对于第一个关系，就说明该节点的左右子节点都不可能为<code>NULL</code>，则可以得到下述：</p>
<p>java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( root.left != <span class="keyword">null</span> &amp;&amp; root.right!=<span class="keyword">null</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于第二和三的关系，假设当前节点就是公共节点，可以返回该节点。然后由上面一个节点判断此时本节点是公共节点还是一个节点的长辈节点：</p>
<p>java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( root == <span class="keyword">null</span> || root.val == o1 || root.val == o2 )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了防止有节点只有左节点和右节点中的一个：</p>
<p>java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br></pre></td></tr></table></figure>
<p>总体代码如下：</p>
<p>java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o1 int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o2 int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="keyword">int</span> o1, <span class="keyword">int</span> o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CommonAncestor(root, o1, o2).val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">CommonAncestor</span><span class="params">(TreeNode root, <span class="keyword">int</span> o1, <span class="keyword">int</span> o2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span> || root.val == o1 || root.val == o2 )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = CommonAncestor(root.left, o1, o2);</span><br><span class="line">        TreeNode right = CommonAncestor(root.right, o1, o2);</span><br><span class="line">        <span class="keyword">if</span>( left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param root TreeNode类 </span></span><br><span class="line"><span class="comment"># @param o1 int整型 </span></span><br><span class="line"><span class="comment"># @param o2 int整型 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self , root , o1 , o2 </span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">CommonAncestor</span>(<span class="params">root, o1, o2</span>):</span></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> root.val <span class="keyword">in</span> [o1, o2]:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            left = CommonAncestor(root.left, o1, o2)</span><br><span class="line">            right = CommonAncestor(root.right, o1, o2)</span><br><span class="line">            <span class="keyword">if</span> left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">return</span> left <span class="keyword">if</span> left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> right</span><br><span class="line">        <span class="keyword">return</span> CommonAncestor(root, o1, o2).val</span><br></pre></td></tr></table></figure>
<h3 id="2-从整体看：看每个值之间的区别"><a href="#2-从整体看：看每个值之间的区别" class="headerlink" title="2. 从整体看：看每个值之间的区别"></a>2. 从整体看：看每个值之间的区别</h3><p>可以记录从顶点到每个值的路径，然后比较两个路径是从哪个顶点开始聚合或分道扬镳的，该节点就算最近公共节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o1 int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o2 int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="keyword">int</span> o1, <span class="keyword">int</span> o2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        getPath(root, o1, s1);</span><br><span class="line">        getPath(root, o2, s2);</span><br><span class="line">        <span class="keyword">int</span> res = root.val;</span><br><span class="line">        <span class="keyword">while</span>( !(s1.isEmpty() || s2.isEmpty()) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> f1 = s1.pop(), f2 = s2.pop();</span><br><span class="line">            System.out.println(f1+<span class="string">&quot; &quot;</span>+f2);</span><br><span class="line">            <span class="keyword">if</span>( f1 != f2 )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            res = f1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">getPath</span><span class="params">(TreeNode root, <span class="keyword">int</span> o, Stack&lt;Integer&gt; stack)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( root.val == o || getPath(root.left, o, stack) || getPath(root.right, o, stack) )</span><br><span class="line">        &#123;</span><br><span class="line">            stack.push(root.val);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择元素不相等时退出是因为<code>getPath</code>函数是从下往上<code>push</code>元素的。</p>
<p>python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param root TreeNode类 </span></span><br><span class="line"><span class="comment"># @param o1 int整型 </span></span><br><span class="line"><span class="comment"># @param o2 int整型 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self , root , o1 , o2 </span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getPath</span>(<span class="params">root, o, s</span>):</span></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> root.val == o <span class="keyword">or</span> getPath(root.left, o, s) <span class="keyword">or</span> getPath(root.right, o, s):</span><br><span class="line">                s.append(root.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        s1, s2 = [], []</span><br><span class="line">        res = root.val</span><br><span class="line">        getPath(root, o1, s1)</span><br><span class="line">        getPath(root, o2, s2)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(s1) != <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(s2) != <span class="number">0</span>:</span><br><span class="line">            f1, f2 = s1.pop(), s2.pop()</span><br><span class="line">            <span class="keyword">if</span> f1 != f2:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            res = f1</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>java, python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC19 子数组的最大累加和问题</title>
    <url>/2021/07/15/LeetCode-NC19-%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E7%B4%AF%E5%8A%A0%E5%92%8C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/554aa508dd5d4fefbf0f86e5fe953abd?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/554aa508dd5d4fefbf0f86e5fe953abd?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<span id="more"></span>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="1-理解"><a href="#1-理解" class="headerlink" title="1. 理解"></a>1. 理解</h3><p>我之前一直想的方法：获取每个子数组的最大连续累加和。</p>
<p>但是这种方法并不适用于这里，因为这种方式求的是并不能连续的最大和。</p>
<p>正确的方法：将之前累加的值永远与当前的值进行比较，将比当前值小的累加抛弃，最小的和是0，即所有值都不取。</p>
<h3 id="2-具体代码"><a href="#2-具体代码" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * max sum of the subarray</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxsumofSubarray</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Math.max(<span class="number">0</span>, arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = Math.max(arr[i], arr[i-<span class="number">1</span>]+arr[i]);</span><br><span class="line">            max = Math.max(max, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC156 数组中只出现一次的数（其它数出现k次）</title>
    <url>/2021/07/29/LeetCode-NC156-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%EF%BC%88%E5%85%B6%E5%AE%83%E6%95%B0%E5%87%BA%E7%8E%B0k%E6%AC%A1%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/5d3d74c3bf7f4e368e03096bb8857871?tpId=188&amp;&amp;tqId=38592&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/5d3d74c3bf7f4e368e03096bb8857871?tpId=188&amp;&amp;tqId=38592&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking</a></p>
<span id="more"></span>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-使用map计数"><a href="#1-使用map计数" class="headerlink" title="1. 使用map计数"></a>1. 使用map计数</h3><p>该方法没有使用到变量 <code>k</code>，它将数组中的每个元素进行计数，并将数值以&lt;元素,count&gt;的形式存储到map中，遍历完数组后，返回map的值为1的键。</p>
<p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">foundOnceNumber</span> <span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(arr[i], map.getOrDefault(arr[i], <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( Map.Entry m : map.entrySet() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( m.getValue().equals(<span class="number">1</span>) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">int</span>)m.getKey();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><p>代码中提到的map的一点基本操作：</p>
<p>1） map默认赋值：getOrDefault(a, b)</p>
<p>map使用 <code>get</code> 方法获取key对应的值，如果没有，会返回 <code>null</code>；可以使用 <code>getOrDefault</code> 方法，如果没有key <code>a</code>，会返回一个默认值 <code>b</code>。</p>
<p>2）Entry迭代</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Map.Entry m: map.entrySet())</span><br><span class="line">&#123;</span><br><span class="line">	System.out.println(m.getKey()+<span class="string">&quot; &quot;</span>+m.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中， <code>m.getKey()</code> 的数据类型为 <code>Object</code> ，指定类型需要进行转换。</p>
<h3 id="2-排序比较"><a href="#2-排序比较" class="headerlink" title="2. 排序比较"></a>2. 排序比较</h3><p>先对数组进行排序，然后比较 <code>n-1</code> 个元素：</p>
<p>当前元素下标为 <code>i</code> ，如果 <code>arr[i] == arr[i+1]</code> ，则说明当前元素是重复的，因为从下标为0开始比较，如果重复肯定往后k个元素都是一样的，所以直接往后跳k步，再进行比较；</p>
<p>为了防止 <code>i+1</code> 的操作越界，需要设定 <code>i &lt; len(arr) - 1</code>，则可以知道，最后一个元素是肯定不会作为 <code>i</code> 进行比较的，所以如果前面所有元素都是重复的，就可以肯定，最后一个元素的个数一定为1。</p>
<p>python:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param arr int一维数组 </span></span><br><span class="line"><span class="comment"># @param k int </span></span><br><span class="line"><span class="comment"># @return int</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foundOnceNumber</span>(<span class="params">self , arr , k </span>):</span></span><br><span class="line">        arr.sort()</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(arr) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> arr[i] == arr[i+<span class="number">1</span>]:</span><br><span class="line">                i += k</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> arr[i]</span><br><span class="line">        <span class="keyword">return</span> arr[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="3-位运算"><a href="#3-位运算" class="headerlink" title="3. 位运算"></a>3. 位运算</h3><p>因为 <code>k</code> 不一定是偶数，所以不能使用异或运算。可以计算每一位上的1的个数，相同元素肯定会在同一位存在 <code>k</code> 的倍数个 <code>1</code> 。因为 <code>int</code> 的二进制是32位，所以创建长度为32的数组来存储每一位的 <code>1</code> 的个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">foundOnceNumber</span> <span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] binary_sum = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> n : arr )</span><br><span class="line">            &#123;</span><br><span class="line">                sum += (n &gt;&gt; i &amp; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            binary_sum[i] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( binary_sum[i] % k != <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                res += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>java, python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC22 合并两个有序的数组</title>
    <url>/2021/07/14/LeetCode-NC22-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/89865d4375634fc484f3a24b7fe65665?tpId=188&amp;&amp;tqId=38585&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/89865d4375634fc484f3a24b7fe65665?tpId=188&amp;&amp;tqId=38585&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking</a></p>
<span id="more"></span>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-从前往后遍历"><a href="#1-从前往后遍历" class="headerlink" title="1. 从前往后遍历"></a>1. 从前往后遍历</h3><p>将两个数组从前往后遍历，如果遇到A数组有值比B当前元素大，则插入；在比较极端的情况下，B数组可能在A数组的两端。</p>
<p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( i &lt; m &amp;&amp; j &lt; n )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( A[i] &lt;= B[j] )</span><br><span class="line">            &#123;</span><br><span class="line">                ++ i;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                move(A, m - <span class="number">1</span>, i);</span><br><span class="line">                A[i] = B[j];</span><br><span class="line">                ++ m;</span><br><span class="line">                ++ j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( i &lt; A.length )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( j &lt; n )</span><br><span class="line">            &#123;</span><br><span class="line">                A[i++] = B[j];</span><br><span class="line">                ++ j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> m, <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( m + <span class="number">1</span> &gt;= A.length )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=m; i&gt;=s; --i )</span><br><span class="line">        &#123;</span><br><span class="line">            A[i+<span class="number">1</span>] = A[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param A int整型一维数组 </span></span><br><span class="line"><span class="comment"># @param B int整型一维数组 </span></span><br><span class="line"><span class="comment"># @return void</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self , A, m, B, n</span>):</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> j &lt; n:</span><br><span class="line">            <span class="keyword">if</span> A[i] &lt;= B[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.move(A, m - <span class="number">1</span>, i)</span><br><span class="line">                A[i] = B[j]</span><br><span class="line">                m += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(A):</span><br><span class="line">            <span class="keyword">while</span> j &lt; n:</span><br><span class="line">                A[i] = B[j]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self, A, m, s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> m &gt;= <span class="built_in">len</span>(A):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m, s-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            A[i + <span class="number">1</span>] = A[i]</span><br></pre></td></tr></table></figure>
<h3 id="2-从后往前遍历"><a href="#2-从后往前遍历" class="headerlink" title="2. 从后往前遍历"></a>2. 从后往前遍历</h3><p>将两张表的当前最后一个元素进行比较，将大的值放到A数组的最后一个空间，循环直到某个表遍历完，如果是B表遍历完结束，A表遍历完就意味着可能B表还有元素没有插入，但是此时A表已经全部存在数据，就意味着A表的前n个数据在后面已经存在，只需要将这些位置的数据替换成B表相应位置的数据就行。</p>
<p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( m &gt; <span class="number">0</span> &amp;&amp; n &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( A[m - <span class="number">1</span>] &gt;= B[n - <span class="number">1</span>] )</span><br><span class="line">            &#123;</span><br><span class="line">                A[m + n - <span class="number">1</span>] = A[m - <span class="number">1</span>];</span><br><span class="line">                m -= <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                A[m + n - <span class="number">1</span>] = B[n - <span class="number">1</span>];</span><br><span class="line">                n -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( n &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i )</span><br><span class="line">            &#123;</span><br><span class="line">                A[i] = B[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param A int整型一维数组 </span></span><br><span class="line"><span class="comment"># @param B int整型一维数组 </span></span><br><span class="line"><span class="comment"># @return void</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self , A, m, B, n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A: <span class="keyword">return</span> B</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> B: <span class="keyword">return</span> A</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> A <span class="keyword">and</span> <span class="keyword">not</span> B: <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">while</span> m &gt; <span class="number">0</span> <span class="keyword">and</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> A[m - <span class="number">1</span>] &lt; B[n - <span class="number">1</span>]:</span><br><span class="line">                A[m + n - <span class="number">1</span>] = B[n - <span class="number">1</span>]</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A[m + n - <span class="number">1</span>] = A[m - <span class="number">1</span>]</span><br><span class="line">                m -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            A[:n] = B[:n]</span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>
<p><strong>上述两种方法并没有实质上的区别</strong></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>java, python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC3 链表中环的入口结点</title>
    <url>/2021/07/28/LeetCode-NC3-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=188&amp;&amp;tqId=38577&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=188&amp;&amp;tqId=38577&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking</a></p>
<span id="more"></span>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><h3 id="1-使用栈留存比较"><a href="#1-使用栈留存比较" class="headerlink" title="1. 使用栈留存比较"></a>1. 使用栈留存比较</h3><p>pHead一次走一步，先与栈中元素进行比较，如果存在当前节点，说明该链表存在环，如果不存在，将当前节点存入，继续进行比较。第一个在栈中出现的节点为入口结点。</p>
<p>Java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( pHead == <span class="keyword">null</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        Stack&lt;ListNode&gt; list = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>( pHead != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( list.contains(pHead) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> pHead;</span><br><span class="line">            &#125;</span><br><span class="line">            list.push(pHead);</span><br><span class="line">            pHead = pHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Python:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        arr = []</span><br><span class="line">        <span class="keyword">while</span> pHead:</span><br><span class="line">            <span class="keyword">if</span> pHead <span class="keyword">in</span> arr:</span><br><span class="line">                <span class="keyword">return</span> pHead</span><br><span class="line">            arr.append(pHead)</span><br><span class="line">            pHead = pHead.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<h3 id="2-使用快慢指针"><a href="#2-使用快慢指针" class="headerlink" title="2. 使用快慢指针"></a>2. 使用快慢指针</h3><p>一开始想到的就是这种方法，但是陷入一个<strong>误区</strong>：快慢指针相等时的节点为入口结点。这个错误的认知就是无知无畏……</p>
<p>忽略掉的核心步骤：</p>
<p>快慢指针会进行两次 - </p>
<p>（1）找到第一个相同的节点，将该节点置为此链表的最后一个节点，此时slow节点至少会遍历完所有的节点一次；</p>
<p>（2）第二次将fast和slow节点放在头和最后一个节点，每次各走一步：fast走两格、slow走一格；二者第一次相遇的节点即为入口结点。</p>
<blockquote>
<p>比如 {1,2},{3,4,5}，其中前面括号是环外的节点，后面是环中的节点。</p>
<p>第一次遍历：fast - 1 3 5 4；slow - 1 2 3 4 -&gt; 同为4，将链表变为 {1,2},{3,4}；</p>
<p>第二次便利，fast - 1 3 4；slow - 4 3 -&gt; 同为3，可知入环节点为3.</p>
</blockquote>
<p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( pHead == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast = pHead, slow = pHead;</span><br><span class="line">        Stack&lt;ListNode&gt; slow_list = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>( fast != <span class="keyword">null</span> &amp;&amp; slow != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( fast.next != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            slow_list.push(slow);</span><br><span class="line">            <span class="keyword">if</span>( fast == slow )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( fast == <span class="keyword">null</span> || slow == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span>( fast != slow_list.peek() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( fast.next != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            slow_list.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow_list.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        fast, slow = pHead, pHead</span><br><span class="line">        slow_list = []</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> slow:</span><br><span class="line">            <span class="keyword">if</span> fast.<span class="built_in">next</span>:</span><br><span class="line">                fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            slow_list.append(slow)</span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> slow:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        fast = pHead</span><br><span class="line">        <span class="keyword">while</span> fast != slow_list[-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">if</span> fast.<span class="built_in">next</span>:</span><br><span class="line">                fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow_list.pop()</span><br><span class="line">        <span class="keyword">return</span> fast</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>java, python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - JZ48 最长不含重复字符的子字符串</title>
    <url>/2021/11/30/LeetCode-JZ48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.nowcoder.com/practice/48d2ff79b8564c40a50fa79f9d5fa9c7?tpId=13&amp;tqId=2276769&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/48d2ff79b8564c40a50fa79f9d5fa9c7?tpId=13&amp;tqId=2276769&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<span id="more"></span>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>动态规划问题肯定需要一个 <code>dp</code> 或 <code>dp[i]</code> ，本题仅涉及 <code>dp[i-1]</code> ，所以使用 <code>dp</code> 计算就可以了。</p>
<p>涉及到重复字符的问题，需要存储上个相同字符的位置，使用 <code>HashMap</code> 更加便捷。</p>
<p>获得最大值结果，使用 <code>max_length</code> 来存储。</p>
<p>如此其实可以推出了代码的大致方向，这里面最需要思考的问题是 <code>dp</code> 的赋值问题。</p>
<ol>
<li>如果没有重复字符最简单，直接 <code>dp += 1</code> 就可以得到当前不重复长度；</li>
<li>如果有重复字符，一开始的想法是 <code>dp = i - map.get(s.charAt(i))</code> ，但是这种方式的一个误区在于：如果重复元素嵌套，比如 <code>abba</code> ，结果会出错，需要重新理清思路：当前的最长字符串，不是由上个重复元素的位置决定，是由 <strong>上一个最长字符串</strong> 决定的，也就是 <code>第二个a</code> 的最长字符串长度不是由 <code>第一个a</code> 决定，而是由 <code>第二个b</code> 决定，当两个重复元素中间没有嵌套重复元素，比如 <code>abca</code> ，当前的长度才会由上一个重复元素决定，也就是说，应该取二者中更短的一边：<strong>dp = Math.min(dp + 1, i - map.get(s.charAt(i)))</strong> 。</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( s == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( s.length() == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line"><span class="comment">//         int[] dp = new int[chars.length];</span></span><br><span class="line">        <span class="keyword">int</span> dp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max_length = <span class="number">1</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//         dp[0] = 1;</span></span><br><span class="line">        map.put(chars[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; chars.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( !map.containsKey(chars[i]) )</span><br><span class="line">            &#123;</span><br><span class="line">                dp += <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp = Math.min(dp + <span class="number">1</span>, i - map.get(chars[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(chars[i], i);</span><br><span class="line">            max_length = Math.max(max_length, dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC40 两个链表生成相加链表</title>
    <url>/2021/07/24/LeetCode-NC40-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%94%9F%E6%88%90%E7%9B%B8%E5%8A%A0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/c56f6c70fb3f4849bc56e33ff2a50b6b?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/c56f6c70fb3f4849bc56e33ff2a50b6b?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<span id="more"></span>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="1-思路"><a href="#1-思路" class="headerlink" title="1. 思路"></a>1. 思路</h3><p>一开始的思路是将链表转换为具体的值，计算后再转换为最终的链表，但是行不通，因为很有可能会溢出。所以应该要使用类似于数组的结构，可以使用栈Stack来灵活的存取链表的值；也可以更简单粗暴一点，反转链表进行操作。</p>
<h3 id="2-使用栈解决"><a href="#2-使用栈解决" class="headerlink" title="2. 使用栈解决"></a>2. 使用栈解决</h3><p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head1 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head2 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addInList</span> <span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; h1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; h2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        ListNode res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>( head1 != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            h1.push(head1.val);</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( head2 != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            h2.push(head2.val);</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>( !h1.isEmpty() || !h2.isEmpty() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( !h1.isEmpty() )</span><br><span class="line">            &#123;</span><br><span class="line">                sum += h1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( !h2.isEmpty() )</span><br><span class="line">            &#123;</span><br><span class="line">                sum += h2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ListNode tmp = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            tmp.next = res;</span><br><span class="line">            res = tmp;</span><br><span class="line">            </span><br><span class="line">            sum = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( sum != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode tmp = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            tmp.next = res;</span><br><span class="line">            res = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param head1 ListNode类 </span></span><br><span class="line"><span class="comment"># @param head2 ListNode类 </span></span><br><span class="line"><span class="comment"># @return ListNode类</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addInList</span>(<span class="params">self , head1 , head2 </span>):</span></span><br><span class="line">        h1, h2, res = [], [], <span class="literal">None</span></span><br><span class="line">        sum_ = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> head1:</span><br><span class="line">            h1.append(head1.val)</span><br><span class="line">            head1 = head1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> head2:</span><br><span class="line">            h2.append(head2.val)</span><br><span class="line">            head2 = head2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> h1 <span class="keyword">or</span> h2:</span><br><span class="line">            <span class="keyword">if</span> h1:</span><br><span class="line">                sum_ = sum_ + h1.pop(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> h2:</span><br><span class="line">                sum_ = sum_ + h2.pop(-<span class="number">1</span>)</span><br><span class="line">            tmp = ListNode(sum_ % <span class="number">10</span>)</span><br><span class="line">            tmp.<span class="built_in">next</span> = res</span><br><span class="line">            res = tmp</span><br><span class="line">            sum_ = sum_ // <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> sum_ &gt; <span class="number">0</span>:</span><br><span class="line">            tmp = ListNode(sum_)</span><br><span class="line">            tmp.<span class="built_in">next</span> = res</span><br><span class="line">            res = tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="2-反转链表"><a href="#2-反转链表" class="headerlink" title="2. 反转链表"></a>2. 反转链表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head1 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head2 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addInList</span> <span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        ListNode res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        head1 = reverse(head1);</span><br><span class="line">        head2 = reverse(head2);</span><br><span class="line">        <span class="keyword">while</span>( head1 != <span class="keyword">null</span> || head2 != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( head1 != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                sum += head1.val;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( head2 != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                sum += head2.val;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode tmp = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            sum /= <span class="number">10</span>;</span><br><span class="line">            tmp.next = res;</span><br><span class="line">            res = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( sum != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode tmp = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            tmp.next = res;</span><br><span class="line">            res = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode chan = root.next, pre = root;</span><br><span class="line">        <span class="keyword">while</span>( root != <span class="keyword">null</span> &amp;&amp; chan != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            root.next = chan.next;</span><br><span class="line">            chan.next = pre;</span><br><span class="line">            pre = chan;</span><br><span class="line">            <span class="keyword">if</span>( root != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                chan = root.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>java, python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC4 判断链表中是否有环</title>
    <url>/2021/07/06/LeetCode-NC4-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/650474f313294468a4ded3ce0f7898b9?tpId=188&amp;&amp;tqId=38576&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/650474f313294468a4ded3ce0f7898b9?tpId=188&amp;&amp;tqId=38576&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking</a></p>
<span id="more"></span>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="1-快慢指针（典型使用）"><a href="#1-快慢指针（典型使用）" class="headerlink" title="1. 快慢指针（典型使用）"></a>1. 快慢指针（典型使用）</h3><p>java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head, fast = head.next;</span><br><span class="line">        <span class="keyword">while</span>( slow != <span class="keyword">null</span> &amp;&amp; fast != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( slow == fast )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( slow.next == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param head ListNode类 </span></span><br><span class="line"><span class="comment"># @return bool布尔型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self , head </span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        slow, fast = head, head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> slow <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> fast <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> slow.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="2-集合判断是否存在"><a href="#2-集合判断是否存在" class="headerlink" title="2. 集合判断是否存在"></a>2. 集合判断是否存在</h3><p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>( head != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( set.contains(head) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self , head </span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> tmp:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            tmp.append(head)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="3-逐个删除"><a href="#3-逐个删除" class="headerlink" title="3. 逐个删除"></a>3. 逐个删除</h3><p>删除，也就是将每个节点指向自己。</p>
<p>在循环的开始对<code>head</code>和<code>head.next</code>判断是否相等，如果相等，循环，如果不相等，删除后继续循环比较，直到没有节点。</p>
<p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( head != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( head.next != <span class="keyword">null</span> &amp;&amp; head == head.next )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode t = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">            t.next = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self , head </span>):</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> head == head.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            tmp = head</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">            tmp.<span class="built_in">next</span> = tmp</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>java, python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC68 跳台阶</title>
    <url>/2021/07/09/LeetCode-NC68-%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=188&amp;&amp;tqId=38622&amp;rp=1&amp;ru=/ta/job-code-high-week&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=188&amp;&amp;tqId=38622&amp;rp=1&amp;ru=/ta/job-code-high-week&amp;qru=/ta/job-code-high-week/question-ranking</a></p>
<span id="more"></span>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>在中间的某个台阶<code>f[n]</code>，走到这个台阶有两种可能，走一步或走两步，得到公式：<code>f[n] = f[n-1] + f[n-2]</code>，根据常识可以知道，<code>n为1或0时</code>，即<code>f[1] = f[0] = 1</code>，默认排除n小于0的可能性，可以计算结果。</p>
<h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( target &lt;= <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jumpFloor(target-<span class="number">1</span>) + jumpFloor(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法在python中运算时间过长。</p>
<h3 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2. 动态规划"></a>2. 动态规划</h3><p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=target; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对上述代码进行改动，简化了数组的使用。python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        a, b, c = <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, number+<span class="number">1</span>):</span><br><span class="line">            c = a + b</span><br><span class="line">            a = b</span><br><span class="line">            b = c</span><br><span class="line">        <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>爬楼梯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - JZ51 数组中的逆序对</title>
    <url>/2021/12/01/LeetCode-JZ51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&amp;tqId=23260&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&amp;tqId=23260&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<span id="more"></span>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-暴力解法"><a href="#1-暴力解法" class="headerlink" title="1. 暴力解法"></a>1. 暴力解法</h3><p>就是嵌套循环，遍历每个元素的时候，都嵌套一个往回循环到开头，然后计算逆序值。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> P = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>( j &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( array[j] &gt; array[i] )</span><br><span class="line">                &#123;</span><br><span class="line">                    ++P;</span><br><span class="line">                &#125;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(P % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2. 归并排序"></a>2. 归并排序</h3><p><strong>当提示 <code>空间复杂度 O(n)，时间复杂度 O(nlogn)</code> 就可以尝试思考是否可以套归并排序的解法了</strong>。</p>
<ol>
<li>已知归并排序分为两个部分，分治和合并，在分治阶段一般不会有什么其他操作，可以考虑在合并阶段对数据进行操作；</li>
<li>因为是两个部分进行合并，首先可以知道的就是 <code>left</code> 的部分肯定在 <code>right</code> 前面，所以逆序的两个数字可以分别从两个部分选择来比较；</li>
<li>如果确定了逆序的两个数字，可以知道 <code>left</code> 部分从当前元素 <code>i</code> 开始到该部分的结束 <code>mid</code> 对于 <code>right</code> 部分的当前元素 <code>j</code> 都是逆序的，因为此时的两个部分肯定分别是升序排序排列，都是从一个开始排起的。</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> P = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        devide(array, <span class="number">0</span>, len - <span class="number">1</span>, tmp);</span><br><span class="line">        <span class="keyword">return</span> P;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">devide</span><span class="params">( <span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span>[] tmp )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( l &gt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        devide(arr, l, mid, tmp);</span><br><span class="line">        devide(arr, mid + <span class="number">1</span>, r, tmp);</span><br><span class="line">        merge(arr, l, r, mid, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">( <span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> mid, <span class="keyword">int</span>[] tmp )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( mid &gt; r || mid &lt; <span class="number">0</span> || l &gt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( i &lt;= mid &amp;&amp; j &lt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( arr[i] &lt;= arr[j] )</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[t++] = arr[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                P += mid + <span class="number">1</span> - i;</span><br><span class="line">                P %= <span class="number">1000000007</span>;</span><br><span class="line">                tmp[t++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( i &lt;= mid )</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[t++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( j &lt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[t++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( l &lt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            arr[l++] = tmp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC45 实现二叉树先序，中序和后序遍历</title>
    <url>/2021/07/14/LeetCode-NC45-%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%88%E5%BA%8F%EF%BC%8C%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/a9fec6c46a684ad5a3abd4e365a9d362?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/a9fec6c46a684ad5a3abd4e365a9d362?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<span id="more"></span>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-常见思路-递归遍历"><a href="#1-常见思路-递归遍历" class="headerlink" title="1. 常见思路 - 递归遍历"></a>1. 常见思路 - 递归遍历</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param root TreeNode类 the root of binary tree</span></span><br><span class="line"><span class="comment"># @return int整型二维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeOrders</span>(<span class="params">self , root </span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 先序遍历</span></span><br><span class="line">        pre = []</span><br><span class="line">        self.preOrder(root, pre)</span><br><span class="line">        <span class="comment"># 中序遍历</span></span><br><span class="line">        mid = []</span><br><span class="line">        self.midOrder(root, mid)</span><br><span class="line">        <span class="comment"># 后序遍历</span></span><br><span class="line">        post = []</span><br><span class="line">        self.postOrder(root, post)</span><br><span class="line">        <span class="keyword">return</span> [pre, mid, post]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preOrder</span>(<span class="params">self, root, arr</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        arr.append(root.val)</span><br><span class="line">        self.preOrder(root.left, arr)</span><br><span class="line">        self.preOrder(root.right, arr)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">midOrder</span>(<span class="params">self, root, arr</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.midOrder(root.left, arr)</span><br><span class="line">        arr.append(root.val)</span><br><span class="line">        self.midOrder(root.right, arr)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postOrder</span>(<span class="params">self, root, arr</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.postOrder(root.left, arr)</span><br><span class="line">        self.postOrder(root.right, arr)</span><br><span class="line">        arr.append(root.val)</span><br></pre></td></tr></table></figure>
<h3 id="2-对第一个代码进行一点改进"><a href="#2-对第一个代码进行一点改进" class="headerlink" title="2. 对第一个代码进行一点改进"></a>2. 对第一个代码进行一点改进</h3><p>将上面代码的三个排序函数合并为一个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param root TreeNode类 the root of binary tree</span></span><br><span class="line"><span class="comment"># @return int整型二维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeOrders</span>(<span class="params">self , root </span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 先序遍历</span></span><br><span class="line">        pre, mid, post = [], [], []</span><br><span class="line">        self.order(root, pre, mid, post)</span><br><span class="line">        <span class="keyword">return</span> [pre, mid, post]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">order</span>(<span class="params">self, root, pre, mid, post</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        pre.append(root.val)</span><br><span class="line">        self.order(root.left, pre, mid, post)</span><br><span class="line">        mid.append(root.val)</span><br><span class="line">        self.order(root.right, pre, mid, post)</span><br><span class="line">        post.append(root.val)</span><br></pre></td></tr></table></figure>
<h3 id="3-迭代查询"><a href="#3-迭代查询" class="headerlink" title="3. 迭代查询"></a>3. 迭代查询</h3><p>迭代这种就容易想复杂。。。特别是后序遍历！！</p>
<p>以下描述基础思想：</p>
<ol>
<li><p>先序遍历：跟左右</p>
<p>（1）头节点先入栈，然后进入循环；</p>
<p>（2）先出跟，获取其值，然后将右左节点入栈 - 因为栈是先进后出，所以放入应该是先右后左；</p>
<p>（3）然后遍历获取就行了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preOrder</span>(<span class="params">self, root, arr</span>):</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(stack) != <span class="number">0</span>:</span><br><span class="line">            tmp = stack.pop()</span><br><span class="line">            arr.append(tmp.val)</span><br><span class="line">            <span class="keyword">if</span> tmp.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(tmp.right)</span><br><span class="line">            <span class="keyword">if</span> tmp.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(tmp.left)</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历：左跟右</p>
<p>那么存放仅栈的顺序就应该是右跟左，但是不可能从右子树开始遍历，那么就只能存根，遍历左子树，等到没有左子树了，再开始遍历右子树并存值，即出此时没有左子树的跟，取跟值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">midOrder</span>(<span class="params">self, root, arr</span>):</span></span><br><span class="line">    stack = []</span><br><span class="line">    cur = root</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(stack) != <span class="number">0</span> <span class="keyword">or</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> cur.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            stack.append(cur.left)</span><br><span class="line">            cur = cur.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            arr.append(cur.val)</span><br><span class="line">            cur = cur.right</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序遍历（就先序遍历反操作就是了）</p>
<p>也就是先序遍历的反操作，逆序取跟左右，最终输出左右跟。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postOrder</span>(<span class="params">self, root, arr</span>):</span></span><br><span class="line">    stack = [root]</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(stack) != <span class="number">0</span>:</span><br><span class="line">        tmp = stack.pop()</span><br><span class="line">        arr.append(tmp.val)</span><br><span class="line">        <span class="keyword">if</span> tmp.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            stack.append(tmp.left)</span><br><span class="line">        <span class="keyword">if</span> tmp.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            stack.append(tmp.right)</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC76 用两个栈实现队列</title>
    <url>/2021/07/07/LeetCode-NC76-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=188&amp;&amp;tqId=38552&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-rankingj">https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=188&amp;&amp;tqId=38552&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-rankingj</a></p>
<span id="more"></span>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-两个栈分别在push和pop之前都会循环"><a href="#1-两个栈分别在push和pop之前都会循环" class="headerlink" title="1. 两个栈分别在push和pop之前都会循环"></a>1. 两个栈分别在push和pop之前都会循环</h3><p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( !stack2.isEmpty() )</span><br><span class="line">        &#123;</span><br><span class="line">            stack1.push(stack2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( !stack1.isEmpty() )</span><br><span class="line">        &#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-对上面代码的一点点优化，将两个循环转变为一个循环"><a href="#2-对上面代码的一点点优化，将两个循环转变为一个循环" class="headerlink" title="2. 对上面代码的一点点优化，将两个循环转变为一个循环"></a>2. 对上面代码的一点点优化，将两个循环转变为一个循环</h3><p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( stack2.isEmpty() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( !stack1.isEmpty() )</span><br><span class="line">            &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>java, python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC78 反转链表</title>
    <url>/2021/07/04/LeetCode-NC78-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=188&amp;&amp;tqId=38547&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=188&amp;&amp;tqId=38547&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking</a></p>
<span id="more"></span>
<h2 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h2><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>( head != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode p = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">            p.next = res;</span><br><span class="line">            res = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead <span class="keyword">or</span> <span class="keyword">not</span> pHead.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        res = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> pHead:</span><br><span class="line">            p = pHead</span><br><span class="line">            pHead = pHead.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = res</span><br><span class="line">            res = p</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre = ReverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>python：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre = ReverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对上面代码的理解：</p>
<ol>
<li><p>ListNode pre = ReverseList(head.next)</p>
<p>获取当前结点之前反转好的链表，注意，此时head.next是已经反转好的链表的最后一个节点；</p>
</li>
<li><p>head.next.next = head</p>
<p>将当前节点接到已经反转好的链表的最后一个节点后面，也就是将当前head放到head.next后面；</p>
</li>
<li><p>head.next = null</p>
<p>最后将当前节点的next置空，作为当前已经反转好的链表的最后一个节点。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>java, python</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL - 报错</title>
    <url>/2021/07/29/SQL-%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h3 id="1-SQL-ERROR-INFO-‘Operand-should-contain-1-column-s-’"><a href="#1-SQL-ERROR-INFO-‘Operand-should-contain-1-column-s-’" class="headerlink" title="1. SQL_ERROR_INFO: ‘Operand should contain 1 column(s)’"></a>1. SQL_ERROR_INFO: ‘Operand should contain 1 column(s)’</h3><span id="more"></span>
<p>报错语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(salary) <span class="keyword">as</span> avg_salary</span><br><span class="line">  <span class="keyword">from</span> salaries</span><br><span class="line"> <span class="keyword">where</span> salary </span><br><span class="line"><span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(salary)</span><br><span class="line">       ,<span class="built_in">max</span>(salary) </span><br><span class="line">  <span class="keyword">from</span> salaries</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>解决：</p>
<p><code>in</code> 关键字只能对应一列数据。</p>
<h3 id="2-FAILED-SemanticException-Error-10044-Line-1-12-Cannot-insert-into-target-table-because-column-number-types-are-different-‘’813’’-Table-insclause-0-has-7-columns-but-query-has-8-columns"><a href="#2-FAILED-SemanticException-Error-10044-Line-1-12-Cannot-insert-into-target-table-because-column-number-types-are-different-‘’813’’-Table-insclause-0-has-7-columns-but-query-has-8-columns" class="headerlink" title="2. FAILED: SemanticException [Error 10044]: Line 1:12 Cannot insert into target table because column number/types are different ‘’813’’: Table insclause-0 has 7 columns, but query has 8 columns."></a>2. FAILED: SemanticException [Error 10044]: Line 1:12 Cannot insert into target table because column number/types are different ‘’813’’: Table insclause-0 has 7 columns, but query has 8 columns.</h3><p>。。。仔细看 <code>values</code> 里面的内容，应该有多了。</p>
]]></content>
      <categories>
        <category>报错</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL刷题 - SQL12 获取每个部门中当前员工薪水最高的相关信息</title>
    <url>/2021/07/09/SQL%E5%88%B7%E9%A2%98-SQL12-%E8%8E%B7%E5%8F%96%E6%AF%8F%E4%B8%AA%E9%83%A8%E9%97%A8%E4%B8%AD%E5%BD%93%E5%89%8D%E5%91%98%E5%B7%A5%E8%96%AA%E6%B0%B4%E6%9C%80%E9%AB%98%E7%9A%84%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/4a052e3e1df5435880d4353eb18a91c6?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/4a052e3e1df5435880d4353eb18a91c6?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<span id="more"></span>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-知识点"><a href="#1-知识点" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>要求获取每一个分组中的最大元素（也可以看作获取每个分组的第一个元素）。</p>
<p>错误的思考：在同一个语句中group by+order by - </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 错误</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a <span class="keyword">order</span> <span class="keyword">by</span> b</span><br></pre></td></tr></table></figure>
<p>原因：group by后显示的就会是每个分组的第一条数据；之后进行order by就是对每个分组的第一条数据进行排序，即组间排序，并没有意义。</p>
<p>分析：有一种方法是可以先order by limit再进行group by，但是这种方法不够灵活有效；还有一种方法就算下述，先获取每个分组的目标元素的最大值和目标分组的字段，然后联表获取所有所需字段和目标分组字段，将两个部分进行连接就可以了。</p>
<h3 id="2-具体题解"><a href="#2-具体题解" class="headerlink" title="2. 具体题解"></a>2. 具体题解</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> B1.dept_no</span><br><span class="line">      ,B2.emp_no</span><br><span class="line">      ,B1.maxSalary</span><br><span class="line">  <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">        <span class="keyword">select</span> A1.dept_no, <span class="built_in">max</span>(A2.salary) <span class="keyword">as</span> maxSalary</span><br><span class="line">          <span class="keyword">from</span> dept_emp <span class="keyword">as</span> A1</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> salaries <span class="keyword">as</span> A2</span><br><span class="line">            <span class="keyword">on</span> A1.emp_no <span class="operator">=</span> A2.emp_no</span><br><span class="line">      <span class="keyword">group</span> <span class="keyword">by</span> A1.dept_no</span><br><span class="line">) B1</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">(</span><br><span class="line">        <span class="keyword">select</span> A1.dept_no, A1.emp_no, A2.salary</span><br><span class="line">          <span class="keyword">from</span> dept_emp <span class="keyword">as</span> A1</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> salaries <span class="keyword">as</span> A2</span><br><span class="line">            <span class="keyword">on</span> A1.emp_no <span class="operator">=</span> A2.emp_no</span><br><span class="line">) B2</span><br><span class="line">     <span class="keyword">on</span> B1.dept_no <span class="operator">=</span> B2.dept_no</span><br><span class="line">     <span class="keyword">and</span> B1.maxSalary <span class="operator">=</span> B2.salary</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> B1.dept_no</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL刷题 - SQL15 查找employees表emp_no与last_name的员工信息</title>
    <url>/2021/07/09/SQL%E5%88%B7%E9%A2%98-SQL15-%E6%9F%A5%E6%89%BEemployees%E8%A1%A8emp-no%E4%B8%8Elast-name%E7%9A%84%E5%91%98%E5%B7%A5%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/a32669eb1d1740e785f105fa22741d5c?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/a32669eb1d1740e785f105fa22741d5c?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<span id="more"></span>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-知识点"><a href="#1-知识点" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>不相等的三种表达：<code>!=、&lt;&gt;、is not</code>；</p>
<p>求余：<code>%、MOD</code>；</p>
<p>判断是否为奇数：<code>val%2 = 1、val&amp;1</code>；</p>
<p>判断是否为偶数：<code>val = (val &gt;&gt; 1 &lt;&lt; 1)</code> - 即先右移一位再左移一位，如果是奇数，二进制最后一位一定是1，右移一位后再左移一位最后一个二进制数会补0而不是1，此时如果是奇数会与原值不等，如果是偶数会相等；</p>
<p>除法计算：默认 - <code>/</code>、取指定小数位 - <code>convert(val1 / val2, decimal(10, 2))</code> - 取两位小数，为0取整不保留小数、直接取整 - <code>val1 DIV val2</code>；</p>
<p><strong>计算还是推荐使用位运算的</strong>。</p>
<h3 id="2-具体代码"><a href="#2-具体代码" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">from</span> employees</span><br><span class="line">   <span class="keyword">where</span> emp_no <span class="operator">%</span> <span class="number">2</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">     <span class="keyword">and</span> last_name <span class="operator">&lt;&gt;</span> &quot;Mary&quot;</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> hire_date</span><br><span class="line">    <span class="keyword">desc</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">--或者</span></span><br><span class="line">  <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">from</span> employees</span><br><span class="line">   <span class="keyword">where</span> emp_no <span class="operator">&amp;</span> <span class="number">1</span></span><br><span class="line">     <span class="keyword">and</span> last_name <span class="operator">&lt;&gt;</span> &quot;Mary&quot;</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> hire_date</span><br><span class="line">    <span class="keyword">desc</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL刷题 - SQL35 批量插入数据，不使用replace操作</title>
    <url>/2021/07/14/SQL%E5%88%B7%E9%A2%98-SQL35-%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%EF%BC%8C%E4%B8%8D%E4%BD%BF%E7%94%A8replace%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/153c8a8e7805400ba8e384e03acc6b3e?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/153c8a8e7805400ba8e384e03acc6b3e?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<span id="more"></span>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p><strong>主要是insert ignore 和 replace into 的区别：</strong></p>
<p>使用 <code>ignore</code> 关键字。</p>
<p><code>insert ignore</code>  - 如果数据库中不存在这条数据就插入，存在就跳过。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> </span><br><span class="line">ignore </span><br><span class="line">  <span class="keyword">into</span> actor </span><br><span class="line"><span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;ED&#x27;</span>, <span class="string">&#x27;CHASE&#x27;</span>, <span class="string">&#x27;2006-02-15 12:34:33&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>使用 <code>replace</code> 关键字。</p>
<p><code>replace into</code> - 如果存在 <code>primary key</code> 或 <code>unique</code> 相同的记录，先删除原有记录，再添加此新记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">replace </span><br><span class="line">   <span class="keyword">into</span> actor</span><br><span class="line"> <span class="keyword">select</span> <span class="number">3</span></span><br><span class="line">        ,<span class="string">&#x27;ED&#x27;</span></span><br><span class="line">        ,<span class="string">&#x27;CHASE&#x27;</span></span><br><span class="line">        ,<span class="string">&#x27;2006-02-15 12:34:33&#x27;</span></span><br><span class="line">   <span class="keyword">from</span> actor</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p><strong>ignore 和 replace 是mysql8之后有的内容。</strong></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL刷题 - SQL37 对first_name创建唯一索引uniq_idx_firstname</title>
    <url>/2021/07/14/SQL%E5%88%B7%E9%A2%98-SQL37-%E5%AF%B9first-name%E5%88%9B%E5%BB%BA%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95uniq-idx-firstname/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/e1824daa0c49404aa602cf0cb34bdd75?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/e1824daa0c49404aa602cf0cb34bdd75?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<span id="more"></span>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="1-知识点"><a href="#1-知识点" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>有以下几种索引 <code>index</code> ：</p>
<ul>
<li>UNIQUE:可选。表示索引为唯一性索引。</li>
<li>FULLTEXT:可选。表示索引为全文索引。</li>
<li>SPATIAL:可选。表示索引为空间索引。</li>
<li>默认上述关键字都不加，表示索引为普通索引。</li>
</ul>
<p>添加索引的几种方式：</p>
<ol>
<li>创建表时添加：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test</span><br><span class="line">(</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    filename <span class="type">VARCHAR</span> (<span class="number">512</span>),</span><br><span class="line">    fileurl <span class="type">VARCHAR</span> (<span class="number">512</span>),</span><br><span class="line">    filesize <span class="type">BIGINT</span>,</span><br><span class="line">    <span class="comment">-- 带关键字索引</span></span><br><span class="line">    <span class="keyword">unique</span> index (id),</span><br><span class="line">    <span class="comment">-- 普通索引</span></span><br><span class="line">    index (filename),</span><br><span class="line">    <span class="comment">--组合索引</span></span><br><span class="line">    index (fileurl, filesize)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ol>
<li>为已有表添加：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 带关键字的索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test <span class="keyword">add</span> <span class="keyword">unique</span> index (id);</span><br><span class="line"><span class="comment">-- 不带关键字的索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test <span class="keyword">add</span> index (filename);</span><br></pre></td></tr></table></figure>
<h3 id="2-具体代码"><a href="#2-具体代码" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> actor <span class="keyword">add</span> <span class="keyword">unique</span> index uniq_idx_firstname (first_name);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> actor <span class="keyword">add</span> index idx_lastname (last_name);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL刷题 - SQL23 对所有员工的薪水按照salary降序进行1-N的排名</title>
    <url>/2021/07/11/SQL%E5%88%B7%E9%A2%98-SQL23-%E5%AF%B9%E6%89%80%E6%9C%89%E5%91%98%E5%B7%A5%E7%9A%84%E8%96%AA%E6%B0%B4%E6%8C%89%E7%85%A7salary%E9%99%8D%E5%BA%8F%E8%BF%9B%E8%A1%8C1-N%E7%9A%84%E6%8E%92%E5%90%8D/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/b9068bfe5df74276bd015b9729eec4bf?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/b9068bfe5df74276bd015b9729eec4bf?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<span id="more"></span>
<h2 id="求解思路"><a href="#求解思路" class="headerlink" title="求解思路"></a>求解思路</h2><h3 id="1-知识点"><a href="#1-知识点" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><ol>
<li><code>row_number</code> - 生成连续唯一的序号，即序号不重复：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>)</span><br></pre></td></tr></table></figure>
<p>得到结果：</p>
<blockquote>
<p>1</p>
<p>2</p>
<p>2</p>
<p>3</p>
</blockquote>
<ol>
<li><code>rank</code> - 分区内排名，即一个分区的排名一致，但会产生间断：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>)</span><br></pre></td></tr></table></figure>
<p>得到结果：</p>
<blockquote>
<p>1</p>
<p>2</p>
<p>2</p>
<p>4</p>
</blockquote>
<ol>
<li><code>dense_rank</code> - 分区内排名，不会产生间断：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>)</span><br></pre></td></tr></table></figure>
<p>得到结果：</p>
<blockquote>
<p>1</p>
<p>2</p>
<p>2</p>
<p>3</p>
</blockquote>
<ol>
<li><code>ntile</code> - 按照指定的排序规则均分成指定数目的组</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ntile</span>(<span class="number">2</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>)</span><br></pre></td></tr></table></figure>
<p>得到结果：</p>
<blockquote>
<p>1</p>
<p>1</p>
<p>2</p>
<p>2</p>
</blockquote>
<h3 id="2-具体代码"><a href="#2-具体代码" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> emp_no</span><br><span class="line">       ,salary</span><br><span class="line">       ,<span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>) <span class="keyword">as</span> t_rank</span><br><span class="line">  <span class="keyword">from</span> salaries</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> t_rank <span class="keyword">asc</span>, emp_no <span class="keyword">asc</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL刷题 - SQL38 针对actor表创建视图actor_name_view</title>
    <url>/2021/07/15/SQL%E5%88%B7%E9%A2%98-SQL38-%E9%92%88%E5%AF%B9actor%E8%A1%A8%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BEactor-name-view/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/b9db784b5e3d488cbd30bd78fdb2a862?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/b9db784b5e3d488cbd30bd78fdb2a862?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<span id="more"></span>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="1-知识点"><a href="#1-知识点" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>创建视图：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br></pre></td></tr></table></figure>
<p>查询视图：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> view_name;</span><br></pre></td></tr></table></figure>
<p>更新视图：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br></pre></td></tr></table></figure>
<p>撤销视图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW view_name</span><br></pre></td></tr></table></figure>
<h3 id="2-具体解决代码"><a href="#2-具体解决代码" class="headerlink" title="2. 具体解决代码"></a>2. 具体解决代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> actor_name_view <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">select</span> first_name <span class="keyword">as</span> first_name_v</span><br><span class="line">       ,last_name <span class="keyword">as</span> last_name_v</span><br><span class="line">  <span class="keyword">from</span> actor;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL刷题 - SQL39 强制使用索引</title>
    <url>/2021/07/15/SQL%E5%88%B7%E9%A2%98-SQL39-%E5%BC%BA%E5%88%B6%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/f9fa9dc1a1fc4130b08e26c22c7a1e5f?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/f9fa9dc1a1fc4130b08e26c22c7a1e5f?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<span id="more"></span>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="1-知识点"><a href="#1-知识点" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>强制使用索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> TABLE1 FORCE INDEX (索引名或<span class="keyword">PRIMARY</span>) ;</span><br></pre></td></tr></table></figure>
<h3 id="2-具体代码"><a href="#2-具体代码" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> salaries FORCE INDEX (idx_emp_no) <span class="keyword">where</span> emp_no <span class="operator">=</span> <span class="number">10005</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL刷题 - SQL40 在指定列后添加新列</title>
    <url>/2021/07/15/SQL%E5%88%B7%E9%A2%98-SQL40-%E5%9C%A8%E6%8C%87%E5%AE%9A%E5%88%97%E5%90%8E%E6%B7%BB%E5%8A%A0%E6%96%B0%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/119f04716d284cb7a19fba65dd876b03?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/119f04716d284cb7a19fba65dd876b03?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<span id="more"></span>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="1-知识点"><a href="#1-知识点" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">alter</span> </span><br><span class="line">  <span class="keyword">table</span> table_name</span><br><span class="line">    <span class="keyword">add</span></span><br><span class="line"> <span class="keyword">COLUMN</span> column_name column_type [<span class="keyword">not</span> <span class="keyword">NULL</span>]</span><br><span class="line">[<span class="keyword">DEFAULT</span> default_context]</span><br><span class="line">[  after column_name]</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p>其中，<code>after</code> 用来指定在某个列后面添加新列，<code>default</code> 指定默认值。</p>
<h3 id="2-具体代码"><a href="#2-具体代码" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">alter</span> </span><br><span class="line">  <span class="keyword">table</span> actor</span><br><span class="line">    <span class="keyword">add</span></span><br><span class="line"> <span class="keyword">COLUMN</span> create_date datetime <span class="keyword">not</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="string">&#x27;2020-10-01 00:00:00&#x27;</span></span><br><span class="line">  after last_update</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL刷题 - SQL41 构造一个触发器</title>
    <url>/2021/07/16/SQL%E5%88%B7%E9%A2%98-SQL41-%E6%9E%84%E9%80%A0%E4%B8%80%E4%B8%AA%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/7e920bb2e1e74c4e83750f5c16033e2e?tpId=82&amp;&amp;tqId=29809&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/sql/question-ranking">https://www.nowcoder.com/practice/7e920bb2e1e74c4e83750f5c16033e2e?tpId=82&amp;&amp;tqId=29809&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/sql/question-ranking</a></p>
<span id="more"></span>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="1-知识点"><a href="#1-知识点" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>Trigger创建的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">       trigger_time trigger_event </span><br><span class="line">    <span class="keyword">ON</span> tbl_name</span><br><span class="line">   <span class="keyword">FOR</span> </span><br><span class="line">  <span class="keyword">EACH</span> </span><br><span class="line">   <span class="type">ROW</span></span><br><span class="line">       trigger_stmt</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<blockquote>
<p><strong>参数解析</strong></p>
<p>trigger_name：标识触发器名称，用户自行指定；<br>trigger_time：标识触发时机，取值为 BEFORE 或 AFTER；<br>trigger_event：标识触发事件，取值为 INSERT、UPDATE 或 DELETE；<br>tbl_name：标识建立触发器的表名，即在哪张表上建立触发器；<br>trigger_stmt：触发器程序体，可以是一句SQL语句，或者用 BEGIN 和 END 包含的多条语句，每条语句结束要分号结尾。</p>
<p><strong>new 和 old</strong></p>
<p>MySQL 中定义了 NEW 和 OLD，用来表示触发器的所在表中，触发了触发器的那一行数据。<br>具体地：</p>
<ol>
<li>在 INSERT 型触发器中，NEW 用来表示将要（BEFORE）或已经（AFTER）插入的新数据；</li>
<li>在 UPDATE 型触发器中，OLD 用来表示将要或已经被修改的原数据，NEW 用来表示将要或已经修改为的新数据；</li>
<li>在 DELETE 型触发器中，OLD 用来表示将要或已经被删除的原数据；</li>
<li>使用方法： NEW.columnName （columnName 为相应数据表某一列名）</li>
</ol>
</blockquote>
<h3 id="2-具体代码"><a href="#2-具体代码" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">      <span class="keyword">create</span> </span><br><span class="line">     <span class="keyword">trigger</span> audit_log</span><br><span class="line">       after </span><br><span class="line">      <span class="keyword">insert</span> </span><br><span class="line">          <span class="keyword">on</span> employees_test</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line">       <span class="keyword">begin</span></span><br><span class="line">             <span class="keyword">insert</span> <span class="keyword">into</span> audit <span class="keyword">values</span>(new.ID, new.NAME);</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<h3 id="3-摘自"><a href="#3-摘自" class="headerlink" title="3. 摘自"></a>3. 摘自</h3><p><a href="https://blog.csdn.net/haut_ykc/article/details/110226668">SQL编程：构造触发器</a></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL刷题 - SQL42_43 对表进行条件删除和更新</title>
    <url>/2021/07/16/SQL%E5%88%B7%E9%A2%98-SQL42-43-%E5%AF%B9%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%9D%A1%E4%BB%B6%E5%88%A0%E9%99%A4%E5%92%8C%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p>删除：</p>
<p><a href="https://www.nowcoder.com/practice/3d92551a6f6d4f1ebde272d20872cf05?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/3d92551a6f6d4f1ebde272d20872cf05?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<p>更新：</p>
<p><a href="https://www.nowcoder.com/practice/859f28f43496404886a77600ea68ef59?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/859f28f43496404886a77600ea68ef59?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<span id="more"></span>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="1-知识点"><a href="#1-知识点" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>删除语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name [<span class="keyword">WHERE</span> Clause]</span><br></pre></td></tr></table></figure>
<p>更新语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE table_name <span class="keyword">SET</span> field1<span class="operator">=</span><span class="keyword">new</span><span class="operator">-</span>value1, field2<span class="operator">=</span><span class="keyword">new</span><span class="operator">-</span>value2</span><br><span class="line">[<span class="keyword">WHERE</span> Clause]</span><br></pre></td></tr></table></figure>
<h3 id="2-具体代码"><a href="#2-具体代码" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> titles_test</span><br><span class="line"><span class="keyword">where</span> id <span class="keyword">not</span> <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">select</span> <span class="built_in">min</span>(id)</span><br><span class="line">        <span class="keyword">from</span> titles_test</span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span> emp_no</span><br><span class="line">    )A1</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">--更新</span></span><br><span class="line">UPDATE titles_test</span><br><span class="line">   <span class="keyword">SET</span> to_date<span class="operator">=</span><span class="keyword">NULL</span></span><br><span class="line">       ,from_date<span class="operator">=</span><span class="string">&#x27;2001-01-01&#x27;</span></span><br><span class="line"> <span class="keyword">WHERE</span> to_date <span class="operator">=</span> <span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p>这里有一个犯过的错误：</p>
<p><strong>group by前面的select语句中要用聚合函数！！！不然是没有作用的。</strong></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL刷题 - SQL51 查找字符串 10,A,B 中逗号,出现的次数cnt</title>
    <url>/2021/07/19/SQL%E5%88%B7%E9%A2%98-SQL51-%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2-10-A-B-%E4%B8%AD%E9%80%97%E5%8F%B7-%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0cnt/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/e3870bd5d6744109a902db43c105bd50?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/e3870bd5d6744109a902db43c105bd50?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<span id="more"></span>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="1-知识点"><a href="#1-知识点" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>MySQL中没有 <code>split</code> 函数。</p>
<p>我之前以为可以通过 <code>substring_index(str,delim,index)</code> 函数得到和 <code>split</code> 相同的结果…但是不是。这种方法是获取指定字符串按照指定字符分割后的部分字符串。</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL刷题 - SQL44_45 alter和update</title>
    <url>/2021/07/18/SQL%E5%88%B7%E9%A2%98-SQL44-45-alter%E5%92%8Cupdate/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p>update：</p>
<p><a href="https://www.nowcoder.com/practice/2bec4d94f525458ca3d0ebf3bc8cd240?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/2bec4d94f525458ca3d0ebf3bc8cd240?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<p>alter：</p>
<p><a href="https://www.nowcoder.com/practice/5277d7f92aa746ab8aa42886e5d570d4?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/5277d7f92aa746ab8aa42886e5d570d4?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<span id="more"></span>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="1-知识点"><a href="#1-知识点" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>update和alter的<strong>区别</strong>：</p>
<p>alter 是DDL语句，是修改数据库中对象（表，数据库，视图。。）的语句；update是DML语句，是修改表中数据的语句。</p>
<p>alter中：</p>
<p>（1）添加列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">        <span class="keyword">ADD</span> column_name column_type</span><br><span class="line">           [, column_name colum_type ...];</span><br></pre></td></tr></table></figure>
<p>（2）删除列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">       <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> column_name;</span><br></pre></td></tr></table></figure>
<p>（3）改变数据类型：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">MODIFY <span class="keyword">COLUMN</span> column_name column_type;</span><br></pre></td></tr></table></figure>
<p>（4）修改表名：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> old_name</span><br><span class="line">  RENAME <span class="keyword">TO</span> new_name;</span><br></pre></td></tr></table></figure>
<p>update中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE table_name </span><br><span class="line">   <span class="keyword">SET</span> field1<span class="operator">=</span><span class="keyword">new</span><span class="operator">-</span>value1, field2<span class="operator">=</span><span class="keyword">new</span><span class="operator">-</span>value2</span><br><span class="line">[<span class="keyword">WHERE</span> Clause]</span><br></pre></td></tr></table></figure>
<p>特殊的，题中出现替代值,这就用到了 <code>replace函数</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">replace(<span class="keyword">column</span>, old_value, new_value)</span><br></pre></td></tr></table></figure>
<p>出现在 <code>update</code> 也是一样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">set</span> column_name <span class="operator">=</span> replace(column_name, <span class="keyword">old</span>, <span class="keyword">new</span>)</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>
<h3 id="2-具体代码"><a href="#2-具体代码" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sql44</span></span><br><span class="line"> UPDATE titles_test </span><br><span class="line">    <span class="keyword">SET</span> emp_no <span class="operator">=</span> REPLACE(emp_no, <span class="number">10001</span>, <span class="number">10005</span>)</span><br><span class="line">  <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">--sql45</span></span><br><span class="line"> <span class="keyword">alter</span> </span><br><span class="line"> <span class="keyword">table</span> titles_test </span><br><span class="line">rename </span><br><span class="line">    <span class="keyword">to</span> titles_2017</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL刷题 - SQL53 按照dept_no进行汇总</title>
    <url>/2021/07/29/SQL%E5%88%B7%E9%A2%98-SQL53-%E6%8C%89%E7%85%A7dept-no%E8%BF%9B%E8%A1%8C%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/6e86365af15e49d8abe2c3d4b5126e87?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/6e86365af15e49d8abe2c3d4b5126e87?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<span id="more"></span>
<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">select</span> dept_no</span><br><span class="line">         ,GROUP_CONCAT(emp_no)</span><br><span class="line">    <span class="keyword">from</span> dept_emp </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_no;</span><br></pre></td></tr></table></figure>
<h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p><code>group_concat(column, delim)</code></p>
<p>将聚合后的字段进行连接， <code>delim</code> 参数默认是 <code>,</code> 逗号。</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL刷题 - SQL55 分页查询employees表，每5行一页，返回第2页的数据</title>
    <url>/2021/08/08/SQL%E5%88%B7%E9%A2%98-SQL55-%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2employees%E8%A1%A8%EF%BC%8C%E6%AF%8F5%E8%A1%8C%E4%B8%80%E9%A1%B5%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%AC%AC2%E9%A1%B5%E7%9A%84%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/f24966e0cb8a49c192b5e65339bc8c03?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/f24966e0cb8a49c192b5e65339bc8c03?tpId=82&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<span id="more"></span>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>知识点：分页查询。</p>
<p><strong>每页n行，取第k页的全部数据。</strong></p>
<h3 id="1-limit进行分页"><a href="#1-limit进行分页" class="headerlink" title="1. limit进行分页"></a>1. limit进行分页</h3><p>公式：<code>limit n * (k - 1), n</code></p>
<p>具体代码：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> emp_no</span><br><span class="line">limit <span class="number">5</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>在具体代码中，<strong>limit后不支持计算</strong>。</p>
<h3 id="2-row-number实现分页查询"><a href="#2-row-number实现分页查询" class="headerlink" title="2. row_number实现分页查询"></a>2. row_number实现分页查询</h3><p>具体代码：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> emp_no,birth_date,first_name,last_name,gender,hire_date</span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">       ,<span class="built_in">floor</span>(rn <span class="operator">/</span> <span class="number">5</span>) <span class="keyword">as</span> dr</span><br><span class="line">  <span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> e.<span class="operator">*</span></span><br><span class="line">       ,<span class="built_in">row_number</span>() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> emp_no) <span class="operator">-</span> <span class="number">1</span> <span class="keyword">as</span> rn</span><br><span class="line">  <span class="keyword">from</span> employees e</span><br><span class="line">)e1</span><br><span class="line">)e2 <span class="keyword">where</span> dr <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>思路是：</p>
<ol>
<li>首先对整体数据添加序号：<code>row_number() over</code> 至少需要用 <code>order by</code> 进行排序；</li>
<li>先使用 <code>rn / 5</code> 对数据分页，已知 <code>0/5 == 1/5 == 2/5 == 3/5 == 4/5 == 0</code>（仅整数部分），但是由于此处的计算结果是小数，使用 <code>floor()</code> 函数向下取整。</li>
<li>最终取分页值为 <code>(k-1)</code> 的数据即可。</li>
</ol>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark - SparkSQL</title>
    <url>/2021/06/24/Spark-SparkSQL/</url>
    <content><![CDATA[<h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><p>SparkSQL是Spark用于结构化数据处理的Spark模块。</p>
<span id="more"></span>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="1-易整合"><a href="#1-易整合" class="headerlink" title="1. 易整合"></a>1. 易整合</h4><p>无缝地整合了SQL查询和Spark编程。</p>
<h4 id="2-统一的数据访问"><a href="#2-统一的数据访问" class="headerlink" title="2. 统一的数据访问"></a>2. 统一的数据访问</h4><p>使用相同的方式连接不同的数据源。比如数据库，HBase、Hive、MySQL等都可以使用相同的方式进行连接，即具有了通用性，只需要修改一些参数就可以从不同的数据源中获取数据，非常方便。</p>
<h4 id="3-兼容hive"><a href="#3-兼容hive" class="headerlink" title="3. 兼容hive"></a>3. 兼容hive</h4><p>在已有的仓库上直接运行SQL或HiveQL。</p>
<h4 id="4-标准数据连接"><a href="#4-标准数据连接" class="headerlink" title="4. 标准数据连接"></a>4. 标准数据连接</h4><p>通过JDBC或ODBC来连接。</p>
<h3 id="DataFrame是什么？与RDD的区别"><a href="#DataFrame是什么？与RDD的区别" class="headerlink" title="DataFrame是什么？与RDD的区别"></a>DataFrame是什么？与RDD的区别</h3><p>​        在Spark中，DataFrame是一种以RDD为基础的分布式数据集，类似于传统数据库中的二维表格。</p>
<p>​        DataFrame与RDD的主要区别在于，前者带有schema元数据信息，即DataFrame锁表示的</p>
<h2 id="核心编程"><a href="#核心编程" class="headerlink" title="核心编程"></a>核心编程</h2><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>文件可以读取的格式如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">csv   format   jdbc   json   load   option   options   orc   parquet   schema   table   text   textFile</span><br></pre></td></tr></table></figure>
<ol>
<li>读取类型的例子：</li>
</ol>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; spark.read.json(<span class="string">&quot;input/user.json&quot;</span>)</span><br><span class="line">res1: org.apache.spark.sql.<span class="type">DataFrame</span> = [age: string, username: string]</span><br></pre></td></tr></table></figure>
<ol>
<li>读取实际内容的例子：</li>
</ol>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> df = spark.read.json(<span class="string">&quot;input/user.json&quot;</span>)</span><br><span class="line">df: org.apache.spark.sql.<span class="type">DataFrame</span> = [age: string, username: string]</span><br><span class="line"></span><br><span class="line">scala&gt; df.show()</span><br><span class="line">+---+--------+</span><br><span class="line">|age|username|</span><br><span class="line">+---+--------+</span><br><span class="line">| <span class="number">30</span>|zhangsan|</span><br><span class="line">| <span class="number">20</span>|    lisi|</span><br><span class="line">| <span class="number">40</span>|  wangwu|</span><br><span class="line">+---+--------+</span><br></pre></td></tr></table></figure>
<ol>
<li>按照条件读取指定内容的例子：</li>
</ol>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; df.createTempView(<span class="string">&quot;user&quot;</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; spark.sql(<span class="string">&quot;select username from user&quot;</span>).show</span><br><span class="line">+--------+</span><br><span class="line">|username|</span><br><span class="line">+--------+</span><br><span class="line">|zhangsan|</span><br><span class="line">|    lisi|</span><br><span class="line">|  wangwu|</span><br><span class="line">+--------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">scala&gt; spark.sql(<span class="string">&quot;select avg(age) from user&quot;</span>).show</span><br><span class="line">+------------------------+</span><br><span class="line">|avg(<span class="type">CAST</span>(age <span class="type">AS</span> <span class="type">DOUBLE</span>))|</span><br><span class="line">+------------------------+</span><br><span class="line">|                    <span class="number">30.0</span>|</span><br><span class="line">+------------------------+</span><br></pre></td></tr></table></figure>
<p>此处<code>createTempView</code>是创建一次临时表，如果多次创建，可能会报错，使用<code>createOrReplaceTempView</code>可以避免这种错误。</p>
<p><strong>其中，需要知道<code>view</code>即视图，是将查询结果集转换成为一个特定的视图结构，只可以查，不可以改；与表table不同，表可以改。</strong></p>
<p>注意：普通临时表是Session范围内的，如果在创建一个Session，该Session中的使用不会在新创建的Session中留下痕迹。如果想应用范围内有效，可以使用全局临时表。使用全局临时表需要全路径访问，如<code>global_temp.user</code></p>
<ol>
<li>全局临时表</li>
</ol>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; df.createOrReplaceGlobalTempView(<span class="string">&quot;emp&quot;</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; spark.newSession.sql(<span class="string">&quot;select * from global_temp.emp&quot;</span>)</span><br><span class="line">res10: org.apache.spark.sql.<span class="type">DataFrame</span> = [age: string, username: string]</span><br><span class="line"></span><br><span class="line">scala&gt; spark.newSession.sql(<span class="string">&quot;select * from global_temp.emp&quot;</span>).show</span><br><span class="line">+---+--------+</span><br><span class="line">|age|username|</span><br><span class="line">+---+--------+</span><br><span class="line">| <span class="number">30</span>|zhangsan|</span><br><span class="line">| <span class="number">20</span>|    lisi|</span><br><span class="line">| <span class="number">40</span>|  wangwu|</span><br><span class="line">+---+--------+</span><br></pre></td></tr></table></figure>
<p><code>newSession</code>是重新启动一个Session测试是否多个节点都可以进行测试。</p>
<h3 id="DSL的简单使用"><a href="#DSL的简单使用" class="headerlink" title="DSL的简单使用"></a>DSL的简单使用</h3><p>是DataFrame提供的，用来管理结构化的数据。使用这个语言不需要去创建视图等，因为它本身九江DataFrame当成数据源。可以在Scala、Java、Python、R中使用DSL。</p>
<h4 id="1-基本例子："><a href="#1-基本例子：" class="headerlink" title="1. 基本例子："></a>1. 基本例子：</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; df.printSchema</span><br><span class="line">root</span><br><span class="line"> |-- age: string (nullable = <span class="literal">true</span>)</span><br><span class="line"> |-- username: string (nullable = <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">scala&gt; df.select(<span class="string">&quot;age&quot;</span>).show</span><br><span class="line">+---+</span><br><span class="line">|age|</span><br><span class="line">+---+</span><br><span class="line">| <span class="number">30</span>|</span><br><span class="line">| <span class="number">20</span>|</span><br><span class="line">| <span class="number">40</span>|</span><br><span class="line">+---+</span><br></pre></td></tr></table></figure>
<h4 id="2-查看”username”数据和”age-1”数据"><a href="#2-查看”username”数据和”age-1”数据" class="headerlink" title="2. 查看”username”数据和”age+1”数据"></a>2. 查看”username”数据和”age+1”数据</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; df.select($<span class="string">&quot;age&quot;</span> + <span class="number">1</span>).show</span><br><span class="line">+---------+</span><br><span class="line">|(age + <span class="number">1</span>)|</span><br><span class="line">+---------+</span><br><span class="line">|     <span class="number">31.0</span>|</span><br><span class="line">|     <span class="number">21.0</span>|</span><br><span class="line">|     <span class="number">41.0</span>|</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure>
<p>使用<code>$</code>符号表示引用这个变量，如果不使用，就表示简单的字符串相加；</p>
<p>spark提供另一种更简便的方式：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; df.select(<span class="symbol">&#x27;age</span> + <span class="number">1</span>).show</span><br><span class="line">+---------+</span><br><span class="line">|(age + <span class="number">1</span>)|</span><br><span class="line">+---------+</span><br><span class="line">|     <span class="number">31.0</span>|</span><br><span class="line">|     <span class="number">21.0</span>|</span><br><span class="line">|     <span class="number">41.0</span>|</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure>
<p>其中，<code>$</code>和<code>&#39;</code>只能修饰一个列，有多个列，就有多个符号。</p>
<h4 id="3-查看age大于30的数据"><a href="#3-查看age大于30的数据" class="headerlink" title="3. 查看age大于30的数据"></a>3. 查看<code>age</code>大于30的数据</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; df.select(<span class="symbol">&#x27;age</span> &gt; <span class="number">30</span>).show</span><br><span class="line">+----------+</span><br><span class="line">|(age &gt; <span class="number">30</span>)|</span><br><span class="line">+----------+</span><br><span class="line">|     <span class="literal">false</span>|</span><br><span class="line">|     <span class="literal">false</span>|</span><br><span class="line">|      <span class="literal">true</span>|</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure>
<h4 id="4-查看age大于30的数据-过滤"><a href="#4-查看age大于30的数据-过滤" class="headerlink" title="4. 查看age大于30的数据 - 过滤"></a>4. 查看<code>age</code>大于<code>30</code>的数据 - 过滤</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; df.filter($<span class="string">&quot;age&quot;</span> &gt; <span class="number">30</span>).show</span><br><span class="line">+---+--------+</span><br><span class="line">|age|username|</span><br><span class="line">+---+--------+</span><br><span class="line">| <span class="number">40</span>|  wangwu|</span><br><span class="line">+---+--------+</span><br></pre></td></tr></table></figure>
<h4 id="5-按照age分组，查看数组条数-分组"><a href="#5-按照age分组，查看数组条数-分组" class="headerlink" title="5. 按照age分组，查看数组条数 - 分组"></a>5. 按照<code>age</code>分组，查看数组条数 - 分组</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; df.groupBy(<span class="string">&quot;age&quot;</span>).count.show</span><br><span class="line">+---+-----+</span><br><span class="line">|age|count|</span><br><span class="line">+---+-----+</span><br><span class="line">| <span class="number">30</span>|    <span class="number">1</span>|</span><br><span class="line">| <span class="number">40</span>|    <span class="number">1</span>|</span><br><span class="line">| <span class="number">20</span>|    <span class="number">1</span>|</span><br><span class="line">+---+-----+</span><br></pre></td></tr></table></figure>
<h3 id="RDD和DataFrame的转换"><a href="#RDD和DataFrame的转换" class="headerlink" title="RDD和DataFrame的转换"></a>RDD和DataFrame的转换</h3><p>RDD转DataFrame：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">15</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> df = rdd.toDF(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">df: org.apache.spark.sql.<span class="type">DataFrame</span> = [id: int]</span><br><span class="line"></span><br><span class="line">scala&gt; df.show</span><br><span class="line">+---+</span><br><span class="line">| id|</span><br><span class="line">+---+</span><br><span class="line">|  <span class="number">1</span>|</span><br><span class="line">|  <span class="number">2</span>|</span><br><span class="line">|  <span class="number">3</span>|</span><br><span class="line">|  <span class="number">4</span>|</span><br><span class="line">+---+</span><br></pre></td></tr></table></figure>
<p>DataFrame转RDD：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; df.rdd</span><br><span class="line">res4: org.apache.spark.rdd.<span class="type">RDD</span>[org.apache.spark.sql.<span class="type">Row</span>] = <span class="type">MapPartitionsRDD</span>[<span class="number">23</span>] at rdd at &lt;console&gt;:<span class="number">26</span></span><br></pre></td></tr></table></figure>
<h3 id="DataSet"><a href="#DataSet" class="headerlink" title="DataSet"></a>DataSet</h3><p>dataSet是具有强类型的数据集合，需要提供对应的类型信息。</p>
<p>DataSet相比于DataFrame、RDD，后二者没有数据类型的概念，而前者有，即前者是包含了DataFrame的结构和RDD的数据。</p>
<h4 id="1-样例类创建DataSet"><a href="#1-样例类创建DataSet" class="headerlink" title="1. 样例类创建DataSet"></a>1. 样例类创建DataSet</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name:<span class="type">String</span>, age: <span class="type">Long</span></span>)</span></span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> list = <span class="type">List</span>(<span class="type">Person</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">30</span>), <span class="type">Person</span>(<span class="string">&quot;lisi&quot;</span>, <span class="number">40</span>))</span><br><span class="line">list: <span class="type">List</span>[<span class="type">Person</span>] = <span class="type">List</span>(<span class="type">Person</span>(zhangsan,<span class="number">30</span>), <span class="type">Person</span>(lisi,<span class="number">40</span>))</span><br><span class="line"></span><br><span class="line">scala&gt; list.toDS</span><br><span class="line">res5: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">Person</span>] = [name: string, age: bigint]</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> ds = list.toDS</span><br><span class="line">ds: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">Person</span>] = [name: string, age: bigint]</span><br><span class="line"></span><br><span class="line">scala&gt; ds.show</span><br><span class="line">+--------+---+</span><br><span class="line">|    name|age|</span><br><span class="line">+--------+---+</span><br><span class="line">|zhangsan| <span class="number">30</span>|</span><br><span class="line">|    lisi| <span class="number">40</span>|</span><br><span class="line">+--------+---+</span><br></pre></td></tr></table></figure>
<h4 id="2-和DataFrame的转换"><a href="#2-和DataFrame的转换" class="headerlink" title="2. 和DataFrame的转换"></a>2. 和DataFrame的转换</h4><p>DataFrame转换为DataSet：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> ds = df.as[<span class="type">Person</span>]</span><br></pre></td></tr></table></figure>
<p>DataSet转换为DataFrame：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> df = ds.toDF</span><br></pre></td></tr></table></figure>
<h3 id="RDD和DataSet的转换"><a href="#RDD和DataSet的转换" class="headerlink" title="RDD和DataSet的转换"></a>RDD和DataSet的转换</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="type">Person</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">30</span>), <span class="type">Person</span>(<span class="string">&quot;lisi&quot;</span>, <span class="number">40</span>)))</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Person</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">29</span>] at makeRDD at &lt;console&gt;:<span class="number">26</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd.toDS</span><br><span class="line">res11: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">Person</span>] = [name: string, age: bigint]</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> ds = rdd.toDS</span><br><span class="line">ds: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">Person</span>] = [name: string, age: bigint]</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> rdd = ds.rdd</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Person</span>] = <span class="type">MapPartitionsRDD</span>[<span class="number">32</span>] at rdd at &lt;console&gt;:<span class="number">25</span></span><br></pre></td></tr></table></figure>
<h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h3 id="RDD、DataFrame、DataSet的联系"><a href="#RDD、DataFrame、DataSet的联系" class="headerlink" title="RDD、DataFrame、DataSet的联系"></a>RDD、DataFrame、DataSet的联系</h3>]]></content>
      <categories>
        <category>大数据组件的应用</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark - 运行环境的安装配置</title>
    <url>/2021/06/17/Spark-%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="一-解压缩文件"><a href="#一-解压缩文件" class="headerlink" title="一. 解压缩文件"></a>一. 解压缩文件</h2><p>在官网下载 <a href="https://www.apache.org/dyn/closer.lua/spark/spark-3.1.2/spark-3.1.2-bin-hadoop3.2.tgz">spark-3.1.2-bin-hadoop3.2.tgz</a> 文件并上传到Linux，然后解压缩到指定位置，重命名为 <code>spark-local</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf spark-3.1.2-bin-hadoop3.2.tgz -C /opt/pkg</span><br><span class="line">mv spark-3.1.2-bin-hadoop3.2 spark-local</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="local环境"><a href="#local环境" class="headerlink" title="local环境"></a>local环境</h3><ol>
<li><p>进入目录</p>
<p><code>cd /opt/pkg/spark-local</code></p>
</li>
<li><p>启动</p>
<p><code>bin/spark-shell</code></p>
<p>正常情况下会进入spark shell客户端，以<code>scala</code>为输入的标记：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">26</span>:<span class="number">15</span> <span class="type">WARN</span> <span class="type">NativeCodeLoader</span>: <span class="type">Unable</span> to load native-hadoop library <span class="keyword">for</span> your platform... using builtin-java classes where applicable</span><br><span class="line"><span class="type">Using</span> <span class="type">Spark</span><span class="symbol">&#x27;s</span> <span class="keyword">default</span> log4j profile: org/apache/spark/log4j-defaults.properties</span><br><span class="line"><span class="type">Setting</span> <span class="keyword">default</span> log level to <span class="string">&quot;WARN&quot;</span>.</span><br><span class="line"><span class="type">To</span> adjust logging level use sc.setLogLevel(newLevel). <span class="type">For</span> <span class="type">SparkR</span>, use setLogLevel(newLevel).</span><br><span class="line"><span class="type">Spark</span> context <span class="type">Web</span> <span class="type">UI</span> available at http:<span class="comment">//hadoop002:4040</span></span><br><span class="line"><span class="type">Spark</span> context available as <span class="symbol">&#x27;s</span>c&#x27; (master = local[*], app id = local<span class="number">-1624029984600</span>).</span><br><span class="line"><span class="type">Spark</span> session available as <span class="symbol">&#x27;spar</span>k&#x27;.</span><br><span class="line"><span class="type">Welcome</span> to</span><br><span class="line">      ____              __</span><br><span class="line">     / __/__  ___ _____/ /__</span><br><span class="line">    _\ \/ _ \/ _ `/ __/  <span class="symbol">&#x27;_</span>/</span><br><span class="line">   /___/ .__/\_,_/_/ /_/\_\   version <span class="number">3.0</span><span class="number">.1</span></span><br><span class="line">      /_/</span><br><span class="line"></span><br><span class="line"><span class="type">Using</span> <span class="type">Scala</span> version <span class="number">2.12</span><span class="number">.10</span> (<span class="type">Java</span> <span class="type">HotSpot</span>(<span class="type">TM</span>) <span class="number">64</span>-<span class="type">Bit</span> <span class="type">Server</span> <span class="type">VM</span>, <span class="type">Java</span> <span class="number">1.8</span><span class="number">.0</span>_281)</span><br><span class="line"><span class="type">Type</span> in expressions to have them evaluated.</span><br><span class="line"><span class="type">Type</span> :help <span class="keyword">for</span> more information.</span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以写一些基本的<code>scala</code>语法，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scala&gt; var i = 10</span><br><span class="line">i: Int = 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以写<code>spark</code>语法，下面给出<code>wordcount</code>的例子</p>
<p>（1）准备数据</p>
<p>在目录 <code>/opt/pkg/spark-shell/data</code> 下创建文件 <code>test.txt</code></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">hello scala</span><br><span class="line">hello spark</span><br></pre></td></tr></table></figure>
<p>（2）执行命令</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; sc.textFile(<span class="string">&quot;/opt/pkg/spark/data/test.txt&quot;</span>).flatMap(_.split(<span class="string">&quot; &quot;</span>)).map((_,<span class="number">1</span>)).reduceByKey(_+_).collect</span><br><span class="line"></span><br><span class="line">res13: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">Array</span>((scala,<span class="number">1</span>), (spark,<span class="number">1</span>), (hello,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>成功！</p>
<p>（3）下面简单比较一下 <code>shell</code> 下和 <code>scala代码</code> 中的变化</p>
<p>其实大致没有变化，只是 <code>sparkContext</code> 不需要进行配置，在进入客户端时就有提示：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">Spark</span> context available as <span class="symbol">&#x27;s</span>c&#x27; (master = local[*], app id = local<span class="number">-1624029984600</span>).</span><br></pre></td></tr></table></figure>
<p>所以可以直接使用 <code>sc</code> 来进行操作。</p>
</li>
<li><p>查看资源监控页面</p>
<p>直接复制粘贴进入客户端的提示：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">Spark</span> context <span class="type">Web</span> <span class="type">UI</span> available at http:<span class="comment">//hadoop002:4040</span></span><br></pre></td></tr></table></figure>
<p>复制粘贴其中的 <code>http://hadoop002:4040</code> 到网页，就可以打开监控页面了。</p>
<p>结合本地IDEA的应用：</p>
<p>运行 <code>spark</code> 中自带的一个jar包例子：</p>
<p>在 <code>spark-local</code> 的目录下执行：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">[hadoop<span class="meta">@hadoop</span>002 spark-local]$ spark-submit \</span><br><span class="line">&gt; --<span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">spark</span>.<span class="title">examples</span>.<span class="title">SparkPi</span> <span class="title">\</span></span></span><br><span class="line">&gt; --master local[<span class="number">2</span>] \</span><br><span class="line">&gt; ./examples/jars/spark-examples_2<span class="number">.12</span><span class="number">-3.0</span><span class="number">.1</span>.jar \</span><br><span class="line">&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>得到结果：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">Pi</span> is roughly <span class="number">3.1422671422671424</span></span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">SparkUI</span>: <span class="type">Stopped</span> <span class="type">Spark</span> web <span class="type">UI</span> at http:<span class="comment">//hadoop002:4040</span></span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">MapOutputTrackerMasterEndpoint</span>: <span class="type">MapOutputTrackerMasterEndpoint</span> stopped!</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">MemoryStore</span>: <span class="type">MemoryStore</span> cleared</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">BlockManager</span>: <span class="type">BlockManager</span> stopped</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">BlockManagerMaster</span>: <span class="type">BlockManagerMaster</span> stopped</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">OutputCommitCoordinator</span>$<span class="type">OutputCommitCoordinatorEndpoint</span>: <span class="type">OutputCommitCoordinator</span> stopped!</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">SparkContext</span>: <span class="type">Successfully</span> stopped <span class="type">SparkContext</span></span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">ShutdownHookManager</span>: <span class="type">Shutdown</span> hook called</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">ShutdownHookManager</span>: <span class="type">Deleting</span> directory /tmp/spark...</span><br></pre></td></tr></table></figure>
<p>其中，</p>
<p><code>--master local[2]</code> 设置部署模式，默认本地模式，数字2表示分配的虚拟CPU核数量；</p>
<p><code>10</code> 表示程序的入口参数，用于设定当前应用的任务数量。</p>
</li>
</ol>
<h3 id="standalone环境"><a href="#standalone环境" class="headerlink" title="standalone环境"></a>standalone环境</h3><ol>
<li><p>在 <code>local环境</code> 的基础上进行配置</p>
<p>（1）将 <code>spark-local</code> 重命名为 <code>spark-standalone</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv spark-local spark-standalone</span><br></pre></td></tr></table></figure>
<p>（2）进入 <code>spark-standalone/conf</code> 目录：</p>
<p>修改 <code>slaves</code> 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd spark-standalone/conf</span><br><span class="line">mv slaves.template slaves</span><br><span class="line">vim slaves</span><br></pre></td></tr></table></figure>
<p>然后修改 <code>localhost</code> 为自己的节点名，如果是分布式部署，就写所有节点名称，如：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">hadoop001</span><br><span class="line">hadoop002</span><br><span class="line">hadoop003</span><br></pre></td></tr></table></figure>
<p>如果是伪分布式部署，即只有一个节点，就写一个节点名称：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">hadoop001</span><br></pre></td></tr></table></figure>
<p>修改 <code>spark-env.sh</code> 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd spark-standalone/conf</span><br><span class="line">mv spark-env.sh.template spark-env.sh</span><br><span class="line">vim spark-env.sh</span><br></pre></td></tr></table></figure>
<p>然后将下述内容贴到文件中：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">SPARK_MASTER_HOST=hadoop001       #添加spark master的主机名</span><br><span class="line">SPARK_MASTER_PORT=<span class="number">7077</span>        #添加spark master的端口号</span><br><span class="line">export JAVA_HOME=/<span class="keyword">opt</span>/pkg/java</span><br></pre></td></tr></table></figure>
<p>其中主要要修改 <code>&#123;JAVA_HOME</code> 的路径。</p>
<p>如果是分布式部署，需要分发 <code>spark-standalone</code> 目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xsync spark-standalone</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动集群</p>
<p>进入 <code>spark-standalone</code> 目录下执行启动命令，它有一个和 <code>Hadoop</code> 启动一样的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sbin/start-all.sh</span><br></pre></td></tr></table></figure>
<p>启动成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hadoop@hadoop002 spark]$ sbin/start-all.sh</span><br><span class="line">starting org.apache.spark.deploy.master.Master, logging to /opt/pkg/spark/logs/spark-hadoop-org.apache.spark.deploy.master.Master-1-hadoop002.out</span><br><span class="line">hadoop002: starting org.apache.spark.deploy.worker.Worker, logging to /opt/pkg/spark/logs/spark-hadoop-org.apache.spark.deploy.worker.Worker-1-hadoop002.out</span><br></pre></td></tr></table></figure>
<p>查看资源监控的 <code>Web UI</code> 界面：<a href="http://hadoop002:8080">http://hadoop002:8080</a></p>
</li>
<li><p>结合本地IDEA应用</p>
<p>运行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hadoop@hadoop002 spark]$ spark-submit \</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> --class org.apache.spark.examples.SparkPi \</span></span><br><span class="line"><span class="bash">&gt; --master spark://hadoop002:7077 \</span></span><br><span class="line"><span class="bash">&gt; ./examples/jars/spark-examples_2.12-3.0.1.jar \</span></span><br><span class="line"><span class="bash">&gt; 10</span></span><br></pre></td></tr></table></figure>
<p>得到结果：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">Pi</span> is roughly <span class="number">3.142367142367142</span></span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">SparkUI</span>: <span class="type">Stopped</span> <span class="type">Spark</span> web <span class="type">UI</span> at http:<span class="comment">//hadoop002:4040</span></span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">StandaloneSchedulerBackend</span>: <span class="type">Shutting</span> down all executors</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">CoarseGrainedSchedulerBackend</span>$<span class="type">DriverEndpoint</span>: <span class="type">Asking</span> each executor to shut down</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">MapOutputTrackerMasterEndpoint</span>: <span class="type">MapOutputTrackerMasterEndpoint</span> stopped!</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">MemoryStore</span>: <span class="type">MemoryStore</span> cleared</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">BlockManager</span>: <span class="type">BlockManager</span> stopped</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">BlockManagerMaster</span>: <span class="type">BlockManagerMaster</span> stopped</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">OutputCommitCoordinator</span>$<span class="type">OutputCommitCoordinatorEndpoint</span>: <span class="type">OutputCommitCoordinator</span> stopped!</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">SparkContext</span>: <span class="type">Successfully</span> stopped <span class="type">SparkContext</span></span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">ShutdownHookManager</span>: <span class="type">Shutdown</span> hook called</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">ShutdownHookManager</span>: <span class="type">Deleting</span> directory /tmp/spa...</span><br></pre></td></tr></table></figure>
<p>成功！</p>
</li>
</ol>
]]></content>
      <categories>
        <category>大数据组件的应用</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>com.mysql.jdbc.MysqlDataTruncation: Data truncation: Data too long for column &#39;picture&#39; at row 1</title>
    <url>/2022/01/14/com-mysql-jdbc-MysqlDataTruncation-Data-truncation-Data-too-long-for-column-picture-at-row-1/</url>
    <content><![CDATA[<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>表字段设置长度不够。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>修改表字段长度设置。</p>
<p>本项目使用 <code>blob</code> 存储图片的二进制数报错，应改成 <code>longblob</code> 。</p>
]]></content>
      <categories>
        <category>报错</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/05/30/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>hive - 报错</title>
    <url>/2021/08/06/hive-%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h3 id="hive-ql-io-orc-OrcSerde-OrcSerdeRow-cannot-be-cast-to-org-apache-hadoop-io-BytesWritable"><a href="#hive-ql-io-orc-OrcSerde-OrcSerdeRow-cannot-be-cast-to-org-apache-hadoop-io-BytesWritable" class="headerlink" title="hive.ql.io.orc.OrcSerde$OrcSerdeRow cannot be cast to org.apache.hadoop.io.BytesWritable"></a>hive.ql.io.orc.OrcSerde$OrcSerdeRow cannot be cast to org.apache.hadoop.io.BytesWritable</h3><span id="more"></span>
<p>具体报错内容如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&quot;area_flag&quot;:&quot;3&quot;,&quot;kpi_value&quot;:<span class="number">72980.5886</span>&#125;</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.mr.ExecMapper.map(ExecMapper.java:<span class="number">179</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.mapred.MapRunner.run(MapRunner.java:<span class="number">54</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.mapred.MapTask.runOldMapper(MapTask.java:<span class="number">459</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.mapred.MapTask.run(MapTask.java:<span class="number">343</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.mapred.YarnChild$<span class="number">2.</span>run(YarnChild.java:<span class="number">164</span>)</span><br><span class="line">        <span class="keyword">at</span> java.security.AccessController.doPrivileged(Native <span class="keyword">Method</span>)</span><br><span class="line">        <span class="keyword">at</span> javax.security.auth.Subject.doAs(Subject.java:<span class="number">415</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:<span class="number">1917</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.mapred.YarnChild.main(YarnChild.java:<span class="number">158</span>)</span><br><span class="line">Caused <span class="keyword">by</span>: org.apache.hadoop.hive.ql.metadata.HiveException: Hive Runtime Error while processing <span class="type">row</span> &#123;&quot;kpi_code&quot;:&quot;FFJFCW121&quot;,&quot;area_code&quot;:&quot;811&quot;,&quot;area_name&quot;:&quot;北京&quot;,&quot;area_flag&quot;:&quot;3&quot;,&quot;kpi_value&quot;:<span class="number">72980.5886</span>&#125;</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.MapOperator.process(MapOperator.java:<span class="number">507</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.mr.ExecMapper.map(ExecMapper.java:<span class="number">170</span>)</span><br><span class="line">        ... <span class="number">8</span> more</span><br><span class="line">Caused <span class="keyword">by</span>: org.apache.hadoop.hive.ql.metadata.HiveException: Unexpected exception: Unexpected exception: org.apache.hadoop.hive.ql.io.orc.OrcSerde$OrcSerdeRow cannot be cast <span class="keyword">to</span> org.apache.hadoop.io.BytesWritable</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.MapJoinOperator.processOp(MapJoinOperator.java:<span class="number">318</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.Operator.forward(Operator.java:<span class="number">815</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.TableScanOperator.processOp(TableScanOperator.java:<span class="number">98</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.MapOperator$MapOpCtx.forward(MapOperator.java:<span class="number">157</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.MapOperator.process(MapOperator.java:<span class="number">497</span>)</span><br><span class="line">        ... <span class="number">9</span> more</span><br><span class="line">Caused <span class="keyword">by</span>: org.apache.hadoop.hive.ql.metadata.HiveException: Unexpected exception: org.apache.hadoop.hive.ql.io.orc.OrcSerde$OrcSerdeRow cannot be cast <span class="keyword">to</span> org.apache.hadoop.io.BytesWritable</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.MapJoinOperator.processOp(MapJoinOperator.java:<span class="number">318</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.Operator.forward(Operator.java:<span class="number">815</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.internalForward(CommonJoinOperator.java:<span class="number">638</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.genAllOneUniqueJoinObject(CommonJoinOperator.java:<span class="number">670</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.checkAndGenObject(CommonJoinOperator.java:<span class="number">748</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.MapJoinOperator.processOp(MapJoinOperator.java:<span class="number">306</span>)</span><br><span class="line">        ... <span class="number">13</span> more</span><br><span class="line">Caused <span class="keyword">by</span>: java.lang.ClassCastException: org.apache.hadoop.hive.ql.io.orc.OrcSerde$OrcSerdeRow cannot be cast <span class="keyword">to</span> org.apache.hadoop.io.BytesWritable</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat$<span class="number">1.</span>write(HiveIgnoreKeyTextOutputFormat.java:<span class="number">91</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.FileSinkOperator.processOp(FileSinkOperator.java:<span class="number">717</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.Operator.forward(Operator.java:<span class="number">815</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.SelectOperator.processOp(SelectOperator.java:<span class="number">84</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.Operator.forward(Operator.java:<span class="number">815</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.internalForward(CommonJoinOperator.java:<span class="number">638</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.createForwardJoinObject(CommonJoinOperator.java:<span class="number">433</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.genObject(CommonJoinOperator.java:<span class="number">525</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.genObject(CommonJoinOperator.java:<span class="number">522</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.genObject(CommonJoinOperator.java:<span class="number">522</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.genJoinObject(CommonJoinOperator.java:<span class="number">451</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.checkAndGenObject(CommonJoinOperator.java:<span class="number">752</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.MapJoinOperator.processOp(MapJoinOperator.java:<span class="number">306</span>)</span><br><span class="line">        ... <span class="number">18</span> more</span><br></pre></td></tr></table></figure>
<p>解决：</p>
<ol>
<li><p>查看表结构</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="keyword">desc</span> formatted table_name;</span><br><span class="line">...                 </span><br><span class="line"># Storage Information            </span><br><span class="line">SerDe Library:          org.apache.hadoop.hive.ql.io.orc.OrcSerde        </span><br><span class="line">InputFormat:            org.apache.hadoop.mapred.TextInputFormat         </span><br><span class="line">OutputFormat:           org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>SerDe Library</code> 的格式为 <code>OrcSerde</code> 。</p>
<p>有两种可能性：</p>
<p>（1）可能是复制其他表的结构创建该表，没有复制完，有部分配置不对，这时候需要对比两个表的结构分析；</p>
<p>（2）创建表结构指定的格式不对。</p>
</li>
<li><p>查看表结构</p>
<p>如果是复制表结构创建的表，可以使用如下命令比对两个表创建时候的结构：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> table_name;</span><br></pre></td></tr></table></figure>
<p>本次错误是因为没有复制完，漏掉了如下设置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="type">ROW</span> FORMAT SERDE </span><br><span class="line">  <span class="string">&#x27;org.apache.hadoop.hive.ql.io.orc.OrcSerde&#x27;</span> </span><br><span class="line"><span class="keyword">WITH</span> SERDEPROPERTIES ( </span><br><span class="line">  <span class="string">&#x27;field.delim&#x27;</span><span class="operator">=</span><span class="string">&#x27;\u0005&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;serialization.format&#x27;</span><span class="operator">=</span><span class="string">&#x27;\u0005&#x27;</span>) </span><br><span class="line">STORED <span class="keyword">AS</span> INPUTFORMAT </span><br><span class="line">  <span class="string">&#x27;org.apache.hadoop.hive.ql.io.orc.OrcInputFormat&#x27;</span> </span><br><span class="line">OUTPUTFORMAT </span><br><span class="line">  <span class="string">&#x27;org.apache.hadoop.hive.ql.io.orc.OrcOutputFormat&#x27;</span></span><br><span class="line">LOCATION</span><br><span class="line">  <span class="string">&#x27;hdfs://ns/domain/ns/sc_share/dm_db/tmp_td_month&#x27;</span></span><br><span class="line">TBLPROPERTIES (</span><br><span class="line">  <span class="string">&#x27;orcfile.compress&#x27;</span><span class="operator">=</span><span class="string">&#x27;Snappy&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;transient_lastDdlTime&#x27;</span><span class="operator">=</span><span class="string">&#x27;1587809055&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>解决方式：</p>
<p>将当前出错的表删掉：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">table</span> table_name;</span><br></pre></td></tr></table></figure>
<p>然后将原表的结构复制，可能需要修改存储位置<code>LOCATION</code> ；</p>
<p>最后使用该创建语句再次创建表，成功解决。</p>
</li>
<li><p>修改表的格式</p>
<p>本内容摘自：<a href="https://blog.csdn.net/wawa8899/article/details/81674817">Hive表的file_format参数</a></p>
<p>有如下这些格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">file_format:</span><br><span class="line">  : SEQUENCEFILE</span><br><span class="line">  <span class="operator">|</span> TEXTFILE    <span class="comment">-- (Default, depending on hive.default.fileformat configuration)  # 默认存储文本格式，不能区分数据类型</span></span><br><span class="line">  <span class="operator">|</span> RCFILE      <span class="comment">-- (<span class="doctag">Note:</span> Available in Hive 0.6.0 and later)</span></span><br><span class="line">  <span class="operator">|</span> ORC         <span class="comment">-- (<span class="doctag">Note:</span> Available in Hive 0.11.0 and later)</span></span><br><span class="line">  <span class="operator">|</span> PARQUET     <span class="comment">-- (<span class="doctag">Note:</span> Available in Hive 0.13.0 and later)</span></span><br><span class="line">  <span class="operator">|</span> AVRO        <span class="comment">-- (<span class="doctag">Note:</span> Available in Hive 0.14.0 and later)</span></span><br><span class="line">  <span class="operator">|</span> JSONFILE    <span class="comment">-- (<span class="doctag">Note:</span> Available in Hive 4.0.0 and later)</span></span><br><span class="line">  <span class="operator">|</span> INPUTFORMAT input_format_classname OUTPUTFORMAT output_format_classname</span><br></pre></td></tr></table></figure>
<p>TEXTFILE：文本格式，为hive默认的存储格式，这种格式不能区分数据类型（Int类型的数据也只能当作文本来处理）。TEXTFILE在使用时只需要指定两个东西：列与列之间的分隔符；行与行之间的分隔符。<br>SEQUENCEFILE：二进制的，它存在一些问题，这种存储格式存储的数据size比原始数据还要大，现在基本不用。<br>RCFILE：它是一个混合的行列编成的，它保证所有行的一个列都在一个节点（block）之上，缺点是row group太小（4M）了，实际的好处只是空间节省只提升了大约10%，工作中不会大面积使用，所以现在基本也不使用了。<br>ORC：优化过后的RC（行列存储），它提供了更高效的存储方式。一个strip（250M）包含了索引文件，索引范围1~10W。查询时只会查询index范围内的strip，提高查询效率。默认每10000行为一个单位。orc默认采用zlib压缩方式。详见官网说明。<br>PARQUET：源于dremel（三秒钟完成一个T的数据处理），效率很高。<br>AVRO：不常用。<br>JSONFILE：不常用。</p>
<p>可以使用如下命令修改表的格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">set</span> fileformat file_format;</span><br></pre></td></tr></table></figure>
<p>一般情况下用来转换为 <code>ORC</code> 格式。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>报错</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>hive - 日志分析项目小记</title>
    <url>/2021/05/31/hive-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="启动hive"><a href="#启动hive" class="headerlink" title="启动hive"></a>启动hive</h2><ol>
<li><p>启动hadoop集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-dfs.sh</span><br><span class="line">start-yarn.sh</span><br></pre></td></tr></table></figure>
</li>
</ol>
<span id="more"></span>
<ol>
<li><p>启动zookeeper集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zkServer.sh start zoo1.cfg</span><br><span class="line">zkServer.sh start zoo2.cfg</span><br><span class="line">zkServer.sh start zoo3.cfg</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动hive</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hive-services.sh start</span><br><span class="line">hive</span><br></pre></td></tr></table></figure>
<p>有时候会遇到下述错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hadoop.ipc.RemoteException(org.apache.hadoop.hdfs.server.namenode.SafeModeException): Cannot create directory /tmp/hive/hadoop/3a6e8cb6-9e44-45ce-8fc4-8d79f816f720. Name node is in safe mode.</span><br><span class="line">The reported blocks 609 needs additional 3 blocks to reach the threshold 0.9990 of total blocks 613.</span><br><span class="line">The minimum number of live datanodes is not required. Safe mode will be turned off automatically once the thresholds have been reached. NamenodeHostName:hadoop002</span><br><span class="line">        at org.apache.hadoop.hdfs.server.namenode.FSNamesystem.newSafemodeException(FSNamesystem.java:1498)</span><br><span class="line">        at org.apache.hadoop.hdfs.server.namenode.FSNamesystem.checkNameNodeSafeMode(FSNamesystem.java:1485)</span><br><span class="line">        at org.apache.hadoop.hdfs.server.namenode.FSNamesystem.mkdirs(FSNamesystem.java:3191)</span><br><span class="line">        at org.apache.hadoop.hdfs.server.namenode.NameNodeRpcServer.mkdirs(NameNodeRpcServer.java:1157)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>解决：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hadoop dfsadmin -safemode leave</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="使用sqoop将mysql数据导入hive"><a href="#使用sqoop将mysql数据导入hive" class="headerlink" title="使用sqoop将mysql数据导入hive"></a>使用sqoop将mysql数据导入hive</h2><p>执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqoop import -m 1 \</span><br><span class="line">--connect jdbc:mysql://192.168.186.100:3306/forum \</span><br><span class="line">--username root \</span><br><span class="line">--password niit1234 \</span><br><span class="line">--hive-import \</span><br><span class="line">--create-hive-table \</span><br><span class="line">--hive-database forum \</span><br><span class="line">--delete-target-dir;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<blockquote>
<p>—create-hive-table ：使用mysql的表名和字段类型直接创建；</p>
<p>—hive-database ：指定将表放到某个数据库</p>
</blockquote>
<h2 id="报错：FAILED-ParseException-line-6-0-cannot-recognize-input-near-‘group’-‘by’-‘t’-in-expression-specification"><a href="#报错：FAILED-ParseException-line-6-0-cannot-recognize-input-near-‘group’-‘by’-‘t’-in-expression-specification" class="headerlink" title="报错：FAILED: ParseException line 6:0 cannot recognize input near ‘group’ ‘by’ ‘t’ in expression specification"></a>报错：FAILED: ParseException line 6:0 cannot recognize input near ‘group’ ‘by’ ‘t’ in expression specification</h2><p>我是因为下面这句报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">on tmp.id=t.course_id and t.type_name=”选修课”</span><br></pre></td></tr></table></figure>
<p>报错点：<code>&quot;&quot;</code>是中文的，我一开始直接在word文档中复制粘贴，但是就算是英文格式，在命令行也是中文的。</p>
<p>解决方法：</p>
<p>在命令行中敲出引号，在文档中进行修改，再将整个语句粘贴到命令行运行。</p>
<p>在创建表的时候，如果定义的字段名称是关键字，也会报这个错。</p>
]]></content>
      <categories>
        <category>项目小记</category>
      </categories>
      <tags>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>java - 内存模型的理解</title>
    <url>/2021/07/13/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="Java中的变量"><a href="#Java中的变量" class="headerlink" title="Java中的变量"></a>Java中的变量</h3><p>有三种：</p>
<span id="more"></span>
<p>成员变量（实例变量、属性）、本地变量（局部变量）、类变量（静态属性）。</p>
<ol>
<li>成员变量在类中定义，在类的内部的任何区域都可以访问的变量。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name,</span><br><span class="line">    <span class="keyword">int</span> age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>本地变量在方法中定义，在方法体的任何区域都可以访问的变量。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类变量是被<code>static</code>关键字修饰的属性，它的作用范围在定义之后，只能在类中修饰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sex;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="成员变量和类变量的区别"><a href="#成员变量和类变量的区别" class="headerlink" title="成员变量和类变量的区别"></a>成员变量和类变量的区别</h4><p>类变量的实质是全局变量，如果某个变量是被所有对象共享，那么这个变量可以被设置成类变量，用<code>static</code>修饰；没有被 <code>static</code> 修饰的变量属于对象的特殊描述。</p>
<p>不同的对象的成员变量会被分配不同的内存空间，如果是类变量，那么所有对象的这个类变量会被分配到同一个内存，改变其中一个对象的类变量就会改变所有对象的这个类变量，即所有对象共享该变量。</p>
<p><strong>对象是类的实例。</strong></p>
<h3 id="摘自"><a href="#摘自" class="headerlink" title="摘自"></a>摘自</h3><p><a href="https://blog.csdn.net/smile_from_2015/article/details/50189797">Java中的变量</a></p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql - 日志分析项目小记</title>
    <url>/2021/05/31/mysql-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="mysql执行本地sql文件"><a href="#mysql执行本地sql文件" class="headerlink" title="mysql执行本地sql文件"></a>mysql执行本地sql文件</h2><p>现在有一个<code>test.sql</code>文件，该文件需要导入到<code>mysql</code>的<code>test</code>数据库中：</p>
<ol>
<li><p>登录<code>mysql</code>，创建数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -ppasswd</span><br><span class="line">create database test;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<span id="more"></span>
<ol>
<li><p>退出登录，执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">quit;</span><br><span class="line">mysql -uroot -ppasswd -Dtest &lt; test.sql</span><br></pre></td></tr></table></figure>
<p>此时可能报如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">ERROR 1273 (HY000) at line 24: Unknown collation: &#x27;utf8mb4_0900_ai_ci&#x27;</span><br></pre></td></tr></table></figure>
<p>那是因为我的<code>mysql</code>的版本为5.7，<code>sql</code>文件的版本是8.x，高版本不能向下兼容。解决：</p>
<p>（1）将<code>utf8mb4_0900_ai_ci</code>全部替换为<code>utf8_general_ci</code>；</p>
<p>（2）将<code>utf8mb4</code>替换为<code>utf8</code>。</p>
<p>我使用<code>vim</code>工具，执行如下命令一次性将内容全部替换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:%s/utf8mb4_0900_ai_ci/utf8_general_ci/g</span><br><span class="line">:%s/utf8mb4/utf8/g</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>%s/a/b/g</code>的解释：即将文档中所有a内容替换为b内容</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>项目小记</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql - 面试题</title>
    <url>/2021/07/13/mysql-%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1-on和where的区别"><a href="#1-on和where的区别" class="headerlink" title="1. on和where的区别"></a>1. on和where的区别</h2><span id="more"></span>
<p>二者都是对临时表进行筛选，不同的是，on是在临时表创建的时候进行筛选，where是在临时表创建完以后进行的筛选。</p>
<p>比如在一个 <code>on a.id=b.id</code> 的连接后面添加条件 <code>b.id = 20</code> ，添加后面的条件之前，可以知道a表的连接条件是<code>= b.id</code> ，b表的连接条件是 <code>= a.id</code>，如果 <code>b.id = 20</code> 的操作是在 <code>on</code> 中，那么a表的筛选是<code>= b.id</code> ，b表的筛选条件是<code>= a.id</code> 和<code>id = 20</code>；</p>
<p>如果该条件在 <code>where</code> 中，操作就变成了首先将ab表通过前面的连接条件连接起来之后，对此临时表进行 <code>b.id = 20</code> 的筛选。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>spark - 报错</title>
    <url>/2021/08/13/spark-%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h3 id="Error-in-query-Detected-cartesian-product-for-INNER-join-between-logical-plans"><a href="#Error-in-query-Detected-cartesian-product-for-INNER-join-between-logical-plans" class="headerlink" title="Error in query: Detected cartesian product for INNER join between logical plans"></a>Error in query: Detected cartesian product for INNER join between logical plans</h3><p>默认sparksql版本2.x不支持笛卡尔积操作，需要手动开启支持权限：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> spark.sql.crossJoin.enabled<span class="operator">=</span><span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="Caused-by-org-apache-spark-SparkException-Job-aborted-due-to-stage-failure-ResultStage-98-sql-at-0-M-has-failed-the-maximum-allowable-number-of-M-times-4-M-Most-recent-failure-reason-org-apache-spark-shuffle-MetadataFetchFailedException-Missing-an-output-location-for-shuffle-33"><a href="#Caused-by-org-apache-spark-SparkException-Job-aborted-due-to-stage-failure-ResultStage-98-sql-at-0-M-has-failed-the-maximum-allowable-number-of-M-times-4-M-Most-recent-failure-reason-org-apache-spark-shuffle-MetadataFetchFailedException-Missing-an-output-location-for-shuffle-33" class="headerlink" title="Caused by: org.apache.spark.SparkException: Job aborted due to stage failure: ResultStage 98 (sql at :0)^M has failed the maximum allowable number of^M times: 4.^M Most recent failure reason: org.apache.spark.shuffle.MetadataFetchFailedException: Missing an output location for shuffle 33"></a>Caused by: org.apache.spark.SparkException: Job aborted due to stage failure: ResultStage 98 (sql at <unknown>:0)^M has failed the maximum allowable number of^M times: 4.^M Most recent failure reason: org.apache.spark.shuffle.MetadataFetchFailedException: Missing an output location for shuffle 33</h3><p>不知道具体什么原因（热烈欢迎大佬教我如何深入查找具体原因），只能通过代码大致判断可能数据量太大造成内存溢出。</p>
<p>解决方法：</p>
<p>使用 <code>mapjoin</code> 将小表放到内存，减少reduce端的压力。</p>
<ol>
<li><p>设置参数：<code>set hive.ignore.mapjoin.hint=true;</code></p>
<p>true 注释方式不生效，false 注释方式生效 - 用于强行指定需要加入内存走mapjoin的表。</p>
</li>
<li><p>将小表进行 <code>mapjoin</code> 操作。</p>
<p>具体代码为 <code>/*+ mapjoin(table_name)*/</code></p>
</li>
</ol>
<p>具体代码：</p>
<p>前：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_a <span class="keyword">join</span> table_b;</span><br></pre></td></tr></table></figure>
<p>其中 <code>table_b</code> 为小表。</p>
<p>后：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="comment">/*+ mapjoin(table_b)*/</span> <span class="operator">*</span> <span class="keyword">from</span> table_a <span class="keyword">join</span> table_b;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>报错</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>spark - 安装 &amp; 简单使用wordcount</title>
    <url>/2021/06/06/spark-%E5%AE%89%E8%A3%85%20&amp;%20%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8wordcount/</url>
    <content><![CDATA[<h3 id="IDEA创建spark项目"><a href="#IDEA创建spark项目" class="headerlink" title="IDEA创建spark项目"></a>IDEA创建spark项目</h3><span id="more"></span>
<ol>
<li><p>创建java环境为JDK1.8的maven项目，项目名为atguigu-classes；</p>
<p>此步骤省略。</p>
</li>
<li><p>添加scala插件</p>
<p>scala插件是使用spark操作必不可少的工具，默认采用的版本是2.12，而不是最新版本。</p>
<p>File -&gt; Project Structure -&gt; Global Libraries</p>
<p>然后点击<code>+</code>号，选择<code>download</code>，找到合适的版本：<code>2.12.11</code>，下载。此过程可能会有点久。</p>
</li>
<li><p>检查是否成功添加</p>
<p>右键项目 -&gt; add frameworks support</p>
<p>然后寻找是否有scala选项，如果有，则成功添加，此时需要点击打勾，以添加该选项。</p>
</li>
<li><p>新建第一个简单的项目，来测试是否成功配置spark环境</p>
<p>右键<code>new</code>选择<code>Scala Class</code>，然后选择<code>Object</code>，输入名称为<code>test</code>，其中，具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object test &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    println(&quot;Hello Spark&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="WordCount案例"><a href="#WordCount案例" class="headerlink" title="WordCount案例"></a>WordCount案例</h3><ol>
<li><p>任务需求 - 将下述文件进行<code>wordcount</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello scala</span><br><span class="line">hello spark</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始代码如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.core.wc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2021/6/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> 读取数据后，将数据切分并按照相同的单词为一组的思想对数据进行分组，groupBy以后就会得到[word, list[word, word, ...]]，最后输出的是[word, list.size]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark01_WordCount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//Application</span></span><br><span class="line">    <span class="comment">//Spark框架</span></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 建立和spark框架的连接</span></span><br><span class="line">      <span class="comment">//基本配置</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line">    <span class="comment">//创建连接</span></span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 执行业务逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 以行为单位，读取数据</span></span><br><span class="line">    <span class="keyword">val</span> line = sc.textFile(path = <span class="string">&quot;datas&quot;</span>)</span><br><span class="line">    <span class="comment">//2. 将一行数据拆分为一个个单词，即扁平化，flatMap就是扁平映射</span></span><br><span class="line">    <span class="keyword">val</span> words = line.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 以分割后的数据为准，分组累加计算</span></span><br><span class="line">    <span class="comment">//相同的单词进行分组，给我的每个元素是单词，而我按照单词分组</span></span><br><span class="line">    <span class="comment">//此时需要知道，wordGroup的类型是RDD[(String, Iterable[String])]，String是分组的条件，即word，Iterable[String]是结果，即word相同元素的集合</span></span><br><span class="line">    <span class="keyword">val</span> wordGroup = words.groupBy(word =&gt; word)</span><br><span class="line">    <span class="comment">//4. 将分组后的数据进行转换，即多个值 -&gt; 一个值和一个数字（值的数量）</span></span><br><span class="line">    <span class="keyword">val</span> word_count = wordGroup.map&#123;</span><br><span class="line">      <span class="keyword">case</span> (word, list) =&gt;</span><br><span class="line">        (word, list.size)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5. 将结果采集到控制台输出</span></span><br><span class="line">    <span class="keyword">val</span> res = word_count.collect()</span><br><span class="line">    res.foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 关闭连接</span></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用到的部分函数记录</p>
<blockquote>
<p>textFile：读取文件，其中, <code>path</code> 可以是一个文件的路径，也可以是多个文件的目录，即可以同时读取多个文件。</p>
<p>flatMap：对集合中的每个元素进行操作后再扁平化处理；</p>
<p>​        通常会将map和flatMap进行比较：</p>
<p>​        二者均会对集合中的每个元素进行操作，不同的是flatMap会将操作后的结果进行扁平化，即合并为一个一维的集合，而map不会；</p>
<p>groupBy：通过什么规则进行分组；</p>
<p>​        通常将groupBy和groupByKey进行比较</p>
<p>【此处我简单搬了该文章：<a href="https://blog.csdn.net/jiangzhali1623/article/details/83717088">文章链接</a>】：</p>
<p>​        groupByKey希望用户自己实现groupBy的规则，而groupBy被列属性束缚，相较而言，前者更灵活；但groupByKey返回的KeyValueGroupedDataset类提供的操作接口不如groupBy返回的RelationalGroupedDataset类所提供的接口丰富，所以在大多数情况下，更推荐使用groupBy。</p>
</blockquote>
</li>
<li><p>初始代码中进行的所谓聚合，实际上是对函数方法的调用，并不是真正的聚合，以下是对调用部分的更改：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.core.wc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2021/6/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> 核心代码中，将单词划分开后首先均赋1，然后再进行分组，最后累加1值来聚合最终结果。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark02_WordCount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//Application</span></span><br><span class="line">    <span class="comment">//Spark框架</span></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 建立和spark框架的连接</span></span><br><span class="line">      <span class="comment">//基本配置</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line">    <span class="comment">//创建连接</span></span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 执行业务逻辑</span></span><br><span class="line">    <span class="keyword">val</span> line = sc.textFile(path = <span class="string">&quot;datas&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> words = line.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> word2One = words.map(</span><br><span class="line">      word =&gt; (word, <span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里对word2One的(word,1)，以word，即t._1为条件进行分组</span></span><br><span class="line">    <span class="keyword">val</span> wordGroup = word2One.groupBy(</span><br><span class="line">      t =&gt; t._1</span><br><span class="line">    )</span><br><span class="line"><span class="comment">//    wordGroup.foreach(println)</span></span><br><span class="line">    <span class="keyword">val</span> word_count = wordGroup.map&#123;</span><br><span class="line">      <span class="keyword">case</span> (word, list) =&gt; &#123;	<span class="comment">// 因为不使用word遍历，所以也可以写为 case (_, list)</span></span><br><span class="line">        list.reduce(</span><br><span class="line">          (t1, t2) =&gt; &#123;</span><br><span class="line">            (t1._1, t1._2+t2._2)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5. 将结果采集到控制台输出</span></span><br><span class="line">    <span class="keyword">val</span> res = word_count.collect()</span><br><span class="line">    res.foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 关闭连接</span></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改后的代码的部分函数使用</p>
<blockquote>
<ol>
<li><p>map函数</p>
<p>​        map，即映射，可以在 <code>()</code> 或 <code>&#123;&#125;</code> 内遍历数据进行操作，<code>()</code> 和 <code>&#123;&#125;</code> 的区别在于，如果遍历的数据只有一列，用前者，此时定义的临时变量不需要 <code>case</code> 关键字；如果是多列，需要使用 <code>case (...)</code>，其中，<code>case</code> 后的括号内必须包含与列数相等的变量，如果不会使用，可以使用 <code>_</code> 占位符省略名称。</p>
</li>
<li><p>reduce函数</p>
<p>​        reduce可以对集合中的元素进行归约操作。</p>
<p>​        如上述代码，reduce会将每一个分组的元素以某种方式进行合并，即上述的累加1值。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>单看前两版的代码，flatMap、reduce、map等函数，Java中也有，Spark好像并没有什么优势。但实际上，<strong>spark框架提供了更多的功能，其中主要代码的分组和聚合，可以用一个方法实现 - reduceByKey - 相同key的数据，可以对value进行reduce聚合</strong>：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.core.wc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2021/6/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> 核心代码中，将单词划分开后首先均赋1，然后再进行分组，最后累加1值来聚合最终结果。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark03_WordCount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 建立和spark框架的连接</span></span><br><span class="line">      <span class="comment">//基本配置</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line">    <span class="comment">//创建连接</span></span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 执行业务逻辑</span></span><br><span class="line">    <span class="keyword">val</span> line = sc.textFile(path = <span class="string">&quot;datas&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> words = line.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> word2One = words.map(</span><br><span class="line">      word =&gt; (word, <span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Spark框架提供更多的功能，可以将分组和聚合使用一个方法实现</span></span><br><span class="line">    <span class="comment">//reduceByKey：相同key的数据，可以对value进行reduce聚合</span></span><br><span class="line">    <span class="keyword">val</span> word_count = word2One.reduceByKey(_+_)</span><br><span class="line">    <span class="comment">//5. 将结果采集到控制台输出</span></span><br><span class="line">    <span class="keyword">val</span> res = word_count.collect()</span><br><span class="line">    res.foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 关闭连接</span></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="log4j编写"><a href="#log4j编写" class="headerlink" title="log4j编写"></a>log4j编写</h3><p>为了省略执行时显示在控制台的执行日志，可以配置 <code>log4j.properties</code> 文件来提高日志输出的权限等。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">log4j.rootCategory</span>=<span class="string">ERROR, console</span></span><br><span class="line"><span class="meta">log4j.appender.console</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.console.target</span>=<span class="string">System.err</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="string">%d&#123;yy/MM/dd HH:mm:ss&#125; %p %c&#123;1&#125;: %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.logger.org.apache.spark.repl.Main</span>=<span class="string">ERROR</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.logger.org.spark_project.jetty</span>=<span class="string">ERROR</span></span><br><span class="line"><span class="meta">log4j.logger.org.spark_project.jetty.util.component.AbstractLifeCycle</span>=<span class="string">ERROR</span></span><br><span class="line"><span class="meta">log4j.logger.org.apache.spark.repl.SparkIMain$exprTyper</span>=<span class="string">ERROR</span></span><br><span class="line"><span class="meta">log4j.logger.org.apache.spark.repl.SparkILoop$SparkILoopInterpreter</span>=<span class="string">ERROR</span></span><br><span class="line"><span class="meta">log4j.logger.org.apache.parquet</span>=<span class="string">ERROR</span></span><br><span class="line"><span class="meta">log4j.logger.parquet</span>=<span class="string">ERROR</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.logger.org.apache.hadoop.hive.metastore.RetryingHMSHandler</span>=<span class="string">FATAL</span></span><br><span class="line"><span class="meta">log4j.logger.org.apache.hadoop.hive.ql.exec.FunctionRegistry</span>=<span class="string">ERROR</span></span><br></pre></td></tr></table></figure>
<p>日志的级别从高到低为如下：</p>
<blockquote>
<p>OFF、FATAL、ERROR、WARN、INFO、DEBUG、TRACE、ALL</p>
</blockquote>
<p>log4j建议只使用四个级别：<code>ERROR、WARN、INFO、DEBUG</code>，程序会打印高于或等于所设置级别的日志，设置的日志等级越高，打印出来的日志就越少。如果设置级别为INFO，则优先级高于等于INFO级别（如：INFO、WARN、ERROR）的日志信息将可以被输出,小于该级别的如DEBUG将不会被输出。</p>
]]></content>
      <categories>
        <category>大数据组件的应用</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>sparksql脚本的编写</title>
    <url>/2021/07/05/sparksql%E8%84%9A%E6%9C%AC%E7%9A%84%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<h3 id="1-写含有sparksql语句的、带参的shell脚本"><a href="#1-写含有sparksql语句的、带参的shell脚本" class="headerlink" title="1. 写含有sparksql语句的、带参的shell脚本"></a>1. 写含有sparksql语句的、带参的shell脚本</h3><span id="more"></span>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># 此文件命名为show.sh</span></span><br><span class="line">SQL=<span class="string">&quot;</span></span><br><span class="line"><span class="string">show create table <span class="variable">$0</span>;</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line">spark-sql --num-executors 100 -e <span class="variable">$SQL</span></span><br></pre></td></tr></table></figure>
<h3 id="2-写循环数组、可以传参的shell脚本来运行上述脚本"><a href="#2-写循环数组、可以传参的shell脚本来运行上述脚本" class="headerlink" title="2. 写循环数组、可以传参的shell脚本来运行上述脚本"></a>2. 写循环数组、可以传参的shell脚本来运行上述脚本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> !/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此文件命名为run.sh</span></span><br><span class="line">tables=(&quot;a&quot; &quot;b&quot; &quot;c&quot;)</span><br><span class="line">for t in $&#123;tables[@]&#125;    # 循环</span><br><span class="line">do</span><br><span class="line">    sh show.sh $t    # 传参</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上述循环还有一种写法</span></span><br><span class="line">for((i=1;i&lt;=$&#123;#tables&#125;;i++));</span><br><span class="line">do</span><br><span class="line">    sh show.sh $&#123;tables[$i]&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="3-控制并任务的数量"><a href="#3-控制并任务的数量" class="headerlink" title="3. 控制并任务的数量"></a>3. 控制并任务的数量</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while [ `ps -ef |grep show.sh |grep -v grep|wc -l` -gt 2 ]</span><br><span class="line">do...done</span><br></pre></td></tr></table></figure>
<p>其中，<code>ps -ef</code>查询进程的任务数；</p>
<p>​           <code>|</code>管道，前面命令的输出是后面命令的输入；</p>
<p>​           <code>grep bash_file_name</code> 指定进程；</p>
<p>​           <code>grep -v grep</code>去除grep本身；</p>
<p>​           <code>wc -l</code>计算数量。</p>
<p><strong>这个控制并行，当并行任务数大于等于2的时候，执行某一个操作以暂停其他线程的运行。如果让脚本的线程一个一个运行，即不使用&amp;操作，就可以不用（最好别用，容易崩）</strong></p>
<h3 id="4-如果报错，怎么查"><a href="#4-如果报错，怎么查" class="headerlink" title="4. 如果报错，怎么查"></a>4. 如果报错，怎么查</h3><ol>
<li>首先查看进程的ID：<code>ps -ef | grep show.sh</code>；</li>
<li>杀死该进程：将上述得到的<code>sh...</code>的进程ID，即</li>
</ol>
<p><strong>上述需要注意的点：</strong></p>
<ol>
<li>变量的使用需要<code>$</code>；</li>
<li>数组的每个元素之间没有逗号；</li>
<li><code>=</code>两边不能有空格；</li>
<li>最重要的点：一定要仔细检查循环，查看循环本身是不是死循环，还有循环体中调用的脚本要确定是否正确，如果误写了自己，也会导致死循环！！！死循环很可能会导致系统崩盘！！！&lt; 血的教训！！！ &gt;</li>
</ol>
]]></content>
      <categories>
        <category>项目小记</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>sqoop - 使用基础</title>
    <url>/2021/05/31/sqoop-%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="使用sqoop将mysql数据导入hive"><a href="#使用sqoop将mysql数据导入hive" class="headerlink" title="使用sqoop将mysql数据导入hive"></a>使用sqoop将mysql数据导入hive</h2><p>执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqoop import -m 1 \</span><br><span class="line">--connect jdbc:mysql://192.168.186.100:3306/forum \</span><br><span class="line">--username root \</span><br><span class="line">--password niit1234 \</span><br><span class="line">--hive-import \</span><br><span class="line">--create-hive-table \</span><br><span class="line">--hive-database forum \</span><br><span class="line">--delete-target-dir;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>其中：</p>
<blockquote>
<p>—hive-import ：将表导入到hive中，如果不设置，使用hive的默认界定符，即^A or \001；</p>
<p>—create-hive-table ：使用mysql的表名和字段类型直接创建；</p>
<p>—hive-database ：指定将表放到某个数据库；</p>
<p>—connect、—username、—password ：这些不需要说，肯定知道；</p>
<p>—delete-target-dir ：删除指定目录；</p>
</blockquote>
<p>还有一些其他常用的命令：</p>
<blockquote>
<p>—target-dir ：将数据导入指定目录；</p>
<p>—where ：指定条件导入；</p>
<p>—fields-terminated-by ：指定分隔符；</p>
<p>-m ：即—num-mappers，指定map的个数，默认是4个。</p>
</blockquote>
<h4 id="split-by和-m的联系"><a href="#split-by和-m的联系" class="headerlink" title="split-by和-m的联系"></a>split-by和-m的联系</h4><p>sqoop从大多数数据库中并行导入数据。</p>
<p>在执行并行导入的时候，需要一个可用来划分工作负载的标准。</p>
]]></content>
      <categories>
        <category>大数据组件的应用</category>
      </categories>
      <tags>
        <tag>sqoop</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针</title>
    <url>/2021/10/20/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="双指针介绍"><a href="#双指针介绍" class="headerlink" title="双指针介绍"></a>双指针介绍</h2><p><strong>双指针</strong>，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（<em>快慢指针</em>）或者相反方向（<em>对撞指针</em>）的指针进行扫描，从而达到相应的目的。</p>
<span id="more"></span>
<h3 id="对撞指针"><a href="#对撞指针" class="headerlink" title="对撞指针"></a>对撞指针</h3><p>设计 <code>left</code> 和 <code>right</code> 两个指针，从两头开始向中间开始遍历，比如 <strong>快速排序</strong> ，使用到了对撞指针。</p>
<p>简易代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>( left &lt; right )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( nums[left] &lt;= nums[right] )</span><br><span class="line">    &#123;</span><br><span class="line">        left ++;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        right --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>设计 <code>fast</code> 和 <code>slow</code> 两个指针，从同一侧开始遍历，二者以不同策略移动，通常来说，慢指针一次走一步，快指针一次走多步。</p>
<p>经典问题为：是否存在环问题。</p>
<p>思路为：在慢指针遍历完之前，如果与快指针相遇，存在环，否则不存在。</p>
<p>具体代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">if</span>( fast.next != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( slow != <span class="keyword">null</span> &amp;&amp; fast != slow )</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>( fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( slow == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://zhuanlan.zhihu.com/p/71643340">算法一招鲜——双指针问题</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划算法</title>
    <url>/2021/06/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义：是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。</p>
<p>​        按照定义，动态规划是将一个大问题拆分为多个小问题来解决。但是最终决定这个问题是否能用动态规划解决的因素是这些小问题是否能被重复调用。</p>
<p>​        如果能被重复利用，我们需要找出其中的状态转移方程，也就是找到相邻的两个结果之间的转换方程。</p>
<span id="more"></span>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="题目见下链接"><a href="#题目见下链接" class="headerlink" title="题目见下链接"></a>题目见下链接</h3><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a></p>
<h3 id="动态规划思想"><a href="#动态规划思想" class="headerlink" title="动态规划思想"></a>动态规划思想</h3><p>因为要求是连续数组的最大值，所以每一次计算的中间结果，也必须是以当前最后一个元素为当亲计算的结尾。</p>
<p>上述，可以得到状态转移方程：</p>
<p><code>maxn = max(maxn+num[i], num[i])</code></p>
<p>但是由于以当前最后一个元素结尾的最大值不一定是整体数组中的最大值，所以需要再使用一个变量来存储整体数组的最大值：</p>
<p><code>res = max(maxn, res)</code></p>
<p>经过分析，可以得到具体代码如下：</p>
<h4 id="java"><a href="#java" class="headerlink" title="java:"></a>java:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int pre = 0, res = nums[0];</span><br><span class="line">        for ( int n : nums )</span><br><span class="line">        &#123;</span><br><span class="line">            pre = Math.max(pre + n, n);</span><br><span class="line">            res = Math.max(pre, res);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="python"><a href="#python" class="headerlink" title="python:"></a>python:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxSubArray(self, nums: List[int]) -&gt; int:</span><br><span class="line">        pre, res = 0, nums[0]</span><br><span class="line">        for n in nums:</span><br><span class="line">            pre = max( pre + n, n )</span><br><span class="line">            res = max( pre, res )</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2021/10/14/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/contains-duplicate/">https://leetcode-cn.com/problems/contains-duplicate/</a></p>
<span id="more"></span>
<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><h3 id="第一思路"><a href="#第一思路" class="headerlink" title="第一思路"></a>第一思路</h3><p>​        本人的第一思路是使用 <code>arraylist</code> 存放遍历过的元素，如果当前元素在 <code>arraylist</code> 已经存在，返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p><strong>问题：</strong>当数组元素的个数大到一定程度，会超出时间限制。</p>
<p><strong>解决：</strong>使用 <code>hashset</code> 存储。</p>
<h4 id="ArrayList-和-HashSet-的区别"><a href="#ArrayList-和-HashSet-的区别" class="headerlink" title="ArrayList 和 HashSet 的区别"></a>ArrayList 和 HashSet 的区别</h4><p>实际上就是 <code>List</code> 和 <code>Set</code> 两种接口的区别，二者都继承 <code>Collection</code> 接口。</p>
<p>区别在于：</p>
<ol>
<li>ArrayList用于定义一个有序的可重复集合，HashSet用于定义一个无序的不可重复集合；</li>
<li>ArrayList底层用数组存储，所以如果查找某个元素，会从第一个元素开始顺序查找；HashSet底层由数组+链表的形式存储，先根据元素的 <code>hashcode</code> 值确定数组中的位置，再从该位置的链表从头开始遍历查找元素；所以，HashSet 的查询效率比 ArrayList 高。</li>
</ol>
<p><strong>HashSet存储数据的具体流程如下：</strong></p>
<p> 1.获取关键数据—-通过元素的hashCode方法的返回值来获取；<br> 2.通过hash函数计算该数据需要存放在hash表哪个位置；<br> 3.如果没有发生hash碰撞   则放在该位置；<br> 4.如果发生了hash碰撞   形成hash桶（链表）；<br>         形成链表时会触发去重的机制  新来的元素要和链表中的每一个元素进行equals  如果不重复则插在链表末尾（JDK1.8）， 而JDK1.7则会插入在链表的最前面。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> n : nums )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( !set.add(n) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二思路"><a href="#第二思路" class="headerlink" title="第二思路"></a>第二思路</h3><p>先对数组中的元素进行排序，再遍历数组，如果 <code>nums[i] == nums[i+1]</code>，则存在重复元素。</p>
<p>此处的排序很有讲究，得使用语言自带的排序函数才能通过。</p>
<p><strong>原因：</strong> 例如Java中自带的排序函数 <code>Arrays.sort()</code> 用到了三个排序算法：插入排序、快速排序、归并排序。</p>
<p>以数组元素的个数为划分的依据，小于 47 插入，大于等于 47 小于 286 快排，大于等于286 - 高度结构化用归并、非高度结构化用快排。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        devide(nums, <span class="number">0</span>, len - <span class="number">1</span>, tmp);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i] == nums[i+<span class="number">1</span>] )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">devide</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span>[] tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>( l &gt;= r )</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">          devide(nums, l, mid, tmp);</span><br><span class="line">          devide(nums, mid+<span class="number">1</span>, r, tmp);</span><br><span class="line">          merge(nums, l, r, mid, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> mid, <span class="keyword">int</span>[] tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( mid &gt;= r + <span class="number">1</span> || mid &lt; <span class="number">0</span> || l &gt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( i &lt;= mid &amp;&amp; j &lt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i] &lt;= nums[j] )</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[t++] = nums[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmp[t++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( i &lt;= mid )</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[t++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( j &lt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[t++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        i = l;</span><br><span class="line">        <span class="keyword">while</span>( l &lt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            nums[l++] = tmp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表是根据关键键值进行直接访问的数据结构，查询速度非常快，时间复杂度几乎是 O(1) 。如果需要在一秒钟内查找上千条数据，通常就会使用哈希表。</p>
<p>获取键的哈希值：<code>hash(键)%k</code> 。但是这种方法可能会产生 <strong>哈希冲突</strong> 。实际中这种冲突不可避免，只能设法减少。</p>
<h4 id="生成哈希函数的方法"><a href="#生成哈希函数的方法" class="headerlink" title="生成哈希函数的方法"></a>生成哈希函数的方法</h4><ol>
<li><p>直接定址法</p>
<p>以键的线性函数作为哈希地址：hash(k) = a * k + b(其中a,b为常数)` 。</p>
<p>这种方法不会产生哈希冲突，但是要求键是连续的，否则产生的哈希表会造成较大的空间浪费，因此，该方法适应性不强。</p>
</li>
<li><p>数字分析法</p>
<p>如果键是位数比较多的数字，比如手机号有11位，且这些数字存在相同的规律，则可以抽取剩余规律不同的部分作为散列地址。</p>
<p>比如手机号的后四位是用户号，前7位很有可能是相同的，那么可以使用后四位作为散列地址。</p>
<p>如果事先知道关键字的<strong>分布</strong>且关键字的<strong>若干位分布较均匀</strong>，就可以考虑用这个方法。</p>
</li>
<li><p>折叠法</p>
<p>将键值从左到右分成几个部分，然后将几个部分叠加求和，并按散列表表长，取后几位作为散列地址。</p>
<p>比如 key = 9876543210，散列表表长 = 3，那么可以分为 987|654|321|0 ，叠加求和：987+654+321+0=1962，再取后 3 位得到散列地址即为 962。</p>
<p>上述方式还不够分布均匀，可以尝试从一端到另一端折叠对齐相加。</p>
<p>还是上述例子，将 987 和 321 反转，叠加求和为：789+654+123+0=1566，得到散列地址为 566。</p>
<p>折叠法事<strong>先不需要知道关键字的分布</strong>，<strong>适合</strong>关键字位数较多的情况。</p>
</li>
<li><p>平方取中法</p>
<p>取 键 的平方的中位数作为散列地址。</p>
<p>比如 key = 4321，那么平方 = 18671041，抽取中间的 3 位就可以是 671，也可以是 710，用做散列地址。</p>
<p>此方法适合不知道键值分布，而位数又不是很大的情况。</p>
</li>
<li><p>除留余数法</p>
<p>是最常用的构造散列函数的方法。</p>
<p>公式为：<code>hash(key) = key % k</code></p>
<p>该方法的关键在于合适的 <code>k</code> 值。根据前人的经验，若表长为 <code>m</code> ，通常 <code>k</code> 为小于等于表长（最好接近 <code>m</code>）的最小质数或不包含小于20的质因子的合数。</p>
</li>
<li><p>随机数法</p>
<p>取 键值 的随机函数值为它的散列地址：<code>hash(key) = random(key)</code></p>
<p>当键值的长度不等时，采用该方法是最合适的。</p>
</li>
</ol>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://blog.csdn.net/liu17234050/article/details/104270709/">数据结构—— 构造散列函数的六种方法</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序算法</title>
    <url>/2021/07/13/%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>简单来说就是完全二叉树，大顶堆的每个父节点会大于等于它的子节点；小顶堆的每个父节点会小于等于它的子节点。</p>
<span id="more"></span>
<h2 id="思路拆解"><a href="#思路拆解" class="headerlink" title="思路拆解"></a>思路拆解</h2><p>一般情况下，堆排序是针对数组的排序（应该吧。。。）：</p>
<ol>
<li><p>首先会将可能无序的数组初始化为一个堆，即构建堆；</p>
</li>
<li><p>对于堆的构建，是从数组的末尾、即最后一个父节点开始循环进行构建 - 也就是把三个节点中值最小的换到父节点；</p>
</li>
<li>但是这里有一个小问题 - 这样的构建方式相当于是在上一次构建完成的基础上进行构建，那么很有可能会破坏之前构建的结果；</li>
<li>针对这个问题，需要写一个函数对这样的部分堆进行从上往下的调整；</li>
<li>之后，初步构造的堆就完成了；</li>
<li>之后的升序或降序排序，只要将头尾的元素互换，数组的最后一个元素就是当前数组中最小的元素，然后将该元素去除（简单一点就是len-1），对剩余的前<code>n-1</code>个元素从头进行由上往下的调整，再将第一个元素和当前数组的最后一个元素交换，就可以得到第二小的元素，以此类推。</li>
</ol>
<p>下面以小顶堆为例说明上述思路。</p>
<h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><ol>
<li><p>先写一个会经常使用的元素交换函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = input[a];</span><br><span class="line">    input[a] = input[b];</span><br><span class="line">    input[b] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建小顶堆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initHeap</span><span class="params">(<span class="keyword">int</span>[] input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( input.length &lt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = input.length;</span><br><span class="line">    <span class="keyword">int</span> f = len / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(f &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = f * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>( i + <span class="number">1</span> &lt; len &amp;&amp; input[i] &gt; input[i + <span class="number">1</span>] )</span><br><span class="line">        &#123;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( i &lt; len &amp;&amp; input[f] &gt; input[i] )</span><br><span class="line">        &#123;</span><br><span class="line">            swap(input, f, i);</span><br><span class="line">        &#125;</span><br><span class="line">        heapSort(input, i, len);</span><br><span class="line">        -- f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（1）<code>f = len / 2 - 1</code>：</p>
<p>默认元素从0开始取最后一个元素的父节点，如果从1开始就是<code>f = len / 2</code>；</p>
<p>（2）<code>i = f * 2 + 1</code>：</p>
<p>从0开始的父节点，子节点为<code>left = f * 2 + 1; right = f * 2 + 2</code>，从1开始的父节点，子节点为<code>left = f * 2; right = f * 2+ 1;</code> ；</p>
<p>（3）两个 <code>if</code> 语句：</p>
<p>先获取两个子节点中值最小的节点；然后判断父节点与最小子节点的大小，如果父节点比最小子节点大，则交换元素；</p>
<p>（4）<code>heapSort(input, i, len);</code></p>
<p>进行部分堆的调整。</p>
</li>
<li><p>排序（小顶堆就是逆序了）</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> f, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 重新调整为小顶堆</span></span><br><span class="line">    <span class="keyword">while</span>( f &lt; len )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = f * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>( i + <span class="number">1</span> &lt; len &amp;&amp; input[i] &gt; input[i + <span class="number">1</span>] )</span><br><span class="line">        &#123;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( i &lt; len &amp;&amp; input[f] &gt; input[i] )</span><br><span class="line">        &#123;</span><br><span class="line">            swap(input, i, f);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title>建立第一个独立博客</title>
    <url>/2021/05/30/%E5%BB%BA%E7%AB%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>前人栽树，后人乘凉~</p>
<p>具体见<a href="https://zhuanlan.zhihu.com/p/102592286?tdsourcetag=s_pctim_aiomsg">https://zhuanlan.zhihu.com/p/102592286?tdsourcetag=s_pctim_aiomsg</a></p>
<span id="more"></span>
<p>此处记录日常生成并上传文件的方式。</p>
<h3 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new &quot;文章标题&quot;</span><br></pre></td></tr></table></figure>
<p>文章标题可以不用双引号括住。</p>
<h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序算法</title>
    <url>/2021/07/15/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="1-知识点"><a href="#1-知识点" class="headerlink" title="1. 知识点"></a>1. 知识点</h2><p>一般情况下，将第一个元素作为基准，设置两个指针 <code>i = 0, j = n - 1</code> ，先用 <code>j</code> 从后往前找第一个小于基准的值，赋给 <code>i</code> 所在位置；然后再用 <code>i</code> 从前往后找第一个大于基准的值，赋给 <code>j</code> 所在位置。最终 <code>i &gt;= j</code> 的时候退出循环，以 <code>i == j</code> 的这个位置为分割线，将数组划分为两个，分别继续进行排序。</p>
<span id="more"></span>
<h2 id="2-具体实例和代码"><a href="#2-具体实例和代码" class="headerlink" title="2. 具体实例和代码"></a>2. 具体实例和代码</h2><h3 id="1-题目链接"><a href="#1-题目链接" class="headerlink" title="1. 题目链接"></a>1. 题目链接</h3><p><a href="https://www.nowcoder.com/practice/e016ad9b7f0b45048c58a9f27ba618bf?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/e016ad9b7f0b45048c58a9f27ba618bf?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<h3 id="2-具体代码"><a href="#2-具体代码" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><p>通用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        quickSort(a, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> a[n-K];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( l &gt;= a.length || r &lt; <span class="number">0</span> || l &gt; r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = l, j = r;</span><br><span class="line">        <span class="keyword">int</span> f = a[l];</span><br><span class="line">        <span class="keyword">while</span>( i &lt; j )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( i &lt; j &amp;&amp; a[j] &gt;= f )</span><br><span class="line">            &#123;</span><br><span class="line">                -- j;</span><br><span class="line">            &#125;</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            <span class="keyword">while</span>( i &lt; j &amp;&amp; a[i] &lt;= f )</span><br><span class="line">            &#123;</span><br><span class="line">                ++ i;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        a[i] = f;</span><br><span class="line">        quickSort(a, l, i-<span class="number">1</span>);</span><br><span class="line">        quickSort(a, j+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对具体问题进行改进：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKth</span>(<span class="params">self, a, n, K</span>):</span></span><br><span class="line">        self.findK(a, <span class="number">0</span>, n-<span class="number">1</span>, K-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> a[K-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findK</span>(<span class="params">self, a, l, r, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> l &gt;= <span class="built_in">len</span>(a) <span class="keyword">or</span> r &lt; <span class="number">0</span> <span class="keyword">or</span> k &lt; <span class="number">0</span> <span class="keyword">or</span> l &gt; r:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        i, j = l, r</span><br><span class="line">        f = a[i]</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> a[j] &lt;= f:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            a[i] = a[j]</span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> a[i] &gt;= f:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            a[j] = a[i]</span><br><span class="line">        a[i] = f</span><br><span class="line">        <span class="keyword">if</span> i &gt; k:</span><br><span class="line">            self.findK(a, l, i-<span class="number">1</span>, k)</span><br><span class="line">        <span class="keyword">elif</span> i &lt; k:</span><br><span class="line">            self.findK(a, j+<span class="number">1</span>, r, k)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>笔试刷题</title>
    <url>/2021/12/24/%E7%AC%94%E8%AF%95%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<h3 id="1-阅读下面的程序："><a href="#1-阅读下面的程序：" class="headerlink" title="1. 阅读下面的程序："></a>1. 阅读下面的程序：</h3><span id="more"></span>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span> ; x &lt;=<span class="number">3</span> ; x++) &#123;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">         System.out.print(x%<span class="number">2</span> + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下列选项，哪个是结果：</p>
<p>A. 0 1 2 3</p>
<p>B. 0 1 2 1</p>
<p>C. 0 1 2</p>
<p>D. 编译失败</p>
<p><strong>结果：D</strong></p>
<blockquote>
<p>会报错：error: unreachable statement。</p>
<p>原因一：</p>
<p>下面的几种情况会出现 unreachable statement：<br>（1）在reutrn语句后写语句。<br>（2）在throw语句后写语句。<br>（3）break、continue语句之后定义语句。<br>（4）“\u10100”//合法，相当于‘\u1010’和字符串“0”。<br>（5）移位运算符可以用于long int char short byte。<br>（6）类的访问控制符可以是public或什么都不加。<br>（7）goto是保留字但不是关键字。then什么都不是。<br>（8）把超类的类型强制转换后赋给子类的对象时，编译无异常，但运行时会出现异常。</p>
<p>原因二：</p>
<p>不可达语句的造成是因为：在此语句前面有一个返回操作，或者其他操作导致不管什么条件都无法执行到这一句。<br>最重要的是：检查前面语句是否有返回，并查看是否因为自己的疏忽，即使没有语法等错误，导致的任何条件都会在此语句前面返回。因为自己的疏忽，好几次在if 或for条件句后面加了; 导致下面的return语句不会执行之后的任何语句，就会返回1；</p>
</blockquote>
<h3 id="2-下列关于冒泡排序的描述中，正确的是（-）-多选"><a href="#2-下列关于冒泡排序的描述中，正确的是（-）-多选" class="headerlink" title="2. 下列关于冒泡排序的描述中，正确的是（ ） - 多选"></a>2. 下列关于冒泡排序的描述中，正确的是（ ） - 多选</h3><p>A. 冒泡排序是不断的比较数组中相邻的两个元素</p>
<p>B. 冒泡排序比较的总轮次是“数组长度-1”轮</p>
<p>C. 冒泡排序中会涉及到元素位置的置换</p>
<p>D. 其他说法均不正确</p>
<p><strong>结果：ABC</strong></p>
<blockquote>
<p>注意B说的是 <code>总轮次</code>。</p>
</blockquote>
<h3 id="3-下列关于二维数组定义的选项中，错误的是（-）"><a href="#3-下列关于二维数组定义的选项中，错误的是（-）" class="headerlink" title="3. 下列关于二维数组定义的选项中，错误的是（ ）"></a>3. 下列关于二维数组定义的选项中，错误的是（ ）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A. int\[][] arr = new int\[3][4];</span><br><span class="line">B. int\[][] arr = new int\[3][];</span><br><span class="line">C. int\[][] arr = new int\[][4];</span><br><span class="line">D. int[][] arr = &#123;&#123;1,2&#125;,&#123;3,4,5&#125;,&#123;6&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>结果：C</strong></p>
<blockquote>
<p>可以省略列，不能省略行。</p>
</blockquote>
<h3 id="4-下列选项中，哪些可以作为方法重载的判断条件（-）-多选"><a href="#4-下列选项中，哪些可以作为方法重载的判断条件（-）-多选" class="headerlink" title="4. 下列选项中，哪些可以作为方法重载的判断条件（ ） - 多选"></a>4. 下列选项中，哪些可以作为方法重载的判断条件（ ） - 多选</h3><p>A. 方法名</p>
<p>B. 方法的参数列表</p>
<p>C. 方法的返回值</p>
<p>D. 方法的修饰符</p>
<p><strong>结果：AB</strong></p>
<blockquote>
<p>方法重载是可以定义多个方法名相同、参数列表不同的方法。</p>
</blockquote>
<h3 id="5-下列关于方法重载的说法中，正确的是（-）-多选"><a href="#5-下列关于方法重载的说法中，正确的是（-）-多选" class="headerlink" title="5. 下列关于方法重载的说法中，正确的是（ ） - 多选"></a>5. 下列关于方法重载的说法中，正确的是（ ） - 多选</h3><p>A. 方法名相同，参数的个数不同可以形成方法重载。</p>
<p>B. 方法名相同，参数的类型不同可以形成方法重载。</p>
<p>C. 方法名相同，参数的类型排列顺序不同可以形成方法重载。</p>
<p>D. 方法名相同，返回值类型不同，可以形成方法重载。</p>
<p><strong>结果：ABC</strong></p>
<blockquote>
<p>注意看C，是 <code>类型</code> 排列顺序不同。</p>
</blockquote>
<h3 id="6-请阅读下面的程序："><a href="#6-请阅读下面的程序：" class="headerlink" title="6. 请阅读下面的程序："></a>6. 请阅读下面的程序：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(“<span class="keyword">int</span>:” + (a+b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">float</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(“<span class="keyword">float</span>:” + (a+b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(“<span class="keyword">double</span>:” + (a+b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">long</span> b = <span class="number">20</span>;</span><br><span class="line">        sum(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下列选项中，哪一个是程序的正确运行结果（ ）</p>
<p>A. int:30<br>B. float:30.0<br>C. double:30.0<br>D. int:30.0</p>
<p><strong>结果：B</strong></p>
<blockquote>
<p>比long范围更大的是float</p>
</blockquote>
<h3 id="7-下面关于构造方法的描述中，正确的是（-）"><a href="#7-下面关于构造方法的描述中，正确的是（-）" class="headerlink" title="7. 下面关于构造方法的描述中，正确的是（ ）"></a>7. 下面关于构造方法的描述中，正确的是（ ）</h3><p>A. 构造方法在类定义的时候被调用<br>B. 构造方法在创建对象的时候被调用<br>C. 构造方法在调用对象的时候被调用<br>D. 构造方法在使用对象的时候被调用</p>
<p><strong>结果：B</strong></p>
<h3 id="8-下列关于this关键字的说法中，错误的是（-）"><a href="#8-下列关于this关键字的说法中，错误的是（-）" class="headerlink" title="8. 下列关于this关键字的说法中，错误的是（  ）"></a>8. 下列关于this关键字的说法中，错误的是（  ）</h3><p>A. this可以解决成员变量与局部变量重名的问题</p>
<p>B. this出现在成员方法中，代表的是调用这个方法的对象</p>
<p>C. this可以出现在任何方法中</p>
<p>D. this相当于一个引用，可以通过它调用成员属性与方法</p>
<p><strong>结果：C</strong></p>
<blockquote>
<p>this只能在类中的非静态方法中使用，静态方法和静态的代码块中绝对不能出现this。</p>
</blockquote>
<h3 id="9-以下代码执行后的结果是（-）"><a href="#9-以下代码执行后的结果是（-）" class="headerlink" title="9. 以下代码执行后的结果是（ ）"></a>9. 以下代码执行后的结果是（ ）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        String name = “小芳”;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            name = “小兰”;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = “小翠”;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Person p = <span class="keyword">new</span> Person(“小凤”);</span><br><span class="line">    System.out.println(p.name);</span><br><span class="line">    p.show();</span><br><span class="line">    System.out.println(p.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A. 小兰小翠</p>
<p>B.小凤小翠</p>
<p>C. 小芳小翠</p>
<p>D. 程序编译失败</p>
<p><strong>结果：C</strong></p>
<blockquote>
<p>小凤用来告诉系统应该调用一个有参的构造方法，而不是起赋值作用，至于小兰的话，name前面没有this，故小兰只是个局部变量，出不去。</p>
</blockquote>
<h3 id="10-以下关于方法重写，说法错误的是（-）-多选"><a href="#10-以下关于方法重写，说法错误的是（-）-多选" class="headerlink" title="10. 以下关于方法重写，说法错误的是（ ） - 多选"></a>10. 以下关于方法重写，说法错误的是（ ） - 多选</h3><p>A. 方法重写时，子类的函数名与参数列表必须与父类的一致</p>
<p>B. 方法重写时，子类的返回类型必须大于或者等于父类的返回类型</p>
<p>C. 方法重写时，子类的访问修饰符必须大于或者等于父类的访问修饰符</p>
<p>D. 方法重写与返回类型无关</p>
<p><strong>结果：BD</strong></p>
<blockquote>
<p>重写的规范</p>
<ol>
<li><p>子类方法的名称、参数列表与父类相同;</p>
</li>
<li><p>子类方法的返回类型与父类相同或更小;</p>
</li>
<li><p>子类方法声明的异常与父类相同或更小;</p>
</li>
<li><p>子类方法的访问权限与父类相同或更大。</p>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础知识 - 面试题</title>
    <url>/2021/12/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1-OSI七层网络模型"><a href="#1-OSI七层网络模型" class="headerlink" title="1. OSI七层网络模型"></a>1. OSI七层网络模型</h2><span id="more"></span>
<p>自下而上包括：</p>
<ol>
<li>物理层：比如将电脑连上网线，这个网线就属于物理层的一个设备；</li>
<li>链路层：比如mac地址就是链路层的一个协议；</li>
<li>网络层：IP协议就是网络层的一个协议；</li>
<li>传输层：TCP协议和UDP协议就是传输层的协议；</li>
<li>会话层、表示层：这两个层级一般就存在概念中，不具有实用性；</li>
<li>应用层：比如HTTP协议、FTP协议就是应用层的协议。</li>
</ol>
<h2 id="2-TCP-IP协议"><a href="#2-TCP-IP协议" class="headerlink" title="2. TCP / IP协议"></a>2. TCP / IP协议</h2><p>包含了物理层、链路层、网络层、传输层以及应用层，其中这里的应用层就涵盖了OSI七层模型里面的会话层、表示层和应用层。TCP/IP协议相较于OSI模型，是实践性更高一种描述。</p>
<h2 id="3-TCP三次握手和四次握手"><a href="#3-TCP三次握手和四次握手" class="headerlink" title="3. TCP三次握手和四次握手"></a>3. TCP三次握手和四次握手</h2><p>建立TCP需要三次握手才能建立，而断开连接则需要四次握手。</p>
<h4 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a>三次握手：</h4><p>第一次握手，主机A通过向主机B发送一个含有同步序列号的标志位的数据段给主机B，向主机B请求建立连接，通过这个数据段，主机A对主机B说：我想与你通信，你可以用哪个序列号作为其实数据段来回应我；<br>第二次握手，主机B收到主机A的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应主机A，也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用这个序列号作为起始数据段来回应我；<br>第三次握手，主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B的数据段：”我已收到回复，我现在要开始传输实际数据了。</p>
<h4 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h4><p>第一次： 当主机A完成数据传输后,将控制位FIN置1，提出停止TCP连接的请求；<br>第二次： 主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将关闭,将ACK置1；<br>第三次： 由B 端再提出反方向的关闭请求,将FIN置1 ；<br>第四次： 主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束。</p>
<h2 id="4-TCP、UDP的区别"><a href="#4-TCP、UDP的区别" class="headerlink" title="4. TCP、UDP的区别"></a>4. TCP、UDP的区别</h2><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>UDP协议的全称是用户数据报协议，它和TCP一样用于处理数据包，它是一种无连接协议，在OSI模型中，二者位于传输层，在IP层的上一层，UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，因此，当数据报文传输后，无法确认是否能够安全完整的到达。<br><strong>UDP有如下几个特点：</strong><br>1）面向无连接：UDP是不需要和TCP一样通过三次握手建立连接的，想发数据的时候就可以发，并且也只是数据报文的搬运工，不会对数据报文进行任何拆分或拼接；<br>2）有单播、多播和广播功能：UDP不仅能够一对一传输，还能多对一、一对多、多对多传输，所以它有单播、多播和广播功能；<br>3）UDP是面向报文的：面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，接收方IP层则需要进行数据报的重组；<br>4）不可靠性：<br>（1）首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠；<br>（2）并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了；<br>（3）再者网络环境时好时坏，但是 UDP因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。 5）头部花销少，传输数据报文是高效的：UDP的头部包含以下几个数据：16位源端口号、16位目的端口号、16位UDP长度和16位UDP校验和；因为UDP的头部花销少，只有8个字节，相比TCP需要至少20个字节，在传输数据的时候是高效的。</p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP是面向连接的、可靠的流协议。流就是指不间断的数据结构。<br><strong>TCP的特点如下：</strong><br>1）面向连接：面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。 2）仅支持单播传输： 每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。<br>3）面向字节流：TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。<br>4）可靠传输：对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。<br>5）提供拥塞控制：当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。<br>6）TCP提供全双工通信：TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于最大报文段长度MSS）</p>
<h4 id="二者的区别大致如下"><a href="#二者的区别大致如下" class="headerlink" title="二者的区别大致如下"></a>二者的区别大致如下</h4><p>1）TCP是面向连接的，而UDP是面向无连接即发送数据钱不需要建立连接；<br>2）TCP提供可靠的服务，而UDP无法保证；<br>3）TCP面向字节流，UDP面向报文；<br>4）TCP数据传输慢，UDP的数据传输快。</p>
<h2 id="5-TCP如何保证可靠传输"><a href="#5-TCP如何保证可靠传输" class="headerlink" title="5. TCP如何保证可靠传输"></a>5. TCP如何保证可靠传输</h2><p>TCP协议传输的特点主要就是面向字节流、传输可靠、面向连接。</p>
<p>TCP保证数据可靠传输的方式主要有以下六点：校验和、确认应答与序列号、超时重传、连接管理、流量控制、拥塞控制。</p>
<p>1）校验和</p>
<p>在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。发送方在发送数据之前计算校验和，并进行校验和的填充。接收方收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。</p>
<p>注意：如果接收方比对校验和与发送方不一致，那么数据一定传输有误。但是如果接收方比对校验和与发送方一致，数据不一定传输成功。</p>
<p>2）确认应答与序列号</p>
<p>序列号：TCP传输时将每个字节的数据都进行了编号，这就是序列号。</p>
<p>确认应答：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。</p>
<p>序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。</p>
<p>3）超时重传</p>
<p>简单理解就是发送方在发送完数据后等待一个时间，时间到达没有接受到ACK报文，那么对刚才发送的数据进行重新发送。由于TCP传输时保证能够在任何环境下都有一个高性能的通信，因此这个最大超时时间（也就是等待时间）是动态计算的。</p>
<p>4）连接管理</p>
<p>连接管理就是三次握手和四次挥手的过程，保证可靠的连接，是保证可靠性的前提。</p>
<p>5）流量控制</p>
<p>接收端在接收到数据后，对其进行处理。如果发送端的发送速度太快，导致接收端的结束缓冲区很快的填充满了。此时如果发送端仍旧发送数据，那么接下来发送的数据都会丢包，继而导致丢包的一系列连锁反应，超时重传。而TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制。</p>
<p>6）拥塞控制</p>
<p>TCP通过维护一个拥塞窗口来进行拥塞控制。网络中没有出现拥塞，拥塞窗口的值就可以再增大一些，以便把更多的数据发送出去。网络出现拥塞，拥塞窗口的值就应该减小一些，以减少注入到网络中的数据包数。</p>
<h2 id="6-浏览器输入url到显示网页过程"><a href="#6-浏览器输入url到显示网页过程" class="headerlink" title="6. 浏览器输入url到显示网页过程"></a>6. 浏览器输入url到显示网页过程</h2><ol>
<li>解析URL，生成发送给Web服务器的请求信息。</li>
</ol>
<h2 id="7-HTTP、HTTPS的区别"><a href="#7-HTTP、HTTPS的区别" class="headerlink" title="7. HTTP、HTTPS的区别"></a>7. HTTP、HTTPS的区别</h2><p>http是超文本传输协议，它是通过明文的方式发送内容，没有任何的加密，比如我们访问一个网站，我们可能需要在这个网站输入密码，之后账号和密码就会发送到网站的服务器上，但要是有人在中途截取了信息，这些信息很容易就会暴露，为了解决http在传输过程中不加密的问题，又增加了一个SSL协议，这个协议简单说就是提供数据安全和完整性的协议，也就是负责网络连接的加密，比如访问一个https的网站，电脑就会先和服务器建立一个安全的连接通道，然后服务器会先发送一份网站的证书信息到电脑，就相当于是告诉电脑，你访问的服务器没有问题，确认了信息之后，我们的服务器就会生成一个加锁的箱子，但是这把锁有两把不一样的钥匙，一把给电脑，一把自留，然后服务器就会把没有上锁的箱子和钥匙发给电脑，我们把信息放在箱子里面之后，用钥匙锁上，再发给服务器，服务器再用自己的钥匙打开箱子，来保证信息的安全，在这个过程中，即使箱子被人拦截，因为没有钥匙，以目前的技术来讲，还是很难打开箱子的，所以一些大的网站尤其是购物网站，或者是需要登录的网站，基本都是https的。</p>
<h2 id="8-http1-0和http1-1"><a href="#8-http1-0和http1-1" class="headerlink" title="8. http1.0和http1.1"></a>8. http1.0和http1.1</h2><h2 id="9-cookie和session的作用和区别"><a href="#9-cookie和session的作用和区别" class="headerlink" title="9. cookie和session的作用和区别"></a>9. cookie和session的作用和区别</h2><h2 id="10-什么是操作系统"><a href="#10-什么是操作系统" class="headerlink" title="10. 什么是操作系统"></a>10. 什么是操作系统</h2><h2 id="11-进程状态及通信方式"><a href="#11-进程状态及通信方式" class="headerlink" title="11. 进程状态及通信方式"></a>11. 进程状态及通信方式</h2><h2 id="12-线程间的同步方式"><a href="#12-线程间的同步方式" class="headerlink" title="12. 线程间的同步方式"></a>12. 线程间的同步方式</h2><h2 id="13-进程调度算法"><a href="#13-进程调度算法" class="headerlink" title="13. 进程调度算法"></a>13. 进程调度算法</h2><h2 id="14-内存管理"><a href="#14-内存管理" class="headerlink" title="14. 内存管理"></a>14. 内存管理</h2><h2 id="15-虚拟内存"><a href="#15-虚拟内存" class="headerlink" title="15. 虚拟内存"></a>15. 虚拟内存</h2><h2 id="16-什么是内核"><a href="#16-什么是内核" class="headerlink" title="16. 什么是内核"></a>16. 什么是内核</h2><h2 id="17-Shell编程和Linux基本命令"><a href="#17-Shell编程和Linux基本命令" class="headerlink" title="17. Shell编程和Linux基本命令"></a>17. Shell编程和Linux基本命令</h2><h2 id="18-什么是MySQL"><a href="#18-什么是MySQL" class="headerlink" title="18. 什么是MySQL"></a>18. 什么是MySQL</h2><h2 id="19-MySQL主从复制"><a href="#19-MySQL主从复制" class="headerlink" title="19. MySQL主从复制"></a>19. MySQL主从复制</h2><h2 id="20-存储引擎"><a href="#20-存储引擎" class="headerlink" title="20. 存储引擎"></a>20. 存储引擎</h2><h2 id="21-索引及索引底层结构"><a href="#21-索引及索引底层结构" class="headerlink" title="21. 索引及索引底层结构"></a>21. 索引及索引底层结构</h2><h2 id="22-查询缓存"><a href="#22-查询缓存" class="headerlink" title="22. 查询缓存"></a>22. 查询缓存</h2><h2 id="23-什么是事务"><a href="#23-什么是事务" class="headerlink" title="23. 什么是事务"></a>23. 什么是事务</h2><h2 id="24-事务四大特性"><a href="#24-事务四大特性" class="headerlink" title="24. 事务四大特性"></a>24. 事务四大特性</h2><h2 id="25-事务隔离及MySQL的默认隔离级别"><a href="#25-事务隔离及MySQL的默认隔离级别" class="headerlink" title="25. 事务隔离及MySQL的默认隔离级别"></a>25. 事务隔离及MySQL的默认隔离级别</h2><h2 id="26-并发事务带来的问题"><a href="#26-并发事务带来的问题" class="headerlink" title="26. 并发事务带来的问题"></a>26. 并发事务带来的问题</h2><h2 id="27-锁机制"><a href="#27-锁机制" class="headerlink" title="27. 锁机制"></a>27. 锁机制</h2><h2 id="28-大表优化"><a href="#28-大表优化" class="headerlink" title="28. 大表优化"></a>28. 大表优化</h2><h2 id="29-SQL语句的执行过程"><a href="#29-SQL语句的执行过程" class="headerlink" title="29. SQL语句的执行过程"></a>29. SQL语句的执行过程</h2><h2 id="30-MySQL高性能优化"><a href="#30-MySQL高性能优化" class="headerlink" title="30. MySQL高性能优化"></a>30. MySQL高性能优化</h2><h2 id="31-MVCC及视图"><a href="#31-MVCC及视图" class="headerlink" title="31. MVCC及视图"></a>31. MVCC及视图</h2><h2 id="32-SQL语句的熟练编写"><a href="#32-SQL语句的熟练编写" class="headerlink" title="32. SQL语句的熟练编写"></a>32. SQL语句的熟练编写</h2><h2 id="33-常用工具"><a href="#33-常用工具" class="headerlink" title="33. 常用工具"></a>33. 常用工具</h2>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>购物车结算系统-CSS篇-项目小记</title>
    <url>/2022/01/06/%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%BB%93%E7%AE%97%E7%B3%BB%E7%BB%9F-CSS%E7%AF%87-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>常用的选择器如下：</p>
<span id="more"></span>
<ol>
<li><code>.exam</code> ：选择所有class=”exam”的元素；</li>
<li><code>#exam</code> ：选择所有id=”exam”的元素；</li>
<li><code>*</code> ：选择所有元素；</li>
<li><code>div</code> ：选择所有\<div>元素；</li>
<li><code>div,p</code> ：选择所有\<div>元素和\<p>元素；</li>
<li><code>div p</code> ：选择\<div>元素内的所有\<p>元素；</li>
<li><code>div&gt;p</code> ：选择所有父级是 \<div> 元素的 \<p> 元素；</li>
<li><code>[input=text]</code> ：选择所有 \<input type="text"> 元素；</li>
<li><code>a:link</code>：选择所有未访问链接；</li>
<li><code>a:visited</code>：选择所有访问过的链接；</li>
<li><code>a:active</code>：选择点击后的链接；</li>
<li><code>a:hover</code> ：选择鼠标在链接上面时。</li>
</ol>
<h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><p>应用于元素的2D或3D转换。这个属性允许你将元素旋转，缩放，移动，倾斜等。</p>
<p>本项目中使用：<code>transform: translate(-50%,-50%);</code></p>
<p>即往上（x轴）,左（y轴）移动自身长宽的 50%，以使其居于中心位置。</p>
<p><strong>用处：实现水平垂直居中。</strong></p>
<h3 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h3><p>设置一个或多个下拉阴影的框。</p>
<p>语法：<code>box-shadow: h-shadow v-shadow blur spread color inset;</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"><em>h-shadow</em></th>
<th style="text-align:center">必需的。水平阴影的位置。允许负值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><em>v-shadow</em></td>
<td style="text-align:center">必需的。垂直阴影的位置。允许负值</td>
</tr>
<tr>
<td style="text-align:center"><em>blur</em></td>
<td style="text-align:center">可选。模糊距离</td>
</tr>
<tr>
<td style="text-align:center"><em>spread</em></td>
<td style="text-align:center">可选。阴影的大小</td>
</tr>
<tr>
<td style="text-align:center"><em>color</em></td>
<td style="text-align:center">可选。阴影的颜色。</td>
</tr>
<tr>
<td style="text-align:center">inset</td>
<td style="text-align:center">可选。从外层的阴影（开始时）改变阴影内侧阴影</td>
</tr>
</tbody>
</table>
</div>
<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p>规定元素的定位类型。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>absolute</th>
<th>生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</th>
</tr>
</thead>
<tbody>
<tr>
<td>fixed</td>
<td>生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</td>
</tr>
<tr>
<td>relative</td>
<td>生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。</td>
</tr>
<tr>
<td>static</td>
<td>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承 position 属性的值。</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>项目小记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>购物车结算系统 - HTML篇 - 项目小记</title>
    <url>/2022/01/03/%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%BB%93%E7%AE%97%E7%B3%BB%E7%BB%9F-HTML%E7%AF%87-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="form"><a href="#form" class="headerlink" title="form"></a>form</h3><h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><p>使用：<code>action=&quot;[跳转页面名称].jsp&quot;</code></p>
<p>如：<code>action=&quot;choose_goods.jsp&quot;</code></p>
<span id="more"></span>
<h4 id="method"><a href="#method" class="headerlink" title="method"></a>method</h4><p>有两个值：<code>post</code> 不显示中间 <code>input</code> 内容，<code>get</code> 显示。</p>
<p><strong>get：</strong></p>
<ol>
<li>请求参数会在地址栏中显示，会封装在请求行中</li>
<li>请求参数的大小是有限制的</li>
<li>请求方式不安全</li>
</ol>
<p><strong>post：</strong></p>
<ol>
<li>请求参数不会在地址栏中显示，会封装在请求体中</li>
<li>请求参数的大小没有限制</li>
<li>请求方式比较安全</li>
</ol>
<p>请求参数为中间 <code>&lt;input&gt;</code> 元素的结果。</p>
<p>一般情况 <code>&lt;form&gt;</code> 与 <code>&lt;input&gt;</code> 连用，当使用 <code>&lt;input type=&quot;submit&quot;&gt;</code> 按钮的时候会将其中的 <code>&lt;input&gt;</code> 的参数传第到指定跳转页面。</p>
<p>具体实例：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;choose_goods.jsp&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;input_field&quot;</span>&gt;</span><br><span class="line">          &lt;input name=<span class="string">&quot;username&quot;</span> type=<span class="string">&quot;text&quot;</span> required=<span class="string">&quot;required&quot;</span> placeholder=<span class="string">&quot;用户名&quot;</span>&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;input_field&quot;</span>&gt;</span><br><span class="line">          &lt;input name=<span class="string">&quot;password&quot;</span> type=<span class="string">&quot;password&quot;</span> required=<span class="string">&quot;required&quot;</span> placeholder=<span class="string">&quot;密码&quot;</span>&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;input_field&quot;</span>&gt;</span><br><span class="line">          &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;登录&quot;</span>&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
<h4 id="onsubmit"><a href="#onsubmit" class="headerlink" title="onsubmit"></a>onsubmit</h4><p>点击 <code>&lt;input type=&quot;submit&quot;&gt;</code> 按钮时会触发指定函数。</p>
<p>使用：<code>onsubmit=&quot;checkPayword()&quot;</code>。</p>
<h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>常用的值如下：</p>
<ol>
<li>text：定义单行的输入字段，用户可在其中输入文本。默认宽度为 20 个字符。</li>
<li>submit：定义提交按钮。提交按钮会把表单数据发送到服务器。</li>
<li>buttom：定义可点击按钮（多数情况下，用于通过 JavaScript 启动脚本）。</li>
<li>password：定义密码字段。该字段中的字符被掩码。</li>
</ol>
<h4 id="required"><a href="#required" class="headerlink" title="required"></a>required</h4><p>表示该字段是必填的，不能为空。</p>
<h4 id="placeholder"><a href="#placeholder" class="headerlink" title="placeholder"></a>placeholder</h4><p>规定可描述输入字段预期值的简短的提示信息。也就是提示。</p>
<h4 id="value"><a href="#value" class="headerlink" title="value"></a>value</h4><p>input元素显示的值。</p>
<h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><p>该input元素的名称。</p>
<h4 id="maxlength"><a href="#maxlength" class="headerlink" title="maxlength"></a>maxlength</h4><p>规定输入字段的最大长度，以字符个数计。</p>
<h4 id="onclick"><a href="#onclick" class="headerlink" title="onclick"></a>onclick</h4><p>点击按钮事件。</p>
<h4 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h4><p>规定输入字段为只读，不可修改。</p>
<h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><h4 id="rel"><a href="#rel" class="headerlink" title="rel"></a>rel</h4><p>规定当前文档与被链接文档/资源之间的关系，是必须的。</p>
<p>使用如：<code>rel=&quot;stylesheet&quot;</code></p>
<p>常用的值如下：</p>
<ol>
<li>stylesheet：要导入的样式表的 URL。</li>
<li>next： 表示该文档是集合中的一部分，且集合中的下一个文档是被引用的文档。</li>
<li>icon：导入表示该文档的图标。</li>
<li>alternate：链接到该文档的替代版本（比如打印页、翻译或镜像）。</li>
</ol>
<h4 id="href"><a href="#href" class="headerlink" title="href"></a>href</h4><p>规定外部资源（通常是样式表文件）的位置（URL）。</p>
<p>使用：<code>&lt;link href=&quot;URL&quot;&gt;</code></p>
<p>绝对URL - 指向另一个网站，如： <code>href=&quot;http://www.example.com/theme.css&quot;</code></p>
<p>相对URL - 指向网站内的一个文件，如： <code>href=&quot;/themes/theme.css&quot;</code></p>
<p><strong>此处有一个使用技巧：</strong></p>
<p>因为这种方式导入文件，这个文件就已经在浏览器加载过了，之后再进入此浏览器这个文件不会在被加载，为了保证每次进入浏览器的文件都是最新的，可以在导入的文件后添加这样的内容：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">?v=&lt;%= System.currentTimeMillis()%&gt;</span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">href=<span class="string">&quot;/themes/theme.css?v=&lt;%= System.currentTimeMillis()%&gt;&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>System.currentTimeMillis()</code> 就是获取系统的当前时间戳，相当于给文件一个版本号，这样每次进入浏览器，文件都会被更新。</p>
<h3 id="onclick-”this-form-onsubmit-”"><a href="#onclick-”this-form-onsubmit-”" class="headerlink" title="onclick=”this.form.onsubmit()”"></a>onclick=”this.form.onsubmit()”</h3><p>本项目使用在 点击 <code>&lt;input type=&quot;buttom&quot;&gt;</code> 按钮后检查密码是否合法。</p>
<p>意思就是点击这个按钮，会触发 <code>this</code> 这个 <code>form</code> 表单的 <code>obsubmit()</code> 这个方法指向的js方法。</p>
]]></content>
      <categories>
        <category>项目小记</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>购物车结算系统-JS篇-项目小记</title>
    <url>/2022/01/07/%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%BB%93%E7%AE%97%E7%B3%BB%E7%BB%9F-JS%E7%AF%87-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="document"><a href="#document" class="headerlink" title="document"></a>document</h3><blockquote>
<p>借鉴：<a href="https://www.cnblogs.com/www1842564021/p/11830139.html">https://www.cnblogs.com/www1842564021/p/11830139.html</a></p>
</blockquote>
<ol>
<li><strong>document.getElementById()：返回对拥有指定 id 的第一个对象的引用。</strong></li>
<li><strong>document.getElementsByName()：返回带有指定名称的对象集合，也就是如果有多个相同name的元素，会返回数组。</strong></li>
<li><strong>document.getElementsByTagName()：返回带有指定标签名的对象集合。</strong></li>
<li><strong>document.getElementsByClassName()：返回对拥有指定 class 的对象集合。</strong></li>
</ol>
<span id="more"></span>
<h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><p>设置或返回密码域的默认值。</p>
<p>用法如：<code>document.getElementById(&quot;username&quot;).value</code>，返回结果为<strong>字符串</strong>。</p>
<h3 id="location-href"><a href="#location-href" class="headerlink" title="location.href"></a>location.href</h3><blockquote>
<p>借鉴：<a href="https://www.w3school.com.cn/js/js_window_location.asp">https://www.w3school.com.cn/js/js_window_location.asp</a></p>
</blockquote>
<p>一些类似的例子：</p>
<ul>
<li>window.location.href 返回当前页面的 href (URL)</li>
<li>window.location.hostname 返回 web 主机的域名</li>
<li>window.location.pathname 返回当前页面的路径或文件名</li>
<li>window.location.protocol 返回使用的 web 协议（http: 或 https:）</li>
<li>window.location.assign 加载新文档</li>
</ul>
<p>本项目将它与 \<form\> 表单的 <code>onsubmit</code> 方法连用，用于判断密码是否正确，如果正确跳转到指定的链接。</p>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">checkPassword</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">document</span>.getElementById(<span class="string">&quot;username&quot;</span>).value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          alert(<span class="string">&quot;用户名为空。&quot;</span>)</span><br><span class="line">      &#125;<span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">	location.href=<span class="string">&#x27;basic_info.jsp&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="alert"><a href="#alert" class="headerlink" title="alert"></a>alert</h3><blockquote>
<p>借鉴：<a href="https://www.w3school.com.cn/js/js_popup.asp">https://www.w3school.com.cn/js/js_popup.asp</a></p>
</blockquote>
<p>用于显示带有一条指定消息和一个 OK 按钮的警告框。</p>
<p>用法：<code>window.alert(&quot;I am an alert box!!&quot;)</code>，前缀 <code>window.</code> 可以省略不写。</p>
<p>类似的：</p>
<p><strong>confirm(“sometext”)</strong></p>
<p>确认框。如果用户单击“确定”，该框返回 true。如果用户单击“取消”，该框返回 false。</p>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = confirm(<span class="string">&quot;请按按钮&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (r == <span class="literal">true</span>) &#123;</span><br><span class="line">    x = <span class="string">&quot;您按了确认！&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    x = <span class="string">&quot;您按了取消！&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>prompt(“sometext”,”defaultText”)</strong></p>
<p>提示框。如果用户单击“确定”，该框返回输入值。如果用户单击“取消”，该框返回 NULL。</p>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = prompt(<span class="string">&quot;请输入您的姓名&quot;</span>, <span class="string">&quot;比尔盖茨&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (person != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>).innerHTML = <span class="string">&quot;你好 &quot;</span> + person + <span class="string">&quot;！今天过的怎么样？&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for，if"><a href="#for，if" class="headerlink" title="for，if"></a>for，if</h3><p>和 java 一样。</p>
<p>不同的是，0 和 1 可以作为 false 和 true 使用。</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Sqoop50题</title>
    <url>/2021/06/27/Sqoop50%E9%A2%98/</url>
    <content><![CDATA[<p>Sqoop导出操作</p>
<p>\1. 准备数据</p>
<span id="more"></span>
<p>CREATE TABLE student (</p>
<p>id int(11) DEFAULT NULL,</p>
<p>name varchar(100) DEFAULT NULL,</p>
<p>class varchar(100) DEFAULT NULL,</p>
<p>age int(11) DEFAULT NULL,</p>
<p>high varchar(10) DEFAULT NULL</p>
<p>) ENGINE=InnoDB DEFAULT CHARSET=latin1;</p>
<p>INSERT INTO student VALUES (‘1001’, ‘James’, ‘12’, ‘16’, ‘158’);</p>
<p>INSERT INTO student VALUES (‘1002’, ‘Mark’, ‘34’, ‘17’, ‘169’);</p>
<p>INSERT INTO student VALUES (‘1003’, ‘Henry’, ‘13’, ‘18’, ‘178’);</p>
<p>INSERT INTO student VALUES (‘1004’, ‘Kitte’, ‘24’, ‘17’, ‘175’);</p>
<p>INSERT INTO student VALUES (‘1005’, ‘Tom’, ‘23’, ‘20’, ‘180’);</p>
<p>使用sqoop把部分数据导入到HDFS的 /MysqlToHDFS3 目录下,要求使用query sql语句查询，导入的字段为id,name,age,查询条件为age&gt;16,两个map，以id字段进行划分。语句是？</p>
<p>A.  bin/sqoop import</p>
<p>–connect jdbc:mysql://192.168.10.10:3306/userdb</p>
<p>–username root</p>
<p>–delete-target-dir</p>
<p>–target-dir /MysqlToHDFS3</p>
<p>–query “select id,name,age from student WHERE age &gt; 16 and $CONDITIONS”</p>
<p>–split-by id</p>
<p>–fields-terminated-by ‘\t’</p>
<p>—num-mappers 2</p>
<p>B. bin/sqoop import</p>
<p>–connect jdbc:mysql://192.168.10.10:3306/userdb</p>
<p>–username root</p>
<p>–delete-target-dir</p>
<p>–target-dir /MysqlToHDFS3</p>
<p>–query ‘select id,name,age from student WHERE age &gt; 16’</p>
<p>–split-by id</p>
<p>–fields-terminated-by ‘\t’</p>
<p>—num-mappers 2</p>
<p>C. bin/sqoop import</p>
<p>–connect jdbc:mysql://192.168.10.10:3306/userdb</p>
<p>–username root</p>
<p>–delete-target-dir</p>
<p>–target-dir /MysqlToHDFS3</p>
<p>–query ‘select id,name,age from student WHERE age &gt; 16 and $CONDITIONS’</p>
<p>–split-by id</p>
<p>–fields-terminated-by ‘\t’</p>
<p>–m 2</p>
<p>D. bin/sqoop import</p>
<p>–connect jdbc:mysql://192.168.10.10:3306/userdb</p>
<p>–username root</p>
<p>–delete-target-dir</p>
<p>–target-dir /MysqlToHDFS3</p>
<p>–query “select id,name,age from student WHERE age &gt; 16 and $CONDITIONS”</p>
<p>–split-by id</p>
<p>–fields-terminated-by ‘\t’</p>
<p>–m 2</p>
<p>参考答案C</p>
<p>2.阅读下面两个陈述：</p>
<p>A. 用Sqoop将关系型数据库中的数据导入Hive，当Hive中没有对应表时，则自动创建。</p>
<p>B. Sqoop命令create-hive-table可以生成与关系数据库表结构对应的hive表结构。</p>
<p>A.A 错B 错</p>
<p>B.A 错 B 对 </p>
<p>C.A 对 B 对 </p>
<p>D.A 对 B 错</p>
<p>参考答案C</p>
<p>3.<strong>__</strong>工具将文件从HDFS传输到RDBMS</p>
<p>A. export</p>
<p>B. transfer</p>
<p>C. import</p>
<p>D. output</p>
<p>参考答案A</p>
<p>\4. 关于Sqoop说法正确的是？</p>
<p>A.可以列出关系型数据库的某个说数据库下的所有表</p>
<p>B.可以列出关系型数据库的所有数据库</p>
<p>C.以上都是</p>
<p>D.可以执行SQL语句</p>
<p>参考答案C</p>
<p>\5. 下面哪个场景适合使用Sqoop？</p>
<p>A.将HDFS数据传输到Oracle数据库中</p>
<p>B.将服务器日志传输到Kafka消息中间件中</p>
<p>C.将Kafka主题的消息传输到HDFS</p>
<p>D.将一个MySQL服务器数据同步到另外一个MySQL服务器中</p>
<p>参考答案A</p>
<p>\6. ___ 就是只导入表中新添加的记录的导入方式。</p>
<p>A减量导入</p>
<p>B.全量导入</p>
<p>C.以上都不对</p>
<p>D.增量导入</p>
<p>参考答案D</p>
<p>7.Sqoop导出操作失败的原因可能是？</p>
<p>A. RAM不足</p>
<p>B. 磁盘空间不足</p>
<p>C. 以上都是</p>
<p>D.使用错误的定界符解析记录</p>
<p>参考答案C</p>
<p>\8. Sqoop将导入或导出命令翻译成MapReduce程序，而MapReduce 中主要是对<strong>___</strong>和<strong>__</strong>进行定制</p>
<p>A.以上都不对</p>
<p>B. InputText, OutputText</p>
<p>C. InputFormat, OutputFormat</p>
<p>D. InputTextFormat, OutputTextFormat</p>
<p>参考答案C</p>
<p>9.在使用Sqoop导入数据到hive时，添加那个属性可以去掉数据中的\r\n\013\010这样的字符?</p>
<p>A. —input-lines-terminated-by</p>
<p>B. —hive-delims-replacement </p>
<p>C. —hive-drop-import-delims</p>
<p>D. —input-lines-terminated-by</p>
<p>参考答案C</p>
<p>\10. 导入MySQL数据库dbtest下emp表数据到HDFS语句正确的是？</p>
<p>A. sqoop-import —connect jdbc:mysql://node01:3306/dbtest —password 123456 —username root —schema emp -m 1</p>
<p>B. sqoop-import —connect jdbc:mysql://node01:3306/dbtest —password 123456 —username root —table emp -m 1</p>
<p>C. sqoop export —connect jdbc:mysql://node01:3306/dbtest —password 123456 —username root —table emp -m 1</p>
<p>D. sqoop export —connect jdbc:mysql://node01:3306/dbtest —password 123456 —username root —schema emp -m 1</p>
<p>参考答案B</p>
<p>\11. 默认情况下，Sqoop将在导出过程中并行使用____个任务。</p>
<p>A.4</p>
<p>B.2</p>
<p>C.3</p>
<p>D.1</p>
<p>参考答案A</p>
<p>12.A. Sqoop可以保存作业反复执行</p>
<p>B. sqoop在创建job时，使用—password-file参数，可以避免输入mysql密码, 而是从本地文件系统的指定文件获取密码</p>
<p>A.A 错 B 错</p>
<p>B.A 错 B 对 </p>
<p>C.A 对 B 对 </p>
<p>D.A 对 B 错</p>
<p>参考答案D</p>
<p>13.对于Sqoop导出控制参数，说明正确的是？</p>
<p>A. —input-null-string 字符串列将被解释为null的字符串表示</p>
<p>B. —input-null-non-string 非字符串列将被解释为null的字符串</p>
<p>C. —table 可以不指定</p>
<p>D. —export-dir 可以不指定</p>
<p>参考答案C</p>
<p>\14. Sqoop导出操作失败的原因可能是？</p>
<p>A.以上都是</p>
<p>B. Hadoop集群与数据库之间的连接丢失</p>
<p>C.尝试从HDFS源数据中解析不完整或格式不正确的记录</p>
<p>D.尝试在关系型数据库中插入违反一致性约束的记录</p>
<p>参考答案A</p>
<p>\15. 关于sqoop的导出操作说法错误的是？</p>
<p>A.默认导出操作是转换为UPDATE语句实现的</p>
<p>B.可以使用命令 sqoop-export实现导出</p>
<p>C.导出的目标表必须已经存在于数据库中</p>
<p>D.可以使用命令 sqoop export实现导出</p>
<p>参考答案A</p>
<p>Sqoop介绍和导入操作</p>
<p>1.Sqoop Import 命令中如果没有制定 -m 或者 —num-mappers 参数，则默认的mapper任务数量为？</p>
<p>A.4</p>
<p>B.2</p>
<p>C.3</p>
<p>D.1</p>
<p>参考答案A</p>
<p>\2. 哪个选项不会是下面这个命令执行失败的原因？</p>
<p>sqoop import \</p>
<p>—connect jdbc:mysql://192.168.186.100:3306/test \</p>
<p>—username root \</p>
<p>—password niit1234 \</p>
<p>—table message \</p>
<p>—delete-target-dir \</p>
<p>—target-dir /sqoop/result \</p>
<p>-m 1</p>
<p>A.导入的目标路径里面已经有文件存在</p>
<p>B.没有配置环境变量</p>
<p>C. Hadoop文件系统服务资源不足</p>
<p>D. MySQL用户root没有配置远程访问</p>
<p>参考答案A</p>
<p>3.在sqoop导入命令中，中的有关—split-by参数的用途说法正确的是 ？</p>
<p>A:如果指定了主键，默认按照主键进行分片</p>
<p>B:如果没有指定主键，则必须指定—split-by才能实现分片</p>
<p>A.A对B对</p>
<p>B.A对B错</p>
<p>C.B对A错</p>
<p>D.A错B错</p>
<p>参考答案A</p>
<p>\4. 关于Apache Sqoop 的版本说法正确的是 ？</p>
<p>A.只有 Sqoop 2 可以用于生产环境</p>
<p>B. Sqoop 1 和 Sqoop 2 都可以用于生产环境</p>
<p>C. Sqoop 1 和 Sqoop 2 都不可以用于生产环境</p>
<p>D.只有 Sqoop 1 可以用于生产环境</p>
<p>参考答案D</p>
<p>\5. sqoop导入到Hive的数据。默认的行分隔符为？</p>
<p>A.”\t”</p>
<p>B.”\001”</p>
<p>C.”\012”</p>
<p>D.”,”</p>
<p>参考答案C</p>
<p>\6. 使用Sqoop导入到Hive时，如果没有指定Hive表名会怎么样？</p>
<p>A.默认会在Hive中创建和MySQL同名的数据库和表</p>
<p>B.以上都不对</p>
<p>C.默认会在Hive中创建和MySQL同名的表，数据库需要另外指定</p>
<p>D.报错，必须指定表名</p>
<p>参考答案C</p>
<p>7.使用Sqoop工具将MySQL数据传送到HDFS文件系统应该使用什么命令 ？</p>
<p>A. sqoop export</p>
<p>B. sqoop transfer</p>
<p>C. sqoop transport</p>
<p>D. sqoop import</p>
<p>参考答案D</p>
<p>\8. Apache Sqoop 是一款<strong><strong>的工具，主要用于数据的</strong></strong>？</p>
<p>A.开源、采集</p>
<p>B.开源、传输</p>
<p>C.闭源、采集</p>
<p>D.闭源、传输</p>
<p>参考答案B</p>
<p>9.如何使用Sqoop导入关系型数据库中某个表的满足某个条件下的记录中的部分列数据到HDFS中 ？</p>
<p>A.以上都不对</p>
<p>B.指定—where</p>
<p>C.指定—query</p>
<p>D.指定—columns</p>
<p>参考答案C</p>
<p>10.Sqoop导入命令中，如何修改字段分隔符为制表符？</p>
<p>A. —fields-terminated-by = ‘/t’</p>
<p>B. —fields-terminated-by = ‘\t’</p>
<p>C. —fields-terminated-by ‘\t’</p>
<p>D. —fields-terminated-by ‘/t’</p>
<p>参考答案C</p>
<p>\11. 使用Sqoop还可以 ____ ?</p>
<p>A.连接关系型数据库并执行SQL语句</p>
<p>B.列出关系型数据库的某个数据库下的所有表</p>
<p>C.以上都是</p>
<p>D.列出关系型数据库的所有数据库</p>
<p>参考答案C</p>
<p>\12. 关于增量导入：</p>
<p>说法A：只能由一个列作为检查列 —check-column</p>
<p>说法B：必须指定 —last-value</p>
<p>A.A对B对</p>
<p>B.A错B错</p>
<p>C.A错B对</p>
<p>D.A对B错</p>
<p>参考答案C</p>
<p>\13. sqoop导入到Hive的数据。默认的列分隔符为？</p>
<p>A.”\t”</p>
<p>B.”\001”</p>
<p>C.”\012”</p>
<p>D.”,”</p>
<p>参考答案B</p>
<p>14.在Linux系统中配置Sqoop环境变量的方式正确的是 ？</p>
<p>A. export $SQOOP_HOME=/home/soft/sqoop-1.4.6.bin_hadoop-2.0.4-alpha</p>
<p>export PATH=$PATH:$SQOOP_HOME/bin</p>
<p>B. export SQOOP_HOME=/home/soft/sqoop-1.4.6.bin_hadoop-2.0.4-alpha</p>
<p>export PATH=$PATH:$SQOOP_HOME/bin</p>
<p>C. export SQOOP_HOME=/home/soft/sqoop-1.4.6.bin_hadoop-2.0.4-alpha</p>
<p>export $PATH=$PATH:$SQOOP_HOME/bin</p>
<p>D. export SQOOP_HOME=/home/soft/sqoop-1.4.6.bin_hadoop-2.0.4-alpha</p>
<p>export PATH=PATH:$SQOOP_HOME/bin</p>
<p>参考答案B</p>
<p>15.下面哪个选项是属于Sqoop import ？</p>
<p>A.将Oracle数据库中的数据保存到Hive表中</p>
<p>B.将MongoDB数据库中的数据传输到HDFS文件系统</p>
<p>C.将HBase数据库中的数据转存到Hive表中</p>
<p>D.将Storm中拓扑处理的数据持久化到HBase数据库中</p>
<p>参考答案A</p>
<p>16.Sqoop导入数据的方式有？</p>
<p>A.以上都对</p>
<p>B.部分导入</p>
<p>C.全量导入</p>
<p>D.增量导入</p>
<p>参考答案A</p>
<p>\17. 如何使用sqoop import 导入部分记录？</p>
<p>A. —columns</p>
<p>B. —where</p>
<p>C以上都是</p>
<p>D. —query</p>
<p>参考答案C</p>
<p>18.sqoop导入到HDFS中的所有记录存储为____格式。</p>
<p>A.以上都不对</p>
<p>B.文本格式</p>
<p>C.二进制</p>
<p>D.十六进制</p>
<p>参考答案B</p>
<p>\1. 根据时间上晚于某列来进行数据增量导入，应使用<strong><strong>类型的增量模式配合_</strong></strong>属性</p>
<p>A.append —last-value</p>
<p>B.append —last-time</p>
<p>C.lastmodified —last-value</p>
<p>D.lastmodified —last-time</p>
<p>参考答案C</p>
<p>2.根据自增数值型主键进行增量导入，应使用<strong><strong>类型的增量模式配合_</strong></strong>属性</p>
<p>A.append —last-value</p>
<p>B.append —last-time</p>
<p>C.lastmodified —last-value</p>
<p>D.lastmodified —last-time</p>
<p>参考答案A</p>
<p>3.增量导入的check-colume参数是指？</p>
<p>A.设置作为增量导入检查依据的列，只能指定1列</p>
<p>B.设置作为增量导入检查依据的列，可以指定多列</p>
<p>C.指定增量导入的实际列，只能指定1列</p>
<p>D.指定增量导入的实际列，可以指定多列</p>
<p>参考答案B</p>
<p>4.Sqoop从MySQL到HDFS传输数据属于<strong><strong>___</strong></strong>, 使用Sqoop从HDFS到MySQL传输数据属于<strong>____</strong></p>
<p>A.导入，导出    </p>
<p>B.导出，导入</p>
<p>回答正确，得分 2</p>
<p>参考答案A</p>
<p>\5. A. Sqoop可以保存作业反复执行</p>
<p>B. sqoop在创建job时，使用—password-file参数，可以避免输入mysql密码, 而是从本地文件系统的指定文件获取密码</p>
<p>A.A 对 B 错</p>
<p>B.A 错 B 对 </p>
<p>C.A 错 B 错</p>
<p>D.A 对 B 对 </p>
<p>参考答案A</p>
<p>\6. 准备数据</p>
<p>CREATE TABLE student (</p>
<p>id int(11) DEFAULT NULL,</p>
<p>name varchar(100) DEFAULT NULL,</p>
<p>class varchar(100) DEFAULT NULL,</p>
<p>age int(11) DEFAULT NULL,</p>
<p>high varchar(10) DEFAULT NULL</p>
<p>) ENGINE=InnoDB DEFAULT CHARSET=latin1;</p>
<p>INSERT INTO student VALUES (‘1001’, ‘James’, ‘12’, ‘16’, ‘158’);</p>
<p>INSERT INTO student VALUES (‘1002’, ‘Mark’, ‘34’, ‘17’, ‘169’);</p>
<p>INSERT INTO student VALUES (‘1003’, ‘Henry’, ‘13’, ‘18’, ‘178’);</p>
<p>INSERT INTO student VALUES (‘1004’, ‘Kitte’, ‘24’, ‘17’, ‘175’);</p>
<p>INSERT INTO student VALUES (‘1005’, ‘Tom’, ‘23’, ‘20’, ‘180’);</p>
<p>使用sqoop把部分数据导入到HDFS的 /MysqlToHDFS3 目录下,要求使用query sql语句查询，导入的字段为id,name,age,查询条件为age&gt;16,两个map，以id字段进行划分。语句是？</p>
<p>A.bin/sqoop import</p>
<p>–connect jdbc:mysql://192.168.10.10:3306/userdb</p>
<p>–username root</p>
<p>–delete-target-dir</p>
<p>–target-dir /MysqlToHDFS3</p>
<p>–query ‘select id,name,age from student WHERE age &gt; 16 and $CONDITIONS’</p>
<p>–split-by id</p>
<p>–fields-terminated-by ‘\t’</p>
<p>–m 2</p>
<p>B.bin/sqoop import</p>
<p>–connect jdbc:mysql://192.168.10.10:3306/userdb</p>
<p>–username root</p>
<p>–delete-target-dir</p>
<p>–target-dir /MysqlToHDFS3</p>
<p>–query “select id,name,age from student WHERE age &gt; 16 and $CONDITIONS”</p>
<p>–split-by id</p>
<p>–fields-terminated-by ‘\t’</p>
<p>–m 2</p>
<p>C.bin/sqoop import</p>
<p>–connect jdbc:mysql://192.168.10.10:3306/userdb</p>
<p>–username root</p>
<p>–delete-target-dir</p>
<p>–target-dir /MysqlToHDFS3</p>
<p>–query “select id,name,age from student WHERE age &gt; 16 and $CONDITIONS”</p>
<p>–split-by id</p>
<p>–fields-terminated-by ‘\t’</p>
<p>—num-mappers 2</p>
<p>D.bin/sqoop import</p>
<p>–connect jdbc:mysql://192.168.10.10:3306/userdb</p>
<p>–username root</p>
<p>–delete-target-dir</p>
<p>–target-dir /MysqlToHDFS3</p>
<p>–query ‘select id,name,age from student WHERE age &gt; 16’</p>
<p>–split-by id</p>
<p>–fields-terminated-by ‘\t’</p>
<p>—num-mappers 2</p>
<p>参考答案A</p>
<p>\7. 关于Sqoop说法正确的是？</p>
<p>A.可以列出关系型数据库的所有数据库</p>
<p>B.可以列出关系型数据库的某个说数据库下的所有表</p>
<p>C.可以执行SQL语句</p>
<p>D.以上都是</p>
<p>参考答案D</p>
<p>\8. 阅读下面两个陈述：</p>
<p>A. 用Sqoop将关系型数据库中的数据导入Hive，当Hive中没有对应表时，则自动创建。</p>
<p>B. Sqoop命令create-hive-table可以生成与关系数据库表结构对应的hive表结构。</p>
<p>A.A 对 B 错</p>
<p>B.A 错 B 对 </p>
<p>C.A 对 B 对 </p>
<p>D.A 错B 错</p>
<p>参考答案C</p>
<p>\9. 在使用Sqoop导入数据到hive时，添加那个属性可以去掉数据中的\r\n\013\010这样的字符?</p>
<p>A.—hive-delims-replacement </p>
<p>B.—hive-drop-import-delims</p>
<p>C.—input-lines-terminated-by</p>
<p>D.—input-lines-terminated-by</p>
<p>参考答案B</p>
<p>10.导入MySQL数据库dbtest下emp表数据到HDFS语句正确的是？</p>
<p>A.sqoop export —connect jdbc:mysql://node01:3306/dbtest —password 123456 —username root —table emp -m 1</p>
<p>B.sqoop-import —connect jdbc:mysql://node01:3306/dbtest —password 123456 —username root —table emp -m 1</p>
<p>C.sqoop-import —connect jdbc:mysql://node01:3306/dbtest —password 123456 —username root —schema emp -m 1</p>
<p>D.sqoop export —connect jdbc:mysql://node01:3306/dbtest —password 123456 —username root —schema emp -m 1</p>
<p>参考答案B</p>
<p>\11. 下面哪个场景适合使用Sqoop？</p>
<p>A.将服务器日志传输到Kafka消息中间件中</p>
<p>B.将一个MySQL服务器数据同步到另外一个MySQL服务器中</p>
<p>C.将HDFS数据传输到Oracle数据库中</p>
<p>D.将Kafka主题的消息传输到HDFS</p>
<p>参考答案C</p>
<p>\12. Sqoop将导入或导出命令翻译成MapReduce程序，而MapReduce 中主要是对<strong>___</strong>和<strong>__</strong>进行定制</p>
<p>A.InputText, OutputText</p>
<p>B.InputTextFormat, OutputTextFormat</p>
<p>C.InputFormat, OutputFormat</p>
<p>D.以上都不对</p>
<p>参考答案C</p>
<p>13.___ 就是只导入表中新添加的记录的导入方式。</p>
<p>A.全量导入</p>
<p>B.增量导入</p>
<p>C.减量导入</p>
<p>D.以上都不对</p>
<p>参考答案B</p>
<p>\14. Sqoop导出操作失败的原因可能是？</p>
<p>A.Hadoop集群与数据库之间的连接丢失</p>
<p>B.尝试在关系型数据库中插入违反一致性约束的记录</p>
<p>C.尝试从HDFS源数据中解析不完整或格式不正确的记录</p>
<p>D.以上都是</p>
<p>参考答案D</p>
<p>\15. 默认情况下，Sqoop将在导出过程中并行使用____个任务。</p>
<p>A.1</p>
<p>B.2</p>
<p>C.3</p>
<p>D.4</p>
<p>参考答案D</p>
<p>\16. 对于Sqoop导出控制参数，说明正确的是？</p>
<p>A.—input-null-string 非字符串列将被解释为null的字符串</p>
<p>B.—input-null-non-string 字符串列将被解释为null的字符串表示</p>
<p>C.—export-dir 可以不指定</p>
<p>D.—table 可以不指定</p>
<p>参考答案D</p>
<p>\17. 关于sqoop的导出操作说法错误的是？</p>
<p>A.导出的目标表必须已经存在于数据库中</p>
<p>B.可以使用命令 sqoop export实现导出</p>
<p>C.可以使用命令 sqoop-export实现导出</p>
<p>D.默认导出操作是转换为UPDATE语句实现的</p>
<p>参考答案D</p>
<p>\18. <strong>__</strong>工具将文件从HDFS传输到RDBMS</p>
<p>A.import</p>
<p>B.export</p>
<p>C.output</p>
<p>D.transfer</p>
<p>参考答案B</p>
<p>\19. 关于增量导入：</p>
<p>说法A：</p>
<p>只能由一个列作为检查列 —check-column</p>
<p>说法B：</p>
<p>必须指定 —last-value</p>
<p>A.A对B错</p>
<p>B.A错B对</p>
<p>C.A对B对</p>
<p>D.A错B错</p>
<p>参考答案B</p>
<p>\20. 如何使用sqoop import 导入部分记录？</p>
<p>A.—query</p>
<p>B.—where</p>
<p>C.—columns</p>
<p>D.以上都是</p>
<p>参考答案D</p>
<p>\21. 哪个选项不会是下面这个命令执行失败的原因？</p>
<p>sqoop import \</p>
<p>—connect jdbc:mysql://192.168.186.100:3306/test \</p>
<p>—username root \</p>
<p>—password niit1234 \</p>
<p>—table message \</p>
<p>—delete-target-dir \</p>
<p>—target-dir /sqoop/result \</p>
<p>-m 1</p>
<p>A.没有配置环境变量</p>
<p>B.MySQL用户root没有配置远程访问</p>
<p>C.导入的目标路径里面已经有文件存在</p>
<p>D.Hadoop文件系统服务资源不足</p>
<p>参考答案C</p>
<p>22.如何使用Sqoop导入关系型数据库中某个表的满足某个条件下的记录中的部分列数据到HDFS中 ？</p>
<p>A.指定—where</p>
<p>B.指定—query</p>
<p>C.指定—columns</p>
<p>D.以上都不对</p>
<p>参考答案B</p>
<p>\23. 在sqoop导入命令中，中的有关—split-by参数的用途说法正确的是 ？</p>
<p>A:如果指定了主键，默认按照主键进行分片</p>
<p>B:如果没有指定主键，则必须指定—split-by才能实现分片</p>
<p>A.A对B错</p>
<p>B.B对A错</p>
<p>C.A对B对</p>
<p>D.A错B错</p>
<p>参考答案C</p>
<p>\24. 使用Sqoop导入到Hive时，如果没有指定Hive表名会怎么样？</p>
<p>A.报错，必须指定表名</p>
<p>B.默认会在Hive中创建和MySQL同名的数据库和表</p>
<p>C.默认会在Hive中创建和MySQL同名的表，数据库需要另外指定</p>
<p>D.以上都不对</p>
<p>参考答案C</p>
<p>\25. sqoop导入到Hive的数据。默认的行分隔符为？</p>
<p>A.”,”</p>
<p>B.”\t”</p>
<p>C.”\001”</p>
<p>D.”\012”</p>
<p>参考答案D</p>
<p>\26. sqoop导入到Hive的数据。默认的列分隔符为？</p>
<p>A.”,”</p>
<p>B.”\t”</p>
<p>C.”\012”</p>
<p>D.”\001”</p>
<p>参考答案D</p>
<p>\27. Sqoop导入命令中，如何修改字段分隔符为制表符？</p>
<p>A.—fields-terminated-by = ‘\t’</p>
<p>B.—fields-terminated-by ‘\t’</p>
<p>C.—fields-terminated-by = ‘/t’</p>
<p>D.—fields-terminated-by ‘/t’</p>
<p>参考答案B</p>
<p>\28. Sqoop导入数据的方式有？</p>
<p>A.全量导入</p>
<p>B.增量导入</p>
<p>C.部分导入</p>
<p>D.以上都对</p>
<p>参考答案D</p>
<p>\29. sqoop导入到HDFS中的所有记录存储为____格式。</p>
<p>A.二进制</p>
<p>B.十六进制</p>
<p>C.文本格式</p>
<p>D.以上都不对</p>
<p>参考答案C</p>
<p>\30. Sqoop Import 命令中如果没有制定 -m 或者 —num-mappers 参数，则默认的mapper任务数量为？</p>
<p>A.1</p>
<p>B.2</p>
<p>C.3</p>
<p>D.4</p>
<p>参考答案D</p>
<p>31.使用Sqoop还可以 ____ ?</p>
<p>A.列出关系型数据库的所有数据库</p>
<p>B.列出关系型数据库的某个数据库下的所有表</p>
<p>C.连接关系型数据库并执行SQL语句</p>
<p>D.以上都是</p>
<p>参考答案D</p>
<p>\32. 在Linux系统中配置Sqoop环境变量的方式正确的是 ？</p>
<p>A.export SQOOP_HOME=/home/soft/sqoop-1.4.6.bin_hadoop-2.0.4-alpha</p>
<p>export $PATH=$PATH:$SQOOP_HOME/bin</p>
<p>B.export $SQOOP_HOME=/home/soft/sqoop-1.4.6.bin_hadoop-2.0.4-alpha</p>
<p>export PATH=$PATH:$SQOOP_HOME/bin</p>
<p>C.export SQOOP_HOME=/home/soft/sqoop-1.4.6.bin_hadoop-2.0.4-alpha</p>
<p>export PATH=PATH:$SQOOP_HOME/bin</p>
<p>D.export SQOOP_HOME=/home/soft/sqoop-1.4.6.bin_hadoop-2.0.4-alpha</p>
<p>export PATH=$PATH:$SQOOP_HOME/bin</p>
<p>回答错误，得分 0</p>
<p>参考答案D</p>
<p>\33. 关于Apache Sqoop 的版本说法正确的是 ？</p>
<p>A.只有 Sqoop 1 可以用于生产环境</p>
<p>B.只有 Sqoop 2 可以用于生产环境</p>
<p>C.Sqoop 1 和 Sqoop 2 都可以用于生产环境</p>
<p>D.Sqoop 1 和 Sqoop 2 都不可以用于生产环境</p>
<p>参考答案A</p>
<p>\34. 使用Sqoop工具将MySQL数据传送到HDFS文件系统应该使用什么命令 ？</p>
<p>A.sqoop import</p>
<p>B.sqoop export</p>
<p>C.sqoop transfer</p>
<p>D.sqoop transport</p>
<p>参考答案A</p>
<p>\35. 下面哪个选项是属于Sqoop import ？</p>
<p>A.将HBase数据库中的数据转存到Hive表中</p>
<p>B.将Storm中拓扑处理的数据持久化到HBase数据库中</p>
<p>C.将MongoDB数据库中的数据传输到HDFS文件系统</p>
<p>D.将Oracle数据库中的数据保存到Hive表中</p>
<p>参考答案D</p>
<p>\36. Apache Sqoop 是一款<strong><strong>的工具，主要用于数据的</strong></strong>？</p>
<p>A.闭源、采集</p>
<p>B.开源、采集</p>
<p>C.闭源、传输</p>
<p>D.开源、传输</p>
<p>参考答案D</p>
<p>\37. 选出不属于RDBMS的数据库</p>
<p>A.MySQL</p>
<p>B.MongoDB</p>
<p>C.Redis</p>
<p>D.HBase</p>
<p>参考答案BCD</p>
<p>\38. sqoop import 包括从<strong><strong>到</strong></strong></p>
<p>A.HBase -&gt; HDFS</p>
<p>B.Hive -&gt; HDFS</p>
<p>C.MySQL -&gt; HIVE</p>
<p>D.Oracle -&gt; HDFS</p>
<p>参考答案CD</p>
<p>\39. Sqoop工具中最核心的是<strong><strong>和_</strong></strong></p>
<p>A.import</p>
<p>B.export</p>
<p>C.job</p>
<p>D.help</p>
<p>参考答案AB</p>
<p>\40. 增量导入必须指定last-value属性值</p>
<p>对</p>
<p>错</p>
<p>参考答案对</p>
<p>41.MySQL表用SQOOP传输到HDFS后默认字段分割符号是逗号</p>
<p>对</p>
<p>错</p>
<p>参考答案对</p>
<p>\42. 导入HDFS操作时，可以同时指定target-dir和warehouse-dir属性。</p>
<p>对</p>
<p>错</p>
<p>参考答案错</p>
<p>\43. 使用sqoop job工具，命令如下，可以立即执行一个导入操作。</p>
<p>sqoop job —create sqoopimport1 — import —connect jdbc:mysql:</p>
<p>对</p>
<p>错</p>
<p>参考答案错</p>
<p>\44. Sqoop工具适用于数据库管理员、数据分析师和数据工程师。</p>
<p>对</p>
<p>错</p>
<p>参考答案对</p>
<p>\45. Sqoop可以用于关系型数据库之间的数据传输。</p>
<p>对</p>
<p>错</p>
<p>参考答案错</p>
<p>\46. Sqoop导入命令中使用<strong><strong><strong>___</strong></strong></strong>属性可以修改字段分隔符</p>
<p>参考答案—fields-terminated-by</p>
<p>\47. HIVE表的默认字段分隔符是”_”，Hive表的默认记录分隔符是”_”</p>
<p>47.1</p>
<p>参考答案\001;CTRL+A;SOH;^A</p>
<p>47.2</p>
<p>参考答案\012;\N;\n</p>
<p>\48. Sqoop import 工具指定数据传输到HDFS的目标路径用<strong><strong>_</strong></strong>属性。</p>
<p>参考答案—target-dir</p>
<p>49.SQOOP传输数据到HDFS时，如果需要预先清空目标路径再执行数据传输可以使用<strong><strong>__</strong></strong>属性</p>
<p>参考答案—delete-target-dir</p>
<p>\50. Apache Sqoop 是一款<strong><strong>的工具，主要用于数据的</strong></strong></p>
<p>50.1</p>
<p>参考答案开源;开放源代码</p>
<p>50.2</p>
<p>参考答案传输;导入导出</p>
]]></content>
      <tags>
        <tag>sqoop</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop - 面试题</title>
    <url>/2021/08/03/hadoop-%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1-MapReduce优化"><a href="#1-MapReduce优化" class="headerlink" title="1. MapReduce优化"></a>1. MapReduce优化</h2><h3 id="1-跑得慢的原因"><a href="#1-跑得慢的原因" class="headerlink" title="1. 跑得慢的原因"></a>1. 跑得慢的原因</h3><p>Mapreduce的瓶颈在于两点：</p>
<span id="more"></span>
<p>（1）计算机性能：CPU、内存、磁盘健康、网络等。</p>
<p>（2）I/O操作：数据倾斜、Map和Reduce数设置不合理、Map运行时间太长导致Reduce等待过久、小文件过多、大量的不可分块的超大文件、spill次数过多、Merge次数过多等。</p>
<h3 id="2-具体的优化方法"><a href="#2-具体的优化方法" class="headerlink" title="2. 具体的优化方法"></a>2. 具体的优化方法</h3><p>主要从六个方面考虑：数据输入、Map阶段、Reduce阶段、IO传输、数据倾斜问题和常用的调优参数。</p>
<h4 id="1）数据输入"><a href="#1）数据输入" class="headerlink" title="1）数据输入"></a>1）数据输入</h4><p>（1）合并小文件：在执行MR任务前将小文件进行合并，大量的小文件会产生大量的Map任务，增大Map任务装载次数，而任务的装载比较耗时，从而导致MR运行较慢。</p>
<p>（2）采用CombineTextInputFormat来作为输入，解决输入端大量小文件场景。</p>
<h4 id="2）Map阶段"><a href="#2）Map阶段" class="headerlink" title="2）Map阶段"></a>2）Map阶段</h4><p>（1）减少溢写(Spill)次数：通过调整io.sort.mb及sort.spill.percent参数值，增大触发Spill的内存上限，减少Spill次数，从而减少磁盘IO。</p>
<p>（2）减少合并(Merge)次数：通过调整io.sort.factor参数，增大Merge的文件数目，减少Merge的次数，从而缩短MR处理时间。</p>
<p>（3）在Map之后，不影响业务逻辑前提下，先进行Conbine处理，减少IO。</p>
<h4 id="3）Reduce阶段"><a href="#3）Reduce阶段" class="headerlink" title="3）Reduce阶段"></a>3）Reduce阶段</h4><p>（1）合理设置Map和Reduce数：两个都不能设置太少，也不能设置太多。太少，会导致Task等待，延长处理时间；太多，会导致Map、Reduce任务间竞争资源，造成处理超时等错误。</p>
<p>（2）设置Map、Redce共存：调整slowstart.completedmaps参数，使Map运行到—定程度后，Recuce也开始运行，减少Reduce的等待时间。</p>
<p>（3）规避使用Reduce：因为Reduce在用于连接数据集的时候将会产生大量的网络消耗。</p>
<p>（4）合理设置Reduce端的Buffer：默认情况下，数据达到一个阈值的时候，Buffer中的数据就会写入磁盘，然后Recuce会从磁盘中获得所有的数据。也就是说，Buffer和Recuce是没有直接关联的，中间多次写磁盘-&gt;读磁盘的过程，既然有这个弊端，那么就可以通过参数来配置，使得Buffer中的一部分数据可以直接输送到Reduce，从而减少Io开销：mapreduce.reduce.input.buffer.percent，默认为0.0。当值大于0的时候，会保留指定比例的内存读Buffer中的数据直接拿给Recuce使用。但是这样一来，设置Buffer需要内存，读取数据需要内存，Recuce计算也要内存，所以要根据作业的运行情况进行调整。</p>
<h4 id="4）IO传输"><a href="#4）IO传输" class="headerlink" title="4）IO传输"></a>4）IO传输</h4><p>（1）采用数据压缩的方式，减少网络Io的的时间。安装Snappy和LZo压缩编码器。</p>
<p>（2）使用SequenceFile二进制文件。</p>
<h4 id="5）数据倾斜"><a href="#5）数据倾斜" class="headerlink" title="5）数据倾斜"></a>5）数据倾斜</h4><p><strong>（1）数据倾斜现象</strong><br>大量的相同key被分配到一个分区里，map /reduce程序执行时，reduce节点大部分执行完毕，但是有一个或者几个reduce节点运行很慢，导致整个程序的处理时间很长。<br><strong>（2）减少数据倾斜的方法</strong><br>方法1∶抽样和范围分区</p>
<p>可以通过对原始数据进行抽样得到的结果集来预设分区边界值。</p>
<p>方法2：自定义分区</p>
<p>基于输出键的背景知识进行自定义分区。</p>
<p>例如，如果Map输出键的单词来源于一本书。且其中某几个专业词汇较多。那么就可以自定义分区将这这些专业词汇发送给固定的一部分Reduce实例。而将其他的都发送给剩余的Reduce实例。</p>
<p>方法3：Combine<br>使用Combine可以大量地减小数据倾斜。在可能的情况下，Combine的目的就是聚合并精简数据。</p>
<p>方法4：采用Map Join，尽量避免Reduce Join。</p>
<h4 id="6）常见的调优参数"><a href="#6）常见的调优参数" class="headerlink" title="6）常见的调优参数"></a>6）常见的调优参数</h4><p>mapreduce中比如有 <code>mapreduce.map.cpu.vcores</code> 设置每个MapTask可使用的最多cpu core数目，默认值: 1；</p>
<p>yarn中比如有 <code>yarn.scheduler.minimum-allocation-vcores</code> 设置每个Container申请的最小CPU核数，默认值：1；</p>
<p>shuffle中比如有 <code>mapreduce.map.sort.spill.percent</code> 设置环形缓冲区溢出的阈值，默认80%；</p>
<p>容错相关系数比如有 <code>mapreduce.map.maxattempts</code> 设置每个Map Task最大重试次数，一旦重试参数超过该值，则认为Map Task运行失败，默认值：4。</p>
<h2 id="2-yarn怎么保证高可用？"><a href="#2-yarn怎么保证高可用？" class="headerlink" title="2. yarn怎么保证高可用？"></a>2. yarn怎么保证高可用？</h2><p>YARN的高可用:<br>ResourceManager：基于Zookeeper 实现高可用机制，避免单点故障。</p>
<p>NodeManager：执行失败之后，ResourceManager将失败任务告诉对应的ApplicationMaster ，由ApplicationMaster来决定如何处理失败的任务。</p>
<p>ApplicationMaster：执行失败之后，由ResourceManager负责重启；ApplicationMaster需处理内部的容错问题，并保存已经运行完成的Task ,重启后无需重新运行。</p>
<h2 id="3-HDFS小文件处理"><a href="#3-HDFS小文件处理" class="headerlink" title="3. HDFS小文件处理"></a>3. HDFS小文件处理</h2><ol>
<li>影响<br>每个文件在HDFS中均分为多个块进行存储，每个块的元数据信息都保存在NameNode中，因此HDFS存储小文件会非常低效。因为大量的小文件产生的大量元数据信息会占用NameNode的大部分内存，甚至会耗尽内存，存储小文件所需要的磁盘容量和数据块的大小无关，一个文件至少会需要一个块存储。假设有一个小文件为1M，存储进一个块中，这个块的其余127M也不能存储其他文件。</li>
<li>解决方法<br>对于小文件问题，有三种解决方案：har、sequencefile和combinefileinputformat。<br>1）har：har是一个高效的将小文件放入hdfs块的文件存档工具，它能将多个小文件打包成一个har文件，以减少namenode内存使用，它允许对文件进行透明访问；<br>2）sequence file：以文件名为key，文件内容为value，这样就可以将多个小文件以key-value的形式合并为一个大文件；<br>3）combinefileinputformat：是一种新的inputformat，用于将多个文件合并为一个split，它也会考虑数据的存储位置。</li>
</ol>
<h2 id="4-Map-Join-和-Reduce-Join"><a href="#4-Map-Join-和-Reduce-Join" class="headerlink" title="4. Map Join 和 Reduce Join"></a>4. Map Join 和 Reduce Join</h2><p>reduce join是在map阶段完成数据的标记，在reduce阶段完成数据的合并；</p>
<p>map join是直接在map阶段完成数据的合并，没有reduce阶段。</p>
<p>Reduce Join的缺陷：</p>
<p>1、合并的任务在reduce端执行，reduce端处理压力大，而map端负载很低，资源利用率不高。<br>2、容易产生数据倾斜。</p>
<p>Map Join没有reduce过程，所有的工作都在map阶段完成，极大减少了网络传输和io的代价。它适用于一张小表的一张大表进行join操作。</p>
<h2 id="5-Hadoop组成架构"><a href="#5-Hadoop组成架构" class="headerlink" title="5. Hadoop组成架构"></a>5. <strong>Hadoop组成架构</strong></h2><ol>
<li><p>版本区别：</p>
<p>1.x包括辅助工具、hdfs数据存储、mapreduce进行计算和资源调度；</p>
<p>2.x与1.x版本大致相同，唯一的区别在于将mapreduce的任务一分为二，mapreduce继续负责进行计算，资源调度由yarn负责；</p>
<p>3.x版本在组成上与2.x版本没有区别。</p>
</li>
<li><p>hdfs组成：</p>
<p>（1） NameNode(m)：存储文件的元数据，如文件名，文件目录结构，文件属性（生成时间、副本数、文件权限），以及每个文件的块列表和块所在的DataNode等。</p>
<p>（2）DataNode(dn)：在本地文件系统存储文件块数据，以及块数据的校验和。</p>
<p>（3）Secondary NameNode(2nn)：用来监控HDFS状态的辅助后台程序，每隔一段时间从namenode对元数据进行备份。</p>
</li>
<li><p>yarn组成：</p>
<p>YARN 主要由 ResourceManager、NodeManager、ApplicationMaster 和 Container 等组件构成。</p>
<p>1）ResourceManager ( RM )主要作用如下：<br>（1）处理客户端请求；</p>
<p>（2）监控NodeManager；</p>
<p>（3）启动或监控ApplicationMaster；</p>
<p>（4）资源的分配与调度。</p>
<p>2）NodeManager ( NM）主要作用如下：<br>（1）管理单个节点上的资源；</p>
<p>（2）处理来自ResourceManager的命令；</p>
<p>（3）处理来自ApplicationMaster的命令。</p>
<p>3）ApplicationMaster ( AM )作用如下：<br>（1）负责数据的切分；</p>
<p>（2）为应用程序申请资源并分配给内部的任务；</p>
<p>（3）任务的监控与容错。</p>
<p>4）Container<br>Container是YARN中的资源抽象，它封装了某个节点上的多维度资源，如内存、CPu、磁盘网络等。</p>
</li>
<li><p>mr组成</p>
<p>Hadoop MapReduce采用Master/Slave（M/S）架构，主要包括以下组件：Client、JobTracker、TaskTracker和Task。</p>
<p>（1）Client<br>  用户编写的MapReduce程序通过Client提交到JobTracker端；同时，用户可通过Client提供的一些接口查看作业运行状态。在Hadoop内部用“作业”（Job）表示MapReduce程序。一个MapReduce程序可对应若干个作业，而每个作业会被分解成若干个Map/Reduce任务（Task）。</p>
<p>(2)JobTracker的主要功能：<br>  负责作业的分解和状态监控。 最重要的是状态监控：主要包括TaskTracker状态监控、作业状态监控和任务状态监控。主要作用：容错和为任务调度提供决策依据。</p>
<p>（3）TaskTracker：<br>  与JobTarcker保持通信，执行JobTracker分配的任务，监控节点健康情况、资源使用情况以及任务执行进度、任务运行状态等。</p>
<p>（4）Task<br>  Task分为Map Task和Reduce Task两种，均由TaskTracker启动。我们知道，HDFS以固定大小的block为基本单位存储数据，而对于MapReduce而言，其处理单位是split。split是一个逻辑概念，它只包含一些元数据信息，比如数据起始位置、数据长度、数据所在节点等。它的划分方法完全由用户自己决定。但需要注意的是，split的多少决定Map Task的数目，因为每个split会交由一个Map Task处理。</p>
</li>
<li><p>三者关系的简述</p>
<p>客户端将任务提交到RM，RM到某个NM下启动一个container，并在该container内放置传输的AM；接着AM向RM申请资源，RM返回相应的资源列表，然后AM启动这些对应的资源，这些资源在对应的DN上处理相应的任务，这部分称为maptask，maptask处理完后，将所有maptask的结果传输到reduce端执行，最终将reduce端的结果对应的元数据信息传输到namenode中；2NN会每隔一段时间对NM的元数据进行备份。</p>
</li>
</ol>
<h2 id="6-Yarn工作机制"><a href="#6-Yarn工作机制" class="headerlink" title="6. Yarn工作机制"></a>6. Yarn工作机制</h2><p>Yarn是典型的<code>master-slave</code>架构，<code>master</code>称为<code>ResourceManager(RM)</code>，<code>slave</code>称为<code>NodeManager(NM)</code>。<br>RM负责接收用户提交的任务，并且决定为任务分配多少资源和调度到哪个NM执行；NM是真正执行任务的节点，周期性地向RM汇报自己的资源使用情况并领取分配的任务，负责启动和停止任务相关的进程等工作。</p>
<h3 id="具体工作流程如下："><a href="#具体工作流程如下：" class="headerlink" title="具体工作流程如下："></a>具体工作流程如下：</h3><p>（1）用户使用客户端向Yarn提交应用程序，其中包括ApplicationMaster(AM)程序、启动ApplicationMaster的命令、用户程序、环境变量、作业信息、文件位置等；<br>（2）ResourceManager(RM)为该应用程序分配第一个container，并与对应的NodeManager(NM)通过心跳的方式通信，要求它在这个container中启动应用程序的AM；<br>（3）AM首先向RM注册，这样用户之间可以通过RM查看应用程序的运行状态，然后它将为各个任务申请资源，并监控它的运行状态，直到运行结束；<br>（4）AM采用轮询的方式通过RPC协议向RM申请和领取资源；<br>（5）一旦AM领取到资源，便与对应的NM通信，要求它启动任务；<br>（6）NM为任务设置好运行环境，将任务启动命令写入脚本，通过运行该脚本启动任务；<br>（7）各个任务可以通过RPC协议向AM汇报自己的状态和进度，以让AM随时掌握各个任务的运行状态，从而可以在任务失败时重启任务，在应用程序运行过程中，用户可以随时通过RPC向AM查询应用程序的当前运行状态；<br>（8）应用程序运行完成后，AM向RM注销并关闭自己。</p>
<h2 id="7-Yarn提交作业流程"><a href="#7-Yarn提交作业流程" class="headerlink" title="7. Yarn提交作业流程"></a>7. Yarn提交作业流程</h2><p><strong>1.1、客户端提交作业申请</strong></p>
<p>1.1.1、客户端向ResourceManager（后续简称RM）提交作业申请。</p>
<p>1.1.2、RM根据申请内容返回相关的信息（例如根据input的路径，返回对应的文件元数据，还有作业资源的提交路径）。</p>
<p>1.1.3、客户端根据RM返回的信息生成资源文件（job.split、job.xml、app.jar）并将资源文件提交至提交路径（一般存放在hdfs上）</p>
<p>1.14、资源文件提交完毕，向RM申请运行applicationMaster（后续简称AM）。</p>
<p><strong>1.2、RM处理用户请求</strong></p>
<p>1.2.1、RM将用户的请求打包为task，放置调度队列，根据当前yarn的调度模式进行调度（YARN提供的三种任务调度策略：FIFO Scheduler，Capacity Scheduler 和 Fair Scheduler）。</p>
<p><strong>1.3、NodeManager（后续简称NM）从队列中获取task。</strong></p>
<p>1.3.1、创建contianer容器启动AM。</p>
<p>1.3.2、下载资源文件。</p>
<p><strong>1.4、AM向RM申请运行mapTask容器，RM将请求再打包为task放置调度队列。</strong></p>
<p>1.4.1、其它NM获取到task后会再创建contianer容器并下载资源文件，contianer中的mapTask任务由AM负责监控和调度。</p>
<p><strong>1.5、AM向maptask发送程序启动命令。</strong></p>
<p><strong>1.6、contianer运行mapTask</strong></p>
<p>1.6.1、当各节点mapTask运行完毕后，AM重复3.4的步骤（这次申请运行reduceTask）。</p>
<p><strong>1.7、程序运行完成后，AM向RM注销自己。</strong></p>
<h3 id="8-hadoop解决哪些问题，有哪些特性"><a href="#8-hadoop解决哪些问题，有哪些特性" class="headerlink" title="8. hadoop解决哪些问题，有哪些特性"></a>8. hadoop解决哪些问题，有哪些特性</h3><ol>
<li><p>主要用于解决海量数据的存储和分析计算的问题。</p>
</li>
<li><p>特性有如下四个：</p>
<p>（1）高可靠性：hadoop底层维护多个数据副本，即使某个节点的计算出现问题活存储出现故障，数据也不会丢失；</p>
<p>（2）高扩展性：可以在集群间分配任务数据，以方便的扩展出多个节点；</p>
<p>（3）高效性：在mapreduce的思想中，hadoop是并行工作的，这就提高了任务的处理效率；</p>
<p>（4）高容错性：可以自动讲运行失败的任务重新分配到新的节点运行。</p>
</li>
</ol>
<h3 id="9-请简述mapreduce中的combine、partition和shuffle的作用。"><a href="#9-请简述mapreduce中的combine、partition和shuffle的作用。" class="headerlink" title="9. 请简述mapreduce中的combine、partition和shuffle的作用。"></a>9. <strong>请简述mapreduce中的combine、partition和shuffle的作用。</strong></h3><ol>
<li><p>combine</p>
<p>​        combine分为map端和reduce端，作用是把同一个key的键值对合并在一起，可以自定义的。<br>​        combine函数把一个map函数产生的<key,value>对（多个key,value）合并成一个新的<key2,value2>.将新的<key2,value2>作为输入到reduce函数中，这个value2亦可称之为values，因为有多个。</p>
<p>​        这个合并的目的是为了减少网络传输。</p>
</li>
<li><p>partition</p>
<p>​        partition是分割map每个节点的结果，按照key分别映射给不同的reduce，也是可以自定义的。这里其实可以理解归类。<br>​        我们对于错综复杂的数据归类。比如在动物园里有牛羊鸡鸭鹅，他们都是混在一起的，但是到了晚上他们就各自牛回牛棚，羊回羊圈，鸡回鸡窝。partition的作用就是把这些数据归类。</p>
</li>
<li><p>shuffle</p>
<p>​        shuffle就是map和reduce之间的过程，包含了两端的combine和partition。</p>
<p>​        Map的结果，会通过partition分发到Reducer上，Reducer做完Reduce操作后，通过OutputFormat，进行输出；</p>
<p>​        shuffle阶段的主要函数是fetchOutputs(),这个函数的功能就是将map阶段的输出，copy到reduce 节点本地。</p>
</li>
</ol>
<h3 id="10-reduce和mapreduce中的reduce区别是什么"><a href="#10-reduce和mapreduce中的reduce区别是什么" class="headerlink" title="10. reduce和mapreduce中的reduce区别是什么"></a>10. reduce<strong>和map</strong>reduce<strong>中的</strong>reduce区别是什么</h3><p><strong>在mapreduce中，map多，reduce少。</strong><br><strong>在reduce中由于数据量比较多，所以干脆，我们先把自己map里面的数据归类，这样到了reduce的时候就减轻了压力。</strong></p>
<p><strong>这里举个例子：</strong><br><strong>map与reduce的例子</strong><br><strong>map理解为销售人员，reduce理解为销售经理。</strong><br><strong>每个人（map）只管销售,赚了多少钱销售人员不统计，也就是说这个销售人员没有**</strong>Combine，那么这个销售经理就累垮了，因为每个人都没有统计，它需要统计所有人员卖了多少件，赚钱了多少钱。<strong>
</strong>这样是不行的，所以销售经理（reduce）为了减轻压力，每个人（map）都必须统计自己卖了多少钱，赚了多少钱（<strong><strong>Combine</strong></strong>），<strong><strong>然后经理所做的事情就是统计每个人统计之后的结果。这样经理就轻松多了。所以</strong></strong>Combine在map所做的事情，减轻了reduce的事情。**</p>
<h3 id="11-MapTask工作机制"><a href="#11-MapTask工作机制" class="headerlink" title="11. MapTask工作机制"></a>11. <strong>MapTask工作机制</strong></h3><p>分为5个阶段：</p>
<p>Read阶段：<br>对于待处理的文本，客户端submit()前，获取待处理数据的信息，然后根据参数配置，形成一个分配的规划（处理切片信息） ；之后提交信息（切片、jar包、xml信息）到集群，集群启动相应的MrAppMaster，计算出MapTask数量，开启相应的MapTask；默认用TextInputFormat去读待处理文本中一行行的数据；</p>
<p>Map阶段：<br>读取完待处理文本中的数据后，返回相应的<k,v>数据，并将数据写入到Mapper里面进行业务逻辑运算；</p>
<p>Collect阶段：<br>从Map阶段写出的<k,v>数据，调用partitioner进行分区和针对key进行排序（方法：快速排序，默认按照字典顺序排序），并写入到环形缓冲区（内存缓冲区）；</p>
<p>溢写阶段：<br>从环形缓冲区不断溢出到本地磁盘文件；</p>
<p>Combiner阶段：<br>可能会溢出多个文件（分区且区内有序），多个溢出文件会被合并（归并排序）成大的溢出文件，在溢出过程及合并的过程中，都要调用Partitioner进行分区和针对key进行排序。</p>
<h3 id="12-ReduceTask工作机制"><a href="#12-ReduceTask工作机制" class="headerlink" title="12. ReduceTask工作机制"></a>12. <strong>ReduceTask工作机制</strong></h3><p>包括4个阶段。</p>
<p>Copy阶段：<br>MapTask结束后，Reduce Task需要拷贝根据自己的分区号对应Map Task机器上的结果分区数据；</p>
<p>Merge阶段：<br>Reduce Task会取到同一个分区的来自不同MapTask的结果文件，Reduce Task会将这些文件再进行合并；</p>
<p>Sort阶段：<br>使用归并排序方法合并文件，合并成大文件后（到这里Shuffle过程结束），将相同key的数据拷贝到一个reduce方法里面去；</p>
<p>Reduce阶段：<br>进入Reduce Task进行逻辑运算（从文件中取出一个一个的键值对Group，调用用户自定义的reduce()方法）；</p>
<p>最后默认通过TextOutputFormat输出数据。</p>
<h3 id="13-HDFS数据读取和写入流程"><a href="#13-HDFS数据读取和写入流程" class="headerlink" title="13. HDFS数据读取和写入流程"></a>13. <strong>HDFS数据读取和写入流程</strong></h3><ol>
<li><p><strong>HDFS中的block、packet、chunk</strong></p>
<p>要把读写过程细节搞明白前，必须知道block、packet与chunk。下面分别讲述：</p>
<p>（1）block：文件上传前需要分块，这个块就是block，一般为128MB，当然你可以去改，不过不推荐。因为块太小：寻址时间占比过高。块太大：Map任务数太少，作业执行速度变慢。它是最大的一个单位。</p>
<p>（2）packet：packet是第二大的单位，它是client端向DataNode，或DataNode的PipLine之间传数据的基本单位，默认64KB。</p>
<p>（3）chunk：chunk是最小的单位，它是client向DataNode，或DataNode的PipLine之间进行数据校验的基本单位，默认512Byte，因为用作校验，故每个chunk需要带有4Byte的校验位。所以实际每个chunk写入packet的大小为516Byte。由此可见真实数据与校验值数据的比值约为128 : 1。（即64*1024 / 512）</p>
<p>例如，在client端向DataNode传数据的时候，HDFSOutputStream会有一个chunk buff，写满一个chunk后，会计算校验和并写入当前的chunk。之后再把带有校验和的chunk写入packet，当一个packet写满后，packet会进入dataQueue队列，其他的DataNode就是从这个dataQueue获取client端上传的数据并存储的。同时一个DataNode成功存储一个packet后之后会返回一个ack packet，放入ack Queue中。</p>
</li>
<li><h4 id="写流程"><a href="#写流程" class="headerlink" title="写流程"></a>写流程</h4><ol>
<li>客户端通过Distributed File System 向 NameNode 请求上传文件，NameNode检查目标文件及其路径是否存在，然后返回给分布式文件系统是否上传；</li>
<li>客户端向NameNode询问，第一个block将上传到哪个DataNode服务器，NameNode返回三个DataNode节点，分别是dn1、dn2、dn3；（默认需要备份三个）</li>
<li>客户端通过FSDataOutputStream向dn1请求建立Block传输通道，dn1将请求传递给dn2，dn2传递给dn3，然后从dn3开始逐一向上应答，将传输管道建成；</li>
<li>客户端开始向dn1传输第一个block（注：客户端将需要传输的内容分成多个block，一个block0-128M），dn1以packet为单位，每收到packet数量的数据就会将内容传递给dn2，dn2再传递给dn3，每传一个packet会放入一个应答队列等待应答，此处一个packet一个应答队列；</li>
<li>当一个block传输完成后，客户端再向NameNode请求上传第二个block。</li>
</ol>
</li>
<li><p><strong>读流程</strong></p>
<ol>
<li>客户端通过Distributed File System向NameNode请求下载文件 ，NameNode通过查询元数据，返回block所在的DataNode地址；</li>
<li>客户端挑选一个DataNode（先就近原则，然后随机）服务器，请求读取数据；</li>
<li>DataNode开始传输数据给客户端（从磁盘里面读取数据输入流，以packet为单位校验），客户端以packet为单位接收，先在本地缓存，然后写入目标文件。</li>
</ol>
</li>
</ol>
<h3 id="14-ETL的几个过程分别是什么？"><a href="#14-ETL的几个过程分别是什么？" class="headerlink" title="14. ETL的几个过程分别是什么？"></a>14. <strong>ETL的几个过程分别是什么？</strong></h3><p>ETL是Extract Transform Load三个英文单词的缩写，中文意思就是抽取、转换、加载。说到ETL就必须提到数据仓库，ETL负责完成数据从数据源向目标数据仓库转化的过程，是实施数据仓库的重要步骤。<br>构建数据仓库的核心是建模，在数据仓库的构建中，ETL贯穿于项目始终，它是整个数据仓库的生命线。从数据源中抽取数据，然后对这些数据进行转化，最终加载到目标数据库或者数据仓库中去，这就是ETL 过程。<br>通常数据抽取工作分抽取、清洗、转换、装载几个步骤：</p>
<p>抽取主要是针对各个业务系统及不同服务器的分散数据，充分理解数据定义后，规划需要的数据源及数据定义，制定可操作的数据源，制定增量抽取和缓慢渐变的规则。</p>
<p>清洗主要是针对系统的各个环节可能出现的数据二义性、重复、不完整、违反业务规则等数据质量问题，允许通过数据抽取设定的数据质量规则，将有问题的记录先剔除出来，根据实际情况调整相应的清洗操作。</p>
<p>转换主要是针对数据仓库建立的模型，通过一系列的转换来实现将数据从业务模型到分析模型，通过ETL工具可视化拖拽操作可以直接使用标准的内置代码片段功能、自定义脚本、函数、存储过程以及其他的扩展方式，实现了各种复杂的转换，并且支持自动分析日志，清楚的监控数据转换的状态并优化分析模型。</p>
<p>装载主要是将经过转换的数据装载到数据仓库里面，可以通过直连数据库的方式来进行数据装载，可以充分体现高效性。在应用的时候可以随时调整数据抽取工作的运行方式，可以灵活的集成到其他管理系统中。</p>
<h3 id="15-hadoop的二级排序"><a href="#15-hadoop的二级排序" class="headerlink" title="15. hadoop的二级排序"></a>15. hadoop的二级排序</h3><p>即对key和value双排序。默认情况下，Map输出的结果会对Key进行默认的排序，但是有时候需要对Key排序的同时还需要对Value进行排序，这时候就要用到二次排序了。<br>有两种方法进行二次排序，分别为：buffer and in memory sort和 value-to-key conversion。<br>1、buffer and in memory sort<br>在reduce()函数中，将某个key对应的所有value保存到内存中，然后进行排序。 这种方法最大的缺点是：可能会造成out of memory。<br>2、value-to-key conversion<br>MapReduce程序中，Mapper输出的键值对会经历shuffle过程再交给 Reducer。在shuffle阶段，Mapper输出的键值对会经过partition(分区)-&gt;sort(排序)-&gt;group(分组) 三个阶段。<br>将key和部分value拼接成一个组合key，这样reduce获取的结果便是先按key排序，后按value排序的结果，需要注意的是，用户需 要自己实现Paritioner，以便只按照key进行数据划分。Hadoop显式的支持二次排序，在Configuration类中有setSotComparatorClass()方法可以对key值进行处理，setGroupingComparatorClass()方法对相同key的value值进行处理。<br>shuffle 的 sort 过程会根据键值对<key, value>的 key 进行排序，但是二次排序中，value 也是需要排序的字段。因此需要将 value 字段合并到 key 中作为新的 key，形成新的键值对<key#value, value>。在排序时使其先根据 key 排序，如果相同，再根据 value 排序。</p>
<h3 id="16-为什么HDFS文件块的大小不能设置太小，也不能设置太大？"><a href="#16-为什么HDFS文件块的大小不能设置太小，也不能设置太大？" class="headerlink" title="16. 为什么HDFS文件块的大小不能设置太小，也不能设置太大？"></a>16. 为什么HDFS文件块的大小不能设置太小，也不能设置太大？</h3><p>HDFS的文件在物理上是分块存储的，块的大小可以通过配置参数dfs.blocksize来决定，默认情况下，hadoop2为128M，hadoop1为64M。<br>（1）如果块太小，会增加寻址的时间，程序会一直在找块的位置；<br>（2）如果块太大，以至于从磁盘传输数据的时间明显大于定位开始位置的时间，会导致程序在处理这块数据时会很慢。</p>
<h3 id="17-NameNode和SecondaryNameNode机制"><a href="#17-NameNode和SecondaryNameNode机制" class="headerlink" title="17. NameNode和SecondaryNameNode机制"></a>17. NameNode和SecondaryNameNode机制</h3><h4 id="（1）引入"><a href="#（1）引入" class="headerlink" title="（1）引入"></a>（1）引入</h4><p>首先我们知道NameNode是用来存放元数据信息的，当元数据存储在NameNode节点的磁盘中，因为经常需要被访问、响应客户需求等，会使得NameNode的效率变低；当仅存储在内存中，如果断电，元数据将来不及保存。于是引出了fsImage，将元数据存储在内存，再备份到磁盘的fsImage。<br>但是上述又会带来新的问题，当内存的元数据更新，fsImage也会随之更新，会导致效率变低，如果不更新，又会导致一致性问题，一旦NameNode断电，就会导致数据丢失。因此引入了edits文件，只进行追加操作，效率就会变得很高。每当元数据有更新变动就会将信息追加到edits文件中，这样，当断电时就可以将fsImage中的内容与edits中的内容进行合并，变成完整的元数据信息。<br>但是这种合并需要定期进行，否则，长期将数据存放在edits，使其数据量过大也会导致效率过低，且一旦断电，二者合并的时间也会过长（因为Edits数据量太大）。如果使用NN执行定期合并的操作，会增加它的工作量，使其效率变低。因此，引入2NN执行定期合并FsImage和Edits的操作。</p>
<h4 id="（2）工作机制"><a href="#（2）工作机制" class="headerlink" title="（2）工作机制"></a>（2）工作机制</h4><p>分为两个阶段： 第一个阶段，NN的工作：<br>（1）第一次启动NameNode，格式化后，创建FsImage和Edits文件；如果不是第一次，直接加载二者到内存。<br>（2）客户端对元数据进行增删改的请求。<br>（3）NN记录操作日志，更新滚动日志。<br>（4）NN在内存中对元数据进行增删改。<br>第二个阶段，2NN的工作：<br>（1）询问NN是否需要CheckPoint。返回是否检查的结果。<br>（2）2NN请求执行CheckPoint。<br>（3）NN滚动正在写的Edits日志，将滚动前的FsImage和Edits拷贝到2NN。<br>（4）2NN加载二者到内存并合并。<br>（5）生成新的fsimage.chkpoint。<br>（6）将fsimage.chkpoint拷贝到NN。<br>（7）在NN中将其重命名为fsimage。</p>
<h3 id="18-shuffle过程详解"><a href="#18-shuffle过程详解" class="headerlink" title="18. shuffle过程详解"></a>18. shuffle过程详解</h3><p>Shuffle横跨Map端和Reduce端，在Map端包括Spill过程，Reduce端包括copy、merge、sort过程。<br>（1）Map端<br>当map task开始运算，并产生中间数据时，其产生的中间结果不会简单的写入磁盘，而是利用内存buffer来进行已经产生的部分结果的缓存，并在内存buffer中进行一些预排序来优化整个map的性能。每个map都会对应存在一个内存buffer中，map会将产生的部分结果先写入对应buffer。该buffer默认大小为100MB，可以根据job提交的参数 - io.sort.mb 调整。<br>当map产生的数据量非常大，如将io.sort.mb调大，那么map在整个计算过程中spill的次数就会降低，map task对磁盘的操作会减少，如果map task的瓶颈在磁盘上，这样调整就能大大提升map的性能。<br>Spill的过程包括collect、sort、spill、merge。<br><strong>collect：</strong> 每个map task不断地以键值对的形式把数据输出到在内存中构造的一个环形数据结构中，这种结构，即看kvbuffer，是为了更有效地利用内存空间来存储数据。默认当存储到内存的80%，就会将内存中的数据刷到磁盘上，接着再往内存中存储，这个过程就是spill；<br>sort：先将kvbuffer中的数据按照partition值和key升序排序，（移动的只是索引数据），排序结果是，kvbuffer中数据按照partition排序，同一partition内按照key排序；<br><strong>spill：</strong> spill线程为spill过程创建一个磁盘文件，然后根据排过序的kvbuffer依次将partition写入这个文件，直到把所有文件遍历完，一个partition在文件中对应的数据也叫段。每一次spill过程至少生成一个out文件；<br><strong>merge：</strong> Map任务如果输出数据很大，可能会进行多次spill，相应的磁盘文件也会很多，最后由merge把这些文件进行合并。<br>（2）Reduce端<br><strong>copy：</strong> 由于Job上的每一个map都会根据reduce数将输出结果分成同等数量的partition，让reduce task可以从不同的已完成的map上下载该reduce对应的partition部分数据，由于map通常有多个，所以对于一个reduce来说，下载也可以是并行的从多个map选择，这些数据默认会保存在内存的缓冲区，等达到阈值才溢出到磁盘；<br><strong>merge：\</strong>在*<em>copy<strong>的同时，会在后台开启两个线程 - 内存到磁盘的合并、磁盘到磁盘的合并，对内存到本地磁盘的数据文件进行合并；
</strong>sort：*<em>在*<em>merge<em>*的同时，会进行排序操作，由于map task阶段已经进行了局部排序，reduce task只需要保证</em></em>copy</em></em>的数据最终整体有效就行。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>hive面试题</title>
    <url>/2021/07/21/hive%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="1-hive的实现逻辑：为什么小表延迟比较高？"><a href="#1-hive的实现逻辑：为什么小表延迟比较高？" class="headerlink" title="1. hive的实现逻辑：为什么小表延迟比较高？"></a>1. hive的实现逻辑：为什么小表延迟比较高？</h3><p>因为hive是基于hadoop实现的，其计算会经过mapreduce。MapReduce是批处理、高延迟的，无论文件大小都会经过mapreduce。所以Hive的优势在于批处理大数据，而不是小文件。</p>
<span id="more"></span>
<h3 id="2-sql语句的顺序"><a href="#2-sql语句的顺序" class="headerlink" title="2. sql语句的顺序"></a>2. sql语句的顺序</h3><p>有两种顺序：</p>
<p>（1）关键字顺序：</p>
<blockquote>
<p>select -&gt; distinct -&gt; from -&gt; join -&gt; on -&gt; where -&gt; group by -&gt; with -&gt; having -&gt; order by -&gt; limit</p>
</blockquote>
<p>（2）执行顺序</p>
<blockquote>
<p>from -&gt; on -&gt; join -&gt; where -&gt; group by -&gt; with -&gt; having -&gt; select -&gt; distinct -&gt; order by -&gt; limit</p>
</blockquote>
<h3 id="3-事实表和维度表"><a href="#3-事实表和维度表" class="headerlink" title="3. 事实表和维度表"></a>3. 事实表和维度表</h3><p>简单地说，维度表就是观察某个事物的角度或维度，事实表是要关注的具体内容。</p>
<p>比如要分析某个产品的销售情况，可以根据产品类别、时间两个维度进行分析，而事实表就是将数据聚合后依据某个维度生成的结果表。</p>
<p>事实表用来存储事实的度量及指向各个维度的外键值；维度表用来保存该维的元数据，包括维的描述信息。</p>
<p>二者的区别如下：</p>
<ol>
<li>维度表的冗余很大，主要是因为维度一般不大(相对于事实表来说的)，而维度表的冗余可以使事实表节省很多空间。</li>
<li>事实表一般都很大，如果以普通方式查询的话，得到结果一般发的时间都不是我们可以接受的。所以它一般要进行一些特殊处理。如SQL Server 2005就会对事实表进行如预生成处理等。</li>
<li>维度表的主键一般都取整型值的标志列类型，这样也是为了节省事实表的存储空间。</li>
</ol>
<h3 id="4-事实表的种类"><a href="#4-事实表的种类" class="headerlink" title="4. 事实表的种类"></a>4. 事实表的种类</h3><ol>
<li>事务型事实表<br>以每个事务或事件为单位，例如一个销售订单记录，一笔支付记录等，作为事实表里的一行数据。一旦事务被提交，事实表数据被插入，数据就不再进行更改，其更新方式为增量更新。</li>
<li>周期型快照事实表<br>周期型快照事实表中不会保留所有数据， 只保留固定时间间隔的数据，例如每天或者每月的销售额，或每月的账户余额等。</li>
<li>累积型快照事实表<br>累计快照事实表用于跟踪业务实时的变化。例如，数据仓库中可能需要累积或者存储订单从下订单开始，到订单商品被打包、运输、和签收的各个业务阶段的时间点数据来跟踪订单声明周期的进展情况。当这个业务过程进行时，事实表的记录也要不断更新。累积型快照事实表用于时间跨度不确定的不断变化的流水线/工作线。</li>
</ol>
<h3 id="5-是否了解数仓分层"><a href="#5-是否了解数仓分层" class="headerlink" title="5. 是否了解数仓分层"></a>5. 是否了解数仓分层</h3><p>首先我们知道数仓即数据仓库，是为企业制定决策，提供数据支持的，可以帮助企业，改进业务流程、提高产品质量等。</p>
<p>数据仓库的来源如下：</p>
<ol>
<li>爬虫数据；</li>
<li>用户行为数据：比如用户和网站交互产生的数据；</li>
<li>业务数据：存储在后台MySQL对应的数据库中。</li>
</ol>
<p>具体分层如下：</p>
<ol>
<li>ODS：原始数据层，存放原始数据，用来直接加载原始日志、数据，数据保持原貌不做处理；</li>
<li>DWD：明细数据层，对ODS层数据进行清洗(去除空值，脏数据，超过极限范围的数据)；</li>
<li>DWS：服务数据层，以DWD为基础，进行轻度汇总，一般聚集到以用户当日，设备当日，商家当日，商品当日等等的粒度；</li>
<li>ADS：数据应用层，面向实际的数据需求，以DWD或者DWS层的数据为基础，组成各种统计报表，一般ADS层的指标是提供给高层来进行决策的。</li>
</ol>
<h3 id="6-udf、udaf、udtf自定义函数的实现过程"><a href="#6-udf、udaf、udtf自定义函数的实现过程" class="headerlink" title="6. udf、udaf、udtf自定义函数的实现过程"></a>6. udf、udaf、udtf自定义函数的实现过程</h3><h4 id="UDF、UDAF、UDTF"><a href="#UDF、UDAF、UDTF" class="headerlink" title="UDF、UDAF、UDTF"></a>UDF、UDAF、UDTF</h4><p>UDF是一进一出；UDAF是多进一出，比如count；UDTF是一进多出。 。。。忘了就算了</p>
<h4 id="自定义的步骤"><a href="#自定义的步骤" class="headerlink" title="自定义的步骤"></a>自定义的步骤</h4><ol>
<li>自定义UDF：继承UDF，重写evaluate()方法；</li>
<li>自定义UDTF：继承GenericUDTF，重写三个方法 - initialize、process、close；</li>
<li>自定义UDAF：函数类需要继承UDAF类，计算类Evaluator实现UDAFEvaluator接口，其中Evaluator需要实现UDAFEvaluator的init、iterate、terminatePartial、merge、terminate。执行的过程有：第一阶段map，init()-&gt;iterate()-&gt;terminatePartial()；第二阶段combine：init()-&gt;merge()-&gt;terminatePartial()；第三阶段reduce：init()-&gt;merge()-&gt;terminate()；最后直接输出阶段：init()-&gt;iterate()-&gt;terminate()。每个阶段首先都会经过init()。</li>
</ol>
<h4 id="hive为什么需要自定义函数"><a href="#hive为什么需要自定义函数" class="headerlink" title="hive为什么需要自定义函数"></a>hive为什么需要自定义函数</h4><ol>
<li>内置函数不能满足所有的业务需求；</li>
<li>自定义函数可以自己埋点log打印日志、报错或数据异常，方便调试。</li>
</ol>
<h3 id="7-数据库与数据仓库"><a href="#7-数据库与数据仓库" class="headerlink" title="7. 数据库与数据仓库"></a>7. 数据库与数据仓库</h3><p>当今的数据处理大致可以分成两大类：联机事务处理OLTP（on-line transaction processing）、联机分析处理OLAP（On-Line Analytical Processing）。<br>       基本日常的事务处理，比如数据库记录的增删查改，通常被称为OLTP（On-Line Transaction Processing，联机事务处理），OLTP是数据库的主要应用。<br>       OLAP（On-Line Analytical Processing，联机分析处理）支持复杂的分析操作，侧重提供决策支持，并且提供直观易懂的分析结果，目标是探索并挖掘数据价值，作为企业高层进行决策的参考，OLAP是数据仓库的主要应用。</p>
<p>OLTP的特点一般有：</p>
<ol>
<li>实时性要求高。</li>
<li>数据量不是很大，生产库上的数据量一般不会太大，而且会及时做相应的数据处理与转移。</li>
<li>OLTP是对确定性的数据进行存取。</li>
<li>高并发，并且要求满足ACID原则。比如两人同时操作一个银行卡账户，比如大型的购物网站秒杀活动时上万的QPS请求。</li>
</ol>
<p>OLAP的特点一般有：</p>
<ol>
<li>实时性要求不是很高，比如最常见的应用就是天级更新数据，然后出对应的数据报表。</li>
<li>数据量大，因为OLAP支持的是动态查询，所以用户也许要通过将很多数据进行统计后才能得到想要知道的信息，例如时间序列分析等等，所以处理的数据量很大。</li>
<li>OLAP系统的重点是通过数据提供决策支持。</li>
</ol>
<h3 id="8-窗口函数"><a href="#8-窗口函数" class="headerlink" title="8. 窗口函数"></a>8. 窗口函数</h3><h4 id="1）窗口函数和普通聚合函数的区别"><a href="#1）窗口函数和普通聚合函数的区别" class="headerlink" title="1）窗口函数和普通聚合函数的区别"></a>1）窗口函数和普通聚合函数的区别</h4><p>（1）聚合函数是将多条记录合并为一条；窗口函数是每条记录都会执行，原来有几条记录最终执行完还是几条；<br>（2）聚合函数也可以用于窗口函数：窗口函数在逻辑上的执行顺序是在FROM、JOIN、WHERE、GROUP BY 、HAVING 之后，在ORDER BY、LIMIT、SELECT DISTINCT之前。它执行之前GROUP BY的聚合过程已经完成了，所以不会再产生数据聚合。</p>
<h4 id="2）常用窗口函数"><a href="#2）常用窗口函数" class="headerlink" title="2）常用窗口函数"></a>2）常用窗口函数</h4><ol>
<li>over：指定分析函数工作的数据窗口大小，这个大小可能会随着行的变化而变化；</li>
<li>current row：当前行；</li>
<li>n preceding：往前n行数据；</li>
<li>n following：往后n行数据；</li>
<li>unbounded preceding表示表中的第一行；unbounded following表示表中的最后一行；</li>
<li>lag(col, n)：往前第n行数据；</li>
<li>lead(col, n)：往后第n行数据；</li>
<li>ntile(n)：n为int类型，用于将分组数据按照顺序切分成n片，并返回当前记录所在的切片值。</li>
</ol>
<h3 id="9-Hive优化"><a href="#9-Hive优化" class="headerlink" title="9. Hive优化"></a>9. Hive优化</h3><h4 id="1）-fetch抓取"><a href="#1）-fetch抓取" class="headerlink" title="1）. fetch抓取"></a>1）. fetch抓取</h4><p>即Hive中某些情况的查询可以不必经过MapReduce计算；<br>通过修改hive-default.xml中的hive.fetch.task.conversion参数为more，使得全局查找、字段查找、limit查找等都不用经过MapReduce。</p>
<h4 id="2）-本地模式"><a href="#2）-本地模式" class="headerlink" title="2）. 本地模式"></a>2）. 本地模式</h4><p>Hive在本地模式使用单台机器处理所有事务，当数据集比较小的时候，执行时间明显的被缩短；<br>通过修改hive.exec.mode.local.auto参数为true，那么Hive可以在适当的时候自动地启动这个优化。</p>
<h4 id="3）-表的优化"><a href="#3）-表的优化" class="headerlink" title="3）. 表的优化"></a>3）. 表的优化</h4><p><strong>（1）小表Join大表</strong>：将key相对分散，并将小表放在Join的左边，这样可以有效的减少内存溢出错误发生的机率；但实际测试证明：新版的Hive的小表Join大表和大表Join小表已经没有明显区别。<br><strong>（2）大表Join大表</strong>：<br>a）空key过滤：有些Join超时是因为某些key对应的数据太多，而相同的key对应的数据都会被放到同一个reducer，会导致内存不够用；此时我们可以仔细分析这些异常的key，很多情况下这些key对应的都是异常数据，我们使用SQL语句将这些异常数据过滤就行。<br>b）空key转换：有时候这些key对应的数据并不是异常数据，我们可以将这些空key随机转换为不同的值，使得数据能随即均匀的分不到不同的reducer上。<br><strong>（3）MapJoin</strong>：<br>如果不指定MapJoin或者不符合MapJoin的条件，Hive解析器会将这些数据给Reduce端处理，容易造成数据倾斜，可以使用MapJoin将小表都加载到内存，在map端进行Join操作。<br><strong>（4）笛卡尔积</strong>：<br>尽量不使用笛卡尔积，Join的时候尽量不用on或无效的on，Hive只能在一个reducer上完成笛卡尔积。<br><strong>（5）行列过滤</strong>：<br>（1）如果是列处理，只拿需要的列，尽量使用分区过滤，少用 select <em>；<br>（2）如果是行处理，在分区剪裁中，当使用外关联时，副表的过滤条件写在where之后，会先进行全表关联，再进行过滤。<br><em>*（6）动态分区调整</em></em>：<br>关系型数据中，对分区表insert数据的时候，会根据分区字段的值，将数据插入相应的分区；Hive中也设置了相似的机制，即动态分区。</p>
<h4 id="4）-MR优化"><a href="#4）-MR优化" class="headerlink" title="4） MR优化"></a>4） MR优化</h4><h5 id="（1）合理设置Map数"><a href="#（1）合理设置Map数" class="headerlink" title="（1）合理设置Map数"></a>（1）合理设置Map数</h5><p>当Map数过大，如果一个任务有许多小文件，这些小文件的大小远小于一个块的大小，则每个小文件也会被当成一个块，用一个map来完成，而一个map的启动和初始化的时间远大于逻辑处理时间，这样会对造成很大的资源浪费，而且，同时可执行的map数是有限的。<br>但是，如果每个Map都处理将近一个块的大小的数据也不行，假设有一个127M的文件，其中只有一到两个字段，却有成千上万的数据，这时当Map处理的逻辑比较复杂的时候，也会很耗时。<br>对于第一个问题，我们需要减少map的数量，第二个问题需要增加map的数量。</p>
<h4 id="（2）合并小文件来减少map的数量"><a href="#（2）合并小文件来减少map的数量" class="headerlink" title="（2）合并小文件来减少map的数量"></a>（2）合并小文件来减少map的数量</h4><p>CombineHiveInputFOrmat具有对小文件进行合并的功能，是系统默认的格式。</p>
<h4 id="（3）对于复杂文件可以通过增加Map的数量来减少每个map需要处理的数据量，从而提高任务的执行效率。"><a href="#（3）对于复杂文件可以通过增加Map的数量来减少每个map需要处理的数据量，从而提高任务的执行效率。" class="headerlink" title="（3）对于复杂文件可以通过增加Map的数量来减少每个map需要处理的数据量，从而提高任务的执行效率。"></a>（3）对于复杂文件可以通过增加Map的数量来减少每个map需要处理的数据量，从而提高任务的执行效率。</h4><p>增加map的方式为：</p>
<blockquote>
<p>computSliteSize(Math.max(minSize, Math.min(maxSize, blockSize))) = blockSize = 128M<br>//调整maxSize的值，使得maxSize的最大值小于blockSize，这样就可以增加map的个数了。</p>
</blockquote>
<h4 id="（4）合理设置Reduce数"><a href="#（4）合理设置Reduce数" class="headerlink" title="（4）合理设置Reduce数"></a>（4）合理设置Reduce数</h4><p>reduce个数并不是越多越好：<br>1）过多的启动和初始化会消耗时间和资源；<br>2）多少个reduce就会生成多少个输出文件，当输出多个小文件，同时这些文件会作为下一个任务的输入，也会造成小文件过多的问题；<br>3）在设置reduce数的时候也要遵循两个原则：大数据量要有合适的reduce数；每个reduce要有合适的数据量。</p>
<h4 id="（5）并行执行"><a href="#（5）并行执行" class="headerlink" title="（5）并行执行"></a>（5）并行执行</h4><p>Hive会将一个查询转换为一至多个阶段，这些阶段可能并发完全相互依赖，有些阶段可能可以并行执行，这样就有可能将整个job的执行时间缩短。如果有更多的阶段可以并行执行，那么job就有可能越快完成；当然，这得是在系统资源比较空闲的时候才有优势，不然就算想并行也起不来。可以通过设置参数：hive.exec.parallel值为true来开启并行。</p>
<h3 id="10-Hive数据倾斜"><a href="#10-Hive数据倾斜" class="headerlink" title="10. Hive数据倾斜"></a>10. Hive数据倾斜</h3><h4 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h4><p>不同数据类型关联产生数据倾斜；大量空值进入某一个reduce造成数据倾斜。</p>
<h4 id="解决的方法"><a href="#解决的方法" class="headerlink" title="解决的方法"></a>解决的方法</h4><ol>
<li>group by：group by优于distinct group，可以采用sum() group by() 的方式替换count(distinct)完成计算；</li>
<li>mapjoin：如果不指定mapjoin或者不符合mapjoin的条件，Hive解析器会将jin操作放到reduce端处理，可以使用mapjoin将这些小表放到内存中，在map端进行处理；</li>
<li>开启数据倾斜时负载均衡<br>set hive.groupby.skewindata=true</li>
<li>设置多个reduce个数</li>
</ol>
<h3 id="11-Hive里边字段的分隔符用的什么？为什么用-t？有遇到过字段里边有-t的情况吗，怎么处理的？"><a href="#11-Hive里边字段的分隔符用的什么？为什么用-t？有遇到过字段里边有-t的情况吗，怎么处理的？" class="headerlink" title="11. Hive里边字段的分隔符用的什么？为什么用\t？有遇到过字段里边有\t的情况吗，怎么处理的？"></a>11. Hive里边字段的分隔符用的什么？为什么用\t？有遇到过字段里边有\t的情况吗，怎么处理的？</h3><p>字段分隔符默认是<code>^A</code>，即ascII码的\001。<br>如果采用<code>\t</code>或<code>\001</code>等作为分隔符，需要要求前端埋点和JavaEE后台传递过来的数据不能存在该分隔符，同代码规划约束，如果出现该分隔符，需要到前一级数据中去转移或者替换。<br>可以设置如下参数：</p>
<blockquote>
<p>-hive.drop.import.delims 导入到hive时删除分隔符；<br>-hive.delims.replacement 导入到hive时用自定义的分隔符替代</p>
</blockquote>
<h3 id="12-Hive的特点以及和RDBMS的区别"><a href="#12-Hive的特点以及和RDBMS的区别" class="headerlink" title="12. Hive的特点以及和RDBMS的区别"></a>12. Hive的特点以及和RDBMS的区别</h3><h4 id="（1）特点"><a href="#（1）特点" class="headerlink" title="（1）特点"></a>（1）特点</h4><p>hive由Facebook开源用于解决海量结构化日志的数据统计，是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供完整的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析。</p>
<h4 id="（2）Hive和数据库比较"><a href="#（2）Hive和数据库比较" class="headerlink" title="（2）Hive和数据库比较"></a>（2）Hive和数据库比较</h4><ol>
<li>查询语言：数据库使用SQL语言，Hive使用类SQL的HQL语言。</li>
<li>数据存储位置：Hive建立在Hadoop之上，Hive所有真实数据的存储都在HDFS中；而数据库可以将数据保存在块设备或本地系统中。</li>
<li>数据更新：Hive中不建议对数据进行改写，数据库中的数据经常需要被改写。</li>
<li>执行：Hive中大多数的查询是通过MapReduce来完成的，而数据库有自己的搜索引擎。</li>
<li>执行延迟：Hive在查询数据的时候，因为没有索引，需要扫描整张表，因此延迟会较高，又因为Mapreduec本身具有比较高的延迟，当Hive使用Mapreduce执行查询时，延迟会更高；相较而言，数据库的延迟就会比较低；当数据规模比较小，但仍超过数据库的处理能力时，Hive的并行计算才显出优势。</li>
<li>可扩展性：由于Hive建立在Hadoop之上，所以二者的扩展性是一致的；而数据库收到ACID语义的限制，扩展行非常有限，目前最大的并行数据库Oracle在理论上的扩展能力也只有100台左右。</li>
<li>数据规模：由于Hive建立在集群上并可以利用Mapreduce进行并行计算，所以可以处理大规模的数据；相对而言，数据库的处理规模就比较小。<br>注 - ACID语义：<br>1）原子性：即操作要么全部完成，要么全部不完成，不会结束在中间的某个环节；<br>2）一致性：操作开始到结束，数据对象的完整性不会被破坏；<br>3）隔离性：操作独立于其他并发操作完成；<br>4）持久性：操作处理结束后，对数据的修改将永久有效，即使出现故障，该修改也不会丢失。</li>
</ol>
<h3 id="13-Union和Union-all的区别"><a href="#13-Union和Union-all的区别" class="headerlink" title="13. Union和Union all的区别"></a>13. Union和Union all的区别</h3><p>Union会将联合的结果集去重，效率较union all差；<br>Union all不会对结果集去重，所以效率高。</p>
<h3 id="14-group-by和partition-by的区别"><a href="#14-group-by和partition-by的区别" class="headerlink" title="14. group by和partition by的区别"></a>14. group by和partition by的区别</h3><ol>
<li>group by是分组函数，partition by是分析函数；</li>
<li>在执行顺序上，对于group by而言：from&gt;where&gt;group by&gt;having&gt;order by；对于prtition by而言，在执行完select之后，会在所得结果上进行partition；</li>
<li>在group by结果集上进行聚合，会作用在分组下的所有记录上；而在partition by的结果集上进行聚合，就要注意聚合函数是逐条累计进行计算的；</li>
<li>group by将分组记录汇总成一条记录，具有去重效果；partition by会显示所有数据，不会去重。</li>
</ol>
<h3 id="15-分区和分桶的区别"><a href="#15-分区和分桶的区别" class="headerlink" title="15. 分区和分桶的区别"></a>15. 分区和分桶的区别</h3><p>分区：<br>指按照数据表的某列或某些列分为多个区，区从形式上可以理解为文件夹，比如我们要收集某个大型网站的日志数据，一个网站每天的日志数据存在同一张表上，由于每天会生成大量的日志，导致数据表的内容巨大，在查询时进行全表扫描耗费的资源非常多。那其实这个情况下，我们可以按照日期对数据表进行分区，不同日期的数据存放在不同的分区，在查询时只要指定分区字段的值就可以直接从该分区查找。<br>分桶：<br>分桶是相对分区进行更细粒度的划分。分桶将整个数据内容按照某列属性值得hash值进行区分，如要按照name属性分为3个桶，就是对name属性值的hash值对3取摸，按照取模结果对数据分桶：取模结果为0的数据记录存放到一个文件，取模为1的数据存放到一个文件，取模为2的数据存放到一个文件。</p>
<h3 id="16-Hive常见的存储文件类型？"><a href="#16-Hive常见的存储文件类型？" class="headerlink" title="16. Hive常见的存储文件类型？"></a>16. Hive常见的存储文件类型？</h3><p>常用的存储文件类型：SEQUENCEFILE（二进制序列文件）、TEXTFILE（文本）、RCFILE（列式存储格式文件）、ORCFILE、PARQUET。<br>如果文件数据是纯文本，可以使用 STORED AS TEXTFILE。<br>如果数据需要压缩，使用 STORED AS SEQUENCEFILE。</p>
<h3 id="17-Hive的架构"><a href="#17-Hive的架构" class="headerlink" title="17. Hive的架构"></a>17. Hive的架构</h3><p>Hive架构包含用户接口Client、元数据Metastore、Hadoop和驱动器Driver。</p>
<ol>
<li>Client：有CLI，即hive shell、JDBC/ODBC，即用Java访问Hive、WEBUI，用浏览器访问Hive。</li>
<li>Metastore：元数据包括表名、表所属数据库(默认是default)、表的拥有者、表的类型(是否是外部表)、列和分区字段等，默认使用Derby数据库存储元数据，但是derby属于嵌套式数据库，一次只能支持一个会话，所以建议使用Mysql存储元数据。</li>
<li>Hadoop：使用HDFS进行存储，Mapreduce进行计算。</li>
<li>Driver：包括解析器、编译器、优化器和执行器，其中解析器将Hive的Sql语句转变为抽象语法树AST；编译器将AST转变为逻辑执行计划；优化器将逻辑执行计划进行优化；执行器最后将逻辑执行计划转变为物理执行计划，对于Hive来说，就是MR/Spark。</li>
</ol>
<h3 id="18-外部表和内部表"><a href="#18-外部表和内部表" class="headerlink" title="18. 外部表和内部表"></a>18. 外部表和内部表</h3><p>删除数据时，外部表只删除元数据，保留原始数据，这样的数据可修复；内部表会将元数据和原始数据都删除，这样数据不可修复。<br>在企业绝大部分都使用外部表，只有个人使用的临时表，才会创建内部表。</p>
<h3 id="19-排序的4个By区别"><a href="#19-排序的4个By区别" class="headerlink" title="19. 排序的4个By区别"></a>19. 排序的4个By区别</h3><ol>
<li>order by：全局排序，只会有一个Reducer；</li>
<li>sort by：局部排序，只在每个Reducer内部排序，对全局结果集来说是无序的；</li>
<li>distribute by：类似MR中的partition，进行分区，需要结合sort by使用，且要写在sort by之前；</li>
<li>cluster by：当distribute by所用字段和sort by所用字段相同时，就使用cluster by，它兼具了前二者的功能，但是只能升序排序，不能降序。</li>
</ol>
<h3 id="20-常用的几个系统函数"><a href="#20-常用的几个系统函数" class="headerlink" title="20. 常用的几个系统函数"></a>20. 常用的几个系统函数</h3><h4 id="1-聚合函数"><a href="#1-聚合函数" class="headerlink" title="1. 聚合函数"></a>1. 聚合函数</h4><ol>
<li>sum() - 求和；</li>
<li>count() - 求个数；</li>
<li>avg() - 求平均值；</li>
<li>distict - 去重；</li>
<li>min() - 求最小值;</li>
<li>max() - 求最大值；</li>
</ol>
<h4 id="2-分析函数"><a href="#2-分析函数" class="headerlink" title="2. 分析函数"></a>2. 分析函数</h4><ol>
<li>rank()：生成的数据项是在组内的排名，如果排名相等会在名次中留下空位；</li>
<li>row_number()：生成的数据项从1开始，按照顺序生成在组内的序列号；</li>
<li>dense_rank()：与rank()类似，但是如果排名相等，不会留下空位；</li>
<li>cume_dist() = 小于等于<code>当前元素的值</code>的行数/总行数；</li>
<li>percent_rank() = 分组内当前行的rank值-1/总行数-1。</li>
</ol>
<h4 id="3-字符串连接函数"><a href="#3-字符串连接函数" class="headerlink" title="3. 字符串连接函数"></a>3. 字符串连接函数</h4><ol>
<li>concat(str1, str2, …)：用于将多个字符串连接成一个字符串；</li>
<li>concat_ws(sep, str1, str2, …)：指定分隔符将多个字符串连接成一个，其中，<code>sep</code>为分隔符；</li>
<li>collect_set(字段)：根据指定内容分组后，将分在一组的该字段的列值合并为数组，默认分隔符为<code>,</code>，可以将concat_ws和concat_set组合指定分隔符；</li>
<li>collect_list(字段)：与collect_list相似，区别是collect_set可以去重，collect_list不行。</li>
</ol>
<h4 id="4-还有一些其他类型函数"><a href="#4-还有一些其他类型函数" class="headerlink" title="4. 还有一些其他类型函数"></a>4. 还有一些其他类型函数</h4><ol>
<li>cast(字段名 as 转换的类型)：转换字段的类型；</li>
<li>if(表达式, trueValue, falseValue_or_NULL)：相当于Java的三目运算符。</li>
</ol>
<h3 id="21-Hive有哪些方式保存元数据，各有哪些特点？"><a href="#21-Hive有哪些方式保存元数据，各有哪些特点？" class="headerlink" title="21. Hive有哪些方式保存元数据，各有哪些特点？"></a>21. Hive有哪些方式保存元数据，各有哪些特点？</h3><p>1）内嵌模式：将元数据保存在本地内嵌的derby数据库中，内嵌的derby数据库每次只能访问一个数据文件，也就意味着它不支持多会话连接。 </p>
<p>2）本地模式：将元数据保存在本地独立的数据库中（一般是mysql），这可以支持多会话连接。 </p>
<p>3）远程模式：把元数据保存在远程独立的mysql数据库中，避免每个客户端都去安装mysql数据库。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>购物车结算系统-配置文件篇-项目小记</title>
    <url>/2022/01/11/%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%BB%93%E7%AE%97%E7%B3%BB%E7%BB%9F-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AF%87-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="编写Properties文件"><a href="#编写Properties文件" class="headerlink" title="编写Properties文件"></a>编写Properties文件</h3><ol>
<li><p>文件名：<code>xxx.properties</code></p>
</li>
<li><p>内容格式：<code>key=value</code>，如 <code>driver=com.mysql.jdbc.Driver</code></p>
<p>如果 key 是多个单词组成，需要使用空格，可以使用反斜杠(\)对空格进行转移。如 <code>main form firstName=Stone</code> 可以修改为 <code>main\ form\ firstName=Stone</code></p>
</li>
</ol>
<span id="more"></span>
<h3 id="获取Properties文件的内容"><a href="#获取Properties文件的内容" class="headerlink" title="获取Properties文件的内容"></a>获取Properties文件的内容</h3><p>参考如下代码使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">      InputStream input;</span><br><span class="line">      String profile = <span class="string">&quot;jdbc.properties&quot;</span>;</span><br><span class="line">      <span class="comment">// 加载配置文件到输入流</span></span><br><span class="line">      input = DBUtil.class.getClassLoader().getResourceAsStream(profile);</span><br><span class="line">      <span class="comment">// 从输入流读取属性列表</span></span><br><span class="line">      pro.load(input);</span><br><span class="line">      <span class="comment">// 获取指定参数</span></span><br><span class="line">      String driver = pro.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">      String url = pro.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">      String username = pro.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">      String password = pro.getProperty(<span class="string">&quot;password&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>其中，需要将 <code>jdbc.properties</code> 文件放到 <code>resource</code> 目录下。</p>
]]></content>
      <categories>
        <category>项目小记</category>
      </categories>
      <tags>
        <tag>文件配置</tag>
      </tags>
  </entry>
  <entry>
    <title>spark - 面试题</title>
    <url>/2021/05/31/spark-%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="1-spark是什么"><a href="#1-spark是什么" class="headerlink" title="1. spark是什么"></a>1. spark是什么</h3><p>spark是一种与hadoop相似的开源集群计算框架，是基于内存的快速、通用、可扩展的大数据分析计算引擎。</p>
<p>基于内存：并不是说spark是内存计算，因为它的shuffle过程也是需要硬盘落地的，它的特点是多个任务之间的数据通信是通过内存进行的。</p>
<span id="more"></span>
<h3 id="2-spark的hadoop的对比"><a href="#2-spark的hadoop的对比" class="headerlink" title="2. spark的hadoop的对比"></a>2. spark的hadoop的对比</h3><p><strong>MapReduce框架局限性：</strong></p>
<p>1）仅支持Map和Reduce两种操作；</p>
<p>2）处理效率低效；</p>
<p>Map中间结果写磁盘，Reduce写HDFS，多个MR之间通过HDFS交换数据;，任务调度和启动开销大，无法充分利用内存，Map端和Reduce端均需要排序；</p>
<p>3）不适合迭代计算(如机器学习、图计算等)，交互式处理（数据挖掘)）和流式处理(点击日志分析）。</p>
<p><strong>Spark相比的优势：</strong><br>1.高性能：Spark采用内存计算引擎，允许用户将数据放到内存中以加快数据读取；同时，Spark提供了更加通用的DAG计算引擎，使得数据可通过本地磁盘或内存流向不同的计算单元。</p>
<p>2.简单易用：Spark提供了丰富的高层次API，包括sortByKey、groupByKey等操作，并且提供了四种编程语言API：Scala、Python、Java和R，从代码量看，Spark比MapReduce少2~5倍。</p>
<p>3.与Hadoop完好集成：Spark作为新型框架，可以部署在YARN集群上，读取和存储HDFS/HBase中的数据。</p>
<p>经过上述比较可知，在绝大多数的数据计算场景下，spark比hadoop更具有优势，但是spark是基于内存的，在实际的生产环境中，由于内存的限制，可能会因为内存资源不够而导致job运行失败，此时，hadoop的mapreduce就是一个更好的选择，所以spark并不能完全替代hadoop。</p>
<h3 id="3-spark核心模块简介"><a href="#3-spark核心模块简介" class="headerlink" title="3. spark核心模块简介"></a>3. spark核心模块简介</h3><p>即spark sql、spark streaming、spark mllib、spark graphx和spark core。</p>
<p>其中，位于最底层的是spark core，它是整个spark框架的核心，其余的功能模块都是基于core来实现和完善的。</p>
<p>spark sql：用于操作结构化数据的功能模块，通过spark sql，用户可以使用sql或apache hive版本的sql语言来查询数据；</p>
<p>spark streaming：用于对流式数据进行处理的功能模块，提供了丰富的处理数据流的API；</p>
<p>spark mllib：是spark提供的一个机器学习算法库，不仅提供了模型评估、数据导入等额外的功能，还提供了一些更底层的机器学习原语；</p>
<p>spark graphx：是面向图计算提供的框架和算法库。</p>
<h3 id="4-RDD、DataFrame和DataSet的区别和联系"><a href="#4-RDD、DataFrame和DataSet的区别和联系" class="headerlink" title="4. RDD、DataFrame和DataSet的区别和联系"></a>4. RDD、DataFrame和DataSet的区别和联系</h3><h4 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h4><p>1、RDD、DataFrame、Dataset全都是spark平台下的分布式弹性数据集，为处理超大型数据提供便利；</p>
<p>2、三者都有惰性机制，在进行创建、转换，如map方法时，不会立即执行，只有在遇到Action如foreach、count、collect等时，三者才会开始运算，极端情况下，如果代码里面有创建、转换，但是后面没有Action操作，在执行时会被直接跳过；    </p>
<p>3、三者都会根据spark的内存情况自动缓存运算，这样即使数据量很大，也不用担心会内存溢出；</p>
<p>4、三者都有partition的概念；</p>
<p>5、三者有许多共同的函数，如filter，排序等；</p>
<p>6、对DataFrame和Dataset的许多操作都需要import spark.implicits._进行支持；</p>
<p>7、DataFrame和Dataset均可使用模式匹配获取各个字段的值和类型；</p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol>
<li><p>RDD</p>
<p>1、RDD一般和spark mllib同时使用；</p>
<p>2、RDD不支持sparksql操作；</p>
</li>
<li><p>DataFrame</p>
<p>1、与RDD和Dataset不同，DataFrame每一行的类型固定为Row，只有通过解析才能获取各个字段的值，即每一列的值不能直接访问；</p>
<p>2、DataFrame与Dataset一般与spark mllib同时使用；</p>
<p>3、DataFrame与Dataset均支持sparksql的操作，比如select，groupby之类，还能注册临时表/视窗，进行sql语句操作；</p>
<p>4、DataFrame与Dataset支持一些特别方便的保存方式，比如保存成csv，可以带上表头，这样每一列的字段名一目了然，利用这样的保存方式，可以方便的获得字段名和列的对应，而且分隔符（delimiter）可以自由指定；</p>
</li>
<li><p>DataSet</p>
<p> 主要是与DataFrame的比较，因为Dataset和DataFrame拥有完全相同的成员函数，区别只是每一行的数据类型不同；</p>
<p>DataFrame也可以叫Dataset[Row],每一行的类型是Row，不解析，每一行究竟有哪些字段，各个字段又是什么类型都无从得知，只能用getAS模式匹配取出特定字段；</p>
<p>而Dataset中，每一行是什么类型是不一定的，在自定义了case class之后可以很自由的获得每一行的信息；</p>
<p>相较而言，DataSet访问列的某个字段是方便的，然后，如果要写一些适配性比较强的函数，如果使用DataSet，行的类型又不确定，可以使用DataFrame。</p>
</li>
</ol>
<h3 id="5-SparkSession和SparkContext的区别和联系"><a href="#5-SparkSession和SparkContext的区别和联系" class="headerlink" title="5. SparkSession和SparkContext的区别和联系"></a>5. SparkSession和SparkContext的区别和联系</h3><p>SparkSession实质上是SparkContext和HiveContext的组合，所以在SparkContext和HiveContext上可用的API在SparkSession上同样可用。</p>
<p>SparkSession的内部封装了SparkContext，所以它的计算实际上是由SparkContext完成的。即需要SpakSQL活Hive时使用SparkSession，否则用SparkContext就行。</p>
<h3 id="6-DataSet、DataFrame常见的Action行动算子"><a href="#6-DataSet、DataFrame常见的Action行动算子" class="headerlink" title="6. DataSet、DataFrame常见的Action行动算子"></a>6. DataSet、DataFrame常见的Action行动算子</h3><blockquote>
<p>show(n) - 显示n条记录，n省略时显示全部；</p>
<p>collect - 获取所有数据并返回Array结构；</p>
<p>collectAsList - 获取所有数据并返回list结构；</p>
<p>first - 获取第一行数据；</p>
<p>head - 获取第一行数据 - head(n:int) - 获取前n行数据；</p>
<p>take(n:int) - 获取前n行数据；</p>
<p>takeAsList(n:int) - 获取前n行数据并以list形式展示；</p>
<p>printSchema - 输出数据结构信息；</p>
<p>explain - 将物理计划打印到控制台以进行调试；</p>
<p>count - 统计个数；</p>
<p>reduce - 对数据进行规约操作。</p>
</blockquote>
<h3 id="7-DataSet、DataFrame常见的Transformation转换算子"><a href="#7-DataSet、DataFrame常见的Transformation转换算子" class="headerlink" title="7. DataSet、DataFrame常见的Transformation转换算子"></a>7. DataSet、DataFrame常见的Transformation转换算子</h3><blockquote>
<p>map - 分析表中的数据；</p>
<p>flatMap - 在map的基础上将String扁平化为字符数组；</p>
<p>filter - 过滤；</p>
<p>select和selectExpr - 查询，select写查询语句，selectExpr写要查询的字段；</p>
<p>drop - 将表从内存删除；</p>
<p>withColumn - 用于向DataFrame添加列、更新现有列的值、转换列的数据类型以及从现有列派生新列；</p>
<p>join - 连接；</p>
<p>where - 指定条件；</p>
<p>groupBy - 分组；</p>
<p>agg - 对整个数据集聚合；</p>
<p>orderBy - 先将数据按照指定字段分区，在进行分区内排序；</p>
<p>sortBy - 分区内排序；</p>
<p>union、intersect、except - 并、交、差。</p>
</blockquote>
<h3 id="8-Spark有哪几种部署模式，每种模式有哪些特点"><a href="#8-Spark有哪几种部署模式，每种模式有哪些特点" class="headerlink" title="8. Spark有哪几种部署模式，每种模式有哪些特点"></a>8. Spark有哪几种部署模式，每种模式有哪些特点</h3><ol>
<li>本地模式：该模式被称为local[N]模式，是利用本地的多个线程来模拟spark的分布式计算，便于调试；它有以下分类：local - 只运行一个线程；local[K] - 运行K个executor；local[*] - 运行和cpu数目相同的executor。</li>
<li>standalone模式：是Spark自身的一个调度系统。 对集群性能要求非常高；分布式部署集群，自带完整的服务，其中资源管理和任务监控都由spark自己监控，该模式是其他模式的基础。</li>
<li>spark on yarn模式：分布式部署集群，资源和任务监控交给yarn管理，它是粗粒度资源分配方式，包含cluster和client运行模式：cluster 适合生产，driver运行在集群子节点，具有容错功能；client 适合调试，dirver运行在客户端。</li>
<li>spark on mesos模式：官方推荐这种模式（当然，原因之一是血缘关系）。正是由于Spark开发之初就考虑到支持Mesos，因此，目前而言，Spark运行在Mesos上会比运行在YARN上更加灵活，更加自然。用户可选择两种调度模式之一运行自己的应用程序：<br>  ①粗粒度模式（Coarse-grained Mode）：每个应用程序的运行环境由一个Dirver和若干个Executor组成，其中，每个Executor占用若干资源，内部可运行多个Task（对应多少个“slot”）。应用程序的各个任务正式运行之前，需要将运行环境中的资源全部申请好，且运行过程中要一直占用这些资源，即使不用，最后程序运行结束后，回收这些资源。<br>  ② 细粒度模式（Fine-grained Mode）：鉴于粗粒度模式会造成大量资源浪费，Spark On Mesos还提供了另外一种调度模式：细粒度模式，这种模式类似于现在的云计算，思想是按需分配。<br><strong>Spark 客户端直接连接 Mesos；不需要额外构建 Spark 集群。国内应用比较少，更多的是运用 yarn 调度。</strong></li>
</ol>
<h3 id="9-Spark的常用端口号"><a href="#9-Spark的常用端口号" class="headerlink" title="9. Spark的常用端口号"></a>9. Spark的常用端口号</h3><p>（1）4040：spark shell任务端口；<br>（2）7077：内部通讯端口，类似于hadoop的8020；<br>（3）8080：查看任务执行情况的端口号，类似hadoop的8088；<br>（4）18080：历史服务器，类似于hadoop的19888。</p>
<h3 id="10-SparkSQL中的三种join操作"><a href="#10-SparkSQL中的三种join操作" class="headerlink" title="10. SparkSQL中的三种join操作"></a>10. SparkSQL中的三种join操作</h3><p>用于小表join大表的 <code>broadcast join</code> 和 <code>shuffle join</code>，以及用于将两个大表连接的 <code>sort merge join</code>。</p>
<ol>
<li>broadcast join：将小表的数据通过广播的数据，分发到各个excutor中，即每个excutor都存储小表的全部数据，然后将大表分区，每个分区都和本地的广播变量进行join操作，这种方式会消耗空间，但会缩短shuffle的时间；</li>
<li>shuffle join：broadcast join适用于比较小的表，这个小的程度由spark.sql.broadcastTreshold参数来设置，默认是10M。对于表较大的小表，可以对两个表进行shuffle操作，将相同key的数据分到同一个分区，在分区之间进行join操作，这就相当于是将两张表分成若干份，小份和小份之间进行join，充分利用集群资源；</li>
<li>sort merge join：<code>broadcast join</code> 和 <code>shuffle join</code> 都是采用hash join，即将小表的数据完全加载到内存，然后通过hashcode取join key相等的方式进行连接，如果两个表都是大表就不适用了。此时就需要用到 <code>sort merge join</code>。它将两张表依照join key进行分区，然后对分区中的数据进行排序，排序后在对相应分区的数据遍历，碰到key相同就输出，这种方式大大提高了大数据量下sql join的稳定性。</li>
</ol>
<h3 id="11-Spark任务的提交流程-有时间再看看这个"><a href="#11-Spark任务的提交流程-有时间再看看这个" class="headerlink" title="11. Spark任务的提交流程**有时间再看看这个"></a>11. Spark任务的提交流程**有时间再看看这个</h3><p>spark的任务，在生产环境中一般会在yarn上运行，具体流程如下：</p>
<ol>
<li>用户通过client将任务提交到RM；</li>
<li>RM会启动一个AM；</li>
<li>AM会在内部启动一个driver线程，并向RM申请资源；</li>
<li>RM会返回一个资源可用列表；</li>
<li>Driver会在内部初始化SC、进行任务的划分和调度；</li>
<li>AM通过NM启动Container，并在Container内部启动一个ExcutorBanked进程；</li>
<li>Excutor反向注册给Driver；</li>
<li>Excutor启动任务。</li>
</ol>
<h3 id="12-如何划分Spark的stage"><a href="#12-如何划分Spark的stage" class="headerlink" title="12. 如何划分Spark的stage"></a>12. 如何划分Spark的stage</h3><p>有两个点，概念和划分的思路。</p>
<ol>
<li>窄依赖是父RDD的一个分区最多只能被子RDD的一个分区依赖，常见的有map、flatmap、filter等；</li>
<li>宽依赖是父RDD的一个分区可以由子RDD的多个分区所依赖，常见的有groupbykey、sortbykey、reducebykey等；</li>
<li>shuffle的概念是，在spark中，每个任务对应一个分区，通常不会跨区域操作数据，但遇到宽依赖的操作，spark必须从多个分区中读取数据，并查找所有键对应的值，最终汇总在一起以计算每个键最终的结果；</li>
<li>stage划分的思路：stage是以result和shuffle两种类型来划分task的，对于窄依赖，由于分区依赖关系的确定性，partition转换处理可以在同一个线程完成，这成为resulttask；对于宽依赖，需要等待父RDD的shuffle处理完成，在下一个stage才能开始接下来的计算，这成为shuffletask。</li>
<li>因此，stage的划分原则为：从后往前推RDD算子，如果遇到宽依赖就断开，划分为一个stage；如果是窄依赖，就将该RDD加入当前的stage中。</li>
</ol>
<h3 id="13-spark的懒加载机制"><a href="#13-spark的懒加载机制" class="headerlink" title="13. spark的懒加载机制"></a>13. spark的懒加载机制</h3><p>在spark中，RDD包含两种操作，一种是转换，泛指接收rdd作为输入，并输出一个rdd的函数，划分为窄依赖和宽依赖；另一种是行为，将rdd转换为非rdd的变量的操作，通常用于返回rdd计算的结果。其中转换操作就是懒操作，转换操作是延迟计算的，也就是说一个rdd转换生成另一个rdd的过程不会立即执行，而是等到出现行为操作的时候才会真正触发运算。</p>
<p>转化操作返回的数据类型是一个rdd类型；行为运算返回的数据类型是其他类型，二者的区别在于spark计算rdd的方式不同。</p>
<h3 id="14-spark的DAG？"><a href="#14-spark的DAG？" class="headerlink" title="14. spark的DAG？"></a>14. spark的DAG？</h3><p>DAG的中文全称是有向无环图，在spark中，使用DAG来描述我们的计算逻辑。</p>
<p>DAG简单的说就是一个RDD的执行流程和依赖关系。 有方向无闭环。创建RDD的时候构建DAG图，执行行动算子时一个DAG图形成。一个应用里面有多少个DAG取决于执行了多少次行动算子。</p>
<h3 id="15-spark的数据倾斜问题"><a href="#15-spark的数据倾斜问题" class="headerlink" title="15. spark的数据倾斜问题"></a>15. spark的数据倾斜问题</h3><p><strong>一. 产生的原因</strong></p>
<p>spark 中的数据倾斜并不是说原始数据存在倾斜，原始数据都是一个一个的 block，大小都一样，不存在数据倾斜；</p>
<p>而是指 shuffle 过程中产生的数据倾斜，由于不同的 key 对应的数据量不同导致不同 task 处理的数据量不同。</p>
<p>这里需要注意一点，数据倾斜和数据过量不同，数据倾斜是某几个task处理的数据量很大，数据过量是所有task的数据量都很大。</p>
<p><strong>二. 数据倾斜的表现</strong></p>
<p>大部分 task 都快速执行完毕，少数 task 执行缓慢，甚至报错 OOM，即使最终运行完毕，也叫数据倾斜。</p>
<p><strong>三. 后果</strong></p>
<ol>
<li>程序运行缓慢；</li>
<li>报错OOM；</li>
</ol>
<p><strong>四. 定位问题</strong></p>
<ol>
<li>查看代码中的shuffle算子，如reduceByKey、sortByKey、groupByKey、join等，根据代码逻辑推断是否会出现数据倾斜；</li>
<li>查看spark log文件，log记录错误发生在哪一行，再根据自己的理解定位到哪个shuffle算子；</li>
<li>使用spark web UI查看。</li>
</ol>
<p><strong>五. 解决方案</strong></p>
<ol>
<li><p>使用Hive FTL预处理数据</p>
<p>​        适用于导致数据倾斜的表是hive表。如果该hive表中的数据本身就很不均匀，如某个key对应100万条数据，而其他key才对应10条数据，而且业务场景需要频繁使用spark对hive表执行某个分析操作，就比较适合使用这种技术。</p>
<p>​        该方法的优点是实现起来简单便捷，效果还非常好，完全规避掉了数据倾斜，Spark作业的性能会大幅度提升。</p>
<p>​        缺点是治标不治本，Hive ETL中还是会发生数据倾斜。</p>
</li>
<li><p>过滤少数会导致倾斜的key</p>
<p>​        如果我们判断哪少数几个数据量特别多的key，对作业的执行和计算结果不是特别重要的话，那么干脆就直接过滤掉那少数几个key。比如，在Spark SQL中可以使用where子句过滤掉这些key或者在Spark Core中对RDD执行filter算子过滤掉这些key。如果需要每次作业执行时，动态判定哪些key的数据量最多然后再进行过滤，那么可以使用sample算子对RDD进行采样，然后计算出每个key的数量，取数据量最多的key过滤掉即可。</p>
<p>​        优点是实现简单，而且效果也很好，可以完全规避掉数据倾斜。</p>
<p>​        缺点是适用场景不多，大多数情况下，导致倾斜的key还是很多的，并不是只有少数几个。</p>
</li>
<li><p>提高shuffle操作的并行度</p>
<p>​        在对RDD执行shuffle算子时，给shuffle算子传入一个参数，比如reduceByKey(1000)，该参数就设置了这个shuffle算子执行时shuffle read task的数量。对于Spark SQL中的shuffle类语句，比如group by、join等，需要设置一个参数，即spark.sql.shuffle.partitions，该参数代表了shuffle read task的并行度，该值默认是200，对于很多场景来说都有点过小。</p>
<p>​        优点是实现起来比较简单，可以有效缓解和减轻数据倾斜的影响。</p>
<p>​        缺点是只是缓解了数据倾斜而已，没有彻底根除问题，其效果有限。</p>
</li>
<li><p>局部和全局两阶段聚合</p>
<p>​        对RDD执行reduceByKey等聚合类shuffle算子或者在Spark SQL中使用group by语句进行分组聚合时，比较适用这种方案。</p>
<p>​        该方法的原理是将原本相同的key通过附加随机前缀的方式，变成多个不同的key，就可以让原本被一个task处理的数据分散到多个task上去做局部聚合，进而解决单个task处理数据量过多的问题。接着去除掉随机前缀，再次进行全局聚合，就可以得到最终的结果。</p>
<p>​        优点是对于聚合类的shuffle操作导致的数据倾斜，效果是非常不错的。通常都可以解决掉数据倾斜，或者至少是大幅度缓解数据倾斜，将Spark作业的性能提升数倍以上。</p>
<p>​        缺点是仅仅适用于聚合类的shuffle操作，适用范围相对较窄。如果是join类的shuffle操作，还得用其他的解决方案。</p>
</li>
<li><p>将reduce join转为map join</p>
<p>​        正常情况下，join 会产生 shuffle 过程，而且是 reduce join，即先将相同 key 对应的 value 汇聚到一个 reduce task 中，再进行 join。如果其中有一个 RDD 很小，就可以采用 广播小 RDD + map 大 RDD 实现 join 功能，此时没有 shuffle 操作，自然不会有数据倾斜。</p>
<p>​        该方法的优点是对join操作导致的数据倾斜，效果非常好，因为根本就不会发生shuffle，也就根本不会发生数据倾斜。</p>
<p>​        缺点是适用场景较少，因为这个方案只适用于一个大表和一个小表的情况。毕竟我们需要将小表进行广播，此时会比较消耗内存资源，driver和每个Executor内存中都会驻留一份小RDD的全量数据。如果我们广播出去的RDD数据比较大，比如10G以上，那么就可能发生内存溢出了。因此并不适合两个都是大表的情况。</p>
</li>
<li><p>采样倾斜key并分拆join操作</p>
<p>​        适于大表join大表，对于join导致的数据倾斜，如果只是某几个key导致了倾斜，可以将少数几个key分拆成独立RDD，并附加随机前缀打散成n份去进行join，此时这几个key对应的数据就不会集中在少数几个task上，而是分散到多个task进行join了。</p>
<p>​        优点是对于join导致的数据倾斜，如果只是某几个key导致了倾斜，采用该方式可以用最有效的方式打散key进行join。而且只需要针对少数倾斜key对应的数据进行扩容n倍，不需要对全量数据进行扩容。避免了占用过多内存。</p>
<p>​        缺点是如果导致倾斜的key特别多的话，比如成千上万个key都导致数据倾斜，那么这种方式也不适合。</p>
</li>
<li><p>使用随机前缀和扩容RDD进行join</p>
<p>​        适用于在进行join操作时，有大量的key导致数据倾斜。</p>
<p>​        它将原先一样的key通过附加随机前缀变成不一样的key，然后就可以将这些处理后的“不同key”分散到多个task中去处理，而不是让一个task处理大量的相同key。该方案上种方法的不同之处就在于，上一种方法是尽量只对少数倾斜key对应的数据进行特殊处理，由于处理过程需要扩容RDD，因此上一种方案扩容RDD后对内存的占用并不大；而这一种方案是针对有大量倾斜key的情况，没法将部分key拆分出来进行单独处理，因此只能对整个RDD进行数据扩容，对内存资源要求很高。</p>
<p>​        优点是对join类型的数据倾斜基本都可以处理，而且效果也相对比较显著，性能提升效果非常不错。</p>
<p>​        缺点是该方法更多的是缓解数据倾斜，而不是彻底避免数据倾斜。而且需要对整个RDD进行扩容，对内存资源要求很高。</p>
</li>
<li><p>多种方法组合使用</p>
<p>​        如果只是处理较为简单的数据倾斜场景，那么使用上述方案中的某一种基本就可以解决。但是如果要处理一个较为复杂的数据倾斜场景，那么可能需要将多种方案组合起来使用。比如说，我们针对出现了多个数据倾斜环节的Spark作业，可以先运用解决方案一和二，预处理一部分数据，并过滤一部分数据来缓解；其次可以对某些shuffle操作提升并行度，优化其性能；最后还可以针对不同的聚合或join操作，选择一种方案来优化其性能。</p>
</li>
</ol>
<h3 id="16-Spark的内存管理机制"><a href="#16-Spark的内存管理机制" class="headerlink" title="16. Spark的内存管理机制"></a>16. Spark的内存管理机制</h3><h4 id="B站摘："><a href="#B站摘：" class="headerlink" title="B站摘："></a>B站摘：</h4><p>​        在一个executor节点上，内存被分为堆内内存和堆外内存，堆外内存由JVM来使用，对spark来说是不可见的，所以更多讨论的是堆内内存的内容。</p>
<p>​        这一块分为四个部分，首先它会默认保留300M的Reserved保留存储，剩下的for执行、for缓存、和for用户的memory，默认是按照334的比例进行划分。其中for执行指的是在计算过程中，特别是shuffle过程中，所需要使用到的临时的内存，而for缓存是缓存rdd时需要用到的内存。在1.6版本之前，这些配置都是相对静态的，1.6之后spark引入了统一内存管理的特性，极大的简化和优化了这个问题。</p>
<p>​        在默认情况下，执行和缓存各占一半的内存，而在统一内存管理中，当缓存需要内存多于一半的时候，它可以部分的占用原本属于执行的内存空间，反过来也一样，从而使它们之间有一个buffer的区域，可以互相占用，这种方式可以保证在大多数情况下，内存能有一个很好的利用。</p>
<h4 id="网上找："><a href="#网上找：" class="headerlink" title="网上找："></a>网上找：</h4><p>在执行 Spark 的应用程序时，Spark 集群会启动 Driver 和 Executor 两种 JVM 进程，前者为主控进程，负责创建 Spark 上下文，提交 Spark 作业（Job），并将作业转化为计算任务（Task），在各个 Executor 进程间协调任务的调度，后者负责在工作节点上执行具体的计算任务，并将结果返回给 Driver，同时为需要持久化的 RDD 提供存储功能。</p>
<p>1）堆内和堆外内存划分<br>堆内内存受到 JVM 统一管理，堆外内存是直接向操作系统进行内存的申请和释放。<br>1&gt;堆内内存<br>Executor 内运行的并发任务共享 JVM 堆内内存，这些任务在缓存 RDD 数据和广播（Broadcast）数据时占用的内存被规划为存储（Storage）内存 ， 而这些任务在执行 Shuffle 时占用的内存被规划为执行（Execution）内存，剩余的部分不做特殊规划，那些 Spark 内部的对象实例，或者用户定义的 Spark 应用程序中的对象实例，均占用剩余的空间。</p>
<p>Spark 对堆内内存的管理是一种逻辑上的”规划式”的管理，因为对象实例占用内存的申请和释放都由 JVM 完成，Spark 只能在申请后和释放前记录这些内存，我们来看其具体流程：<br>申请内存流程如下：<br>1.Spark 在代码中 new 一个对象实例；<br>2.JVM 从堆内内存分配空间，创建对象并返回对象引用；<br>3.Spark 保存该对象的引用，记录该对象占用的内存。<br>释放内存流程如下：<br>1.Spark 记录该对象释放的内存，删除该对象的引用；<br>2.等待 JVM 的垃圾回收机制释放该对象占用的堆内内存。<br>java虚拟机管理的内存（堆内内存），若想去控制它，比如说资源的释放是无法做到的，通知释放指令后，什么时候释放是不确定的，只能通知而不能控制，导致不灵活，即被 Spark 标记为释放的对象实例，很有可能在实际上并没有被 JVM 回收，导致实际可用的内存小于 Spark 记录的可用内存，比如想要去加载数据，但是发现内存没释放，导致内存不够用。所以 Spark 并不能准确记录实际可用的堆内内存。<br>2&gt;堆外内存<br>为了进一步优化内存的使用以及提高 Shuffle 时排序的效率，Spark 引入了堆外（Off-heap）内存。堆外内存意味着把内存对象分配在 Java 虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机）。这样做的结果就是能保持一个较小的堆，以减少垃圾收集对应用的影响。<br>堆外内存可以被精确地申请和释放（堆外内存之所以能够被精确的申请和释放，是由于内存的申请和释放不再通过 JVM 机制，而是直接向操作系统申请，JVM 对于内存的清理是无法准确指定时间点的，因此无法实现精确的释放），而且堆外内存序列化的数据占用的空间可以被精确计算，所以相比堆内内存来说降低了管理的难度，也降低了误差。但是相对来说也就不安全。因为它不是自动化的，而是人为控制的，存在人为操作错误的风险。<br>2）内存空间分配<br>和java虚拟机内存结构进行分类管理类似，Spark也将内存进行分类，分为：存储内存、执行内存、其他内存。</p>
<p>存储内存主要存储RDD缓存数据以及广播变量（广播变量：把task重复的数据独立出来共享到Excuter，所以放在存储内存中）。<br>执行内存存储的是Shuffle过程中的操作。<br>其他内存：系统自带的数据以及RDD元数据的信息。<br>预留内存：固定大小300M。<br>存储内存占除了预留内存其余内存的30%，执行内存占30%，其他内存占40%。</p>
<p>在 Spark 最初采用的静态内存管理机制下，存储内存、执行内存和其他内存的大小在 Spark 应用程序运行期间均为固定的，Spark 1.6 之后引入的统一内存管理机制，与静态内存管理的区别在于存储内存和执行内存共享同一块空间，可以动态占用对方的空闲区域。</p>
<p>其中最重要的优化在于动态占用机制，其规则如下：<br>1&gt;设定基本的存储内存和执行内存区域（spark.storage.storageFraction 参数），该设定确定了双方各自拥有的空间的范围；<br>2&gt;双方的空间都不足时，则存储到硬盘；若一方空间不足而对方空余时，可借用对方的空间;（存储空间不足是指不足以放下一个完整的 Block）.<br>3&gt;存储内存不够的时候，向执行内存借的内存需要还回去。可让对方将占用的部分转存到硬盘，然后”归还”借用的空间；<br>4&gt;执行内存不够用向存储内存借的内存不用还，因为如果执行内存还回借用的内存，会造成数据丢失，shuffle在Excuter中执行，意味着需要做统计分析。数据丢失，那么统计的结果将不正确。因此Excuter不能淘汰内存还给存储内存。<br>        存储内存不够的时候，向执行内存借的内存需要还回去，而执行内存不够用向存储内存借的内存不用还。因为存储内存如果丢失了，可以再走一遍，程序不会出现太多问题，只不过性能差一些，延时更长一些。如果执行内存还回借用的内存，会造成数据丢失，shuffle在Excuter中执行，意味着需要做统计分析。数据丢失，那么统计的结果将不正确。因此Excuter不能淘汰内存还给存储内存。</p>
<h3 id="17-spark中可以引起shuffle的算子"><a href="#17-spark中可以引起shuffle的算子" class="headerlink" title="17. spark中可以引起shuffle的算子"></a>17. spark中可以引起shuffle的算子</h3><ol>
<li>去重：distinct</li>
<li>聚合：reduceByKey、groupByKey、aggregateByKey、combineByKey。</li>
<li>排序：sortByKey、sortBy</li>
<li>重分区：coalesce、repartition</li>
<li>集合或表操作：intersection、subtract、subtractByKey、join、leftOuterJoin</li>
</ol>
<h3 id="18-Spark中的Shuffle"><a href="#18-Spark中的Shuffle" class="headerlink" title="18. Spark中的Shuffle"></a>18. Spark中的Shuffle</h3><p>​        Shuffle描述着数据从map task输出到reduce task输入的这段过程。shuffle是连接Map和Reduce之间的桥梁，Map的输出要用到Reduce中必须经过shuffle这个环节，shuffle的性能高低直接影响了整个程序的性能和吞吐量。因为在分布式情况下，reduce task需要跨节点去拉取其它节点上的map task结果。这一过程将会产生网络资源消耗和内存，磁盘IO的消耗。通常shuffle分为两部分：Map阶段的数据准备和Reduce阶段的数据拷贝处理。一般将在map端的Shuffle称之为Shuffle Write，在Reduce端的Shuffle称之为Shuffle Read。</p>
<p>​        在Spark的中，负责shuffle过程的执行、计算和处理的组件主要就是ShuffleManager，也即shuffle管理器。ShuffleManager随着Spark的发展有两种实现的方式，分别为HashShuffleManager和SortShuffleManager，因此spark的Shuffle有Hash Shuffle和Sort Shuffle两种。</p>
<p>1）Hash shuffle</p>
<p>这种shuffle类型在2.0之后就不再使用了。优化前的hashshuffle，每个task 会生成reducer类别数的数据文件，然后reducer会将每个task中对应类别的数据收集汇聚，这种方式会得到n个task和m个reducer数量输出的n * m数量的小文件；优化后的hashshuffle会复用buffer，即无论多少个task，都只会将数据存放在m个reducer数量的buffer中。</p>
<p>2）Sort Shuffle</p>
<p>​        这种方式以更少的中间磁盘文件产生而远远优于HashShuffle。而它的运行机制主要分为两种。一种为普通机制，另一种为bypass机制。而bypass机制的启动条件为，当shuffle read task的数量小于等于spark.shuffle.sort.bypassMergeThreshold参数的值时（默认为200），就会启用bypass机制。</p>
<p>（1）普通机制：</p>
<p>​        在该模式下，数据会先写入一个数据结构，聚合算子写入Map，一边通过Map局部聚合，一遍写入内存。Join算子写入ArrayList直接写入内存中。然后需要判断是否达到阈值，如果达到就会将内存数据结构的数据写入到磁盘，清空内存数据结构。</p>
<p>​        在溢写磁盘前，先根据key进行排序，排序过后的数据，会分批写入到磁盘文件中。默认批次为10000条，数据会以每批一万条写入到磁盘文件。写入磁盘文件通过缓冲区溢写的方式，每次溢写都会产生一个磁盘文件，也就是说一个task过程会产生多个临时文件。</p>
<p>​        最后在每个task中，将所有的临时文件合并，这就是merge过程，此过程将所有临时文件读取出来，一次写入到最终文件。意味着一个task的所有数据都在这一个文件中。同时单独写一份索引文件，标识下游各个task的数据在文件中的索引，start offset和end offset。</p>
<p>​        这样算来如果第一个stage 50个task，每个Executor执行一个task，那么无论下游有几个task，就需要50个磁盘文件。</p>
<p>（2）bypass机制</p>
<p>bypass机制运行条件：</p>
<p>① shuffle map task数量小于spark.shuffle.sort.bypassMergeThreshold参数的值。<br>② 不是聚合类的shuffle算子（比如reduceByKey）。<br>        在这种机制下，当前stage的task会为每个下游的task都创建临时磁盘文件。将数据按照key值进行hash，然后根据hash值，将key写入对应的磁盘文件中（个人觉得这也相当于一次另类的排序，将相同的key放在一起了）。最终，同样会将所有临时文件依次合并成一个磁盘文件，建立索引。</p>
<p>​        该机制与未优化的hashshuffle相比，没有那么多磁盘文件，下游task的read操作相对性能会更好。</p>
<p>​        该机制与sortshuffle的普通机制相比，在readtask不多的情况下，首先写的机制是不同，其次不会进行排序。这样就可以节约一部分性能开销。</p>
<h3 id="19-foreach和foreachPartition的区别"><a href="#19-foreach和foreachPartition的区别" class="headerlink" title="19. foreach和foreachPartition的区别"></a>19. foreach和foreachPartition的区别</h3><h4 id="我自己的理解"><a href="#我自己的理解" class="headerlink" title="我自己的理解"></a>我自己的理解</h4><p>二者都用来迭代rdd，前者一次迭代一个数据，后者一次迭代一批数据。</p>
<h4 id="找到的答案"><a href="#找到的答案" class="headerlink" title="找到的答案"></a>找到的答案</h4><p>每个partition中iterator时行迭代的处理，通过用户传入的function对iterator进行内容的处理。</p>
<p>（1）foreach</p>
<p>​        Foreach中，传入一个function，这个函数的传入参数就是每个partition中，每次的foreach得到的一个rdd的kv实例，也就是具体的内容<br>​        这种处理你并不知道这个iterator的foreach什么时候结果，只能是在foreach过程中，你得到一条数据，就处理一条数据。</p>
<p>（2）foreachPartition</p>
<p>​        这个函数也是根据传入的function进行处理，但是不同之处再有这里function传入的参数是一个partition对应数据的iterator，而不是直接使用iterator的foreach。</p>
<h3 id="20-map和mapPartitions的区别"><a href="#20-map和mapPartitions的区别" class="headerlink" title="20 map和mapPartitions的区别"></a>20 map和mapPartitions的区别</h3><p>（1）主要区别在于：</p>
<p>1） map ：一次处理一个元素的数据；</p>
<p>2）mapPartitions：一次处理一批数据。</p>
<p>（2）mapPartitions的优缺点：</p>
<p>优点：速度快，一次处理一批数据，即一次接收所有的partition数据，在map过程中需要频繁创建额外的对象(例如将rdd中的数据通过jdbc写入数据库，map需要为每个元素创建一个链接，而mapPartition为每个partition创建一个链接)，则mapPartitions效率比map高的多。</p>
<p>缺点：容易出现内存溢出，当接收的partition的数据量较大时，例如100万数据， 一次传入一个function以后，那么可能一下子内存不够，但是又没有办法去腾出内存空间来，可能就导致OOM（内存溢出）；而map一般较少出现内存溢出。</p>
<p>（3）mapPartitions()出现内存溢出时的解决方法：</p>
<ol>
<li>将数据切成较多的partition：<br><code>repartition(100).mapPartitions(xx)</code></li>
<li>设置较大的处理器内存<br><code>--executor-memory 8g</code></li>
</ol>
<h3 id="21-Spark-Sql支持的存储文件类型？"><a href="#21-Spark-Sql支持的存储文件类型？" class="headerlink" title="21 Spark Sql支持的存储文件类型？"></a>21 Spark Sql支持的存储文件类型？</h3><p>常见的文件存储类型：Text文件、Json文件、Sequence文件和Object文件。<br>Spark Sql的默认存储格式是Parquet，Parquet是一种列式存储格式。</p>
<h3 id="22-spark的核心组件"><a href="#22-spark的核心组件" class="headerlink" title="22 spark的核心组件"></a>22 spark的核心组件</h3><ol>
<li><p>Driver：Spark驱动节点，用于执行Spark任务中的main方法，负责实际代码的执行工作。Driver在Spark作业执行时主要负责：</p>
<p>1）将用户程序转化为job；</p>
<p>2）在Executor之间调度Task；</p>
<p>3）跟踪Executor的执行情况；</p>
<p>4）通过UI查询展示运行情况；</p>
</li>
<li><p>Executor：Executor节点是一个JVM进程，负责运行具体任务，任务之间相互独立。</p>
<p>Spark应用启动时，Executor节点被同时启动，并且始终伴随着整个Spark应用的生命周期。</p>
<p>如果有Executor节点发生故障或者崩溃，Spark应用会将出错节点上的任务调度到其他Executor节点上继续运行。</p>
<p>Executor有两个核心功能：</p>
<p>1）负责运行组成Spark应用的任务，并将结果返回给驱动器进程；</p>
<p>2）Executor通过自身的块管理器（Block Manager）为用户程序中要求缓存的RDD提供内存式存储。RDD是直接缓存在Executor进程内的，因此任务可以在运行时充分利用缓存数据加速运算。</p>
</li>
</ol>
<h3 id="23-什么是RDD"><a href="#23-什么是RDD" class="headerlink" title="23 什么是RDD"></a>23 什么是RDD</h3><p>RDD (Resilient Distributed Dataset)叫做弹性分布式数据集，是Spark中最基本的数据处理模型。代码中是一个抽象类，它代表一个弹性的、不可变、可分区、里面的元素可并行计算的集合。</p>
<p>它有五大特性：</p>
<ol>
<li><p><strong>分区列表( a list of partitions)</strong></p>
<p>Spark RDD是被分区的，每一个分区都会被一个计算任务(Task)处理，分区数决定了并行计算的数量，RDD的并行度默认从父RDD传给子RDD。默认情况下，一个HDFS上的数据分片就是一个 partiton，RDD分片数决定了并行计算的力度，可以在创建RDD时指定RDD分片个数（分区）。</p>
</li>
<li><p><strong>每一个分区（分片）都有一个计算函数( a function for computing each split）</strong></p>
<p>每个分区都会有计算函数， Spark的RDD的计算函数是以分片为基本单位的，每个RDD都会实现 compute函数，对具体的分片进行计算，RDD中的分片是并行的，所以是分布式并行计算。</p>
</li>
<li><p><strong>依赖于其他RDD的列表</strong></p>
<p>RDD会记录它的依赖 ，为了容错，也就是说在内存中的RDD操作时出错或丢失会进行重算。</p>
</li>
<li><p><strong>key- value数据类型的RDD分区</strong></p>
<p>如果RDD里面存的数据是key-value形式，则可以传递一个自定义的Partitioner进行重新分区，例如这里自定义的Partitioner是基于key进行分区，那则会将不同RDD里面的相同key的数据放到同一个partition里面。</p>
</li>
<li><p><strong>每个分区都有一个优先位置列表</strong></p>
<p>优先位置列表会存储每个 Partition的优先位置，对于一个HDFS文件来说，就是每个Partition块的位置。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 面试题</title>
    <url>/2021/11/15/Java-%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1-Java语言的特点"><a href="#1-Java语言的特点" class="headerlink" title="1. Java语言的特点"></a>1. Java语言的特点</h2><p>Java语言有十大特点：</p>
<span id="more"></span>
<ol>
<li>简单性：Java继承c++语言的优点，去掉指针运算、头文件等比较复杂的部分，使用起来更加方便；</li>
<li>面向对象：即面向数据；</li>
<li>分布性：Java应用程序可以通过url打开或访问网络上的对象，其便捷程度仿佛访问本地文件一样；</li>
<li>编译和解释性：Java编译程序生成字节码，而不是普通机器的机器码，这使得Java开发比其他语言更快；</li>
<li>稳健性：Java编译器能检测出在其它语言中仅在运行时才能检测出来的问题；</li>
<li>安全性：Java的存储分配模型是防御恶意代码的主要方法之一，因此许多大型项目都会选择Java开发；</li>
<li>高性能：字节码可以在运行时动态翻译对应运行该应用的cpu的机器码；</li>
<li>可移植性：Java不依赖于平台，Java程序可以运行在所有平台上；</li>
<li>多线程：可以同时执行多个程序，处理不同任务；</li>
<li>动态性：库中可以自由添加新方法和实例变量，不会对客户端产生任何影响。</li>
</ol>
<hr>
<h3 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h3><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><p>就是分析出系统中应包含哪些对象，以及它们之间的关系，再用特定的语法来描述这些对象和关系。</p>
<p>比如，使用面向对象的思想来说一下上课的过程。有电瓶车和司机，司机开电瓶车，我要坐电瓶车去上课，然后有学生，上课的点有许多学生要上车，还有教学楼，乘车到目的的教学楼然后下车前往教室上课。</p>
<h3 id="Java运行机制-机器码和字节码"><a href="#Java运行机制-机器码和字节码" class="headerlink" title="Java运行机制 - 机器码和字节码"></a>Java运行机制 - 机器码和字节码</h3><p>​        现在我们所使用的几乎所有的编程语言都是高级语言。用这种语言写的代码，就是由英文和符号组成的代码，就是源代码。之后，为了能让计算机识别代码，需要<strong>将源代码翻译为二进制的机器码</strong>。</p>
<p>​        从源代码生成机器码的过程有两种形式：编译和解释。</p>
<blockquote>
<p>编译：程序运行前，使用编译器将代码完全翻译为机器码；</p>
<p>解释：程序运行时，使用解释器逐行翻译代码，并运行。</p>
<ol>
<li><u><em>源代码 — [编译] —&gt; 机器码 — [运行] —&gt; 计算机</em></u></li>
</ol>
<blockquote>
<p>这种方式的优点是程序运行的效率会很高；问题在于，不同架构的计算机的机器码是不一样的，这种情况下，源代码的可移植性不高。如果要在多种计算机下运行，就需要编译多次，甚至还需要改部分源代码，</p>
</blockquote>
<ol>
<li><u><em>源代码 — [运行] —&gt; 计算机 — [解释] —&gt; 机器码</em></u>  注：解释的过程是在计算机中进行 <em><u>源代码 — [解释] —&gt; 机器码</u></em> 的过程。</li>
</ol>
<blockquote>
<p>在计算机运行的情况下，解释一行，执行一行。这种方式相较于上面的方式会慢一些，但是可以提高源代码的可移植性。因为不同计算机的解释器会有不同的版本，只需要写一份源代码，在计算机运行时会解释成相对应的机器码。</p>
</blockquote>
</blockquote>
<p>​        <strong>Java使用的方式是：先编译，后解释。此处引出中间内容，字节码。</strong></p>
<blockquote>
<p>先编译：程序运行前，使用编译器将代码完全翻译为字节码；</p>
<p>后解释：程序运行时，使用解释器将字节码逐行翻译成机器码，并运行。</p>
<p>下面逐步理解：</p>
<p><em><u> 1. 源代码 — [编译] —&gt; 字节码 — [运行] —&gt; 计算机</u></em></p>
<blockquote>
<p>字节码和机器码比较接近，也是二进制文件，所以如果在计算机上将字节码解释成机器码会比较快；之后我们将字节码提交给计算机运行；</p>
</blockquote>
<p><em><u>2. [计算机中] —&gt; 字节码 —[解释] —&gt; 机器码</u></em></p>
<blockquote>
<p>在计算机中，使用解释器将字节码翻译成机器码就会比较快。</p>
</blockquote>
<p>Java将两种方式结合的好处有两个：</p>
<ol>
<li>相比较解释性语言，Java在运行时的部分效率比较高；</li>
<li>相较于编译型语言，Java只需要一份字节码就可以运行在多应用上，所以更方便跨平台。</li>
</ol>
</blockquote>
<h2 id="2-JDK、JRE和JVM的区别和联系"><a href="#2-JDK、JRE和JVM的区别和联系" class="headerlink" title="2. JDK、JRE和JVM的区别和联系"></a>2. JDK、JRE和JVM的区别和联系</h2><p>​        JDK是Java标准开发包，包括编译以及运行Java程序所需的各种工具和资源，比如Java编译器、Java运行时环境、常用的Java类库等。</p>
<p>​        JRE是Java运行时环境，用于编译和执行字节码文件，普通用户只需要运行Java程序安装JRE就好，如果要编译和调试程序需要安装JDK。</p>
<p>​        JVM是Java虚拟机，是JRE的一部分，是Java跨平台最核心的部分，用于解释和执行字节码文件。所有平台的JVM虚拟机都向Java编译器提供一个相同的接口，Java编译器只需要面向JVM，生成虚拟机能够识别的字节码，就可以实现跨平台运行。</p>
<h2 id="3-类和对象"><a href="#3-类和对象" class="headerlink" title="3. 类和对象"></a>3. 类和对象</h2><p>类可以相当于设计图，用于描述一批对象的信息，它是抽象的，不是具体的实例；</p>
<p>对象是具体的，是根据类的描述，由JVM创建出来的一个实例，这个过程叫实例化；</p>
<p>类是自定义的数据类型，通过这个类创建对象，实际上就是初始化这种类型的变量。</p>
<h2 id="4-面向对象的三大特征"><a href="#4-面向对象的三大特征" class="headerlink" title="4. 面向对象的三大特征"></a>4. 面向对象的三大特征</h2><p>三大特征为：封装、继承、多态。</p>
<ol>
<li>封装：指属性私有化，隐藏具体实现的细节，仅提供setter和getter方法来访问属性，用于提高数据安全性，类和方法也属于封装；</li>
<li>继承：指将多个相同的属性和方法提取出来，新建为一个父类，子类可以重写其中的方法，用于代码复用；</li>
<li>多态：分为两种，编译时多态和运行时多态，编译时多态即重载，方法名相同而参数不同；运行时多态即重写，子类重写父类方法，用于增强代码的灵活度。</li>
</ol>
<h2 id="5-修饰符"><a href="#5-修饰符" class="headerlink" title="5. 修饰符"></a>5. 修饰符</h2><p>分为访问修饰符和非访问修饰符。</p>
<p><strong>访问修饰符有：</strong></p>
<ol>
<li>public：对所有的类都可见；</li>
<li>protected：对同一个包可见，如果父类和子类不同包，对不同包的子类可见；</li>
<li>default：对同一个包可见；</li>
<li>private：对同一个类可见。</li>
</ol>
<p><strong>非访问修饰符有：</strong></p>
<ol>
<li>static：声明的对象初始化后不能再修改；</li>
<li>final：修饰的类不能被继承，修饰的方法不能重新定义，修饰的变量为常量；</li>
<li>synchronized：用于多线程同步；</li>
<li>abstract：用来创建抽象类和方法。</li>
</ol>
<h2 id="6-Object类的常用方法"><a href="#6-Object类的常用方法" class="headerlink" title="6. Object类的常用方法"></a>6. Object类的常用方法</h2><ol>
<li>equals() - 判断相等</li>
<li>hashCode() - 返回散列值；</li>
<li>toString() - 返回对象的字符串表示；</li>
<li>clone() - 创建并返回对象的克隆对象，一般子类会重写该方法；</li>
<li>finalized() - 当垃圾收集确定对象没有更多的引用时，由该对象的垃圾收集器调用；</li>
<li>getClass() - 返回此对象的运行时class类对象；</li>
<li>notify() - 唤醒正在此对象监视器上等待的某个线程，主要用于多线程通信，需配合wait()方法使用；</li>
<li>notifyAll() - 唤醒正在此对象监视器上等待的全部线程；</li>
<li>wait() - 导致当前线程等待，直到另一个对象调用该对象的notify() 或 notifyAll() 方法；</li>
<li>wait(long timeout) - 导致当前线程等待，直到另一个对象调用该对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法，或经过指定的timeout时间；</li>
<li>wait(long timeout, int nanos) - 导致当前线程等待，直到另一个对象调用当前对象的 <code>notify()</code> 或 <code>notifyAll()</code> 或经过指定的timeout时间或被其他线程中断当前线程。</li>
</ol>
<h2 id="7-字符型常量和字符串常量的区别"><a href="#7-字符型常量和字符串常量的区别" class="headerlink" title="7. 字符型常量和字符串常量的区别"></a>7. 字符型常量和字符串常量的区别</h2><ol>
<li>字符型用单引号，字符串用双引号；</li>
<li>字符型相当于一个ascii值，可以直接参与计算，字符串是一个地址值，代表该字符串在内存中存放的位置；</li>
<li>Java中字符型占两个字节，字符串占若干字节，字节数由其中的字符数决定。</li>
</ol>
<h2 id="8-常见的关键字"><a href="#8-常见的关键字" class="headerlink" title="8. 常见的关键字"></a>8. 常见的关键字</h2><p>private、default、public、protected、static初始化后不再更改、this表示当前类的对象引用、final避免重写等。</p>
<h2 id="9-标识符和关键字的区别"><a href="#9-标识符和关键字的区别" class="headerlink" title="9. 标识符和关键字的区别"></a>9. 标识符和关键字的区别</h2><p>标识符是用户编程时创建的名称，关键字是具有特殊含义的单词。</p>
<h2 id="10-泛型和泛型擦除"><a href="#10-泛型和泛型擦除" class="headerlink" title="10. 泛型和泛型擦除"></a>10. 泛型和泛型擦除</h2><p>​        参数化类型被称为泛型，泛型允许在创建集合时指定元素的类型，则集合中只保存这种类型的元素。泛型的作用是在发生编译时，提供安全检查机制。</p>
<p>​        泛型类允许在定义接口、类、方法时声明类型形参，该类型形参在整个接口、类、方法中可以作为普通类型使用，直到声明变量、创建对象或调用方法时再动态的指定实际的参数类型。如果要定义泛型类的子类，因为此时是在使用父类了，所以必须传入实参，或者不传参。</p>
<p>​        在定义泛型的时候也可以指定类型形参的上限，如 <code>class A&lt;T extends B&gt;</code> ，该声明表示，传入的实参为类型 <code>B</code> 及其子类。</p>
<p>​        而泛型擦除是指，当把一个具有泛型信息的对象赋值给一个没有泛型的对象，就会把尖括号之间的所有泛型信息都扔掉，比如List<Integer> 类型会转换为 List 类型，则该 List 元素的类型就会变成该类型变量的上限。如果反过来，就是泛型转换。</p>
<h2 id="11-和-equals-的区别，以及hashCode-和-euqlas"><a href="#11-和-equals-的区别，以及hashCode-和-euqlas" class="headerlink" title="11. == 和 equals() 的区别，以及hashCode() 和 euqlas()"></a>11. == 和 equals() 的区别，以及hashCode() 和 euqlas()</h2><ol>
<li><p>== 和 equals() 的区别：==比较基本类型会判断两个值是否相同，比较引用类型会判断两个地址是否相同；equals知判断引用类型的两个地址是否相同。</p>
</li>
<li><p>hashCode() 和 equals() 的区别和联系：</p>
<p>（1）HashCode()返回的值是一个对象在hash表中的位置，这个位置是依据特定的hash算法得到的，所以，两个不同的对象有可能有相同的hash code；<br>（2）hashcode()和equals()常被组合用于排序，在大型排序中，常会重写hashcode()和equals()方法，让具有相同hashcode的对象执行equals()方法，以提高排序的效率；<br>（3）相同的hash code，equals()返回的值不一定是true；equals返回值相同的，hash code一定相同。</p>
</li>
</ol>
<h2 id="12-基本的数据类型有哪些？自动装箱和拆箱？"><a href="#12-基本的数据类型有哪些？自动装箱和拆箱？" class="headerlink" title="12. 基本的数据类型有哪些？自动装箱和拆箱？"></a>12. 基本的数据类型有哪些？自动装箱和拆箱？</h2><ol>
<li>Java支持的数据类型有两种：基本数据类型和引用类型。</li>
</ol>
<p>（1）基本数据类型有8个：int、short、double、float、byte、char、long、boolean；</p>
<p>（2）引用类型比如 String、Integer等。</p>
<ol>
<li><p>自动装箱和拆箱：</p>
<p>​        自动装箱和拆箱是基本类型和包装器类型之间的转换，比如是 <code>int</code> 和 <code>Integer</code> 之间的转换，自动装箱将 <code>int</code> 转换为 <code>Integer</code>，拆箱反之。</p>
<p>​        装箱和拆箱的实现过程是：装箱通过调用包装器的 <code>valueOf</code> 方法实现，拆箱通过调用包装器的 <code>xxxValue</code> 实现，如 <code>intValue</code> 。</p>
</li>
<li><p>引申问题①：<strong>Integer i = new Integer(10)</strong> 和 <strong>Integer i = 10</strong> 的区别</p>
<p>（1）第一种方式不会触发自动装箱，第二种会；</p>
<p>（2）一般情况下，第二种方式的执行效率和资源占比会比第一种方式高，但不是绝对的。</p>
</li>
<li><p>引申问题②：下面程序的输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer i1 = <span class="number">100</span>;</span><br><span class="line">    Integer i2 = <span class="number">100</span>;</span><br><span class="line">    Integer i3 = <span class="number">200</span>;</span><br><span class="line">    Integer i4 = <span class="number">200</span>;</span><br><span class="line">   </span><br><span class="line">    System.out.println(i1 == i2);</span><br><span class="line">    System.out.println(i3 == i4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答：</p>
<blockquote>
<p>true</p>
<p>false</p>
</blockquote>
<p><strong>因为Integer的范围是：-128 ~ 127</strong> 。Integer、Short、Byte、Character、Long这几个类的 <code>valueOf</code> 是类似的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Double i1 = <span class="number">100.0</span>;</span><br><span class="line">    Double i2 = <span class="number">100.0</span>;</span><br><span class="line">    Double i3 = <span class="number">200.0</span>;</span><br><span class="line">    Double i4 = <span class="number">200.0</span>;</span><br><span class="line">   </span><br><span class="line">    System.out.println(i1 == i2);</span><br><span class="line">    System.out.println(i3 == i4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答：</p>
<blockquote>
<p>false</p>
<p>false</p>
</blockquote>
<p><strong>因为在某个范围整形是有限的，而浮点数不是</strong> 。Double、Float的 <code>valueOf</code> 是类似的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Boolean i1 = <span class="keyword">false</span>;</span><br><span class="line">    Boolean i2 = <span class="keyword">false</span>;</span><br><span class="line">    Boolean i3 = <span class="keyword">true</span>;</span><br><span class="line">    Boolean i4 = <span class="keyword">true</span>;</span><br><span class="line">   </span><br><span class="line">    System.out.println(i1 == i2);</span><br><span class="line">    System.out.println(i3 == i4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答：</p>
<blockquote>
<p>true</p>
<p>true</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="number">1</span>;</span><br><span class="line">    Integer b = <span class="number">2</span>;</span><br><span class="line">    Integer c = <span class="number">3</span>;</span><br><span class="line">    Long g = <span class="number">3L</span>;</span><br><span class="line">    Long h = <span class="number">2L</span>;</span><br><span class="line">   </span><br><span class="line">    System.out.println(c==(a+b)); <span class="comment">//1</span></span><br><span class="line">    System.out.println(c.equals(a+b)); <span class="comment">//2</span></span><br><span class="line">    System.out.println(g==(a+b)); <span class="comment">//3</span></span><br><span class="line">    System.out.println(g.equals(a+b)); <span class="comment">//4</span></span><br><span class="line">    System.out.println(g.equals(a+h)); <span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答：</p>
<blockquote>
<p>true<br>true<br>true<br>false<br>true</p>
</blockquote>
<p>首先我们需要知道：</p>
<p>（1）算术运算符仅对于基本数据类型，所以包装器类型进行运算的时候会自动拆箱；</p>
<p>（2）<code>equals</code> 会比较两个对象的类型和值。</p>
<p>所以可以得知 <code>1</code> 、<code>2</code> 和 <code>3</code> 都是 <code>true</code> ，<code>4</code> 因为 <code>Integer</code> 和 <code>Long</code> 类型不同所以是 <code>false</code>，<code>5</code> 因为 <code>h</code> 是 <code>Long</code> 类型，<code>Long</code> 比 <code>Integer</code> 的范围广泛，所以相加后自动装箱会转换为 <code>Long</code> ，之后比较值是相等的，所以是相等的。</p>
</li>
</ol>
<h2 id="13-重载和重写？深拷贝和浅拷贝？"><a href="#13-重载和重写？深拷贝和浅拷贝？" class="headerlink" title="13. 重载和重写？深拷贝和浅拷贝？"></a>13. 重载和重写？深拷贝和浅拷贝？</h2><ol>
<li>重载和重写：重载是方法名相同参数不同；重写是继承父类方法并重写它。</li>
<li>深拷贝和浅拷贝：浅拷贝是拷贝原对象的引用值；深拷贝是根据原对象创建一个新对象。</li>
</ol>
<h2 id="14-方法的四种类型"><a href="#14-方法的四种类型" class="headerlink" title="14. 方法的四种类型"></a>14. 方法的四种类型</h2><p>无参无返回值、无参有返回值、有参无返回值、有参有返回值。</p>
<h2 id="15-常见设计模式"><a href="#15-常见设计模式" class="headerlink" title="15. 常见设计模式"></a>15. 常见设计模式</h2><h3 id="设计模式的原则"><a href="#设计模式的原则" class="headerlink" title="设计模式的原则"></a>设计模式的原则</h3><ol>
<li><p>单一原则：</p>
<p>​    即一个类只有一个职责；</p>
</li>
<li><p>开闭原则：</p>
<p>​    软件实体可扩展，但不可修改。</p>
<p>​    就好比“一国两制”，一个国家有两种制度，没有修改原有的管理制度，而是增加了一种新的制度。对于扩展是开放的，对于更改是封闭的。</p>
</li>
<li><p>里氏代换原则：</p>
<p>​    子类型必须能够替换掉它们的父类型。</p>
<p>​    举个例子，假如现在父类是鸟类，有个属性是可以飞，子类有个企鹅类，那么很明显企鹅类不能继承鸟类，因为鸟类有会飞的属性，如果子类企鹅类继承父类鸟类，则企鹅必须会飞。</p>
</li>
<li><p>依赖倒置原则：</p>
<p>​    高层模块不应该依赖底层模块，两个都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象。后面这句话换个方式说就是针对接口编程，不要对实现编程。</p>
<p>​    举个例子，就好比你的电脑，如果CPU、内存、硬盘都需要依赖具体的主板，主板坏了，所有的部件都不能用了，这显然是不合理的。</p>
<p>​    换句话说，即谁也不要依赖谁，除了约定的接口，大家都可以灵活自如。</p>
</li>
<li><p>接口隔离原则：</p>
<p>​    接口尽量细化，使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p>
<p>​    比如星探找艺人，需要通过一个标准来找，可以分为外貌型和气质型两个接口，这样之后不管是选择气质型的艺人还是外貌型的，都可以保持接口的稳定。</p>
</li>
<li><p>迪米特原则：</p>
<p>​    尽量减少对象之间的交互，可以引入一个合理的第三方来降低现有对象之间的耦合度。</p>
<p>​    比如体育老师上课前清点人数，他让体育委员来替他清点人数，之后再由体育委员告知结果即可，老师本身并没有接触到其他学生。</p>
</li>
<li><p>合成/聚合复用原则</p>
<p>​    尽量使用合成/聚合，尽量不要使用类继承。</p>
<p>​    合成表示一种强的“拥有”关系，体现了严格的部分与整体的关系，他们的生命周期相同；而聚合表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。</p>
<p>​    这里再举个简单的例子，大雁与翅膀是合成关系；而每只大雁都属于一个雁群，即一个雁群可以有多只大雁，所以大雁和雁群是聚合关系。</p>
</li>
</ol>
<h3 id="（1）-单例模式"><a href="#（1）-单例模式" class="headerlink" title="（1） 单例模式"></a>（1） 单例模式</h3><p>使用单一的类创建对象，它只有一个实例，必须自己创建。</p>
<p>懒汉式 - 线程不安全：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton Instance;</span><br><span class="line">    <span class="comment">//私有构造方法，保证外界无法直接实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>( Instance == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            Tnstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式延迟实例化，好处是没有用到该类，就不会实例化Instance，从而节约资源；坏处是线程不安全，多线程情况下会多次创建实例。</p>
<p>懒汉式 - 线程安全：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton Instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( Instance == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            Instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对静态代码 <code>getInstance()</code> 加锁，以确保多线程环境下只会创建一个实例。</p>
<p>饿汉式 - 线程安全：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton Instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接实例化，不会产生线程不安全的问题，但是这也丢失了延迟实例化带来的节约资源的好处。</p>
<p>双重校验锁 - 线程安全：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton Instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( Instance == <span class="keyword">null</span> )<span class="comment">//为了提高代码执行效率，如果已经创建了实例就不需要再竞争锁了。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>( Singleton.class )<span class="comment">// 类锁，表示只能进入一个实例</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( Instance == <span class="keyword">null</span> )<span class="comment">//防止二次创建实例</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>内存中只有一个实例，减少了内存开支。</li>
<li>避免对资源的多重占用，比如写文件操作，只有一个实例时，避免对同一个资源文件同时写操作。</li>
</ul>
<p>缺点：</p>
<ul>
<li>没有接口，不能继承，与单一职责冲突。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>应用程序的日志应用一般使用单例模式实现，因为共享的日志文件一般会一直处于打开状态，所以只能有一个实例取操作，否则内容不好追加；</li>
<li>操作系统的文件系统也是使用单例模式操作的，因为一个操作系统只能有一个文件系统。</li>
</ul>
<h4 id="此处可能会询问volatile的好处"><a href="#此处可能会询问volatile的好处" class="headerlink" title="此处可能会询问volatile的好处"></a>此处可能会询问volatile的好处</h4><p>​        Instance 采用 volatile 关键字修饰也是很有必要的， <code>Instance = new Singleton();</code> 这段代码其实是分为三步执行：分配内存、初始化、指向分配的地址。由于JVM具有指令重排的特性，执行顺序可能会改变，指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 抢占了 T1 的资源，调用 geteInstance() 后发现 Instance 不为空，因此返回 Instance，但此时 Instance 还未被初始化。</p>
<p>​        使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<h3 id="（2）工厂模式"><a href="#（2）工厂模式" class="headerlink" title="（2）工厂模式"></a>（2）工厂模式</h3><h4 id="1-说一说你对工厂模式的理解"><a href="#1-说一说你对工厂模式的理解" class="headerlink" title="1. 说一说你对工厂模式的理解"></a>1. 说一说你对工厂模式的理解</h4><p>工厂模式的用意是定义一个创建产品对象的工厂接口，将实际创建性工作推迟到子类中。工厂模式可分为简单工厂、工厂方法和抽象工厂模式。</p>
<ol>
<li><p>简单工厂</p>
<p>简单工厂的实现思路是，定义一个工厂类，根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或接口。简单工厂的适用场景是：</p>
<ul>
<li>需要创建的对象较少。</li>
<li>客户端不关心对象的创建过程。</li>
</ul>
<p><strong>实例：</strong></p>
<p>创建一个可以绘制不同形状的绘图工具，可以绘制圆形，正方形，三角形，每个图形都会有一个draw()方法用于绘图。</p>
<p>由题可知圆形，正方形，三角形都属于一种图形，并且都具有draw方法，所以首先可以定义一个接口或者抽象类，作为这三个图像的公共父类，并在其中声明一个公共的draw方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承公共父类，编写具体图形：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//圆形</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">circleShape</span> <span class="keyword">implements</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">circleShape</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CircleShape:created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw: circleShape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正方形</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RectShape</span> <span class="keyword">implements</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RectShape</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RectShape: created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw: rectShape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//三角形</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">triangleShape</span> <span class="keyword">implements</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TriangleShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TriangleShape: created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw: TriangleShape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是工厂类的具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">shapeFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title">getShape</span><span class="params">( String type )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Shape shape = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>( type.equalsIgnoreCase( <span class="string">&quot;circle&quot;</span> ) )</span><br><span class="line">        &#123;</span><br><span class="line">            shape = <span class="keyword">new</span> circleShape();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( type.equalsIgnoreCase( <span class="string">&quot;rect&quot;</span> ) )</span><br><span class="line">        &#123;</span><br><span class="line">            shape = <span class="keyword">new</span> rectShape();</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            shape = <span class="keyword">new</span> triangleShape();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shape;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>工厂方法</p>
<p>工厂方法模式是简单工厂的进一步深化， 在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说每个对象都有一个与之对应的工厂。</p>
<p>工厂方法的实现思路是，定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。</p>
<p><strong>实例：</strong></p>
<p>以简单工厂的实例来实现工厂方法模式：</p>
<p>首先编写一个公共的接口来draw：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为每个图形实现 draw() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">circleShape</span> <span class="keyword">implements</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw: circleShape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">rectShape</span> <span class="keyword">implements</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw: rectShape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">triangleShape</span> <span class="keyword">implements</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw: triangleShape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着定义一个抽象的工厂接口shapeFactory：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">shapeFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">Shape <span class="title">getShape</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getShape()</code> 方法用于返回shape类，每个</p>
</li>
<li><p>抽象工厂</p>
<p>​    工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。</p>
</li>
</ol>
<h3 id="（3）观察者模式"><a href="#（3）观察者模式" class="headerlink" title="（3）观察者模式"></a>（3）观察者模式</h3><p>观察者模式很好理解，类似于订阅模式，属于行为型模式的一种，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p>
<p>在观察者模式中有如下角色：</p>
<ol>
<li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</li>
<li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</li>
<li>Observer：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li>
<li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li>
</ol>
<p>这种发布-订阅的形式我们可以拿微信公众号来举例，假设微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了这个公众号，当这个公众号更新时就会通知这些订阅的微信用户。</p>
<p>具体实例如下：</p>
<ol>
<li>抽象观察者：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>具体观察者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeixinUser</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 微信用户名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeixinUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;-&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>抽象主题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加订阅者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除订阅者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知订阅者更新消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体主题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriptionSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//储存订阅公众号的微信用户</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; weixinUserlist = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        weixinUserlist.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        weixinUserlist.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : weixinUserlist) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SubscriptionSubject mSubscriptionSubject=<span class="keyword">new</span> SubscriptionSubject();</span><br><span class="line">        <span class="comment">//创建微信用户</span></span><br><span class="line">        WeixinUser user1=<span class="keyword">new</span> WeixinUser(<span class="string">&quot;杨影枫&quot;</span>);</span><br><span class="line">        WeixinUser user2=<span class="keyword">new</span> WeixinUser(<span class="string">&quot;月眉儿&quot;</span>);</span><br><span class="line">        WeixinUser user3=<span class="keyword">new</span> WeixinUser(<span class="string">&quot;紫轩&quot;</span>);</span><br><span class="line">        <span class="comment">//订阅公众号</span></span><br><span class="line">        mSubscriptionSubject.attach(user1);</span><br><span class="line">        mSubscriptionSubject.attach(user2);</span><br><span class="line">        mSubscriptionSubject.attach(user3);</span><br><span class="line">        <span class="comment">//公众号更新发出消息给订阅的微信用户</span></span><br><span class="line">        mSubscriptionSubject.notify(<span class="string">&quot;刘望舒的专栏更新了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">杨影枫-刘望舒的专栏更新了</span><br><span class="line">月眉儿-刘望舒的专栏更新了</span><br><span class="line">紫轩-刘望舒的专栏更新了</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>优点：</p>
<ul>
<li>观察者和被观察者是抽象耦合的</li>
<li>建立了一套触发机制</li>
</ul>
<p>缺点：</p>
<ul>
<li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间</li>
<li>如果观察者和观察目标间有循环依赖，可能导致系统崩溃</li>
<li>没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的</li>
</ul>
<p>使用场景：</p>
<ul>
<li>关联行为场景</li>
<li>事件多级触发场景</li>
<li>跨系统的消息变换场景，如消息队列的处理机制</li>
</ul>
<h3 id="（4）装饰模式"><a href="#（4）装饰模式" class="headerlink" title="（4）装饰模式"></a>（4）装饰模式</h3><p>定义：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</p>
<p>下面以一个例子来简单说明：</p>
<p>比如我买了一个机器人，它本身有一个对话的功能。我希望它能在此基础上还能帮我扫地。有两种方式实现：</p>
<ol>
<li>第一种方式，可以打电话给厂家，让他们可以研制新的产品，在第一代产品的基础上加两条胳膊，扩展这个功能；</li>
<li>第二种方式是直接给第一代产品加一个箱子，在这个箱子上面加两条胳膊，这样它也拥有了扫地的功能，这种方式更为灵活，不需要去重新研发设计。</li>
</ol>
<p>上述这两种方式都可以实现给一个类或对象增加新的功能，第一种是继承机制，就是继承一个现有的类，然后在子类进行扩展功能；第二种被称为关联机制，是把一个类的对象嵌入到另一个类的对象中，相当于把机器人嵌入到箱子中，给它套一个壳子，扩展出扫地的功能，这个壳子就是装饰器，第二种方式也被称为装饰器模式。</p>
<p>在开发过程中，这两种方式都经常被使用，他们主要的区别在于：对于继承模式来说，这种方式是静态的，一定要实现一个新的子类来对类层级进行扩展；装饰器模式是动态的，我们拿到一个对象就可以对其进行扩展，不需要修改原有类逻辑。</p>
<p>下面使用代码来实现上述例子：</p>
<ol>
<li><p>创建抽象组件，代表被装饰的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建组件实现类，实现第一代机器人：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">firstRobot</span> <span class="keyword">implements</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建装饰器对第一代机器人扩展：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">robotDecorator</span> <span class="keyword">implements</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="comment">//因为要关联使用机器人，所有要定义一个机器人对象</span></span><br><span class="line">    <span class="keyword">private</span> Robot robot;</span><br><span class="line">    <span class="comment">//接着要传这个对象进来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">robotDecorator</span><span class="params">(Robot robot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.robot = robot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接着实现机器人该有的方法，使用机器人对象实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        robot.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//需要扩展功能，新加扫地的功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doMorething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扫地&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> robotDecorator(<span class="keyword">new</span> firstRobot()).doMorething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">扫地</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>优点：</p>
<ul>
<li>装饰类和被装饰类可以独立发展，而不会相互耦合。它有效地把类的核心职责和装饰功能分开了</li>
<li>装饰模式是继承关系的一个替代方案</li>
<li>装饰模式可以动态地扩展一个实现类的功能</li>
</ul>
<p>缺点：</p>
<p>多层装饰比较复杂。比如我们现在有很多层装饰，出了问题，就需要一层一层检查，工作量很大。</p>
<p>使用场景：</p>
<ul>
<li>需要扩展一个类的功能时</li>
<li>需要动态地给一个对象增加功能，并可以动态地撤销时</li>
<li>需要为一批的兄弟类进行改装或加装功能时</li>
</ul>
<h3 id="（5）代理模式"><a href="#（5）代理模式" class="headerlink" title="（5）代理模式"></a>（5）代理模式</h3><p>代理模式就是为其他对象提供一种代理以控制对这个对象的访问。常见的例子就是Windows的快捷方式，通过快捷方式，我们可以访问某个文件夹下的exe文件，这就是一个典型的代理模式，它将接口提供了出来，我们只需点击快捷方式，它会帮我们运行指定目录下的指定程序。</p>
<p>包括如下角色：</p>
<ul>
<li>Subject是主题角色，定义了RealSubject和Proxy的共同接口，即应该提供什么服务；</li>
<li>RealSubject是具体主题角色，定义了Proxy所代表的真实实体；</li>
<li>Proxy为代理主题角色，保存对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ul>
<p>例子：购买机票不一定要去机场买，可以在相关的代售软件上购买。这里的软件就是代理角色。</p>
<p>下面具体实现这个例子：</p>
<ol>
<li><p>定义公共接口，实现购票方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现具体主题角色，也就是机场：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">realSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;机场买机票&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现代理角色，也就是购票网站：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">proxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> realSubject subject;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxySubject</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        subject = <span class="keyword">new</span> realSubject();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;购票网站购买机票&quot;</span>);</span><br><span class="line">        subject.buyTicket();</span><br><span class="line">        System.out.println(<span class="string">&quot;成功购买&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> proxySubject().buyTicket();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">购票网站购买机票</span><br><span class="line">   机场买机票</span><br><span class="line">   成功购买</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>从上述代码中可以看出，代理模式和装饰器模式很像，二者的区别是：装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类（proxy class）可以对它的客户隐藏真实对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建真实对象的实例；当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。</p>
<p>优点：</p>
<ul>
<li>职责清晰。真实的角色就是实现实际的业务逻辑，不用担心其他非本职责的事务</li>
<li>高扩展性。代理类完全可以在不做任何修改的情况下使用</li>
<li>智能化。比如动态代理，动态代理就是使用反射机制在运行时创建代理类</li>
</ul>
<p>缺点：</p>
<ul>
<li>有些类型的代理模式可能会造成请求的处理速度变慢</li>
<li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂</li>
</ul>
<p>使用场景：</p>
<ul>
<li>远程代理。为一个对象在不同的地址空间提供局部代表</li>
<li>虚拟代理。根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象</li>
<li>安全代理。用来控制真实对象访问时的权限</li>
<li>智能指引，当调用真实的对象时，代理处理另外一些事</li>
</ul>
<h4 id="扩展：静态代理和动态代理"><a href="#扩展：静态代理和动态代理" class="headerlink" title="扩展：静态代理和动态代理"></a>扩展：静态代理和动态代理</h4><p>代理模式分为静态代理和动态代理。上述例子实现的是静态代理，下面使用动态代理实现上面的例子：</p>
<p>动态代理是通过实现反射机制下的 <code>InvocationHandler</code> 接口来创建自己的调用处理器。</p>
<ol>
<li><p>实现抽象接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现具体主题角色，也就是机场：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">realSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;机场买机票&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现 InvocationHandler 接口创建一个针对这个具体角色的动态代理调用处理程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">proxySubjectHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    realSubject subject = <span class="keyword">new</span> realSubject();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;购票网站购买机票&quot;</span>);</span><br><span class="line">        Object res = method.invoke(subject, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;成功购买&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Subject <span class="title">getProxyInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Subject)Proxy.newProxyInstance(subject.getClass().getClassLoader(), subject.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        proxySubjectHandler subject = <span class="keyword">new</span> proxySubjectHandler();</span><br><span class="line">        subject.getProxyInstance().buyTicket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">购票网站购买机票</span><br><span class="line">机场买机票</span><br><span class="line">成功购买</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="InvocationHandler-和-Proxy"><a href="#InvocationHandler-和-Proxy" class="headerlink" title="InvocationHandler 和 Proxy"></a>InvocationHandler 和 Proxy</h4><p>InvocationHandler是动态代理类的调用处理程序必须实现的接口。</p>
<p>​        从 <code>Proxy.newProxyInstance</code> 开始方法看，它用来创建一个代理类对象，接收三个参数：具体主题角色的类加载器、具体主题角色实现的所有接口、以及需要关联到的 InvocationHandler 对象实例，也就是上述例子中的 <code>proxySubjectHandler</code> 这个类的实例，如果是在这个类中执行的这个方法，可以使用 <code>this</code> 来表示这个类的实例。</p>
<p>​        这个方法返回的就是一个代理角色，通过这个代理角色调用方法，会被转发到实现 InvocationHandler接口的类的 invoke 方法中调用。</p>
<h2 id="16-List、Set、Map三者的联系和区别"><a href="#16-List、Set、Map三者的联系和区别" class="headerlink" title="16. List、Set、Map三者的联系和区别"></a>16. List、Set、Map三者的联系和区别</h2><p><code>List</code> 和 <code>Set</code> 接口都属于 <code>Collection</code> 接口， <code>Map</code> 接口与 <code>Collection</code> 接口同级。</p>
<p>其中：</p>
<ol>
<li>List中的元素可重复，具有有序性；</li>
<li>Set中的元素不可重复，具有无序性；</li>
<li>Map采用key-value的形式存储元素，key值不可重复。</li>
</ol>
<h2 id="17-HashMap-和-HashTable、HashSet、TreeMap-的区别"><a href="#17-HashMap-和-HashTable、HashSet、TreeMap-的区别" class="headerlink" title="17. HashMap 和 HashTable、HashSet、TreeMap 的区别"></a>17. HashMap 和 HashTable、HashSet、TreeMap 的区别</h2><ol>
<li>HashMap底层由 <code>链表 + 数组 + 红黑树</code> 实现，当链表长度 <code>&gt;=8</code> 、数组长度 <code>超过64</code> 时转换为红黑树，非线程安全，可以存储 <code>null</code> 键和 <code>null</code> 值，初始 <code>size = 16</code> ，扩容方式为 <code>newsize = oldsize * 2</code> 先插入再扩容；</li>
<li>HashTable底层由 <code>链表 + 数组</code> 实现，通过在方法和对象前添加 <code>syncronized</code> 关键字来保证线程安全，不可以存储 <code>null</code> 键 <code>null</code> 值，初始 <code>size = 11</code> ，扩容方式为 <code>newsize = olesize * 2 + 1</code> 先扩容再插入；</li>
<li>HashSet底层由HashMap实现，其中的HashMap仅存在key，value都是同一个object，非线程安全；</li>
<li>TreeMap底层由红黑树实现，是有序的 <code>key-value</code> 组合，非线程安全，存入TreeMap的元素应该实现Comparable或Comparator接口，会按照排序后的顺序迭代元素，主要用于元素插入时对元素自动排序，迭代输出就按顺序输出。</li>
</ol>
<h2 id="18-HashMap的底层原理"><a href="#18-HashMap的底层原理" class="headerlink" title="18. HashMap的底层原理"></a>18. HashMap的底层原理</h2><p>HashMap的底层由数组+链表+红黑树的形式实现，数组中的元素为内部类Node节点。</p>
<p>具体实现如下：</p>
<ol>
<li>首先对key值进行二次哈希，然后将结果对数组长度取模，存入对应下标；</li>
<li>如果没有哈希冲突，直接创建Node存入下标对应的位置；</li>
<li>如果存在哈希冲突，先equals查看是否有相同元素，有则更新，没有则判断链表高度插入链表，如果链表高度到8、数组长度超过64转变为红黑树存储，长度低于6转变为链表存储。</li>
</ol>
<p>当数组长度不够，需要进行扩容的时候，会根据扩容因子new一个新的数组，再将旧数组的元素放入新数组使用，扩容因子默认是0.75。</p>
<p>其中提出的二次哈希，是为了对key的hashCode进行扰动计算，防止不同hashCode的高位不同但低位相同导致的hash冲突。简单来说就是把高位的特征和低位的特征组合起来，降低哈希冲突的概率，尽量做到任何一位的变化都对最终的结果产生影响。</p>
<h2 id="19-ConcurrentHashMap与HashTable的区别"><a href="#19-ConcurrentHashMap与HashTable的区别" class="headerlink" title="19. ConcurrentHashMap与HashTable的区别"></a>19. ConcurrentHashMap与HashTable的区别</h2><p>有两个区别：</p>
<ol>
<li><p>底层数据结构：HashTable由 <code>数组 + 链表</code> 组成，ConcurrentHashMap 由 <code>数组 + 链表 + 红黑树</code> 组成；</p>
</li>
<li><p>实现线程安全的方式：</p>
<p>（1）HashTable使用 <code>Syncronized</code> 关键字实现线程安全，将所有方法和对象都上了锁，在高并发的情况下，同一时刻只能有一个线程操作，其他线程会被阻塞等待，并发度低；</p>
<p>（2）ConcurrentHashMap采用了更细粒度的锁来提高并发情况下的效率，ConcurrentHashMap将hash表默认分为16个桶，每个桶可以看作是一个hashtable，诸如get、put、remove等写操作只需要锁当前需要的桶，在理想状态下，原来同一时刻只能进入一个线程，现在能同时进入16个，并发性的提升显而易见；因为在读取的大多数情况不需要锁，所以读取操作几乎是完全的并发操作。</p>
</li>
</ol>
<h2 id="20-ConcurrentHashMap底层原理"><a href="#20-ConcurrentHashMap底层原理" class="headerlink" title="20. ConcurrentHashMap底层原理"></a>20. ConcurrentHashMap底层原理</h2><p>​        首先了解为什么使用ConcurrentHashMap。在并发编程下使用HashMap可能导致死循环，而使用线程安全的HashTable效率又非常低下，于是引出了ConcurrentHashMap。HashTable效率低的原因很明显，因为HashTable使用Synchronized关键字，所以在并发时只能运行一个线程，而将其他线程阻塞等待；HashMap导致死循环的原因是put操作扩容，假设有两个线程A和B要同时进行扩容，此时数组中下标为1对应的链表指向是 a - b - c，扩容需要将他们迁移到新数组下标为4的位置，这里假设abc钱以后也在同意下标，进行扩容操作有两个指针 e 和 next，A先执行，假设当 e = a，next = b 的时候cpu时间片用完，会暂停A的执行，由B开始执行，因为是头插法，插入的顺序是将e.next = newtable[4]，newtable[4] = e,e = next。B会将 abc 全都放到newtable[4]的空间中，然后时间片用完，A继续执行，在B线程将 b 指向 a，在这里又将 a 指向 b，此时就产生了死循环。</p>
<p>​         而ConcurrentHashMap应用在多线程的优点在于它的数据结构。</p>
<p>​        在JDK1.7底层采用：segment + HashEntry数组结构组成，实现的思路是先将数据分成一段一段地存储，然后给每一段数据配一把锁，这样当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，这就是锁分段技术。其中Segment继承了ReetrantLock可重入锁接口，所以自带了锁的功能，让每一个片段都有了锁；HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构。一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁。</p>
<p>​        JDK1.8底层与HashMap底层结构一致，将锁的粒度调整到每个数组元素加锁，并且定位节点的hash算法被简化，导致hash冲突加剧，因此在链表长度大于8时，会将链表转换为红黑树存储，这样一来，查询的时间复杂度就从O(n)转变为O(logn)。</p>
<p>​        对于锁的设计，JDK1.8取消了Segment分段锁，采用了CAS+Synchronized来保证并发安全。当执行<code>put</code>方法插入数据时，定义一个Node节点 <code>f</code>，如果 <code>f == null</code>，则相应位置的<code>Node</code>还未初始化，通过CAS插入相应的数据；如果 <code>f.hash == -1</code>，说明当前有其他线程正在扩容，则一起进行扩容操作；如果是其余情况就是把新的node节点按照链表或红黑树的方式插入到合适的位置，其中有一个binCount变量用于判断当前链表长度是否&gt;=8。</p>
<p>​        JDK1.8中还使用一个volatile类型的变量baseCount记录元素的个数，用于判断是否扩容，当插入新数据或删除元素时，会通过 <code>addCount()</code> 方法更新 <code>baseCount</code> 。具体的实现过程是：先利用CAS方法更新baseCount的值，然后检查是否需要扩容，默认check=1时需要检查；如果满足扩容条件，即 <code>map.size() &gt;= sizeCTL</code>，此处 <code>sizeCtl</code> 为扩容阈值，判断当前是否正在扩容，如果是正在扩容就一起扩容，如果不在扩容就将 <code>sizeCtl</code> 更新为负数，并进行扩容处理。</p>
<h2 id="21-Comparable-和-Comparator-的区别"><a href="#21-Comparable-和-Comparator-的区别" class="headerlink" title="21. Comparable 和 Comparator 的区别"></a>21. Comparable 和 Comparator 的区别</h2><ol>
<li>Comparable是内部比较器，实现该接口意味着该类支持排序，不需要额外实现比较器，比较简单，但是需要修改源代码；</li>
<li>Comparator是外部比较器，当需要控制某个类的次序，而该类本身不支持排序，可以自定义一个该类的比较器进行排序，好处是不需要修改源代码，只需要自定义一个比较器。</li>
</ol>
<h2 id="22-ArrayList、LinkedList、Vector的区别"><a href="#22-ArrayList、LinkedList、Vector的区别" class="headerlink" title="22. ArrayList、LinkedList、Vector的区别"></a>22. ArrayList、LinkedList、Vector的区别</h2><p>三者都实现了List接口。</p>
<ol>
<li>ArrayList用于处理可变长数组，可存放任意类型的对象，所有方法都默认在单一线程下进行，所以是线程不安全的；</li>
<li>LinkedList相当于双向链表，也是线程不安全的，在内部实现中，使用节点Node存放数据，有一个指向链表头的first和一个指向链表尾的last节点，插入效率高，遍历效率低；</li>
<li>Vector与ArrayList相似，唯一的区别是它是线程安全的，扩容的时候，Vector扩容为原来的2倍，ArrayList扩容为原来的1.5倍。</li>
</ol>
<h2 id="23-HashSet如何检查重复"><a href="#23-HashSet如何检查重复" class="headerlink" title="23. HashSet如何检查重复"></a>23. HashSet如何检查重复</h2><p>当对象 <code>add</code> 到 <code>HashSet</code> 中，首先获取对应的HashCode，判断对象插入的位置，如果没有相同HashCode的对象存在，则成功加入，否则调用 <code>equals</code> 方法判断两个 <code>HashCode</code> 相同的对象是否真的相等，如果相等，加入失败。</p>
<h2 id="24-静态编译和动态编译"><a href="#24-静态编译和动态编译" class="headerlink" title="24. 静态编译和动态编译"></a>24. 静态编译和动态编译</h2><ol>
<li>静态编译：一次编译，在程序运行前将所有模块全都编译进去；</li>
<li>动态编译：按需编译，在程序运行过程中，需要用到哪个模块再编译哪个模块。</li>
</ol>
<h2 id="25-反射机制"><a href="#25-反射机制" class="headerlink" title="25. 反射机制"></a>25. 反射机制</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>反射的概念是在运行状态中，对于任何一个类，都能知道它的所有属性和方法；对于任何一个对象，都能调用它的任意一个方法和属性。这种动态获取信息和动态调用对象方法的功能叫做反射机制。</p>
<h3 id="为什么使用反射"><a href="#为什么使用反射" class="headerlink" title="为什么使用反射"></a>为什么使用反射</h3><p>先抛开概念化的定义，看下面的两段代码：</p>
<p>例子：实现创建一个动物对象 <code>cat</code> 并调用 <code>run</code> 方法计算它跑两公里的距离。</p>
<p>不用反射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal cat = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="keyword">double</span> distance = cat.run(<span class="number">2d</span>);</span><br></pre></td></tr></table></figure>
<p>用反射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取动物类的反射对象</span></span><br><span class="line">Class clz = Class.forName(<span class="string">&quot;com.self.example.Animal&quot;</span>);</span><br><span class="line"><span class="comment">// 获取奔跑方法的反射对象</span></span><br><span class="line">Method met = clz.getMathod(<span class="string">&quot;run&quot;</span>, <span class="keyword">double</span>.class);</span><br><span class="line"><span class="comment">// 获取构造方法的反射对象</span></span><br><span class="line">Constructor cons = clz.getConstructor();</span><br><span class="line"><span class="comment">// 通过反射实例化对象</span></span><br><span class="line">Object obj = cons.newInstance();</span><br><span class="line"><span class="comment">//通过反射调用奔跑方法</span></span><br><span class="line">Object distance = met.invoke(obj, <span class="number">2d</span>);</span><br></pre></td></tr></table></figure>
<p>看起来，反射将两行代码可以解决的问题扩展到了五行代码解决，将简单的事情写复杂化了，但是反射传入的是字符串，如果将字符串提出来，比如放到配置文件中，或者在程序运行的时候传参，这样的程序就会变得非常动态了。</p>
<p>已知Java程序要运行，需要先将源代码通过javac转变为字节码，然后通过Java解释和执行字节码。Java是静态语言，变量的类型在编译前就需要确定，否则编译不能通过，这样限制了程序的灵活性，所以许多静态语言扩展出了动态的反射机制，以能够动态的获取对象信息和调用对象的方法。</p>
<h3 id="反射的基本使用"><a href="#反射的基本使用" class="headerlink" title="反射的基本使用"></a>反射的基本使用</h3><p>首先创建一个 <code>Hello</code> 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bonnie.example;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2022/1/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着在 <code>resource</code> 文件夹下创建一个属性文件 <code>property.properties</code> 存放 <code>hello</code> 类的信息，以便能够动态修改：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">className</span>=<span class="string">com.bonnie.example.Hello</span></span><br><span class="line"><span class="attr">methodName</span>=<span class="string">sayHello</span></span><br></pre></td></tr></table></figure>
<p>最后反射该类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bonnie.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2022/1/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reflectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reflect</span><span class="params">(String name )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取配置文件内容</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        ClassLoader classLoader = reflectTest.class.getClassLoader();</span><br><span class="line">        InputStream inputStream = classLoader.getResourceAsStream(<span class="string">&quot;property.properties&quot;</span>);</span><br><span class="line">        pro.load(inputStream);</span><br><span class="line">        String classname = pro.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">        String methodname = pro.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 获取类对象</span></span><br><span class="line">        Class clz = Class.forName(classname);</span><br><span class="line">        <span class="comment">// 3. 获取实例对象</span></span><br><span class="line">        Object obj = clz.getConstructor().newInstance();</span><br><span class="line">        <span class="comment">// 3. 调用set方法存数据</span></span><br><span class="line">        Method set_method = clz.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        set_method.invoke(obj, <span class="keyword">new</span> Object[]&#123;name&#125;);</span><br><span class="line">        <span class="comment">// 4. 调用 methodname 对应的方法显示</span></span><br><span class="line">        Method get_method = clz.getMethod(methodname);</span><br><span class="line">        get_method.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        reflectTest reflect = <span class="keyword">new</span> reflectTest();</span><br><span class="line">        reflect.reflect(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>Class</code> 类是 <code>Reflection API</code> 中的核心类，主要方法如下：</p>
<ul>
<li>getName()：获得类的完整名字。 getFields()：获得类的public类型的属性。</li>
<li>getDeclaredFields()：获得类的所有属性。</li>
<li>getMethods()：获得类的public类型的方法。</li>
<li>getDeclaredMethods()：获得类的所有方法。</li>
<li>getMethod(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes参数指定方法的参数类型。</li>
<li>getConstrutors()：获得类的public类型的构造方法。</li>
<li>getConstrutor(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes参数指定构造方法的参数类型。</li>
<li>newInstance()：通过类的不带参数的构造方法创建这个类的一个对象。</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点有：</p>
<ol>
<li><p>增加程序的灵活性，避免将程序写死在代码里；</p>
<p>比如一个接口中有若干个实现类，这些类在程序中被频繁使用，可以编写配置文件放接口和实现类，如果改动只需要修改配置文件，就可以利用 <code>Class.forName(class_name).newInstance()</code> 反射获取对应实例。</p>
</li>
<li><p>提高代码的复用率，外部调用方便；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.yonyong.reflection.testdemo;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123; <span class="comment">//水果接口</span></span><br><span class="line">　 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>; <span class="comment">//吃水果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123; <span class="comment">//定义苹果</span></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　　　System.out.println(<span class="string">&quot;**吃苹果。&quot;</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　　　System.out.println(<span class="string">&quot;**吃橘子。&quot;</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getInstance</span><span class="params">(String className)</span></span>&#123;</span><br><span class="line">　　　　Fruit fruit = <span class="keyword">null</span> ;</span><br><span class="line">　　　　<span class="keyword">try</span>&#123;</span><br><span class="line">　　　　　　fruit = (Fruit) Class.forName(className).newInstance() ;</span><br><span class="line">　　　　&#125;<span class="keyword">catch</span>(Exception e )&#123;</span><br><span class="line">　　　　　　e.printStackTrace() ;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　<span class="keyword">return</span> fruit ;</span><br><span class="line">　 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryDemo</span></span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">　　<span class="comment">//通过工厂类取得接口实例，传入完整的包.类名称</span></span><br><span class="line">　　　　Fruit f = Factory.getInstance(<span class="string">&quot;cn.yonyong.reflection.testdemo.Apple&quot;</span>) ;</span><br><span class="line">　　　　<span class="keyword">if</span>(f!=<span class="keyword">null</span>)&#123; <span class="comment">//判断是否取得接口实例</span></span><br><span class="line">　　　　　　f.eat() ;</span><br><span class="line">　　　&#125;</span><br><span class="line">　 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要添加一个西瓜类，就只需要在 <code>FactoryDemo</code> 中的 <code>getInstance</code> 反射对应的名称即可。</p>
</li>
<li><p>对于任意一个类，都能知道它的所有属性和方法，对于任意一个对象，都能调用它的所有方法。</p>
</li>
</ol>
<p>缺点如下：</p>
<ol>
<li>性能问题：反射包含了一些动态类型，这些部分是不能被JVM优化的，所以反射操作的效率会比非反射操作的效率低很多，应该避免在经常被执行的代码和对性能要求较高的场景中使用；</li>
<li>安全限制：通常反射需要程序的运行没有安全方面的限制，因为反射可以获取类中的任意信息，包括私有信息；</li>
<li>程序健壮性：反射允许代码执行一些正常情况不被允许的操作，比如访问私有属性和方法，所以使用反射可能会导致代码出现功能上的错误、降低可移植性等副作用。</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>应用于反编译，将.class文件转变为.java文件；</li>
<li>常用的一些框架，如Spring的配置化就是利用反射机制来动态加载对象；</li>
<li>编译器，比如IDEA会有自动联想类的方法或属性的功能。</li>
</ol>
<h2 id="26-Java中的引用类型有哪些？"><a href="#26-Java中的引用类型有哪些？" class="headerlink" title="26. Java中的引用类型有哪些？"></a>26. Java中的引用类型有哪些？</h2><p>Java中对象的引用分为四种级别，这四种级别由高到低依次为:强引用、软引用、弱引用和虚引用。</p>
<ol>
<li><p>强引用</p>
<p>Java中默认声明的就是强引用，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object obj = new Object(); //只要obj还指向Object对象，Object对象就不会被回收</span><br><span class="line">obj = null;  //手动置null</span><br></pre></td></tr></table></figure>
<p>只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显式的将强引用赋值为null。</p>
<p>Java的对象是位于heap 中的, heap中对象有强可及对象、软可及对象、弱可及对象、虚可及对象和不可到<br>达对象。应用的强弱顺序是强、软、弱、和虚。对于对象是属于哪种可及的对象，由他的最强的引用决定。看如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String abc=<span class="keyword">new</span> string ( <span class="string">&quot;abc&quot;</span>); <span class="comment">//1</span></span><br><span class="line">SoftReference&lt;string&gt; softRef=<span class="keyword">new</span> SoftReference&lt;string&gt; (abc); <span class="comment">//2</span></span><br><span class="line">WeakReference&lt;string&gt; weakRef = <span class="keyword">new</span> WeakReference&lt;string&gt;(abc); <span class="comment">//3</span></span><br><span class="line">abc=<span class="keyword">null</span>; <span class="comment">//4</span></span><br><span class="line">softRef.clear();<span class="comment">//5</span></span><br></pre></td></tr></table></figure>
<p>第一行在heap堆中创建内容为“abc”的对象，并建立abc到该对象的强引用，该对象是强可及的。<br>第二行和第三行分别建立对 heap中对象的软引用和弱引用，此时 heap 中的abc对象已经有3个用，显然此时abc 对象仍是强可及的。<br>第四行之后heap 中对象不再是强可及的，变成软可及的。<br>第五行执行之后变成弱可及的。</p>
</li>
<li><p>软引用</p>
<p>软引用是用来描述一些非必需但仍有用的对象。<strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong>。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。<br>在 JDK1.2 之后，用java.lang.ref.SoftReference类来表示软引用。垃圾收集器只在真正 “需要” 内存时才收集软引用对象。</p>
</li>
<li><p>弱引用</p>
<p>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong>。在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用。</p>
</li>
<li><p>虚引用</p>
<p>虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，虚引用主要用来跟踪对象被垃圾回收的活动。在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p>
</li>
<li><p>引用队列</p>
<p>引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。</p>
</li>
</ol>
<h2 id="27-JVM内存分配与回收"><a href="#27-JVM内存分配与回收" class="headerlink" title="27. JVM内存分配与回收"></a>27. JVM内存分配与回收</h2><h3 id="1-首先了解一下JVM的内存模型。"><a href="#1-首先了解一下JVM的内存模型。" class="headerlink" title="1. 首先了解一下JVM的内存模型。"></a>1. 首先了解一下JVM的内存模型。</h3><p>JVM启动时会向系统申请一块内存，它将这块内存划分为若干个子区域存放不同形式的数据，大致分为三个大区域：堆、栈、方法区。</p>
<ol>
<li><p>堆</p>
<p>（1）堆用来存储引用类型的数据；</p>
<p>（2）堆中的数据是无序的；</p>
<p>（3）堆中数据可以反复使用，这是设置堆的初衷；</p>
<p>（4）JVM会定时清理堆中的垃圾数据，即不会再被使用的数据，这被称为垃圾回收。</p>
</li>
<li><p>栈</p>
<p>（1）栈以方法为单元存放数据，这样的单元叫做方法栈桢；</p>
<p>（2）栈中存放的数据的有序的，遵循先进后出的规则；</p>
<p>（3）方法调用结束后，它占有的方法会被立即释放。</p>
</li>
<li><p>方法区</p>
<p>方法区是线程共享的，它存储已经被虚拟机加载的类信息如类型标志（该类是类类型还是接口类型）、常量、静态变量、即时编译（也就是静态编译）后的代码等等。</p>
</li>
</ol>
<h3 id="2-JVM内存分配："><a href="#2-JVM内存分配：" class="headerlink" title="2. JVM内存分配："></a>2. JVM内存分配：</h3><p>这里具体以一个例子来说明JVM的内存分配过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Car c = <span class="keyword">new</span> Car();</span><br><span class="line">	c.brand = <span class="string">&quot;奔驰&quot;</span>;</span><br><span class="line">	c.color = <span class="string">&quot;红色&quot;</span>;</span><br><span class="line">	c.maxSpeed = <span class="number">500</span>;</span><br><span class="line">	c.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><code>main</code> 栈帧入栈；</p>
</li>
<li><p><code>Car c = new Car()</code> ，因为赋值操作从右往左，先执行 <code>new Car()</code> 操作，在堆中开辟一块内存来存储这个对象，然后将变量 <code>c</code> 存储到 <code>main</code> 栈帧中，然后执行 <code>=</code> 操作；</p>
</li>
<li>后续三个赋值操作访问了成员变量，通过 <code>c.</code> 找到堆中的相应成员变量，进行赋值；</li>
<li><code>c.sun()</code> 操作将 <code>run()</code> 方法入栈。</li>
</ol>
<h3 id="3-JVM内存回收"><a href="#3-JVM内存回收" class="headerlink" title="3. JVM内存回收"></a>3. JVM内存回收</h3><h4 id="判断对象是否可以被回收（引用计数法和可达性分析算法）"><a href="#判断对象是否可以被回收（引用计数法和可达性分析算法）" class="headerlink" title="判断对象是否可以被回收（引用计数法和可达性分析算法）"></a>判断对象是否可以被回收（引用计数法和可达性分析算法）</h4><h4 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1. 引用计数法"></a>1. 引用计数法</h4><p>就是给对象添加一个引用计数器，每当有一个地方引用到它就加一，引用失效就减一，任何时刻计数器为0的对象就是不能再被使用的。引用计数法实现简单，判定效率也很高，但是它很难解决对象间循环引用的问题。比如以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigsize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB]; <span class="comment">// 这个成员属性的唯一意义就是占点内存，方便在GC日志冲查看是否被回收过</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        demo objA = <span class="keyword">new</span> demo();</span><br><span class="line">        demo objB = <span class="keyword">new</span> demo();</span><br><span class="line">        </span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中的 <code>objA</code> 和 <code>objB</code> 两个对象实际上已经不可能再被访问，但是由于它们互相引用对方，导致引用计数器都无法归零，于是引用计数器都无法同之GC收集器回收他们。</p>
<h4 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2. 可达性分析算法"></a>2. 可达性分析算法</h4><p>当前主流的商用语言的内存管理子系统，都是 通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。这个算法的基本思路就是通过 一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过 程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
<p>在java语言中，常见的可作为GC Roots的对象包括下面几种：</p>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li>
<li>方法区中类静态属性引用的对象；</li>
<li>方法区中常量引用的对象；</li>
<li>本地方法栈中JNI（即一般所说的Native方法）引用的对象。</li>
</ol>
<p>这种方式可找到所以得垃圾对象，并且完美解决对象之间循环引用的问题。但是不可避免地要遍历全局所有对象，导致搜索效率不高。</p>
<h3 id="4-垃圾收集算法"><a href="#4-垃圾收集算法" class="headerlink" title="4. 垃圾收集算法"></a>4. 垃圾收集算法</h3><p>有四种垃圾收集算法。</p>
<ol>
<li><strong>标记清除算法</strong>：包括“标记”和“清除”两个过程 - 先标记出所有需要回收的对象，再统一清除掉所有被标记的对象。这种方法有两个缺点：（1）标记和清除的过程的效率都不高；（2）标记清除后可能会产生大量不连续的内存，这样在程序运行过程中，需要分配较大的对象时无法找到足够的连续内存而不得不提前触发再一次的垃圾收集操作。</li>
<li><strong>复制算法</strong>：是为了解决标记清除算法的效率问题产生的。它将内存等分为两个部分，每次只使用其中的一块。当这块内存用完了，将还存活的对象复制到另一边，然后把已使用过的这一部分全部清理掉。这种方式因为每次只对一个部分回收，内存分配就不需要考虑内存碎片的复杂情况，只需要移动堆顶指针，按顺序分配内存即可，简单高效；缺点是一次只使用一半的内存，代价太高；</li>
<li><strong>标记整理算法</strong>：如果对象存活率较高，使用复制算法需要进行多次复制，效率不高。可以使用标记整理算法，它的标记过程与标记清除算法一样，只是后续不是直接对可回收对象进行处理，而是先将所有存活对象向一端移动，然后直接清理掉除了端边界以外的所有内存；</li>
<li><strong>分代收集算法</strong>：当代商业虚拟机的垃圾收集都是采用该方法。该算法根据生命周期的不同将内存划分，一般是将堆划分为新生代和老生代，然后根据不同生代的特点选择合适的算法处理。新生代的特点是大批对象死亡，少量对象存活，可以使用复制算法，以少量存活对象的复制成本就可以完成采集；老生代因为存活率较高，没有多余的空间进行分配担保，所以使用标记清除算法或标记整理算法处理。</li>
</ol>
<h3 id="5-垃圾收集器"><a href="#5-垃圾收集器" class="headerlink" title="5. 垃圾收集器"></a>5. 垃圾收集器</h3><p>有七种垃圾收集器，其中，<code>Serial、Parallel Scavenge、Parnew</code> 是新生代收集器，<code>Serial Old、Parallel Old、CMS</code> 是老生代收集器，G1是整堆收集器，对老生代和新生代都适用。</p>
<ol>
<li><p><strong>Serial</strong>：以串行的方式运行，使用复制算法，是单线程收集器，工作时其他线程会停止工作，使用复制算法收集新生代垃圾。优点是简单高效，在单个CPU环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率，是Client场景下默认的新生代垃圾收集器；</p>
</li>
<li><p><strong>ParNew</strong>：是Serial的多线程版本，使用复制算法，是Server场景下的默认新生代收集器，除了性能原因外，主要是因为除了Serial，只有ParNew能与CMS配合使用；</p>
</li>
<li><p><strong>Parallel Scavenge</strong>：它的诸多特性与ParNew非常相似，不同的地方在于，它的目标是实现可控制的吞吐量。这里的吞吐量指的是处理器用于运行用户代码的时间与处理器总消耗时间的比值，而处理器总消耗时间是处理器处理用户代码的时间和用于处理垃圾回收的时间之和。</p>
<script type="math/tex; mode=display">
吞吐量 = 
\frac{处理器运行用户代码的时间}{处理器运行用户代码的时间 + 运行垃圾收集的时间}</script><p>​        高吞吐量可以最高效率的利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。Parallel Scavenge提供了两个参数用于精确控制吞吐量：MaxGCPauseMillis用于控制最大垃圾收集停顿时间、GCTimeRatio用于直接设置吞吐量大小。这里关于MaxGCPauseMillis参数有一个误区，并不是这个参数设置是值越小，就会使得垃圾收集的速度更快，垃圾收集的停顿时间是以吞吐量和新生代空间为代价换取的，系统将新生代空间调小了，垃圾收集的频率也就变高了。</p>
<p>​        Parallel Scavenge还有一个参数是区别于ParNew的重要特性：UseAdeptiveSizePolicy，启动这个参数，虚拟机就可以动态调整相关参数以提供最合适或最大的吞吐量，这种方式被称为自动调节策略，开启这个开关后，只需要设置上述两个参数之一来设置一个优化目标即可。</p>
</li>
<li><p><strong>Serial Old</strong>：Serial Old是Serial收集器的老年代版本，也是单线程收集器，使用标记-整理算法。主要意义也是提供client模式下的虚拟机使用，在server模式下，也有两种用法：可以跟Parallel Scavenge搭配使用，不过它本身就有一个PS MarkSweep收集器供老年代使用，与Serial Old的实现几乎一样；也可以作为CMS收集器失败时的后备预案，在并发收集发生故障时使用。</p>
</li>
<li><p><strong>Parallel Old</strong>：</p>
<p>是Parallel Scavenge的老年代版本，支持多线程并发收集，基于标记-整理算法实现，在一些注重吞吐量或处理器资源比较稀缺的场景中，可以使用Parallel Scavenge + Parallel Old的组合。</p>
</li>
<li><p><strong>CMS</strong>：是一种以获取最短回收停顿时间为目标的收集器，主要适用于较为关注服务响应速度、希望系统停顿时间尽可能短、以给用户带来良好的交互体验的应用。它的运作过程分为四个步骤：初始标记、并发标记、重新标记、并发清除。其中初始标记、重新标记仍然需要STW机制。</p>
<p><strong>1）初始标记</strong>：</p>
<p>​        用于标记GC Roots以及它们直接关联到的对象，所谓GC Roots是进行可达性分析的时候找到的根节点，从根节点出发，哪些对象被引用了，我们就认为这些对象是存活的，把它们标记上。</p>
<p>​        在这个过程之前，用户线程在正常运行，如果要GC，由于初始标记的过程是要暂停所有用户线程的，这些用户线程就需要找一个安全点（sfaepoint）停下来，这个所谓的安全点，就是对象引用关系不会再发生变化，但是如果有的线程正在休眠，比如线程1正在休眠，这个时候就没有办法判断这个线程有没有执行到安全点，这里就引入了安全区的概念，所谓的安全区，就是在这个代码区域内，对象的引用关系都不会发生改变，也就是说如果线程1在休眠之前进入安全区域，会标识自己进入了安全区域，当初始标记时，就不用管这个线程，当线程向从安全区域出去的时候，先看初始标记的过程是否结束，如果没有结束，就等到结束后才能从安全区域出来。</p>
<p>​        常见的GC Roots有五种：Java虚拟机栈所引用的对象、Java native栈锁引用的对象、类静态属性锁引用的对象、常量所引用的对象、以及synchronized锁引用的对象。</p>
<p><strong>2）并发标记</strong>：</p>
<p>​        初始标记阶段结束后，线程继续运行，同时并发标记也在并发运行，这里，我们引出了三色标记法的概念。</p>
<p>​        三色标记法利用三种颜色将GC对象分为三种情况：白色是没有搜索到的对象，会被判定为垃圾对象，灰色是正在搜索的对象，黑色是以及搜索完成的对象，这种对象不会被当成垃圾对象。</p>
<p>​        并发标记的过程从GC Roots直接关联的对象出发，遍历整个对象图，利用三色标记法对对象进行标记。这个过程因为是和用户线程同时跑的，所以不会有停顿现象，但是这个过程会引发另一个问题：用户线程是可以修改引用关系的。这时候，有三种情况，一种是原有的已经被标记成黑色的对象的引用关系断掉了，这种浮动垃圾可以不用管，下次再回收就行；第二种情况是对黑色的对象直接新建了一个引用关系，就做一个记录，表示这个引用是新建立的，不要去收集它；最后一种情况是灰色对象引用的一个白色对象，这个引用关系断掉了，然而黑色对象直接引用了这个白色对象，这个时候这个白色对象就被直接被认为是垃圾，因为黑色对象不会在被扫描，但是这个白色对象是被黑色对象直接引用的。这种情况有两种解决方案：增量，即把这个黑色节点变成灰色节点，重新扫描一次，CMS就是用这个方式；还有一种方式是，因为这个白色对象是从灰色节点断开的，但是我记下了原来的关系，还是按照原来的关联关系去扫描，G1收集器就是用过这种方式。</p>
<p>​        并发标记的过程，指的是对这些关系作一个记录，并不会重新扫描它，这个阶段还是一次性扫描完，然后把有更改的部分记录下来，然后在到下一个安全点的时候，开始重新标记更改的部分。</p>
<p><strong>3）重新标记</strong>：</p>
<p>​        这个过程就是重新扫描标记一遍并发标记过程出现变化的对象。</p>
<p><strong>4）并发清除</strong>：</p>
<p>​        重新标记结束后，就启动清理线程，和其他用户线程并发执行，将被标记清除的对象一次性清除掉。</p>
<p><strong>CMS有以下缺点：</strong></p>
<p>1）CMS收集器对CPU资源非常敏感,在并发阶段虽然不会导致用户线程停顿，但是会因为占用了一部分CPU资源，如果在CPU资源不足的情况下应用会有明显的卡顿。</p>
<p>2）无法处理浮动垃圾：在执行‘并发清理’步骤时，用户线程也会同时产生一部分可回收对象，但是这部分可回收对象只能在下次执行清理时才会被回收。如果在清理过程中预留给用户线程的内存不足就会出现‘Concurrent Mode Failure’,一旦出现此错误时便会切换到SerialOld收集方式。<br>3）使用标记清除算法会导致每次垃圾回收后产生大量空间碎片，这给大对象的分配带来很大的问题，往往会出现老年代还有很多剩余空间，但就是不能找到足够的连续空间来存储连续对象。</p>
</li>
<li><p><strong>G1</strong>：主要面向服务端应用，取代了Parallel Scavenge + Parallel Old组合，称为服务端模式下的默认垃圾收集器。</p>
<p>​        G1的内存结构基于堆内存布局，虽然G1仍然遵循分代收集的理论，但内部不再坚持固定大小和数量的区域划分，而是把连续的Java内存空间划分为多个大小相等的独立区域，以下简称region，每个region都可以是新生代的E区、S区和O区，收集器对不同类型的region采用不同的方式处理，这样无论是新创建的对象还是已经存活一段时间、熬过多次收集的就对象都能取得很好的收集效果。</p>
<p>​        G1还专门划分一个特殊的humongous（H）区域来存储大对象，只要超过一个region容量一半以上的对象就被判定为大对象，对于超过整个region容量的大对象，使用连续的H区来存储。H区是O区的一种。</p>
<p>​        G1中的新生代和老年代都是一系列不需要连续的动态集合，它将region作为单次回收的最小单元，这样可以有计划的避免在整个Java堆中进行全区域的垃圾收集。更具体的思路就是让G1跟踪每个region离垃圾堆积的“价值”大小，价值即回收获得的空间大小以及回收所需时间的经验值，然后在后台维护一张优先级列表，每次根据用户设定允许的停顿时间，有限处理回收价值最大的region，这也是G1名字的由来。这种使用region划分内存空间，以及具有优先级的区域回收方式，保证了G1在有限的时间内获取尽可能高的手机效率。</p>
<p>​        G1收集器的运作过程大致分为以下四个步骤：</p>
<p>1）初始标记：标记GC Roots能直接关联到的对象，并修改tams指针的值，让下一阶段用户线程并发运行时，能正确的在可用的region中分配对象；</p>
<p>2）并发标记：从GC Roots开始对堆内对象进行可达性分析，递归扫描整个堆内的对象，找出回收对象，这个阶段耗时较长，但可与应用程序并发运行。扫描完成后，需要重新处理satb记录下在并发时有引用引用变动的对象；</p>
<p>3）最终标记：用于处理并发阶段结束后遗留的少量satb记录；</p>
<p>4）筛选回收：负责更新Region的统计数据，对各个Region的回 收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。</p>
<p>​        上述过程的描述可用看出，G1收集器除了并发标记外，都需要stop the world，即它并非单纯追求低延迟，它的目标是在延迟可控的范围内保持尽可能高的吞吐量。上述过程所提及的satb算法是原始快照算法，G1收集器是通过这个算法实现的，此外，G1为每一个Region设 计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过 程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在 这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围。</p>
<p>​        G1和CMS之间的比较如下：</p>
<p>1）与CMS的标记清除算法不同，G1使用标记整理算法，但从局部的两个region上看又是基于复制算法实现的，这两种算法都让G1在运行期间不会产生空间碎片，垃圾收集后能提供规整的可用内存，这种特性有利于程序的长时间运行，不会因为大对象无法得到分配而提前进行下一次垃圾收集。</p>
<p>2）从内存占用上，G1和CMS都使用卡表来处理跨代指针（卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。 关于卡表与记忆集的关系），但G1的卡表更复杂，且每个region都有一份，这导致G1的记忆集可能会占整个堆容量的20%甚至更多空间；而CMS的卡表只有一份，且只需要处理老年代到新生代的引用，反过来不需要，由于新生代具有朝生夕死的不稳定性，引用变化频繁，能省下这个区域的维护开销是划算的。</p>
<p>3）相比起CMS的增量更新算法，原始快照算法能减少并发标记和重新标记阶段的消耗，避免CMS那样在最终标记阶段停顿时间过长的缺点， 但是在用户程序运行过程中确实会产生由跟踪引用变化带来的额外负担。</p>
</li>
</ol>
<h2 id="28-进程和线程的区别和联系"><a href="#28-进程和线程的区别和联系" class="headerlink" title="28. 进程和线程的区别和联系"></a>28. 进程和线程的区别和联系</h2><ol>
<li>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</li>
<li>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的 实时性，实现进程内部的并发；</li>
<li>一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；</li>
<li>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。</li>
</ol>
<h2 id="29-并行与并发"><a href="#29-并行与并发" class="headerlink" title="29. 并行与并发"></a>29. 并行与并发</h2><p><strong>1. 并发：</strong></p>
<p>指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是利用系统CPU的时间分片功能，使多个进程快速交替的执行。</p>
<p><strong>2. 并行：</strong></p>
<p>指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。</p>
<p><strong>3. 场景分析：</strong></p>
<p>一个应用程序可以是并发的，但不能是并行的，这意味着它可以同时处理多个任务，但是没有两个任务可以同时执行。</p>
<p>一个应用程序可以是并行的，但不能是并发的，这意味着它可以同时处理多核CPU中一个任务的多个子任务。</p>
<p>一个应用程序既不能是并行的，也不能是并发的，这意味着它一次顺序地处理所有任务。</p>
<p>一个应用程序可以是并行的，也可以是并发的，这意味着它可以同时在多核CPU中同时处理多个任务。</p>
<h2 id="30-线程的生命周期和状态"><a href="#30-线程的生命周期和状态" class="headerlink" title="30. 线程的生命周期和状态"></a>30. 线程的生命周期和状态</h2><p>线程一共有五种状态：新生态、就绪态、运行态、阻塞态、死亡态。这五种状态统称线程的生命周期。线程在同一时刻只会处于一种状态。下面简述这五种状态：</p>
<ol>
<li><p>新生态：当线程对象创建后，就进入了新生状态：Thread t = new Thread();</p>
</li>
<li><p>就绪态：当调用线程对象的 <code>start()</code> 方法，就进入了就绪状态。处于就绪状态的线程，只是说明词线程已经做好准备，随时等待CPU调度执行，并不是说调用了 <code>start()</code> 方法线程就会立即执行；</p>
</li>
<li><p>运行态：当CPU开始调度处于就绪状态的线程时，该线程真正开始执行，想要进入运行态，就绪态是唯一的入口；</p>
</li>
<li><p>阻塞态：处于运行态的线程因为某种原因暂时放弃了CPU的使用权，停止执行，进入阻塞状态，阻塞态可用分为三种：</p>
<p>（1）等待阻塞：运行态中的线程调用 <code>wait()</code> 方法，使线程进入等待阻塞状态；</p>
<p>（2）同步阻塞：线程获取Synchronized锁失败，因为此时该锁被其他线程占用，该线程进入同步阻塞状态；</p>
<p>（3）其他阻塞：调用线程的 <code>sleep()</code> 或 <code>join()</code> 方法或发出I/O请求时，会使得线程进入阻塞状态，当 <code>sleep()</code> 超时或 <code>join()</code> 等待线程终止或超时、或I/O处理完毕，线程会重新进入就绪态；</p>
</li>
<li><p>死亡态：线程执行完毕或异常退出，该线程结束生命周期。</p>
</li>
</ol>
<p><strong>允许状态的转换：</strong></p>
<ol>
<li>就绪态转换为运行态：线程得到CPU资源；</li>
<li>运行态转换为就绪态：线程主动调用 <code>yield()</code> 方法或在运行过程中失去CPU资源；</li>
<li>运行态转换为死亡态：线程执行完毕或出现异常</li>
</ol>
<h2 id="31-线程死锁"><a href="#31-线程死锁" class="headerlink" title="31. 线程死锁"></a>31. 线程死锁</h2><ol>
<li><p>概念：死锁指的是两个线程互相拥有对方所需要的资源，由于synchronized的特性，一个线程持有一个资源，或者说获得了一个锁，在该线程释放这个锁之前，其他线程是获取不到这个锁的，并会一直等下去，这就造成了死锁。</p>
</li>
<li><p>死锁产生的必要条件：</p>
<p>（1）互斥条件：一个锁只能被一个线程占用，当一个线程占用一个锁，该锁在被该线程释放前，其他线程都不能获取这个锁；</p>
<p>（2）不剥夺条件：锁只能由当前占用的线程释放，不能由其他的线程强行剥夺；</p>
<p>（3）请求和保持条件：线程已经获得一个锁，再获取另一个锁的过程中，即使获取不到也不会释放已经获得的锁；</p>
<p>（4）循环等待条件：两个线程互相拥有对方需要的锁。</p>
</li>
<li><p>如何避免死锁：</p>
<p>（1）加锁顺序：线程按照相同的顺序加锁；</p>
<p>（2）加锁时限：线程获取锁的过程限制等待的时间，这需要用到锁的一些API。</p>
<p>（3）死锁检测：是一种更好的死锁预防机制，针对前两种方法解决不了的情况。当一个线程获得了锁，会在线程和锁相关的数据结构中记下，比如map，除此之外，每当有线程请求锁，也会记录在这个数据结构中，当一个线程获取锁失败，就可以遍历这个数据结构查看是否有死锁发生。</p>
</li>
</ol>
<h2 id="32-线程池的原理及使用"><a href="#32-线程池的原理及使用" class="headerlink" title="32. 线程池的原理及使用"></a>32. 线程池的原理及使用</h2><p>​        线程池是在系统启动或者实例化池时创建一些空闲的线程，等待工作调度，执行完任务后，线程并不会立即被销毁，而是重新处于空闲状态，等待下一次调度。</p>
<p>​        工作机制为：在线程池的编程模式中，任务提交并不是直接提交给线程，而是提交给池。线程池在拿到任务之后，就会寻找有没有空闲的线程，有则分配给空闲线程执行，暂时没有则会进入等待队列，继续等待空闲线程。如果超出最大接受的工作数量，则会触发线程池的拒绝策略。</p>
<p>​        由于线程的创建与销毁需要消耗大量资源，重复的创建与销毁明显不必要。而且池的好处就是响应快，需要的时候自取，就不会存在等待创建的时间。线程池可以很好地管理系统内部的线程，如数量以及调度。</p>
<p>​        Java类ExecutorService是线程池的父接口。以下四种常用线程池的类型都可以是ExecutorService：</p>
<ol>
<li><p>单一线程池 Executors.newSingleThreadExecutor()：内部只有唯一一个线程进行工作调度，可以保证任务的执行顺序；</p>
</li>
<li><p>可缓存线程池 Executors.newCachedThreadPool()：如果线程池中有可使用的线程，则使用，如果没有，则在池中新建一个线程，可缓存线程池中线程数量最大为Integer.MAX_VALUE。通常用它来运行一些执行时间短，且经常用到的任务；</p>
</li>
<li><p>定长线程池 Executors.newFixedThreadPool(int nThreads)：创建一个固定线程数量的线程池，参数手动传入；</p>
</li>
<li><p>定时线程池 Executors.newScheduledThreadPool(int corePoolSize)：创建一个定长线程池，支持定时及周期性任务执行；</p>
<p><strong>除了上述常用的线程池外，还可以自定义线程池，常用的构造函数是ThreadPoolExecutor。</strong></p>
<p><strong>任务的执行顺序是：</strong></p>
<ol>
<li><p>当线程数小于核心线程数时，创建线程执行任务；</p>
</li>
<li><p>当线程数大于等于核心线程数并且保存任务的阻塞队列没有满时，放入workQueue中；</p>
</li>
<li><p>线程数大于等于核心线程数并且当阻塞队列满时，新任务新建线程运行，线程总数要小于最大线程数；</p>
</li>
<li><p>当线程总数等于最大线程数并且阻塞队列满了的时候执行拒绝策略。</p>
</li>
</ol>
</li>
</ol>
<p>线程池包括以下七个参数：</p>
<p><strong>（1）corePoolSize 线程池核心线程大小；</strong></p>
<p><strong>（2）maximumPoolSize 线程池最大线程数量；</strong></p>
<p><strong>（3）keepAliveTime 空闲线程存活时间；</strong></p>
<p><strong>（4）unit 空闲线程存活时间单位；</strong></p>
<p><strong>（5）workQueue 工作队列；</strong></p>
<p>JDK提供了四种队列：</p>
<ol>
<li>ArrayBlockingQueue（int i）:规定大小的BlockingQueue，其构造必须指定大小。其所含的对象是FIFO顺序排序的。</li>
<li>LinkedBlockingQueue（）或者（int i）:大小不固定的BlockingQueue，若其构造时指定大小，生成的BlockingQueue有大小限制，不指定大小，其大小有Integer.MAX_VALUE来决定。其所含的对象是FIFO顺序排序的。</li>
<li>PriorityBlockingQueue（）或者（int i）:类似于LinkedBlockingQueue，但是其所含对象的排序不是FIFO，而是依据对象的自然顺序或者构造函数的Comparator决定。</li>
<li>SynchronizedQueue（）:特殊的BlockingQueue，对其的操作必须是放和取交替完成。</li>
</ol>
<p><strong>（6）threadFactory 线程工厂；</strong></p>
<p><strong>（7）handler 拒绝策略；</strong></p>
<p>JDK也提供了四种拒绝策略：</p>
<ol>
<li>new ThreadPoolExecutor.AbortPolicy() 直接抛出异常RejectedExecutionException</li>
<li>new ThreadPoolExecutor.CallerRunsPolicy() 直接调用run方法并且阻塞执行</li>
<li>new ThreadPoolExecutor.DiscardPolicy() 直接丢弃后来的任务</li>
<li>new ThreadPoolExecutor.DiscardOldestPolicy() 丢弃在队列中队首的任务</li>
</ol>
<h2 id="33-互斥、自旋、读写、悲观、乐观锁"><a href="#33-互斥、自旋、读写、悲观、乐观锁" class="headerlink" title="33. 互斥、自旋、读写、悲观、乐观锁"></a>33. 互斥、自旋、读写、悲观、乐观锁</h2><ol>
<li>互斥锁：一个线程访问共享资源前会对线程访问的这段代码加锁，加锁之后没有释放锁，其他想要访问临界资源的线程会被阻塞睡眠，直到解锁，如果阻塞了多个线程，解锁的时候，这些线程都转换为就绪状态，第一个变为就绪态的线程获取资源的使用权，其他线程继续阻塞等待；</li>
<li>读写锁：也叫共享互斥锁，读模式共享，写模式互斥，即只有一个线程能占有写模式的读写锁，可以有多个线程占用读模式的读写锁。在写加锁模式下，任何线程进行写加锁操作都会被阻塞，直到解锁；在读加锁模式下，任何线程都可以进行读加锁操作，但全部试图进行写加锁的线程都会被阻塞，直到全部读加锁的线程释放锁，可是当读线程太多，写线程一直被阻塞也不行，因此一个线程想加锁的时候，会阻塞之后的读加锁的请求，让写线程先加锁；</li>
<li>自旋锁：自旋锁和互斥锁很像，唯一不同的是自旋锁访问加锁资源时，会循环查看是否释放锁，这种方式比互斥锁更有效率，但是有两个问题：一是会一直占用CPU的资源，所以适用于多核的CPU；二是自旋锁递归调用容易造成死锁，所以得慎重使用自旋锁；</li>
<li>乐观锁：总是假设最好的情况，每次拿数据都认为其他线程不会修改，所以不会上锁，但在更新的时候会判断一下在词期间其他线程有没有更新这个数据，可用使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可用提高吞吐量；</li>
<li>悲观锁：总是假设最坏的情况，每次拿数据都会认为其他线程会修改，所以在拿数据的时候都会上锁，想获取这个锁的线程会被阻塞直到当前线程释放锁。</li>
</ol>
<h2 id="34-Synchronized锁源码"><a href="#34-Synchronized锁源码" class="headerlink" title="34. Synchronized锁源码"></a>34. Synchronized锁源码</h2><p>首先介绍两个概念：</p>
<h4 id="1-cas"><a href="#1-cas" class="headerlink" title="1. cas"></a>1. cas</h4><p>CAS算法的原理：</p>
<p>​        CAS算法的全称是比较和交换，可以看成是一个自旋锁。下面以一个例子来说明：</p>
<p>​        假设有多线程任务，2个线程同时完成对一个共享变量 <code>i</code> 的减法，假设该算法只有三个步骤：<code>get共享变量的值、--、将更新的值put回共享变量</code>，不使用CAS算法的运行过程中，可能将前两个步骤完成，然后在要执行第三个步骤的时候被CPU的时间片切出去，第二个线程开始执行，这时候由于两个线程 <code>get</code> 的值一样，最终所得的结果肯定也是一样的；如果使用CAS算法，即可以简单的使用 <code>atomic</code> 变量来解决，会在 <code>get</code> 方法设置一个E值，即旧的值，计算步骤完成后，将E值和共享变量内的值比较，如果相同，交换共享变量内的值为更新的值，否则线程再运行一遍，重新获取值进行运算，这也可以称为自旋锁。这个atomic变量保证了这个CAS算法不会存在多线程问题，因为这个算法的核心函数是 <code>native</code> 即CPU本地提供的，而CPU都是一行一行执行的，不会存在并行过程。</p>
<p>CAS机制的问题：</p>
<p>​        ABA问题 - 即假设有两个线程对一个共享变量进行操作，这个值初始为A，第一个线程首先将值修改成了B，然后又改回了A，第二个线程因为比较慢，它获取的E值是A，最后比较的时候第一个线程已经完成了两次修改，共享变量的值还是A，所以对第二个线程来说，共享变量值没有被其他线程改动，是安全的。</p>
<p>​        这种可能有两种情况：如果共享变量是基本数据类型，是否改动是不重要的；如果是引用类型，其中的属性可能会发生变化。</p>
<p>​        解决方案：加版本号或时间戳来区分。</p>
<p>​        但是这种方式比较繁琐，不如使用加锁机制，即lock锁解决。比如有多个线程要进行一个业务操作，只要有一个线程获得这个锁进行业务操作，其他线程发现这个锁被占用了，就会阻塞，但是不是让线程自旋等待，而是等到这个锁被释放了，这个锁会通知所有等待该锁的线程它被释放了。</p>
<h4 id="2-对象头"><a href="#2-对象头" class="headerlink" title="2. 对象头"></a>2. 对象头</h4><p>虚拟机中，对象在内存中存储的布局分为三个部分：对象头、实例数据和对齐填充。</p>
<p>其中对象头包含两部分信息：</p>
<p>（1）mark word：用于存储运行时数据，比如hashcode、GC分代年龄等；</p>
<p>（2）klass pointer：是对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p>当对象是数组时，对象头中还需要包含数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但无法确定数组长度的大小。</p>
<p>Synchronized源码使用mark word来标识对象的加锁状态。</p>
<h4 id="synchronized锁实现原理"><a href="#synchronized锁实现原理" class="headerlink" title="synchronized锁实现原理"></a>synchronized锁实现原理</h4><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性。</p>
<p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p>
<ol>
<li><strong>普通同步方法，锁是当前实例对象；</strong></li>
<li><strong>静态同步方法，锁是当前类的class对象；</strong></li>
<li><strong>同步方法块，锁是括号里面的对象。</strong></li>
</ol>
<p>其中同步代码块是使用monitorenter和monitorexit指令实现的，同步方法依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。</p>
<p><strong>同步代码块：</strong></p>
<p>　　monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；</p>
<p><strong>同步方法</strong></p>
<p>　　synchronized方法则会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令，在VM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的<strong>accessflags字段中的synchronized标志位置1</strong>，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象。</p>
<p>JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。 </p>
<p><strong>锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。</strong>他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<ol>
<li>锁粗化：减少不必要的紧连在一起的 lock，unlock 操作，<strong>将多个连续的锁扩展成一个范围更大的锁</strong>；</li>
<li>锁消除：JIT 编译时，会去除不可能存在竞争的锁。通过 <strong>JIT 的逃逸分析</strong>来<strong>消除一些没有在当前同步块以外被其他线程共享的数据的锁的保护</strong>，通过逃逸分析在 TLAB 来分配对象，这样就不存在共享数据带来的线程安全问题；</li>
<li>轻量级锁：这种锁实现的背后基于这样一种假设，即在真实的情况下我们程序中的大部分同步代码一般都处于无锁竞争状态（即单线程执行环境），在无锁竞争的情况下完全可以<strong>避免调用操作系统层面的重量级互斥锁</strong>(重量级锁的底层就是这样实现的)，只需要依靠一条 CAS 原子指令就可以完成锁的获取及释放。<strong>当存在锁竞争的情况下，执行 CAS 指令失败的线程将调用操作系统互斥锁进入到阻塞状态，当锁被释放的时候被唤醒</strong>；</li>
<li>偏向锁（重入锁）：为了在无线程竞争的情况下避免在锁获取过程中执行不必要的 CAS 原子指令，因为 CAS 原子指令虽然相对于重量级锁来说开销比较小但还是存在非常可观的本地延迟，减少同一线程获取锁的代价，省去了大量有关<strong>锁申请</strong>的操作；</li>
<li>适应性自旋：为了避免线程频繁挂起、恢复的状态切换消耗。产生了忙循环（循环时间固定），即自旋。JDK1.6引入了自适应自旋。自旋时间根据之前锁自旋时间和线程状态，动态变化，用以期望能减少阻塞的时间。</li>
</ol>
<p><strong>注：JIT编译狭义来说是当某段代码即将第一次被执行时进行编译，因而叫“即时编译”。<em>JIT编译是动态编译的一种特例</em>。JIT编译一词后来被<em>泛化</em>，时常与动态编译等价</strong>。</p>
<p>加锁过程，主要分为三步：</p>
<ol>
<li><p>在线程进入同步块的时候，如果同步对象状态为<strong>无锁状态</strong>（锁标志为 01），<strong>虚拟机首先将在当前线程的栈帧中建立一个名为锁记录的空间，用来存储锁对象目前的 Mark Word 的拷贝</strong>。拷贝成功后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，并将 Lock Record 里的 owner 指针指向锁对象的 Mark Word。如果更新成功，则执行 2，否则执行 3。</p>
</li>
<li><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且锁<strong>对象的 Mark Word 中的锁标志位设置为 “00”</strong>，即表示此对象处于轻量级锁定状态，这时候虚拟机线程栈与堆中锁对象的对象头的状态如图所示。</p>
</li>
<li>如果这个更新操作失败了，虚拟机首先会检查锁对象的 Mark Word 是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重要量级锁，锁标志的状态值变为 “10”，Mark Word 中存储的就是指向重量级锁的指针，后面等待锁的线程也要进入阻塞状态。而当前线程便尝试使用自旋来获取锁。<strong>自旋失败后膨胀为重量级锁</strong>，被阻塞。</li>
</ol>
<p>解锁过程：</p>
<p>因为虚拟机线程栈帧中的 Displaced Mark Word 是最初的无锁状态时的数据结构，所以用它来替换对象头中的 Mark Word 就可以释放锁。如果锁已经膨胀为重量级，此时是不可以被替换的，所以替换失败，唤醒被挂起的线程。</p>
<p><strong>注：锁膨胀的过程其实就是对象头中的 Mark Word 数据结构改变的过程。</strong></p>
<h2 id="35-volatile、threadlocal"><a href="#35-volatile、threadlocal" class="headerlink" title="35. volatile、threadlocal"></a>35. volatile、threadlocal</h2><p> 首先应该知道并发变成的三个概念：</p>
<ol>
<li>原子性：即一个或多个操作，要不全部执行，要不全部不执行；</li>
<li>可见性：即多个线程访问一个变量，一个线程修改了这个变量，其他线程能够立即看到这个修改；</li>
<li>有序性：即程序执行的顺序按照代码的先后顺序执行。</li>
</ol>
<h3 id="1-ThreadLocal"><a href="#1-ThreadLocal" class="headerlink" title="1. ThreadLocal"></a>1. ThreadLocal</h3><p>ThreadLocal是局部变量，是线程内独享的，在进程中定义的一个变量需要在每个线程中独立操作，互不干扰。</p>
<p>线程内部有个ThreadLocalMap变量，首先根据当前线程对象get到该线程的ThreadLocalMap对象，这个map定义了Entry，用于存储ThreadLocal对象以及对应的值。</p>
<p>一个线程拥有一个ThreadLocalMap对象，一个ThreadLocalMap对象可用存储多个线程的局部变量。</p>
<h3 id="2-volatile"><a href="#2-volatile" class="headerlink" title="2. volatile"></a>2. volatile</h3><p>volatile是修饰符关键字，用于修饰变量，被volatile修饰的变量意味着：</p>
<ol>
<li>一个线程对于这个变量的修改，对其他线程来说是可见的；</li>
<li>禁止编译器的重排序，对于该变量操作之前和操作之后的代码顺序不会变；</li>
<li>volatile关键字只能保变量的可见性，不能保证针对该变量的原子性。</li>
</ol>
<h2 id="36-String-和StringBuffer和-StringBuilder的区别"><a href="#36-String-和StringBuffer和-StringBuilder的区别" class="headerlink" title="36. String 和StringBuffer和 StringBuilder的区别"></a>36. String 和StringBuffer和 StringBuilder的区别</h2><p>String是字符串常量，长度不可变，用于存放字符的数组是 final 类型，所以只能赋值一次，每次更改都是new了一个对象，操作频繁会带来比较大的开销；</p>
<p>StringBuffer是线程安全的字符串变量，可以对内容进行修改，但由于使用Synchronized锁，会产生不可避免的开销；</p>
<p>StringBuilder是线程不安全的字符串变量，也可以对内容进行修改，但是非线程安全，所以可以避免锁的开销。</p>
<h2 id="37-reentrantlock底层原理"><a href="#37-reentrantlock底层原理" class="headerlink" title="37. reentrantlock底层原理"></a>37. reentrantlock底层原理</h2><h3 id="1-什么是可重入锁"><a href="#1-什么是可重入锁" class="headerlink" title="1. 什么是可重入锁"></a>1. 什么是可重入锁</h3><p>即一个线程持有某个对象的锁时，再次去获取这个对象的锁可以成功的。</p>
<p>ReentrantLock是个典型的独占模式AQS，同步状态为0时表示空闲。当有线程获取到空闲的同步状态时，它会将同步状态加1，将同步状态改为非空闲，于是其他线程挂起等待。在修改同步状态的同时，并记录下自己的线程，作为后续重入的依据，即一个线程持有某个对象的锁时，再次去获取这个对象的锁是可以成功的。</p>
<h3 id="2-ReetrantLock的特点"><a href="#2-ReetrantLock的特点" class="headerlink" title="2. ReetrantLock的特点"></a>2. ReetrantLock的特点</h3><h3 id="3-ReetrantLock和Synchronized的区别"><a href="#3-ReetrantLock和Synchronized的区别" class="headerlink" title="3. ReetrantLock和Synchronized的区别"></a>3. ReetrantLock和Synchronized的区别</h3><ol>
<li>可重入性：都是可重入锁，都对当前线程可重入；线程每进入一次计数器+1，直到计数器下降为0才能释放锁</li>
<li>锁实现：Synchronized依赖jvm实现（操作系统实现），ReentrantLock是JDK实现（代码实现）；</li>
<li>性能区别：Synchronized优化后，两者性能差不多，官方建议两种方法都可用的情况下使用Synchronized锁；ReentrantLock使用了CAS技术，Synchronized也借鉴了CAS，都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞；</li>
<li>功能区别：Synchronized使用方便简洁，并有编译器去保证锁的加锁和释放；ReentrantLock需要手工声明加锁和释放锁，为了避免忘记释放锁而造成死锁，最好在finally中声明释放锁。</li>
</ol>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
