<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode - 12. 整数转罗马数字</title>
      <link href="/2022/04/03/LeetCode-12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"/>
      <url>/2022/04/03/LeetCode-12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode-cn.com/problems/integer-to-roman/">12. 整数转罗马数字</a></p><span id="more"></span><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>​        对罗马数字，可以有如下的两个数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] symbol = &#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] value = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br></pre></td></tr></table></figure><p>​        因为罗马数的排列是从左到右降序的，基于贪心法的思想，每次可以取小于指定数字的最大的罗马数，直到数字为0。</p><p>​        具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        String[] symbol = &#123;<span class="string">&quot;M&quot;</span>, <span class="string">&quot;CM&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;CD&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;XC&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;XL&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;IX&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;IV&quot;</span>, <span class="string">&quot;I&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] value = &#123;<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( num &gt;= value[i] )</span><br><span class="line">            &#123;</span><br><span class="line">                res.append(symbol[i]);</span><br><span class="line">                num -= value[i];</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 51. N 皇后</title>
      <link href="/2022/04/02/LeetCode-51-N-%E7%9A%87%E5%90%8E/"/>
      <url>/2022/04/02/LeetCode-51-N-%E7%9A%87%E5%90%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>​        皇后的放置思路是：在行列以及两条斜线上只能存在一个皇后。行列上看很容易判断，只要保证i、j不重复，对于斜线，有两条，一条左上到右下，一条右上到左下，总结这两条斜线的规律，可以看出，左上到右下的i和j之间的关系是，i - j 是相等的；右上到左下的i和j之间的关系是，i + j 是相等的。</p><p>​        最终的思路：使用三个对象，分别保存列和两条斜线的数值，只要都不重复，则本行的该位置可以放皇后。</p><h3 id="Set查重"><a href="#Set查重" class="headerlink" title="Set查重"></a>Set查重</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] queens = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Set&lt;Integer&gt; columns = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; diag1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; diag2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Arrays.fill(queens, -<span class="number">1</span>);</span><br><span class="line">        solveNQueens(res, <span class="number">0</span>, n, queens, columns, diag1, diag2);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveNQueens</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, <span class="keyword">int</span> row, <span class="keyword">int</span> n, <span class="keyword">int</span>[] queens, Set&lt;Integer&gt; columns, Set&lt;Integer&gt; diag1, Set&lt;Integer&gt; diag2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( row == n )</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(toList(queens, n));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 不在一列</span></span><br><span class="line">            <span class="keyword">if</span>( columns.contains(i) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不在一条斜线</span></span><br><span class="line">            <span class="keyword">if</span>( diag1.contains(row - i) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( diag2.contains(row + i) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果都不在，该位置可以放皇后</span></span><br><span class="line">            queens[row] = i;</span><br><span class="line">            columns.add(i);</span><br><span class="line">            diag1.add(row - i);</span><br><span class="line">            diag2.add(row + i);</span><br><span class="line">            solveNQueens(res, row + <span class="number">1</span>, n, queens, columns, diag1, diag2);</span><br><span class="line">            <span class="comment">// 回退操作，尝试下一种</span></span><br><span class="line">            queens[row] = -<span class="number">1</span>;</span><br><span class="line">            columns.remove(i);</span><br><span class="line">            diag1.remove(row - i);</span><br><span class="line">            diag2.remove(row + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">toList</span><span class="params">(<span class="keyword">int</span>[] queens, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( queens[i] == -<span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            StringBuffer s = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; queens[i]; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                s.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            s.append(<span class="string">&quot;Q&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = queens[i] + <span class="number">1</span>; j &lt; n; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                s.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(s.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位运算查重"><a href="#位运算查重" class="headerlink" title="位运算查重"></a>位运算查重</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] queens = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Arrays.fill(queens, -<span class="number">1</span>);</span><br><span class="line">        solveNQueens(res, <span class="number">0</span>, n, queens, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveNQueens</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, <span class="keyword">int</span> row, <span class="keyword">int</span> n, <span class="keyword">int</span>[] queens, <span class="keyword">int</span> columns, <span class="keyword">int</span> diag1, <span class="keyword">int</span> diag2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( row == n )</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(toList(queens, n));</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> col = <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">                <span class="keyword">int</span> d1 = <span class="number">1</span> &lt;&lt; (row - i);</span><br><span class="line">                <span class="keyword">int</span> d2 = <span class="number">1</span> &lt;&lt; (row + i);</span><br><span class="line">                <span class="keyword">if</span>( (columns &amp; col) != <span class="number">0</span> || (diag1 &amp; d1) != <span class="number">0</span> || (diag2 &amp; d2) != <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                queens[i] = row;</span><br><span class="line">                solveNQueens(res, row + <span class="number">1</span>, n, queens, (columns | col), (diag1 | d1), (diag2 | d2));</span><br><span class="line">                queens[i] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">toList</span><span class="params">(<span class="keyword">int</span>[] queens, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( queens[i] == -<span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            StringBuffer s = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; queens[i]; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                s.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            s.append(<span class="string">&quot;Q&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = queens[i] + <span class="number">1</span>; j &lt; n; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                s.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(s.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 31. 下一个排列</title>
      <link href="/2022/04/01/LeetCode-31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"/>
      <url>/2022/04/01/LeetCode-31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></p><span id="more"></span><h3 id="解题思路-两次搜索"><a href="#解题思路-两次搜索" class="headerlink" title="解题思路 - 两次搜索"></a>解题思路 - 两次搜索</h3><p>​        这个题纯粹就是看数学规律：从后往前，后n个元素的子数组如果是逆序的，再往前看 n + 1 个元素的子数组，直到遇到第一个存在升序的子数组，确认这两个升序状态的元素 <code>i</code> 和 <code>j</code> 进行交换，然后将 <code>i + 1</code> 往后的子数组转换为升序状态即可。</p><p>​        先确定 <code>i</code> 的位置，可以比较 <code>nums[i]</code> 和 <code>nums[i + 1]</code> ，当 <code>nums[i] &lt; nums[i + 1]</code> 的时候得到 <code>i</code> 。这里可能会有另一种确认的方法：就是嵌套循环获取 <code>i</code> 值，但是这种方式获取到的子数组不一定是最短的非逆序的子数组。</p><p>​        接着确定 <code>j</code> 的位置，这个时候从 <code>nums.length - 1</code> 开始往前遍历，会在 <code>i &lt; j &lt;= nums.length - 1</code> 的时候取到 <code>j</code> ，然后将 <code>i</code> 和 <code>j</code> 对应的元素交换。</p><p>​        最后将 <code>i + 1</code> 开始的后续的子数组转换为升序数组，可以直接 <code>reverse</code> 反转实现，可以肯定的是，交换之前，<code>i + 1</code> 开头的子数组一定是逆序的，交换之后，因为获取的 <code>j</code> 是这个子数组中第一个大于 <code>i</code> 元素，所以可以保证交换过后依然是逆序的数组。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nextPermutation</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> i = len - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>] )</span><br><span class="line">        &#123;</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( i &gt;= <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>( j &gt; i &amp;&amp; nums[i] &gt;= nums[j] )</span><br><span class="line">            &#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(nums, i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = start, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( left &lt; right )</span><br><span class="line">        &#123;</span><br><span class="line">            swap(nums, left, right);</span><br><span class="line">            ++left;</span><br><span class="line">            --right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 这脑回路我是想不到 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔试错题 - 装箱和拆箱的问题</title>
      <link href="/2022/04/01/%E7%AC%94%E8%AF%95%E9%94%99%E9%A2%98-%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2022/04/01/%E7%AC%94%E8%AF%95%E9%94%99%E9%A2%98-%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="基本数据类型和引用类型之间装箱和拆箱的问题"><a href="#基本数据类型和引用类型之间装箱和拆箱的问题" class="headerlink" title="基本数据类型和引用类型之间装箱和拆箱的问题"></a>基本数据类型和引用类型之间装箱和拆箱的问题</h3><p>如题：</p><blockquote><p>Integer t1 &#x3D; Integer.valueOf(“2”);</p><p>Integer t2 &#x3D; Integer.valueOf(“2”).intValue();</p></blockquote><p>这两个哪个是对象，哪个是变量。</p><span id="more"></span><p>就等号右边来说，<code>Integer.valueOf(&quot;2&quot;)</code> 会声明为一个引用对象，<code>Integer.valueOf(&quot;2&quot;).intValue()</code>是一个int类型的基本数据类型，但是左侧是 <code>Integer t2 = Integer.valueOf(&quot;2&quot;).intValue()</code> ，此时基本数据类型会被自动装箱为一个引用对象。</p>]]></content>
      
      
      <categories>
          
          <category> 报错 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 剑指 Offer II 096. 字符串交织</title>
      <link href="/2022/03/31/LeetCode-%E5%89%91%E6%8C%87-Offer-II-096-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A4%E7%BB%87/"/>
      <url>/2022/03/31/LeetCode-%E5%89%91%E6%8C%87-Offer-II-096-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A4%E7%BB%87/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/IY6buf/">剑指 Offer II 096. 字符串交织</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>​        其实动态规划这个思路应该是不难想到的，主要是动态规划的对象。第一个想法可能就是创建 <code>s3</code> 长度的 <code>dp</code> 数组执行动态规划，但是这种方式没有办法判断 <code>s1</code> 和 <code>s2</code> 的情况，所以应该创建一个dp数组，能够同时对三个字符串产生影响，可以以 s1 为行，s2为列，然后使用 <code>[i + j - 1]</code> 来确定 s3 的下标，最终输出的 <code>dp[len1][len2]</code> 就是结果。</p><p>​        首先需要过滤掉：<code>s1.length() + s2.length() != s3.length()</code> 的情况，这种情况肯定不会是 true 。</p><p>​        接着对dp数组初始化，当 <code>s1 == &quot;&quot; &amp;&amp; s2 == &quot;&quot;</code> 也就是 <code>dp[0][0]</code> 的时候默认为true。接着遍历 <code>dp[i][0]</code> 和 <code>dp[0][j]</code> ，直到第一个 <code>s1.charAt(i) != s3.charAt(i)</code> 和 <code>s2.charAt(j) != s3.charAt(j)</code> 。</p><p>​        在正常遍历的情况下，假设 <code>s1</code> 下标为 <code>i - 1</code>，<code>s2</code> 下标为 <code>j - 1</code> ，那么可以定位到当前比较的 <code>s3</code> 的下标为 <code>i + j - 1</code> ，当 <code>s1[i - 1] == s3[i + j - 1] &amp;&amp; dp[i - 1][j] == true</code> 或 <code>s2[j - 1] == s3[i + j - 1] &amp;&amp; dp[i][j - 1] == true</code> 满足一个条件，<code>dp[i][j] = true</code> 成立。</p><p>​        具体代码如下，已经将二维数组优化为一维数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterleave</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( s1.length() + s2.length() != s3.length() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len1 = s1.length(), len2 = s2.length();</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len2 + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2 &amp;&amp; s2.charAt(j) == s3.charAt(j); ++j )</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j + <span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len1; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">0</span>] &amp;&amp; (s1.charAt(i - <span class="number">1</span>) == s3.charAt(i - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= len2; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( dp[j] || dp[j - <span class="number">1</span>] )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">char</span> c1 = s1.charAt(i - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">char</span> c2 = s2.charAt(j - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">char</span> c3 = s3.charAt(i + j - <span class="number">1</span>);</span><br><span class="line">                    dp[j] = (c1 == c3 &amp;&amp; dp[j]) || (c2 == c3 &amp;&amp; dp[j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔试错题 - 抛出异常</title>
      <link href="/2022/03/30/%E7%AC%94%E8%AF%95%E9%94%99%E9%A2%98-%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
      <url>/2022/03/30/%E7%AC%94%E8%AF%95%E9%94%99%E9%A2%98-%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h3 id="try语句为空"><a href="#try语句为空" class="headerlink" title="try语句为空"></a>try语句为空</h3><p>题目：如下程序的输出结果：</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 不写东西</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (FileNotFoundException e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;FileNotFoundException&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;IOException&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Exception&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译报错：FileNotFoundException 和 IOException 不能通过编译。</p>]]></content>
      
      
      <categories>
          
          <category> 报错 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 480. 滑动窗口中位数</title>
      <link href="/2022/03/26/LeetCode-480-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%8D%E6%95%B0/"/>
      <url>/2022/03/26/LeetCode-480-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/sliding-window-median/">480. 滑动窗口中位数</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>​        使用冒泡排序+二分查找算法实现。其中主要的思路在于，如何对无序的子数组排序。可以使用单独固定的数组来存放固定长度的子数组，然后先使用二分查找获取要删除的元素的位置，再对数组进行向前向后的冒泡排序，将元素的位置摆到顺序的位置上。</p><p>具体的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[] medianSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] ksort = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">double</span>[] res = <span class="keyword">new</span> <span class="keyword">double</span>[len - k + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.k = k;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            ksort[i] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(ksort);</span><br><span class="line">        res[<span class="number">0</span>] = getMid(ksort);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - k; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index = search(ksort, nums[i]);</span><br><span class="line">            ksort[index] = nums[i + k];</span><br><span class="line">            <span class="keyword">while</span>( index + <span class="number">1</span> &lt; k &amp;&amp; ksort[index] &gt; ksort[index + <span class="number">1</span>] )</span><br><span class="line">            &#123;</span><br><span class="line">                swap(ksort, index, index + <span class="number">1</span>);</span><br><span class="line">                ++index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>( index - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; ksort[index] &lt; ksort[index - <span class="number">1</span>] )</span><br><span class="line">            &#123;</span><br><span class="line">                swap(ksort, index, index - <span class="number">1</span>);</span><br><span class="line">                --index;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i + <span class="number">1</span>] = getMid(ksort);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = k - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( left &lt;= right )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>( nums[mid] == num )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( nums[mid] &gt; num )</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getMid</span><span class="params">(<span class="keyword">int</span>[] ksort)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (k &amp; <span class="number">1</span>) == <span class="number">1</span> ? ksort[k / <span class="number">2</span>] : ksort[k / <span class="number">2</span>] / <span class="number">2.0</span> + ksort[k / <span class="number">2</span> - <span class="number">1</span>] / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 冒泡排序 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 剑指 Offer 39. 数组中出现次数超过一半的数字</title>
      <link href="/2022/03/26/LeetCode-%E5%89%91%E6%8C%87-Offer-39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2022/03/26/LeetCode-%E5%89%91%E6%8C%87-Offer-39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">剑指 Offer 39. 数组中出现次数超过一半的数字</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="排序求众数"><a href="#排序求众数" class="headerlink" title="排序求众数"></a>排序求众数</h3><p>​        常规的解法，按升序排列，因为个数超过半数，那么在 <code>nums[nums.length / 2]</code> 处的值肯定是众数值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h3><p>​        核心思想是：正负票抵消。即众数票 +1，非众数票 -1，那么可以肯定的是，最终的投票结果是大于0的。可以推导出，当前a个投票的票数 &#x3D; 0，那么肯定会存在后 n - a 的票数肯定大于0，最终只要票数大于0对应的票值就是众数票。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> votes = <span class="number">0</span>, x = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i] == x )</span><br><span class="line">            &#123;</span><br><span class="line">                votes += <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                votes -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( votes == <span class="number">0</span> &amp;&amp; i + <span class="number">1</span> &lt; nums.length )</span><br><span class="line">            &#123;</span><br><span class="line">                x = nums[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 摩尔投票法(求众数法) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔试错题 - switch问题</title>
      <link href="/2022/03/26/%E7%AC%94%E8%AF%95%E9%94%99%E9%A2%98-switch%E9%97%AE%E9%A2%98/"/>
      <url>/2022/03/26/%E7%AC%94%E8%AF%95%E9%94%99%E9%A2%98-switch%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="switch后面需要注意，有没有添加-break"><a href="#switch后面需要注意，有没有添加-break" class="headerlink" title="switch后面需要注意，有没有添加 break"></a>switch后面需要注意，有没有添加 break</h3><p>如果没有加 break，那么符合条件的 case 之后的所有内容都会执行。</p><span id="more"></span><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2022/3/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGetValue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span>(i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                result = result + i;</span><br><span class="line">                System.out.println(<span class="string">&quot;get1&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                result = result + i * <span class="number">2</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;get2&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                result = result + i * <span class="number">3</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;get3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(getValue(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的输出结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><p>因为 <code>case 2</code> 中没有break退出键，所以后续的 <code>case 3</code> 也会执行。</p>]]></content>
      
      
      <categories>
          
          <category> 报错 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔试错题 - finally&amp;return问题</title>
      <link href="/2022/03/26/%E7%AC%94%E8%AF%95%E9%94%99%E9%A2%98-finally&amp;return%E9%97%AE%E9%A2%98/"/>
      <url>/2022/03/26/%E7%AC%94%E8%AF%95%E9%94%99%E9%A2%98-finally&amp;return%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="return之后执行finally会不会实现"><a href="#return之后执行finally会不会实现" class="headerlink" title="return之后执行finally会不会实现"></a>return之后执行finally会不会实现</h3><p>finally不会执行的时机：</p><ol><li>在try之前return；</li><li>在try中调用 <code>System.exit()</code> 方法。</li></ol><span id="more"></span><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2022/3/26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Annoyance</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneeze</span> <span class="keyword">extends</span> <span class="title">Annoyance</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Sneeze();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(Annoyance a)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Caught Annoyance&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> a;</span><br><span class="line">            &#125; &#125;<span class="keyword">catch</span>(Sneeze s)</span><br><span class="line">         &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;Caught Sneeze&quot;</span>);</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;<span class="keyword">finally</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的返回结果？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Caught Annoyance</span><br><span class="line">Caught Sneeze</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 报错 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 32. 最长有效括号</title>
      <link href="/2022/03/22/LeetCode-32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/"/>
      <url>/2022/03/22/LeetCode-32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>​        以当前遍历到的元素为最后一个元素，计算以当前元素结尾的字符串的最长有效长度，这个最长值应该使用 <code>maxlen</code> 变量额外记录，<code>dp</code> 数组中仅存储取当前元素的情况下的有效长度。</p><p>​        具体代码是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( s.charAt(i) == <span class="string">&#x27;)&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( i - dp[i - <span class="number">1</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="number">1</span>] - <span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span>( i - dp[i - <span class="number">1</span>] - <span class="number">2</span> &gt;= <span class="number">0</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i] += dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxlen = Math.max(maxlen, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        有效长度的选取规则是：</p><ol><li>当 c &#x3D;&#x3D; ‘(‘ ，有效长度肯定为0。</li><li>考虑 c &#x3D;&#x3D; ‘)’ ，如果前一个元素也是 <code>)</code> ，可能存在嵌套问题，可以在 <code>s.charAt(i - dp[i - 1] - 1) == &#39;(&#39;</code> 的前提下，加上嵌套的长度；还有非嵌套的情况：<code>()()</code> ，那么也需要考虑 <code>i - dp[i - 1] - 2 &gt;= 0</code> 也就是本次匹配的 <code>()</code> 前面的最后一个元素也是 <code>)</code> ，就可以加上前面匹配的长度。</li></ol><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>​        栈中存放的标准是：</p><ol><li>对于遇到的每个 ‘(‘ ，我们将它的下标放入栈中</li><li>对于遇到的每个 ‘)’ ，我们先弹出栈顶元素表示匹配了当前右括号：<br>（1）如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中作为「最后一个没有被匹配的右括号的下标」；<br>（2）如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」</li></ol><p>​        需要注意的是，一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 -1 的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        stack.push(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( s.charAt(i) == <span class="string">&#x27;(&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">if</span>( !stack.empty() )</span><br><span class="line">                &#123;</span><br><span class="line">                    maxlen = Math.max(maxlen, i - stack.peek());</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组计算"><a href="#数组计算" class="headerlink" title="数组计算"></a>数组计算</h3><p>​        设置两个计数器分别计算 <code>(</code> 和 <code>)</code> 的个数，首先从左往右遍历，当 <code>left == right</code> 说明当前的字符串肯定是有效的，计算长度；如果 <code>left &lt; right</code> 说明此时字符串不符合规范，需要将两端的计数器归零。相似的，也需要从右往左遍历计算。</p><p>​        具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( s.charAt(i) == <span class="string">&#x27;(&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( left == right )</span><br><span class="line">            &#123;</span><br><span class="line">                maxlen = Math.max(maxlen, left * <span class="number">2</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( left &lt; right )</span><br><span class="line">            &#123;</span><br><span class="line">                left = <span class="number">0</span>; right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( s.charAt(i) == <span class="string">&#x27;(&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( left == right )</span><br><span class="line">            &#123;</span><br><span class="line">                maxlen = Math.max(maxlen, left * <span class="number">2</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( left &gt; right )</span><br><span class="line">            &#123;</span><br><span class="line">                left = <span class="number">0</span>; right = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 41. 缺失的第一个正数</title>
      <link href="/2022/03/20/LeetCode-41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/"/>
      <url>/2022/03/20/LeetCode-41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/first-missing-positive/">41. 缺失的第一个正数</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>​        想要时间复杂度为O(n)，首先想到的就是哈希表存，然后遍历查找，但是这样空间复杂度就不是常数级别了，于是考虑使用数组来代替哈希表。</p><p>​        先不考虑具体的元素值，单以数组的长度 <code>len</code> 来思考，这个最小的未出现的正整数出现的情况：只有两种，要么是在这个长度的范围内 <code>i &gt;= 1 &amp;&amp; i &lt;= len</code> ，要么不在这个范围内 <code>i &gt; len</code> 。</p><p>​        接着不考虑具体元素的正负，如果数组中元素的值不是连续的1到len，那么就意味着 <code>&lt;= len &amp;&amp; &gt;= 1</code> 的范围内有值没有被取到，这个值必然就是结果值；如果数组中的值排序后是连续的1到len，那么最小的正整数就必然是 <code>len + 1</code> 。</p><p>​        基于上述思想，可以对原数组先进行一个排序，但是不应该是从小到大的执行升序排序，而是按照 <code>nums[i] == i + 1</code> 进行排序，也就是对数组 <code>[3,-1,2]</code> ，排序的结果应该为 <code>[-1, 2, 3]</code> ，这样我们遍历排序后的数组，当 <code>num[i] != i + 1</code> 就表示 <code>i + 1</code> 是当前最小的未出现的正整数。</p><p>​        具体的代码是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( nums[i] &gt;= <span class="number">1</span> &amp;&amp; nums[i] &lt;= len &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i] )</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums, i, nums[i] - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i] != i + <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        代码中存在一个 for 循环中嵌套一个 while 循环，这种情况是如何保证 O(n) 的时间复杂度的呢？因为满足 <code>num[i] == i + 1</code> 的结果只会有一个，那么如果在某一个 while 中经过n次循环，就意味着肯定会有n个元素存放到对应的下标中，之后的while肯定不会在这些下标遍历，是互相抵消的。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 45. 跳跃游戏 II</title>
      <link href="/2022/03/18/LeetCode-45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II/"/>
      <url>/2022/03/18/LeetCode-45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-II/</url>
      
        <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode-cn.com/problems/jump-game-ii/">45. 跳跃游戏 II</a></p><span id="more"></span><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>​        就是将大问题拆分为多个子问题，求每个子问题的最优解，然后将这些最优解叠起来，<strong>当作</strong>是整个问题的最优解，所以<strong>贪心算法得到的结果不一定就是全局最优解。</strong></p><p>解题的步骤：</p><ol><li>拆分子问题；</li><li>明确子问题的最优解；</li><li>将子问题的最优解叠成整个问题的解。</li></ol><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>​        题目中最终要求的结果是要到达最后一个位置，最少跳几次。那么有两种思考的方式，第一种正向查找，就是从前往后遍历，找到以当前位置为终点的最小路径；第二种反向查找，是从后往前找，找到第一个离这个位置最远但是能够取到这个位置的下标作为最小的路径。</p><h4 id="反向查找"><a href="#反向查找" class="headerlink" title="反向查找"></a>反向查找</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 反向查找</span></span><br><span class="line">        <span class="keyword">while</span>( len &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( i + nums[i] &gt;= len )</span><br><span class="line">                &#123;</span><br><span class="line">                    len = i;</span><br><span class="line">                    ++steps;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="正向查找"><a href="#正向查找" class="headerlink" title="正向查找"></a>正向查找</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> steps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxpos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            maxpos = Math.max(maxpos, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span>( i == end )</span><br><span class="line">            &#123;</span><br><span class="line">                end = maxpos;</span><br><span class="line">                ++steps;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> steps;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chrontab报错权限不够</title>
      <link href="/2022/03/17/chrontab%E6%8A%A5%E9%94%99%E6%9D%83%E9%99%90%E4%B8%8D%E5%A4%9F/"/>
      <url>/2022/03/17/chrontab%E6%8A%A5%E9%94%99%E6%9D%83%E9%99%90%E4%B8%8D%E5%A4%9F/</url>
      
        <content type="html"><![CDATA[<p>报错内容：</p><blockquote><p>CMDOUT (&#x2F;bin&#x2F;sh: &#x2F;opt&#x2F;data&#x2F;time1.sh: 权限不够)</p></blockquote><span id="more"></span><p>解决：</p><p>应该给这个sh文件添加可执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x time1.sh</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 报错 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea项目上传到github</title>
      <link href="/2022/03/09/idea%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0github/"/>
      <url>/2022/03/09/idea%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E5%88%B0github/</url>
      
        <content type="html"><![CDATA[<p>转载：</p><p><a href="https://www.cnblogs.com/gujun1998/p/11375625.html">idea上传代码到github的3种方式</a></p><span id="more"></span><p>报错：</p><p><a href="https://blog.csdn.net/qq_41946557/article/details/104961248">idea右键项目没有git 【解决方法】</a></p><p>如果要重新上传，需要删除项目的隐藏文件 <code>.git</code> 。</p>]]></content>
      
      
      <categories>
          
          <category> 项目小记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sqoop面试题</title>
      <link href="/2022/03/08/Sqoop%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/03/08/Sqoop%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="Sqoop-概念"><a href="#Sqoop-概念" class="headerlink" title="Sqoop 概念"></a>Sqoop 概念</h3><p>​        实现hdfs数据库与关系型数据库之间的数据传递。底层的导入导出使用mapreduce实现，主要是对inputformat和outputformat进行定制。 在Sqoop的概念中，导入指的是关系型数据库如mysql到hdfs，导出是hdfs到关系型数据库。</p><p>​        Sqoop的2版本不用于生产环境，生产环境使用1版本。</p><span id="more"></span><h3 id="mysql-gt-hdfs-导入"><a href="#mysql-gt-hdfs-导入" class="headerlink" title="mysql -&gt; hdfs 导入"></a>mysql -&gt; hdfs 导入</h3><h4 id="全部导入"><a href="#全部导入" class="headerlink" title="全部导入"></a>全部导入</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bin/sqoop import \</span><br><span class="line">--connect jdbc:mysql://hadoop002:3306/database_name \</span><br><span class="line">--username user_name \</span><br><span class="line">--password passwd \</span><br><span class="line">--table table_name \</span><br><span class="line">--target-dir <span class="variable">$&#123;hdfs存储路径&#125;</span> \</span><br><span class="line">--delete-target-dir \</span><br><span class="line">--num-mappers 1 \</span><br><span class="line">--fields-terminated-by <span class="string">&quot;\t&quot;</span></span><br></pre></td></tr></table></figure><p>部分参数说明：</p><ol><li><code>--delete-target-dir</code> ：如果 <code>--target-dir</code> 指定的路径存在久删除，在生产环境一般不使用，防止误删，可以写一个hdfs api校验一下，如果存在手动删掉；</li><li><code>num-mappers</code> ：指定处理的map数量；</li><li><code>fields-terminated-by</code> ：指定导入的分隔符。</li></ol><h4 id="查询导入"><a href="#查询导入" class="headerlink" title="查询导入"></a>查询导入</h4><p>​        在全部导入的基础上，删除指定表的参数 <code>--table</code>，增加一个 <code>--query</code> 参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bin/sqoop import \</span><br><span class="line">--connect jdbc:mysql://hadoop002:3306/database_name \</span><br><span class="line">--username user_name \</span><br><span class="line">--password passwd \</span><br><span class="line">--target-dir <span class="variable">$&#123;hdfs存储路径&#125;</span> \</span><br><span class="line">--delete-target-dir \</span><br><span class="line">--num-mappers 1 \</span><br><span class="line">--fields-terminated-by <span class="string">&quot;\t&quot;</span></span><br><span class="line">--query <span class="string">&quot;select name, sex from test where id &lt; 1 and \$CONDITIONS&quot;</span></span><br></pre></td></tr></table></figure><p><code>$CONDITIONS</code> 的问题：</p><p>​        首先对于单引号，直接使用，对于双引号，需要转义，即 <code>\$CONDITIONS</code> 。</p><p>​        使用的原因是：是为了保证导入导出时数据的顺序不变，因为使用多个map执行操作，每个map的处理时长不同，会导致不同结果的顺序与导入导出前不同，$CONDITIONS 变量可以看成是一个序号，必须要等前面的内容写完才可以写它对应的数据。</p><h4 id="指定列导入"><a href="#指定列导入" class="headerlink" title="指定列导入"></a>指定列导入</h4><p>在全部导入的基础上，指定 <code>--columns</code> 参数即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bin/sqoop import \</span><br><span class="line">--connect jdbc:mysql://hadoop002:3306/database_name \</span><br><span class="line">--username user_name \</span><br><span class="line">--password passwd \</span><br><span class="line">--table table_name \</span><br><span class="line">--columns name, sex \</span><br><span class="line">--target-dir <span class="variable">$&#123;hdfs存储路径&#125;</span> \</span><br><span class="line">--delete-target-dir \</span><br><span class="line">--num-mappers 1 \</span><br><span class="line">--fields-terminated-by <span class="string">&quot;\t&quot;</span></span><br></pre></td></tr></table></figure><h4 id="指定条件导入"><a href="#指定条件导入" class="headerlink" title="指定条件导入"></a>指定条件导入</h4><p>在全部导入的基础上，指定 <code>--where</code> 参数即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bin/sqoop import \</span><br><span class="line">--connect jdbc:mysql://hadoop002:3306/database_name \</span><br><span class="line">--username user_name \</span><br><span class="line">--password passwd \</span><br><span class="line">--table table_name \</span><br><span class="line">--<span class="built_in">where</span> <span class="string">&quot;id &lt; 1&quot;</span> \</span><br><span class="line">--target-dir <span class="variable">$&#123;hdfs存储路径&#125;</span> \</span><br><span class="line">--delete-target-dir \</span><br><span class="line">--num-mappers 1 \</span><br><span class="line">--fields-terminated-by <span class="string">&quot;\t&quot;</span></span><br></pre></td></tr></table></figure><p>注意，<code>--where</code> 不能和 <code>--query</code> 一起使用，无法识别。</p><h3 id="mysql-gt-hive-导入"><a href="#mysql-gt-hive-导入" class="headerlink" title="mysql -&gt; hive 导入"></a>mysql -&gt; hive 导入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bin/sqoop import \</span><br><span class="line">--connect jdbc:mysql://hadoop002:3306/database_name \</span><br><span class="line">--username user_name \</span><br><span class="line">--password passwd \</span><br><span class="line">--table table_name \</span><br><span class="line">--num-mappers 1 \</span><br><span class="line">--hive-import \</span><br><span class="line">--fields-terminated-by <span class="string">&quot;\t&quot;</span> \</span><br><span class="line">--hive-overwrite \</span><br><span class="line">--hive-table hive_table_name</span><br></pre></td></tr></table></figure><p>hive中指定的表，有久覆盖数据，没有就新建。</p><h3 id="mysql-gt-hbase-导入"><a href="#mysql-gt-hbase-导入" class="headerlink" title="mysql -&gt; hbase 导入"></a>mysql -&gt; hbase 导入</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bin/sqoop import \</span><br><span class="line">--connect jdbc:mysql://hadoop002:3306/database_name \</span><br><span class="line">--username user_name \</span><br><span class="line">--password passwd \</span><br><span class="line">--table table_name \</span><br><span class="line">--num-mappers 1 \</span><br><span class="line">--hbase-create-table \</span><br><span class="line">--hbase-row-key <span class="string">&quot;id&quot;</span> \</span><br><span class="line">--hbase-table <span class="string">&quot;hbase_table_name&quot;</span> \</span><br><span class="line">--column-family <span class="string">&quot;info&quot;</span> \</span><br><span class="line">--split-by id</span><br></pre></td></tr></table></figure><p>​        sqoop1.4.6版本只支持hbase1.0.1版本之前的自动创建表的功能，后面的版本需要手动建表。其中，<code>split-by</code>  指定hbase的表按哪个列切分单元。</p><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>​        说是大数据集群向关系数据库传递数据，底层其实就是hdfs向关系型数据库传递数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bin/sqoop <span class="built_in">export</span> \</span><br><span class="line">--connect jdbc:mysql://hadoop002:3306/database_name \</span><br><span class="line">--username user_name \</span><br><span class="line">--password passwd \</span><br><span class="line">--table table_name \</span><br><span class="line">--num-mappers 1 \</span><br><span class="line">--export-dir <span class="variable">$&#123;存储数据的路径&#125;</span> \</span><br><span class="line">--input-fields-terminated-by <span class="string">&quot;\t&quot;</span></span><br></pre></td></tr></table></figure><p>​        如果mysql中没有对应的表 <code>table_name</code> ，需要手动创建。</p><p>​        <code>--input-fields-terminated-by</code> 指定切割符，因为导出的过程中会将hdfs的一行数据作为一个字段导出，指定切割符后才能分为多个字段存储。</p><h3 id="脚本打包调用"><a href="#脚本打包调用" class="headerlink" title="脚本打包调用"></a>脚本打包调用</h3><p>​        使用 <code>.opt</code> 格式的脚本，具体脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">export</span><br><span class="line">--connect</span><br><span class="line">jdbc:mysql://hadoop002:3306/database_name</span><br><span class="line">--username</span><br><span class="line">user_name</span><br><span class="line">--password</span><br><span class="line">passwd</span><br><span class="line">--table</span><br><span class="line">table_name</span><br><span class="line">--num-mappers</span><br><span class="line">1</span><br><span class="line">--export-dir</span><br><span class="line">$&#123;存储数据的路径&#125;</span><br><span class="line">--input-fields-terminated-by</span><br><span class="line">&quot;\t&quot;</span><br></pre></td></tr></table></figure><p>执行脚本命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/sqoop --options-file test.opt</span><br></pre></td></tr></table></figure><h3 id="Sqoop导入导出-null-存储一致性的问题"><a href="#Sqoop导入导出-null-存储一致性的问题" class="headerlink" title="Sqoop导入导出 null 存储一致性的问题"></a>Sqoop导入导出 null 存储一致性的问题</h3>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kafka面试题</title>
      <link href="/2022/03/03/kafka%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/03/03/kafka%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="Kafka-的概念"><a href="#Kafka-的概念" class="headerlink" title="Kafka 的概念"></a>Kafka 的概念</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>​        做缓冲。正常情况下，网站的行为日志传输到hdfs会使用flume。当flume传输的速率大于hdfs上传的速率，就容易产生数据丢失，于是引入了kafka来做中间的缓存。它是分布式基于发布订阅模式的消息队列，主要用于处理流数据。</p><span id="more"></span><h4 id="应用场景（使用消息队列的原因，应该也可以看成是使用kafka的原因）"><a href="#应用场景（使用消息队列的原因，应该也可以看成是使用kafka的原因）" class="headerlink" title="应用场景（使用消息队列的原因，应该也可以看成是使用kafka的原因）"></a>应用场景（使用消息队列的原因，应该也可以看成是使用kafka的原因）</h4><ol><li>缓冲和削峰：就是用于解决发布和消费的处理速度不一致的情况。</li><li>解耦：假设发布者有三个，消费者也有三个，如果不使用消息队列，那么每个发布者都需要写三个接口发往不同的目的地；如果使用消息队列，就可以让发布者将消息统一发给队列，然后消费者再根据需要到队列获取特定的消息，两边的处理过程可以独立扩展或修改。</li><li>异步通信：假设用户注册信息写入数据库，正常的步骤是会发送短信告诉用户注册成功。如果是同步通信，就需要等待注册信息写入，并调用接口发送短信，之后页面才会响应注册成功；如果是异步通信，当用户注册信息成功后，会将发送短信的请求写入消息队列，然后页面直接响应成功，之后等到消息队列处理到这个请求再发送短信，这个过程相比于同步通信不需要等待太多时间。也就是先将核心业务处理完成，也就是注册信息和响应页面处理完成，发送短信这种不是很重要的事情可以发送到队列慢慢完成。</li></ol><h3 id="消息队列的两种模式（传统的消息传递方式）"><a href="#消息队列的两种模式（传统的消息传递方式）" class="headerlink" title="消息队列的两种模式（传统的消息传递方式）"></a>消息队列的两种模式（传统的消息传递方式）</h3><h4 id="点对点模式"><a href="#点对点模式" class="headerlink" title="点对点模式"></a>点对点模式</h4><p>​        发布者发送消息给消息队列，然后一个消费者会主动拉取消息队列中的数据，然后返回应答，之后消息队列就会删除这条被消费过的数据。</p><h4 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h4><p>​        可以在消息队列中存储不同类型的topic，然后消费者消费数据后，消息队列不会删除数据，每个消费者相互独立，都可以消费到数据。</p><h4 id="Kafka相较于传统消息传递的优势"><a href="#Kafka相较于传统消息传递的优势" class="headerlink" title="Kafka相较于传统消息传递的优势"></a>Kafka相较于传统消息传递的优势</h4><ol><li>快速：单一的kafka代理可以处理成千上万的客户端，每秒处理数兆字节的数据；</li><li>可扩展：kafka可以实现透明扩展，扩展的操作可以在集群联机时进行，而不会影响整个系统的可用性；</li><li>容错性：使用多副本机制对每个分区提供若干个副本，避免数据丢失。</li></ol><h3 id="Kafka基础架构"><a href="#Kafka基础架构" class="headerlink" title="Kafka基础架构"></a>Kafka基础架构</h3><ol><li>Producer：是负责发布数据的生产者；</li><li>Consumer：是消费数据的消费者；</li><li>Topic：主题，用于存储各种类型的数据；</li><li>Consumer Group：是消费者组，一个组内包含多个消费者，消费者组之间是互相独立的，组内的消费者负责消费不同分区的数据，一个分区只能由消费者组中的一个消费者消费；</li><li>Partition：为了方便扩展和提高吞吐量，可以将一个数据量非常大的topic切分为多个partition存储到多个broker中；</li><li>Broker：一个服务器就是一个broker，kafka集群可以包含多个broker，一个broker可以包含多个topic；</li><li>replica：为了保证集群中某个节点出现故障时数据不丢失，让kafka能够正常持续的运行，kafka提供了副本机制，为每个分区提供若干个副本，一个leader和多个follower，其中，生产者发布和消费者消费的对象都是leader。</li><li>zookeeper：kafka2.4版本之前引入了zookeeper框架来存储broker的节点信息和每个分区的副本信息，在2.4版本之后，出现了kraft代替zookeeper执行相同的内容。</li></ol><h3 id="Kafka发布数据的流程"><a href="#Kafka发布数据的流程" class="headerlink" title="Kafka发布数据的流程"></a>Kafka发布数据的流程</h3><ol><li>由main线程创建一个producer，执行send方法发送数据；</li><li>数据首先可以被发送到拦截器，在拦截器内可以对数据进行一些加工处理；</li><li>接着序列化器将数据序列化后，传到分区器进行分区，之后数据被传到相应的分区队列中缓存，这些分区队列使用一块内存存储，内存总大小默认是32M；</li><li>当某一分区的数据量达到batch.size参数设置的16k后，会有一个sender线程将这一批次的数据拉取到kafka broker；但是如果某一批次的数据量一直没满16k，那么在等待linger.ms参数设置的时间后也会发送数据，这个参数单位是ms，默认是0，也就是没有延迟；</li><li>sender线程读取到数据后，会将这些数据封装成类似kv的结构，以brokerid为key，想要发送到该broker上的数据请求会连成一个请求队列，作为value，然后将请求逐一发往对应的broker，如果broker接收到请求后没有立刻回应，sender依然可以继续发送请求，但是如果发了5个都没有得到回应就不会再发了，也就是说这个broker节点上最多能缓存5个请求；</li><li>broker接收到数据以后，会有一个应答机制：如果是0，那么sender不需要等待broker的应答，可以继续发送；如果是1，sender线程需要等待leader接收到后返回应答才能继续发送；如果是-1或all，那么需要leader和所有follower接收到数据后才能返回应答；</li><li>这个返回的应答如果是成功的，删除对应的请求和分区中对应的数据；如果失败了会重试，重试的次数默认是Integer的最大值。</li></ol><h3 id="Kafka同步发送和异步发送"><a href="#Kafka同步发送和异步发送" class="headerlink" title="Kafka同步发送和异步发送"></a>Kafka同步发送和异步发送</h3><p>​        同步发送指的是分区内这个批次的数据发送完了，下一批次才能继续发送；异步发送是无论这一批数据是否发送，下一批数据都会继续发送过来。</p><p>​        kafka使用的send方法默认就是异步发送，如果想要使用带回调函数的异步发送机制，也就是能够返回这个数据的分区、broker等信息，就使用带callback回调参数的 send(, new callback(){…}) 方法；如果想要同步发送，就在 send() 方法使用 <code>.get()</code> 实现。</p><h3 id="Kafka-分区"><a href="#Kafka-分区" class="headerlink" title="Kafka 分区"></a>Kafka 分区</h3><h4 id="使用分区的好处："><a href="#使用分区的好处：" class="headerlink" title="使用分区的好处："></a>使用分区的好处：</h4><ol><li>能够合理使用存储资源，将海量数据分别存储在多个服务器上，起到负载均衡的效果；</li><li>提高并行度，生产者可以以分区为单位传输数据，消费者也可以以分区为单位消费数据。</li></ol><h4 id="分区策略："><a href="#分区策略：" class="headerlink" title="分区策略："></a>分区策略：</h4><ol><li><p>默认的分区策略：</p><p>​        如果传入的数据指定了分区，就向指定分区发布数据；如果没有指定分区，但是指定了key值，就将key值对分区数取模，发布到对应的分区上；如果没有指定分区也没有指定key值，就使用粘性分区器，也就是随机选择一个分区，并在之后一直使用这个分区，直到这个分区内装满一个批次发送出去，再开始随机选择与上一个分区不同的其他分区。</p><p>​        <strong>这里有一个面试题</strong>，如果mysql中有一张订单表，希望将这个表的所有数据都发到一个分区，应该怎么做？应该将表名设置为key，那么相同key的数据就会发送到一个分区。</p></li><li><p>自定义分区器：</p><p>​        具体的步骤是：实现Partitioner接口，声明partition、close和configure方法，主要重写的是partition，partition中传入指定的topic、key和value，然后根据传入的参数指定发往某一个分区，分区从0开始。</p></li></ol><h3 id="Kafka丢不丢数据和应答机制有关"><a href="#Kafka丢不丢数据和应答机制有关" class="headerlink" title="Kafka丢不丢数据和应答机制有关"></a>Kafka丢不丢数据和应答机制有关</h3><p>​        当应答为0，也就是producer发送数据后，不需要等待leader的应答，会一直发送数据，此时如果leader还没有将数据从内存持久化到磁盘就宕机，数据就会丢失，虽然效率高，但一般生产环境极少使用；</p><p>​        当应答为1，也就是producer发送数据后，会等待leader返回应该后再继续发送数据，此时如果follower还没有进行同步，leader就挂了，新leader无法获取没同步数据，producer也不会重发已经接收的数据，就会导致数据丢失，效率中等，可靠性中等，适合传输普通日志，允许个别丢数据；</p><p>​        当应答为-1，也就是producer发送数据后，会等待leader和所有的follower接收到后返回应答，才会继续发送数据，效率查，但是可靠性高，适合传输钱相关的数据。</p><p><strong>应答为-1会产生一个问题，如果有一个follower在同步之前出现故障，迟迟不能与leader进行同步，leader会一直等待这个follower。</strong></p><p>解决：Leader维护一个动态的ISR队列，也就是和Leader保持同步的follower+leader的集合，如果这个集合中的某个follower长时间未向leader发送请求或同步数据，这个follower就会被踢出这个isr队列，这样就不用等待长时间联系不上的节点了。这个时间由参数replica.lag.time.max.ms控制，默认是30s。</p><p>​        但是应答为-1的机制也不能完全保证数据的可靠性，如果副本数为1，或者这个isr队列的最小应答数为1，那么当follower全挂的时候，和ack&#x3D;1的效果就是一样的了，仍然会有丢数的风险。</p><p>​        如果想要保证数据的完全可靠，在ack&#x3D;-1的情况下，还需要设置分区副本数要大于等于2，isr队列里最小应答数量大于等于2。</p><h3 id="Kafka-数据重复"><a href="#Kafka-数据重复" class="headerlink" title="Kafka 数据重复"></a>Kafka 数据重复</h3><p>​        应答为-1除了可靠性的问题，还有数据重复的问题：如果leader在发送ack之前故障了，生产者由于接收不到应答会重发数据，就会导致数据重复。</p><p>​        为了解决这个问题，kafka0.11版本后，引入了<strong>幂等性和事务</strong>的特性。</p><p>​        幂等性指的是无论生产者向broker发送多少重复的数据，broker只会持久化一条，来保证不重复。这里判断重复的标准是具有相同主键的数据就是重复的，这个主键由三部分组成：pid是生产者的id号，kafka重启一次会给producer分配一个新的id；分区号；sequence number，是一个单调自增的数值。这个方法只能保证在kafka没有挂掉之前的这一次运行过程中，一个分区内不会有重复数据产生。</p><p>​        为了解决pid这个问题，引入了事务。事务是建立在幂等性上执行的。在broker上，有两个内容：事务协调器用于处理事务，存储事务的特殊主题，用于持久化存储事务的信息，这个主题的底层也是一个磁盘。其中，事务协调器在每个broker中都有， 如何决定使用哪个broker的事务协调器？首先这个特殊主题默认有50个分区，每个分区负责一部分事务，事务的划分是根据传过来的事务id的哈希值对50取模，然后计算出该事务放到哪个分区，然后由这个分区leader所在的broker上的事务协调器处理这个事务。这个事务id需要由用户手动指定，必须是全局唯一值。这个事务id可以让客户端即使重启也能继续处理未完成的事务。</p><p>​        具体的步骤如下：</p><ol><li>生产者首先向对应的事务协调器请求幂等性要用的pid；</li><li>接收到返回的pid后，生产者开始向对应的leader发送数据，发送完后，生产者会向事务协调器请求提交；</li><li>事务协调器会将提交请求持久化到特殊主题，持久化后会给生产者返回应答；</li><li>接着，事务协调器会向leader发送提交请求，leader将数据接收完后会向协调器返回ack，协调器就会将提交成功的信息持久化到特殊主题。</li></ol><p><img src="/kafka%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220322230050201.png" alt="image-20220322230050201"></p><h3 id="生产者如何提高吞吐量"><a href="#生产者如何提高吞吐量" class="headerlink" title="生产者如何提高吞吐量"></a>生产者如何提高吞吐量</h3><ol><li>设置参数 batch.size 和 linger.ms ，调整每批次拉取的数据量和多久拉取一次的时间来提高吞吐量，一般会将 linger.ms 设置为5~100ms，因为太小可能每次拉取的时候都不到一批次的大小，如果太大，那么拉去一次的延时就高了；</li><li>设置 compression.type 参数为压缩 snappy，压缩之后一个批次拉取的数据量会更大；</li><li>当分区数较多，比如1万的时候，可以增大缓冲区大小，来增大存储的批次数量，默认 buffer.memory &#x3D; 32M 。</li></ol><h3 id="生产者发布的数据乱序的问题（面试重点）"><a href="#生产者发布的数据乱序的问题（面试重点）" class="headerlink" title="生产者发布的数据乱序的问题（面试重点）"></a>生产者发布的数据乱序的问题（面试重点）</h3><h4 id="数据乱序的产生"><a href="#数据乱序的产生" class="headerlink" title="数据乱序的产生"></a>数据乱序的产生</h4><p>​        因为brober默认可以连存5个请求而不需要应答，假设1和2成功发送3发送失败了，此时4就顺位继续发送，然后重发3的时候，就会出现乱序，应该是1234的，结果变成1243。</p><h4 id="数据乱序的解决"><a href="#数据乱序的解决" class="headerlink" title="数据乱序的解决"></a>数据乱序的解决</h4><ol><li>在kafka1版本之前，设置分区内的请求数量为1，只能等到当前请求成功发送才能接收下一个请求；</li><li>1版本之后引入了幂等性，开启幂等性enable.idempotence &#x3D; true，并设置缓存数小于等于5，此时broker会缓存生产者发来的最近5个请求的元数据，能够保证最近5个数据都是有序的。具体实现有序的步骤是：broker中请求落盘的顺序是按照seqnumber的自增顺序进行的，例子中当number不为3的时候，哪怕到了4、5也会继续等待，直到请求3到达，会对broker中未落盘的请求按照sqnumber排序，再一次落盘。</li></ol><p><strong>设置缓存数不能大于5的原因是：</strong></p><p>​        因为broker上的ProducerStateManager实例会缓存每个pid在每个分区上发送的最近5个批次的数据，这个5是写死的，所以如果 max.in.flight.requests.per.connection 这个参数如果设置超过5，producerStateManager就会把最旧的批次数据删除。</p><h3 id="Broker-ZK存储内容"><a href="#Broker-ZK存储内容" class="headerlink" title="Broker ZK存储内容"></a>Broker ZK存储内容</h3><ol><li>在线的brokerid；</li><li>每个分区对应的副本所在的brokerid；</li><li>在某个分区的leader挂掉后，帮助选举新leader。leader的信息存储在&#x2F;kafka&#x2F;controller目录下，每个broker上都有一个controller模块，旧leader挂掉后，现有节点中的controller都会去注册zookeeper上的controller节点，第一个注册上的Controller负责进行选举。</li></ol><h3 id="Broker工作流程"><a href="#Broker工作流程" class="headerlink" title="Broker工作流程"></a>Broker工作流程</h3><ol><li>启动一台服务器会向ZK注册brokerid；</li><li>接着每台服务器上的controller都会去抢占ZK中的controller节点，第一个抢到的负责选举；</li><li>选举之前会监听zk上brokers节点的变化，然后以在isr队列中存活为前提，按照ar的顺序轮询，排在前面的优先，ar是kafka分区中所有副本的统称，ar的顺序就是服务器启动并注册到brokers的顺序，选举完后，这个controller将节点信息上传到zk；</li><li>其他controller会从zk中同步这个节点信息；</li><li>然后，生产者开始发送消息给leader，follower主动向leader同步数据；之后按照应答机制，leader向生产者返回ack；</li><li>如果leader挂掉了，zk会返回给监听他的controller，这个controller会从zk拉取节点信息，重新选举leader；</li><li>选举出新leader，这个controller再向zk更新节点信息。</li></ol><p><strong>脑裂的解决：</strong></p><p>​        出现脑裂的原因是可能由于网络的原因，会出现两个controller负责选举的情况。</p><p>​        解决：每当新的controller产生的时候就会在zk中生成一个全新的、数值更大的controller epoch的标识，并同步给其他的broker进行保存，这样当第二个controller发送指令时，其他的broker就会自动忽略。</p><h3 id="Kafka副本"><a href="#Kafka副本" class="headerlink" title="Kafka副本"></a>Kafka副本</h3><p>​        副本的作用是提高数据的可靠性，默认副本数是1，在生产环境中一般设置为2，不宜太多，因为副本也会消耗磁盘空间和进行网络运输，太多影响效率。</p><p>​        Kafka中所有副本统称为AR，包含了ISR和OSR，ISR中保存和Leader保持同步的leader和follower集合，当ISR中有follower与leader长时间没有通信，会被踢出到OSR集合，这个OSR就是存储超时的follower。这个实际默认是30s，由replica.lag.time.max.ms控制。</p><h3 id="Leader和Follower故障处理"><a href="#Leader和Follower故障处理" class="headerlink" title="Leader和Follower故障处理"></a>Leader和Follower故障处理</h3><p>​        这里涉及两个词：LEO指的是每个副本的offset+1，HW指的是所有副本中最小的LEO。</p><h4 id="Follower故障"><a href="#Follower故障" class="headerlink" title="Follower故障"></a>Follower故障</h4><p>​        当follower出现故障，会被临时踢出ISR，在恢复期间其他的服务器继续接收数据，并更新LEO和HW。等到这个follower恢复后，会先获取本地磁盘记录中故障前的HW，并将log中高于这个HW的部分删掉重新同步，因为这部分数据对于这个follower是没有验证过的。等到follower的HW等于leader的HW后，再重新加入ISR。</p><h4 id="Leader故障"><a href="#Leader故障" class="headerlink" title="Leader故障"></a>Leader故障</h4><p>​        Leader出现故障后，会从ISR中重新选举新Leader。为了保证数据的一致性，会将follower中HW高于leader的部分删掉，对于低于Leader的部分，重新同步。这只能保证数据的一致性，但是不能保证数据不丢失或不重复。</p><h3 id="Kafka-Partition自动平衡"><a href="#Kafka-Partition自动平衡" class="headerlink" title="Kafka Partition自动平衡"></a>Kafka Partition自动平衡</h3><p>​        在正常情况下，Kafka会自动把leader partition均匀的分布在集群上，来保证每台服务器的吞吐量是均匀的，但是如果某些broker出现故障，会导致这些broker上的leader会分布到其他broker上，就会导致这些broker的读写请求过多，并且这些leader在故障的broker重启后也不会自动回到之前的broker运行，就会导致集群负载不均衡。</p><p>​        有三个参数来优化：</p><ol><li>auto.leader.rebalance.enable，默认是true，也就是开启leader自平衡；</li><li>leader.imbalance.per.broker.percentage，默认是10%，当一个broker的不平衡率到达10%会触发自平衡；</li><li>leader.imbalance.check.interval.seconds，默认300s，每过300s检查一次不平衡率。</li></ol><p>​        不平衡率的计算是，假设一个分区中，leader的brokerid是0，ar队列是 [1,0,2,3]，那么不平衡数会依次比较ar队列和leader的id，如果不相等不平衡数会加一，然后再除以副本总数，也就是这里面的 1&#x2F;4&gt;10% ，那么就会触发自平衡。</p><p>​        在生产环境中，这个自平衡不建议开，或者也可以把不平衡率调高，因为自平衡的过程回暂停这个分区的运行，直到平衡完，效率不高。</p><h3 id="Broker-文件存储机制"><a href="#Broker-文件存储机制" class="headerlink" title="Broker 文件存储机制"></a>Broker 文件存储机制</h3><p>​        Kafka中，topic只是一个逻辑概念，实际存储的是partition。每个partition对应一个log文件，这个log用于存储发布的数据，生产者会将生产的数据不断追加到log文件的结尾，为了避免log文件过大导致定位效率低下，将一个log文件切分为多个segment存储，一个segment是1G，里面主要包含的文件有.log存储实际的文件、.index存储.log中数据的索引、.timeindex存储索引进入的时间戳，因为数据默认是保存7天，这个时间戳文件用于在规定时间到后删除数据。</p><p>​        一个partition的数据会存在一个文件夹下，以 topic名称-分区号 命名，其中每个segment下的文件以当前segment的第一条消息的offset命名。</p><p>​        其中，index是稀疏索引，大约每往log中插入4k的数据会写入一条索引，这个4k可以通过 log.index.interval.bytes 修改。index文件中存放的offset是相对的offset，这样能够确保offset的值所占空间不会太大，因此能将offset控制在固定大小。</p><p>​        比如想要在log中定位 offset &#x3D; 600 的数据，会先比较index文件的文件名，找到小于600的最大的值，定位到这个index文件，然后在index文件中找到绝对offset中小于600的最大的offset，因为文件中存的是相对offset，那么绝对offset旧等于文件名对应的值加上这个相对offset，然后取出这个offset对应的position，也就是log文件中这个offset的起始位置，就能得到log中offset为600的数据了。</p><h3 id="文件清理策略"><a href="#文件清理策略" class="headerlink" title="文件清理策略"></a>文件清理策略</h3><p>​        Kafka中默认的日志保存时间是7天，可以通过调整如下参数来修改保存时间：</p><ol><li>log.retention.hours，设置保存的小时数，默认7天；</li><li>log.retention.minutes，设置保存的分钟数，设置这个，小时数的参数就不起作用；</li><li>log.retention.ms，设置保存的毫秒数，设置这个，分钟数举不起作用。</li><li>log.retention.check.intervals.ms，设置检查的周期，默认是5分钟，这个值应该要比保存时间要小。</li></ol><p>​        一旦数据超过了保存的时间，就会触发清理。清理的策略有delete和compact。默认的策略是删除。</p><p>​        删除就是当一个segment中最新写入的数据超过这个保存的时间，就会把这个segment删掉。压缩是对相同key的不同value值，只保留最新版本的数据。压缩后的offset实际是不连续的，只适用于一些特殊场景，比如key是用户id，value是用户资料，可以只保留用户最近的资料。如果想要设置清理策略为compact，可以修改参数 log.cleanup.policy &#x3D; compact 。</p><h3 id="Kafka怎么实现高效读写（高频面试）"><a href="#Kafka怎么实现高效读写（高频面试）" class="headerlink" title="Kafka怎么实现高效读写（高频面试）"></a>Kafka怎么实现高效读写（高频面试）</h3><ol><li>Kafka本身是分布式集群，采用分区技术，并行度高；</li><li>读数据采用稀疏索引，可以快速定位要消费的数据；</li><li>producer发布数据的时候，是顺序追加到log文件的，可以减少寻址时间；</li><li>采用零拷贝+页缓存的技术。</li></ol><p><strong>页缓存：</strong></p><p>​        首先我们知道文件都是存储在本地磁盘的，每次读写文件肯定都会经过磁盘IO，为了减少磁盘IO的次数，提升读写的效率，于是引入了页缓存。Linux内核会将文件以页的大小划分为多个数据块，默认是4kb一页。</p><p>​        当用户执行读操作，如果读取的这个数据存在页缓存，就直接从页缓存拷贝对应的数据返回；否则内核会申请一个空闲的页缓存，然后从文件中读取数据块到页缓存，再将数据从页缓存拷贝给用户。</p><p>​        当用户执行写操作，如果要写入的数据所在的页缓存已经存在，那么会直接写入页缓存，否则内核会申请一个空闲的页缓存，然后从文件中读取数据块到页缓存再将用户插入的数据写到页缓存，对于被修改的页缓存，内核会定时刷新到文件中。</p><p>​        Kafka重度依赖于底层的页缓存功能，读写操作都会在页缓存上执行，这样相比于直接操作磁盘的效率就高得多。</p><p><strong>零拷贝：</strong></p><p>​        kafka将数据的加工处理操作都交给生产者和消费者，本身不用于存储数据，所以数据的读取在查找磁盘和缓存后不需要再上传到kafka，而是直接通过网卡发送给消费者，提高了传输的效率。</p><h3 id="消费者的总体工作流程"><a href="#消费者的总体工作流程" class="headerlink" title="消费者的总体工作流程"></a>消费者的总体工作流程</h3><p>​        由于消费者之间互相独立，那么传输的速度肯定不可能一致，所以消费者的消费是主动从leader拉取数据的过程。一个消费者可以消费多个分区，但是一个分区只能被消费者组中的一个消费者消费。为了避免消费者挂掉重启后重复消费数据，会记录分区中最新读取到的offset。在0.9版本之前，这个信息是存储在zookeeper上的，但是由于所有消费者都需要通过网络和zookeeper交互获取offset，效率太低，在0.9版本之后改为使用本地的系统主题来存储offset，因为kafka中的主题数据最终都是存储在磁盘，所以可靠性得到保证。在系统主题中，使用kv的形式存储，key是 groupid+topic+分区号，value是当前offset的值。每隔一段时间，kafka会对系统主题中的数据进行压缩，也就是每个key只保留最新的数据。</p><h3 id="消费者组的初始化流程（重点）"><a href="#消费者组的初始化流程（重点）" class="headerlink" title="消费者组的初始化流程（重点）"></a>消费者组的初始化流程（重点）</h3><p>​        通过使用coordinator来辅助实现消费者组的初始化和分区的分配。每个broker都存在一个coordinator。首先使用消费者组的groupid的hash值对存储offset的系统主题的分区数，默认是50取模，然后选择这个分区所在的broker上coordinator进行之后的操作。</p><ol><li>每个consumer都会往这个coodinator上发送加入这个消费者组的请求；</li><li>coodinator会随机从这些请求的消费者中选出一个leader，并将接收到的所有信息都发给这个leader；</li><li>leader负责指定消费的方案，也就是哪个consumer消费哪个分区；</li><li>制定完后发回给coordinator，然后coordinator群发给所有的consumer；</li><li>每个consumer都会和coordinator保持默认3秒的心跳通信，也就是会定期汇报自己还活着，一旦超过 session.timeout.ms 参数默认的时间45s，该消费者就会被移除出组，并触发再平衡，或者这个消费者处理消息的时间超过 max.poll.interval.ms 默认是5分钟，也会触发再平衡。</li></ol><h3 id="消费者组具体消费流程"><a href="#消费者组具体消费流程" class="headerlink" title="消费者组具体消费流程"></a>消费者组具体消费流程</h3><p>​        首先会创建一个消费者网络连接客户端，这个客户端主要用于和kafka集群进行交互。consumer会像这个客户端通过sendFetches方法发送消费请求，然后客户端通过send方法将这个请求发送给对应的leader，然后通过回调函数onSuccess()拉取数据到completedFetches队列中，然后消费者就可以调用fetchedRecords方法到这个队列中拉取数据，拉取到的数据回先经过反序列和拦截器对数据进行转换和加工，之后就可以处理数据了。</p><p>​        其中涉及到几个参数：对于每批次能够拉取的数据量，最小拉取量为 fetch.min.bytes &#x3D; 1字节，最大拉取量为 fetch.max.bytes&#x3D;50M，如果参数 fetch.max.wait.ms &#x3D; 500ms 这个时间内一个批次的数据量没有到达最小拉取量，这个批次也会被拉取。对于消费者从队列中拉取的记录数由参数 max.poll.records 设置，默认是500条。</p><h3 id="分区的分配和再平衡"><a href="#分区的分配和再平衡" class="headerlink" title="分区的分配和再平衡"></a>分区的分配和再平衡</h3><h4 id="分区的分配"><a href="#分区的分配" class="headerlink" title="分区的分配"></a>分区的分配</h4><p>​        也就是如何规定哪个consumer消费哪个分区。kafka提供了四种分配策略：range、rangeRobin、Sticky、CooporativeSticky。默认使用的是rage+CooporativeSticky策略，配置的参数是 partition.assignment.strategy 。可以同时使用多个策略。</p><h5 id="Range分配"><a href="#Range分配" class="headerlink" title="Range分配"></a>Range分配</h5><p>​        Range是针对每个topic来说的。会将这个topic中的分区按照序号排序，然后将consumer按照字母顺序排序。将分区数除以消费者数，得到每个消费者消费的分区数，如果除不尽就交由前面的消费者分别处理一个分区。</p><p>​        比如有8个分区，3个消费者，8 &#x2F; 3 &#x3D; 2 …… 2，那么第一个消费者消费0-2的分区，第二个消费者消费3-5的分区，第三个消费者消费6-7的分区。</p><p>​        这种模式如果在消费多topic的情况下，前面的消费者处理的内容就会很多，那么就容易造成数据倾斜。</p><p>​        这种模式下，如果消费者组的某个消费者出现故障，那么这个消费者负责的分区正在处理的操作会全部分配到另一个消费者上，等到处理完这一波，下一次接收数据的时候，再根据range策略重新分配分区。</p><h5 id="RangeRobin分配以及再平衡"><a href="#RangeRobin分配以及再平衡" class="headerlink" title="RangeRobin分配以及再平衡"></a>RangeRobin分配以及再平衡</h5><p>​        RangeRobin是针对所有topic来说的。会将所有topic的分区和所有consumer都列出来，按照hashcode排序，最后通过轮询算法来分配分区。</p><p>​        如果某个消费者出现故障，这个消费者负责的分区依然会按照轮询的策略均分给其他的消费者。</p><h5 id="Sticky分配以及再平衡"><a href="#Sticky分配以及再平衡" class="headerlink" title="Sticky分配以及再平衡"></a>Sticky分配以及再平衡</h5><p>​        是0.11版本引入的，首先会尽量均衡的分配分区，如果同消费组的某个消费者出现问题，会尽量保证原有分配的分区不变化。</p><p>​        该策略的首次分配和Range很像，但是粘性策略不进行排序。如果某个消费者出现故障，会将这个消费者负责的分区尽量均衡分配到其他分区上。这个再平衡的过程会让所有消费者放弃原有分区进行重分配。</p><h5 id="CooporativeSticky分配以及再平衡"><a href="#CooporativeSticky分配以及再平衡" class="headerlink" title="CooporativeSticky分配以及再平衡"></a>CooporativeSticky分配以及再平衡</h5><p>​        这个策略和Sticky策略很像，但是在消费者故障之后，不会让所有其他消费者放弃已有分区进行全局重平衡，而是改成多次小规模分区重平衡。</p><h3 id="Offset的保存和提交"><a href="#Offset的保存和提交" class="headerlink" title="Offset的保存和提交"></a>Offset的保存和提交</h3><h4 id="Offset的保存"><a href="#Offset的保存" class="headerlink" title="Offset的保存"></a>Offset的保存</h4><p>​        在0.9版本之前使用zookeeper存储，但是所有的消费者都和zookeeper进行交互，效率就会很低，所以在0.9版本之后引入了系统主题来存储offset。存储的是kv形式的数据，key保存 groupid+topic+分区号，value保存当前offset的位置。kafka每隔一段时间就会对系统主题的内容进行压缩，也就是只保留每个key中最新的数据。</p><h4 id="Offset的提交"><a href="#Offset的提交" class="headerlink" title="Offset的提交"></a>Offset的提交</h4><h5 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h5><p>​        enable.auto.commit 默认是true，也就是默认开启自动提交的功能，auto.commit.interval.ms 默认5s自动提交一次。</p><p>​        具体的提交流程是：consumer不断的从分区拉取数据，然后每隔5s向系统主题提交一次当前拉取的offset。</p><h5 id="手动提交"><a href="#手动提交" class="headerlink" title="手动提交"></a>手动提交</h5><p>​        自动提交虽然便利，但是因为是基于时间提交的，所以提交时机不好把控。于是kafka提供了手动提交的api实现。</p><p>​        手动提交的方式有两种：同步和异步。二者都是将本次提交的最高偏移量提交。不同的是，同步提交是等到offset提交到系统主题完成后再拉取下一波数据，这种模式会阻塞当前线程直到提交成功，并在失败时重试；异步提交是发送完offset提交请求后就继续拉取下一波数据了，不会进行失败重试，可能提交失败。</p><p>​        设置手动提交，需要配置ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG参数为true，并调用kafkaConsumer.commitSync()执行同步或commitAsync()执行异步。</p><h4 id="指定offset消费"><a href="#指定offset消费" class="headerlink" title="指定offset消费"></a>指定offset消费</h4><p>​        通过参数 auto.offset.reset 指定消费的位置。包括三种：</p><ol><li>earliest：从分区最开始的位置消费；</li><li>latest：从分区最新的位置开始消费，这是默认值；</li><li>none：如果没有找到消费者组之前消费的位置，会向消费者抛出异常。</li></ol><p>​        如果既不想从开始的位置消费，也不想从最新的位置消费，而是想从中间的某个指定位置开始消费，可以在代码中手动指定：consumer.seek(partition, offset) 。因为消费者组的初始化过程会消耗一定时间，而在代码中因为是顺序执行，可能在还没有分配完分区就已经执行到这个代码，就会导致获取不到数据。为了避免这个错误，可以指定消费之前使用 while 循环，在还没有制定好分配方案时不往下进行，并在循环中频繁获取分区信息，一旦分配完毕就立刻退出。</p><h3 id="消费者事务"><a href="#消费者事务" class="headerlink" title="消费者事务"></a>消费者事务</h3><h4 id="重复消费和漏消费"><a href="#重复消费和漏消费" class="headerlink" title="重复消费和漏消费"></a>重复消费和漏消费</h4><p>​        重复消费一般是由自动提交引起的。具体的过程是：consumer默认会5s提交一次offset，并且在发送完这个提交请求后继续拉取数据。假设提交这个offset &#x3D; 2 的请求完成后，这个consumer消费到offset &#x3D; 4的时候挂掉了，此时因为还没到5s，所以还没有发送请求，再次重启就会从offset&#x3D;2的位置继续消费，那么offset&gt;2&amp;&amp;offset&lt;&#x3D;4的位置的数据就被重复消费了。</p><p>​        漏消费的场景是：假设offset设置为手动提交，当consumer拉取数据，并向系统主题提交offset的时候，当offset提交完成，但是数据还没有完全落盘的时候，这个消费者挂掉了，这个时候就会导致还未落盘的这部分数据丢失。</p><h4 id="消费者事务解决重复消费和漏消费"><a href="#消费者事务解决重复消费和漏消费" class="headerlink" title="消费者事务解决重复消费和漏消费"></a>消费者事务解决重复消费和漏消费</h4><p>​        想要完成consumer端的一次性精准消费，就需要将消费的过程和提交offset的过程作为一个事务进行处理，同时消费者需要支持事务，比如mysql，如果是hbase这种不支持事务回滚的消费者，所以是会存在问题的。</p><p>​        想要完全做到整条路线的精确一次消费，除了消费端要使用事务，生产者也需要采用幂等性+事务的特性，同时也需要做到ack&#x3D;-1、副本数大于等于2、isr最小应答数大于等于2。</p><h3 id="数据积压（消费者如何提高吞吐量）（重要）"><a href="#数据积压（消费者如何提高吞吐量）（重要）" class="headerlink" title="数据积压（消费者如何提高吞吐量）（重要）"></a>数据积压（消费者如何提高吞吐量）（重要）</h3><ol><li>如果是kafka的topic数据量大，导致消费速度慢，可以考虑增加分区，但是多个分区使用一个消费者消费也不会很快，于是需要同时提升二者的数量，保证消费者数 &#x3D;&#x3D; 分区数。</li><li>如果是批次拉取的数据量过少，导致处理的数据小于生产的数据，也会造成数据积压，对于这种情况可以提高每批次拉取的数据量。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flume面试题</title>
      <link href="/2022/03/03/flume%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/03/03/flume%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="flume架构"><a href="#flume架构" class="headerlink" title="flume架构"></a>flume架构</h3><ol><li><p>Agent：</p><p>是一个JVM进程，它以事件Event的形式将数据从源头发送到目的地。Agent主要由三个部分组成：Source、Channel、Sink。</p></li></ol><span id="more"></span><ol start="2"><li><p>Event：</p><p>是Flume传输数据的单元，分为两部分：header和body，body部分使用字节数组存储实际传输的数据，header存储一些event的属性，比如说想要将不同类型的输入数据传到不同的channel中处理，可以让source通过header来区分并发送到不同的channel。</p></li><li><p>Source：</p><p>负责接受各种类型的数据到Agent，并将数据推送到Channel。常见的类型包括：avro、exec、spooling directory、netcat、taildir等。</p></li><li><p>Sink：</p><p>不断拉取Channel中的事件且批量的移除它们，并将这些事件批量写入目的地，常见的包括：hdfs、hbase、logger、avro或下一个flume的Agent等。</p></li><li><p>Channel：</p><p>是运行在Source和Sink之间的缓冲区，因此它允许Source和Sink运作在不同的速率上。Channel是线程安全的，可以同时处理几个Source的写入和几个Sink的读取。</p><p>flume自带两种Channel：memory channel和file channel。memory channel因为存在内存，所以速度肯定快，但是一旦出现故障数据就会丢失；file channel因为写在磁盘，所以安全性好，但是速度慢。</p></li></ol><h3 id="Flume-事务"><a href="#Flume-事务" class="headerlink" title="Flume 事务"></a>Flume 事务</h3><p>在从Source推送数据到Channel的过程和Sink从Channel拉取数据的过程可以看成是两个事务。</p><h4 id="Put事务过程"><a href="#Put事务过程" class="headerlink" title="Put事务过程"></a>Put事务过程</h4><p>​        在Source端开始发送数据前会启动一个Put事务。首先 doPut 将数据先写入临时缓冲区 putlist ，然后 doCommit 回去检查channel中是否有足够的空间，如果够就真正提交写入；否则 doRollback 回滚，将数据放回Source。</p><h4 id="Take事务"><a href="#Take事务" class="headerlink" title="Take事务"></a>Take事务</h4><p>​        在Sink端开始拉取数据前会启动一个Take事务。首先 doTake 将数据取到临时缓冲区 takelist ，并尝试往目的地写出，doCommit 检查如果数据发送成功，就情况 takelist，否则 doRollback 将临时缓冲区的数据归还给Channel，此时不会情况缓冲区。</p><h3 id="Agent内部原理（详细架构）"><a href="#Agent内部原理（详细架构）" class="headerlink" title="Agent内部原理（详细架构）"></a>Agent内部原理（详细架构）</h3><ol><li><p>数据输入首先传递给Source。</p></li><li><p>Source将数据作为事件传递给 Channel处理器，这个处理器会将事件传递给拦截器链，也就是一至多个拦截器，拦截器会将数据拦截下来去做一些额外的处理，处理完后再传回给处理器。</p></li><li><p>接着处理器会将事件传给Channel选择器，由这个选择器选择将事件发给哪个Channel。</p><p>选择器有两种类型：Replicating副本选择器，是默认的，假设给一个source绑定了两个channel，并且没有配任何选择器的内容，那么source会将这个事件发送给两个相同的channel；Multiplexing多路复用，这个选择器会有选择的将事件发给不同的channel，但是需要结合拦截器使用，因为这个选择器是根据header的内容来处理的。处理完后选择器又会将事件发回给channel处理器。</p></li><li><p>然后处理器会根据选择器的选择结果将事件发给对应的channel中。</p></li><li><p>接着Channel要发送到哪个Sink又需要做选择，这里就涉及到Sink组的问题，所以出现了SInkProcessor。</p><p>SinkProcessor有三种类型：DefaultSinkProcessor默认的SinkProcessor、LoadBalancingSinkProcessor是负载均衡和FailoverSinkProcessor故障转移。默认SinkProcessor只有一个Sink，所以其实不算在Sink组的类型。</p><p>对于负载均衡，假设一个channel绑定了三个sink，这三个Sink会依次拉取Channel的数据，实现负载均衡。</p><p>对于故障转移，是对sink组里的sink配置优先级，优先级最高的先去拉取数据，当这个sink出现故障，再由下一个优先级最高的继续拉取。</p></li></ol><h3 id="Flume拓扑结构"><a href="#Flume拓扑结构" class="headerlink" title="Flume拓扑结构"></a>Flume拓扑结构</h3><p>​        也就是多个Agent串联的结构。</p><p><a href="https://www.cnblogs.com/jhxxb/p/11578150.html">图片借鉴</a></p><h4 id="简单串联"><a href="#简单串联" class="headerlink" title="简单串联"></a>简单串联</h4><p><img src="/flume%E9%9D%A2%E8%AF%95%E9%A2%98.assets/1595409-20190924142339540-581718439.png"></p><p>​        将多个Agent顺序串联为一条线路，这种模式不建议桥接过多的agent，因为数量过多不仅会影响传输的效率，而且一旦传输过程中某个flume宕机，会影响整个传输系统。</p><p>​        此外，从Sink输出到另一个Source输入的过程，它们的数据类型要求是avro。avro是一个轻量级的通信框架，通过一个接口来实现接收数据和发送数据。</p><h4 id="复制和多路复用"><a href="#复制和多路复用" class="headerlink" title="复制和多路复用"></a>复制和多路复用</h4><p><img src="/flume%E9%9D%A2%E8%AF%95%E9%A2%98.assets/1595409-20190924143041975-1644651799.png"></p><p>​        将Flume中的事件发送到多个目的地，也就是使用多个Channel，然后每个channel可以将相同的数据发送到不同的目的地，来实现备份的效果。</p><h4 id="负载均衡和故障转移"><a href="#负载均衡和故障转移" class="headerlink" title="负载均衡和故障转移"></a>负载均衡和故障转移</h4><p><img src="/flume%E9%9D%A2%E8%AF%95%E9%A2%98.assets/1595409-20190924145106004-1719791353.png"></p><p>​        使用Sink组来实现，这个agent中只有一个channel，然后连接一个sink组，选择使用负载均衡或者故障转移的处理器来输出到对应的多个agent中，这些agent用于将分散的数据写入目的地，这种方式虽然没有降低要写入的数据量，但是增加了channel的个数，提高了缓冲的效率。比如要写入hdfs，但是写入磁盘的速度会比较慢，就可以使用负载均衡的策略将事件分别发送给多个sink传输，然后这些sink分别连接对应的agent去写入hdfs。</p><h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><p><img src="/flume%E9%9D%A2%E8%AF%95%E9%A2%98.assets/1595409-20190924142628732-1732447063.png"></p><p>​        将多个agent的输出数据都发送到一个agent中合并为一条线路，发送到目的地。比如京东或者淘宝用于访问的服务器肯定不止一台，在不同服务器上访问的本地日志肯定是存在本地服务器的，可以在每台服务器启动一个agent把数据都传输到一个总的agent中，让这个总的agent将所有数据写入hdfs。</p><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>​        用于过滤脏数据、不合法的数据等，或者和channel的多路复用选择器结合，将不同的事件传给不同的channel。</p><h4 id="实现的步骤"><a href="#实现的步骤" class="headerlink" title="实现的步骤"></a>实现的步骤</h4><ol><li>创建实现类并实现 Intercept 接口；</li><li>内部需要重写 initialize初始化、处理单个event的 intercept 方法、批处理event的intercept方法以及close方法；</li><li>一般会在处理单个 event 的intercept方法中给事件的header添加选择的属性，然后在批处理intercept方法中调用处理；</li><li>最后要定义一个静态内部类实现 Intercept.Builder 接口来调用外部这个实现类。</li></ol><h3 id="taildir"><a href="#taildir" class="headerlink" title="taildir"></a>taildir</h3><p>​        用于实时监控一批文件，并记录每个文件最新消费的位置，这样当agent宕机重启时就不会存在重复消费的问题。</p><h3 id="Kafka-Channel"><a href="#Kafka-Channel" class="headerlink" title="Kafka Channel"></a>Kafka Channel</h3><p>​        除了Flume自带的两种channel，还有kafka channel。Source端将数据推送到kafka channel中，kafka channel会直接将数据传输到kafka集群等待进一步的消费，这个过程可以省略sink的使用，与memory channel相比能够避免数据的丢失，与file channel相比也提高了传输的速度，但是kafka中的消息是没有头信息的，所以传入kafka channel时事件的header会丢失。</p><h3 id="怎么实现Flume数据传输的监控"><a href="#怎么实现Flume数据传输的监控" class="headerlink" title="怎么实现Flume数据传输的监控"></a>怎么实现Flume数据传输的监控</h3><p>​        具体没有实现，但是直到有这个懂。使用第三方框架Ganglia实时监控flume。里面有五个比较重要的图是：source尝试写入channel的event量、source成功写入的event、sink尝试拉取的event量、sink成功拉取的event量以及channel的容量。当尝试写入或拉取的量一直是远大于成功写入或拉取的量，就说明内存资源可能不够，需要增加agent的内存资源，在conf&#x2F;flume-env.sh里面有一个 java_opts 的变量，这个变量规定了-Xms是最小内存量，-Xmx是最大内存量，可以修改最大内存量来增加内存。</p><h3 id="使用的Source、Channel、Sink是什么类型？为什么这么用？"><a href="#使用的Source、Channel、Sink是什么类型？为什么这么用？" class="headerlink" title="使用的Source、Channel、Sink是什么类型？为什么这么用？"></a>使用的Source、Channel、Sink是什么类型？为什么这么用？</h3><h3 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h3><p>​        在source中，有一个batchsize参数决定source一次批量运输到channel的event条数，可以适当的调大这个参数来提高搬运的效率。增大source的数量也可以提高source的读取能力。</p><p>​        在channel中，使用memory channel的时候，会调整transectioncapacity，这个参数控制一个事务中，source最多推送的event数和sink最多拉取的event数，这个参数需要大于source和sink的batchsize。</p><p>​        在sink中，也有一个batchsize参数决定sink拉取一次的event数，可以适当调大这个参数提高sink从channel拉取的效率。同时，增大sink的个数也可以增加sink消费event的能力，比如sink组的负载均衡和故障转移，但是也不是越多越好的，过多的sink会占用系统的资源，造成系统资源不必要的浪费。</p><h3 id="Flume采集数据会丢失吗"><a href="#Flume采集数据会丢失吗" class="headerlink" title="Flume采集数据会丢失吗"></a>Flume采集数据会丢失吗</h3><p>​        由于Source到Channel的过程和Channel到Sink的过程都采取了事务机制，所以这两个阶段是不可能出现数据丢失的，唯一可能出现的地方在于使用memory channel的时候，一旦agent宕机或者channel存满了，导致source无法写入，这些未写入的数据也会丢失。</p><p>​        Flume不会丢数据，但是有可能造成重复数据，例如数据已经从sink写出了，但是没有接收到应答，sink就会再次发送数据，此时有可能导致数据的重复。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flume </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hbase面试题</title>
      <link href="/2022/03/03/hbase%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/03/03/hbase%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>​        HBase是一种分布式、可扩展、支持海量数据存储的NoSQL数据库，能够在HDFS上实现数据的增删改查。它在运行过程中需要不断切分和聚合，消耗的资源量让其在小数据集上不具有优势，但是对于大数据集能够做到亿万数据的秒级查询。并且Hbase是基于HDFS的，所以可以实现对hdfs存储数据做随机写操作。</p><p>​        HDFS是不支持随机写的，如果要对里面的数据进行修改，需要先下载下来，改完以后再删掉原来的数据重新提交，这种方式非常不灵活。</p><span id="more"></span><h3 id="HBase和MySQL的区别"><a href="#HBase和MySQL的区别" class="headerlink" title="HBase和MySQL的区别"></a>HBase和MySQL的区别</h3><p>​        二者主要的区别在于，HBase是nosql数据库，而MySQL是关系型数据库。对于关系型数据库，最大的特性就是事务的一致性，为了保证一致性，会牺牲掉一部分的读写性能；而nosql数据库不需要遵循ACID特性，读写性能更高。关系型数据库具有固定的表结构，所以扩展性极差，而nosql存储的格式多样，可以是json、hash表或其他格式。</p><p>​        所以，mysql适用于对一致性要求比较高的场景，而hbase适用于网络应用等对读写性能要求比较高的场景。</p><h3 id="HBase-数据模型"><a href="#HBase-数据模型" class="headerlink" title="HBase 数据模型"></a>HBase 数据模型</h3><p>​        从逻辑上看，HBase的数据模型和关系型数据库很相似，都是存在一张表上，有行有列。但是HBase的底层是以键值对的形式存储的。</p><h4 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h4><p>​        首先类似mysql的database，HBase会存在多个命名空间namespace用于存储表，hbase中有两个默认的namespace：hbase存内置的表，default是用户默认使用的库。进入namespace，一张表中包含一列 rowkey，就和mysql中的主键是一样的，不同的是rowkey是必须要带的，表中的数据会根据rowkey的字典序升序排列；还有一至多个列族，列族中至少包含一个列，一般创建表的时候，指定表名和列族就可以成功创建一张表。因为HBase是存储海量数据的，那么当数据量很大的时候就需要对数据进行横向切分，横切之后的每个部分就称为一个region，一张表会包含多个region。将表依据列族竖切，再依据数据量横切，得到的就是一个一个的store，store是实际存储的单位。</p><p><img src="/hbase%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220321192758965.png" alt="image-20220321192758965"></p><h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><p>​        对于store中的一行记录，在物理上是按列分行存的，一行中会包括rowkey、列族名、列名、时间戳、类型和实际的value。时间戳用于标识数据的不同版本，一条数据写入时如果不指定时间戳，系统会自动将插入该数据的时间设定为时间戳。类型有两种：put和delete，表明该数据的状态。这一条数据就是HBase中最小的单元cell，一个cell由行键、列族:列名和时间戳唯一确定。cell中存储的数据在底层以字节码的形式保存，所以实际上HBase中的数据是没有类型的。</p><p><img src="/hbase%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220321202358447.png" alt="image-20220321202358447"></p><h3 id="HBase架构"><a href="#HBase架构" class="headerlink" title="HBase架构"></a>HBase架构</h3><p>​        首先，HBase的底层存储依赖于hdfs，且使用Zookeeper分担了HMaster的和客户端交互的工作，所以在启动HBase的时候，这两个是必须要先启动的。然后，对于HBase来说，需要启动的有两大组件：HMaster和HRegionServer。</p><p>​        HMaster负责命名空间的增删和表的增删改查，以及分配HRegion到某个RS下，并监控每个RS的状态。</p><p>​        HRegionServer负责实际数据增删改查，以及HRegion的切分和聚合。</p><p>​        在HRegionServer内，存在一个HLog，也就是预写入日志，和hdfs的edits文件的作用的一样的。因为HBase中的数据也会先存在内存，然后等到一定的条件再刷写到磁盘，所以避免刷写之前数据丢失，使用hlog存储数据的操作。之后，HRegionServer中还会存储一至多个HRegion。HRegion中包含了多个列族，这里称为store，一个store对应一个文件夹。</p><p>​        store内部开始存储实际的数据，其中包括了 mem store 就是在内存的存储，和storeFile 磁盘的存储。因为每刷写一次会产生一个新文件，所以Store中也会存在很多的storefile，如果这些storefile的容量不大，也就是这些storefile会存在一些小文件，hbase会自动将同store的小文件合并；等到聚合到一定的大小，又会进行切分，这就是hregion的切分和聚合。storefile内包含一个hfile。hfile和hlog都在hdfs上。</p><p><strong>Zookeeper在HBase中的作用：</strong></p><p>HBase启动成功后，会在Zookeeper中注册：当前活动的HMaster信息、热备的HMaster信息和每个HRegionServer的信息。活动的HMaster会注册监听存储HRegionServer信息的znode，这样一旦某个HRegionServer出现问题，HMaster就能第一时间发现；同时，所有热备的HMaster也都会监听活动HMaster的状态，一旦出现故障，热备的HMaster会立刻开始抢Zookeeper中的资源，谁抢到谁就当Leader。</p><p><img src="/hbase%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220321222702447.png" alt="image-20220321222702447"></p><h3 id="HBase写数据流程"><a href="#HBase写数据流程" class="headerlink" title="HBase写数据流程"></a>HBase写数据流程</h3><ol><li>客户端想要put一条数据，首先会向Zookeeper请求meta表所在的regionserver。meta表是hbase命名空间内默认存储的表，里面保存了集群中所有region的位置信息，zookeeper中存储了这个meta表的位置。</li><li>zookeeper会向客户端返回meta表所在的regionserver；</li><li>客户端读取这个meta中的数据，并根据命名空间、表名、列族等返回对应的regionserver；</li><li>客户端向这个regionserver发送put请求，会先写hlog，然后再写到memstore，到这里，对客户端来说，写的过程就结束了，这个regionserver会返回给客户端ack应答。</li></ol><h3 id="HBase-flush过程"><a href="#HBase-flush过程" class="headerlink" title="HBase flush过程"></a>HBase flush过程</h3><p>​        刷写的过程其实很简单，到达某个条件就会触发flush过程。重要的是什么时候会触发刷写。</p><ol><li>默认某个regionserver中memstore的总大小超过堆内存的40%会触发刷写，参数是 hbase.regionserver.global.memstore.flush.size；</li><li>为了防止刷写过程中，写的速度比刷写的速度快，导致memstore的大小一直大于规定的值，所以在总大小超过 堆大小 * 0.4 * 0.95 的时候会阻塞客户端的读写操作，直到memstore的大小降到这个安全值内，这个0.95由参数 hbase.regionserver.global.memstore.size.lower.limit 控制；</li><li>如果内存中的数据长时间没有到达阈值，那么默认最后一条数据写入后1h内不再有新数据写入就会触发刷写，参数是 hbase.regionserver.optionalcacheflushinterval；</li><li>默认单个region中memstore的大小超过 hbase.hregion.memstore.flush.size 参数设置的128M时，这个hregion会触发刷写；</li><li>还有两个针对hlog的不可更改的参数：hbase.regionserver.maxlogs &#x3D; 32和 hbase.regionserver.hlog.blocksize &#x3D; block大小，默认当单个hlog大小达到hdfs的block大小时会写新的hlog，当hlog的数量达到32的时候会触发刷写。</li></ol><h3 id="HBase读数据流程"><a href="#HBase读数据流程" class="headerlink" title="HBase读数据流程"></a>HBase读数据流程</h3><ol><li>客户端向zookeeper请求meta表所在的regionserver；</li><li>zookeeper返回后，客户端向对应的regionserver请求meta读取数据，这个regionserver返回查询的结果；</li><li>客户端会向存储实际数据的regionserver发送get请求；</li><li>这个regionserver会同时在memstore和storefile中查找数据，然后对查找到的数据进行一个合并，找到其中时间戳最大的结果返回。为了提高磁盘读的效率，在regionserver中会额外圈出一块内存来存放磁盘中读出来的数据，让regionserver在找磁盘前先查一下读缓存，但是读缓存中存的只是之前已经扫描过的文件的结果，所以如果读缓存中能找到数据，就不会在磁盘再扫描这个storefile，但是会在磁盘中扫描其他新刷写的文件，然后会对这三个找到的内容进行一个合并，返回时间戳最大的结果。所以无论如何读操作都是会经过磁盘的，所以HBase的读操作肯定会比写操作要慢。</li></ol><p>​        注：因为读缓存的容量肯定是远小于这个磁盘的，所以在存储到达上限就需要删掉一些数据，使用LRU算法，也就是将最近最久未使用的数据删掉。（一般没问也可以不用说，也没背其他的算法）</p><h3 id="HBase-Compact过程（合并小文件）"><a href="#HBase-Compact过程（合并小文件）" class="headerlink" title="HBase Compact过程（合并小文件）"></a>HBase Compact过程（合并小文件）</h3><p>​        分为两种：minor compaction和 major compaction。minor compaction会将临近的若干个较小的hfile合并，但是不会清理过期和删除的数据；major compaction是将整个store的所有hfile进行合并，会清理掉过期和删除的数据。</p><p>​        相关的参数有：</p><ol><li>hbase.hregion.majorcompaction：默认是7天合并一次，这个过程因为比较消耗资源，所以减一生产关闭，在应用空闲时手动触发。</li><li>hbase.hstore.compactionThreshold：默认当store中的hfile个数超过3个，会合并重写为一个新文件，设置个数越大能够减少合并的次数，但是每次合并的时间也会相对延长。当然这里合并之后考虑到数据一致性的问题，不会立刻删除旧文件，而是等一会才删掉。</li></ol><h3 id="HBase-真正删除数据的时间"><a href="#HBase-真正删除数据的时间" class="headerlink" title="HBase 真正删除数据的时间"></a>HBase 真正删除数据的时间</h3><p>​        首先，HBase会在flush和major compaction阶段触发删除数据。</p><p>​        对于flush阶段，如果数据存在同一个内存，就能知道这个数据是否过期，或者这个数据是否已经标记了delete，然后会删掉过期或被删除的数据，但是不会删除这个delete标记。</p><p>​        对于major compaction，由于是整个store的文件合并，在重写到新文件时，就可以看到这个数据是否是过期的，或者是否已经被删除，然后就会删掉这部分数据，并且会删除delete标记。</p><p>​        这个delete标记之所以在flush阶段不删掉，是因为flush阶段看到的只是这块内存中的内容，但是不确定之前刷写到磁盘的数据中是否有这个数据的其他版本，如果在flush阶段就删掉这个标记，那么系统中其他版本的数据还能够被查到；在major compaction阶段会删除这个标记是因为进行大合并的时候就会删掉这个表中所有的不合法的数据，那么这个delete标记的其他版本的数据也会被删掉。</p><h3 id="HBase切分region"><a href="#HBase切分region" class="headerlink" title="HBase切分region"></a>HBase切分region</h3><p>​        HBase在最开始的时候只会有一个Region，等到数据量到达某个阈值才会切分这个region。这个阈值在0.94版本，指的是某个storefile的大小超过10G，它所在的region就会进行切分。在0.94版本后，除了这个值以外，还有一个将数据从内存刷写到磁盘的临界值，默认是hdfs一个块的大小，会将这个临界值乘以这个regionserver中属于这个表的region的个数，然后将这个乘积和10G的参数比较取较小值，这个较小值就是0.94版本之后触发切分的阈值。这样的操作越到后面region就会越大，很容易引起数据倾斜（热点）问题。</p><h3 id="HBase优化"><a href="#HBase优化" class="headerlink" title="HBase优化"></a>HBase优化</h3><h4 id="预分区"><a href="#预分区" class="headerlink" title="预分区"></a>预分区</h4><p>​        为了解决自动切分导致的数据倾斜问题，引入了预分区。预分区就是，每个region会维护一个StartRow和EndRow，如果加入的数据的rowkey在这个region维护的范围内，就将这个数据交给这个region。依照这个原则，可以将数据需要投放的分区大致规划好，以提高hbase的性能。</p><p>分区的代码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表 test，并为该表设置四个分区 [-∞, 1000], [1000, 2000], [2000, 3000], [3000, +∞]</span></span><br><span class="line"><span class="keyword">create</span> <span class="string">&#x27;test1&#x27;</span>, <span class="string">&#x27;info&#x27;</span>, <span class="string">&#x27;partition1&#x27;</span>, &#123;SPLITS <span class="operator">=</span><span class="operator">&gt;</span> [<span class="string">&#x27;1000&#x27;</span>, <span class="string">&#x27;2000&#x27;</span>, <span class="string">&#x27;3000&#x27;</span>]&#125;</span><br><span class="line"><span class="comment">-- 通过文件来指定分区，相对路径是将文件建在 hbase/ 目录下</span></span><br><span class="line"><span class="keyword">create</span> <span class="string">&#x27;test2&#x27;</span>, <span class="string">&#x27;info&#x27;</span>, <span class="string">&#x27;partition1&#x27;</span>, SPLITS_FILE <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;splits.txt&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="RowKey设计"><a href="#RowKey设计" class="headerlink" title="RowKey设计"></a>RowKey设计</h4><p>RowKey的设计有三个原则：</p><ol><li>散列原则：让RowKey能够尽量均匀的分配到不同的分区中，仅使用时间戳作为rowkey无法保证这个散列原则；</li><li>唯一原则：这是RowKey设计必须满足的条件；</li><li>长度原则：正常来说应该是在70~100个字节之间，因为要保证唯一，长度太短比较难实现，如果太长，假设是500字节，如果此时存储了1000万的数据，那么仅rowkey就占了差不多1G的容量，极大的影响了存储的效率。</li></ol><p>​        在生产环境中，rowkey的唯一性和长度是一定要保证的，那么具体的优化内容其实就是围绕散列原则进行的。但是一个好的rowkey不应该只考虑散列性，还需要依据业务逻辑考虑rowkey的集中性，也就是应该将经常一起访问的内容放在一起，这样才能在尽量少的区间获取更多的内容。</p><p>​        <strong>rowkey的设计在面试中常会结合具体示例来考：</strong></p><p>示例：电信业务的某一个项目中，会实时产生这样的数据：</p><blockquote><p>12345678910 -&gt; 13926635209 2022-05-05 15:15:15 568</p></blockquote><p>注：上述这个例子的解读为，在 2022-05-05 15:15:15 这个时间，电话号为 12345678910 的机主给电话号为 13926635209 的记住打了电话，通话时长为 568s 。</p><p><strong>题：</strong>想要查询电话号为 12345678910 的通话详情。假设需要创建300个分区，如何设计rowkey和分区键？</p><p><strong>答：</strong> </p><p>因为rowkey需要均匀分布在不同的分区内，所以首先要考虑分区键的创建：</p><p>​        因为要创建300个分区，那么可以考虑分区键的位数是3，然后通过取模的方式获取具体分区，那么具体的分区键为：</p><blockquote><p>000|</p><p>001|</p><p>…</p><p>298|</p></blockquote><p>​        因为是300个分区，那么分区键的取值范围应该是 1 - 299 或 0 - 298 ，考虑到取模数值肯定存在0，设置 0 ~ 298 ，然后让一个值对299取模，就可以得到该分区的前三位。需要注意，第四位是 <code>|</code> ，因为这个符号在 ascii 码中是比较大的值，又因为hbase中数值是按照字典序比较的，使用 <code>|</code> 可以保证rowkey中前三位数的前缀相等的内容会写到一个分区。</p><p>确定了分区后，接着看rowkey：</p><p>​        RowKey为了保证写操作可以将相同手机号的数据写入一个分区，前缀会对手机号取299的模，然后拼接字符 <code>_</code> 。之所以使用 <code>_</code> 是为了因为 <code>_</code> 的ascii比 <code>|</code> 小，这样就能保证相同前三位数的rowkey能够进入一个分区。</p><p>​        但是不同手机号的通话详情的数据肯定是不一致的，有些很多，有些很少，这种情况单用一个手机号也容易产生数据倾斜，而这种详情基本是按年、月、日来取的，可以加上日期，来让这个值更加散列。如果加上的日期是日或者更小，数据就太散了，如果想要取一年的数据会很复杂；如果使用年份数据依然会比较集中，所以取<strong>年月加上电话号的组合再取299的模</strong>最好。那么具体的rowkey前缀是：</p><blockquote><p>xxx_</p></blockquote><p>​        之所以说是前缀，是为了在保证散列性的前提下，能够让一个手机号的数据存放在一起，这样就能方便取出，那么可以在这个前缀后拼接手机号，因为是按位排序的，相同手机号的数据肯定会放在一起。接着，一般这种详情都是会按年、月、日来读，那么后面拼接具体的日期就可以让一个手机号同一年月的数据更加集中。那么具体的rowkey应该是如下形式：</p><blockquote><p>xxx_12345678910_2022-05-05 15:15:15</p></blockquote><p>那么想要查 <strong>手机号为 12345678910 的机主在 2022年5月的通话详情</strong> ，应该怎么设置 startrow 和 endrow ：</p><p>​        首先取rowkey前缀：<code>(12345678910 + 202205) % 299</code> ，这个值应该是 startrow 和 endrow 的共同前缀，接着因为手机号和年月相同，所以应该拼接手机号和年月，最后，endrow 的结尾应该会比 startrow多一位 <code>|</code> 来表示结束。具体如下：</p><blockquote><p>xxx &#x3D; (12345678910 + 202205) % 299</p><p>startrow &#x3D; xxx_12345678910_202205</p><p>endrow &#x3D; xxx_12345678910_202205|</p><p> 或者</p><p>endrow &#x3D; xxx_12345678910_202206</p></blockquote><p>因为是按位比较，那么 startrow 的值肯定是最小的，endrow 因为有 <code>|</code> 仅小于 <code>&#125;</code> 和 <code>~</code> 的值，所以可以说是 <code>xxx_12345678910_202205</code> 前缀中最大的值了，另一个 <code>6</code> 结尾的 endrow 是因为 5 的字典序肯定比6小，所以这样设计也是5月份中最大的值。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hbase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 面试题 01.01. 判定字符是否唯一</title>
      <link href="/2022/03/03/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%98-01-01-%E5%88%A4%E5%AE%9A%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80/"/>
      <url>/2022/03/03/LeetCode-%E9%9D%A2%E8%AF%95%E9%A2%98-01-01-%E5%88%A4%E5%AE%9A%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>实现一个算法，确定一个字符串 s 的所有字符是否全都不同。</p><p>示例 1：</p><blockquote><p>输入: s &#x3D; “leetcode”<br>输出: false </p></blockquote><p>示例 2：</p><blockquote><p>输入: s &#x3D; “abc”<br>输出: true</p></blockquote><p>限制：</p><blockquote><p>0 &lt;&#x3D; len(s) &lt;&#x3D; 100<br>如果你不使用额外的数据结构，会很加分。</p></blockquote></blockquote><span id="more"></span><p><a href="https://leetcode-cn.com/problems/is-unique-lcci/">https://leetcode-cn.com/problems/is-unique-lcci/</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>这个思路应该是第一反应。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String astr)</span> </span>&#123;</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; astr.length(); ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( !set.add(astr.charAt(i)) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是题目中说明不能使用额外的数据结构，所以这种方法从题意上是错的。</p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>第二个思路就是将字符转换为数字，然后计算数字出现的个数，又考虑到不使用其他的数据结构，联想到位运算。</p><ol><li>使用一个 <code>mark = 0</code> 数字的二进制作为数组；</li><li>计算 <code>bit = astr[i] - &#39;a&#39;</code> ，为了让 <code>mark</code> 在相应的二进制位能够置1，取 <code>1 &lt;&lt; bit</code> 得到相应位置的1，再 <code>mark |= (1 &lt;&lt; bit)</code> 在相应位置置1，只要 <code>mark</code> 在该位置为0，就说明没有重复。</li></ol><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isUnique</span><span class="params">(String astr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mark = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; astr.length(); ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = (<span class="number">1</span> &lt;&lt; (astr.charAt(i) - <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">            <span class="keyword">if</span>( (mark &amp; tmp) != <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mark |= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>(mark &amp; tmp) != 0</code> 在进行该判断的时候，不能判断 <code>(mark &amp; tmp) == 1</code> ，因为1的位置不一定在最末位。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 10. 正则表达式匹配</title>
      <link href="/2022/03/03/LeetCode-10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
      <url>/2022/03/03/LeetCode-10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/regular-expression-matching/">https://leetcode-cn.com/problems/regular-expression-matching/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>动态规划的典型思路：判断s的前缀子串和p的前缀子串究竟符不符合。</p><p>这里有一个小点：<strong>s串如果是空串，这个p串应该也需要判断是否能够成立，因此 i &#x3D; 0 的情况也需要遍历。</strong></p><p>具体思路如下：</p><p>首先肯定的是，分析的重点肯定是在p串上的。对于p上的字符，只有两种：有 <code>*</code> 和 没有 <code>*</code> 。</p><ol><li>没有 <code>* </code> 的情况：</li></ol><p>   <code>(p.charAt(j - 1) == &#39;.&#39;) || (s.charAt(i - 1) == p.charAt(j - 1))</code> 的时候才会存在 <code>dp[i][j] = dp[i - 1][j - 1]</code> ，但是不能保证 <code>false</code> 就可以结束循环，因为还有 <code>i = 0</code> 的情况是需要忽略的。</p><ol start="2"><li><p>有 <code>*</code> 的情况：</p><p>其实也是只有两种情况：0次和无数次的差别。</p><p>（1）默认使用0次，也就是先假设前面的字符不相等的情况；</p><p>（2）然后判断 <code>p[j - 2] == s[i - 1]</code> 是否成立，如果成立，就要考虑用1次还是1次以上的问题；</p><p>（3）但是这种思路容易想复杂，所以可以换个方式去想，不考虑次数问题，就到当前下标的p的前缀子串，和除了当前下标后的s的前缀子串相比，是否相同。也就是如果当前元素是 <code>s[i - 1]</code> 和 <code>p[j - 1]</code> ，如果 <code>s[0 ... i - 2] == p[0 ... j - 1]</code> 是相等的，那就说明此时一定是需要 <code>*</code> 来多贴一个字符的，即在当 <code>p[j - 2] == s[i - 1]</code> 时，<code>dp[i][j] = dp[i][j - 2] || dp[i - 1][j]</code> 。</p><p>综上，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slen = s.length(), plen = p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[slen + <span class="number">1</span>][plen + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= slen; ++i ) <span class="comment">// i = 0 的情况是为了保证空串是否能被匹配</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= plen; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>]; <span class="comment">// 默认前面的字符不使用的情况</span></span><br><span class="line">                    <span class="keyword">if</span>( match(s, p, i, j - <span class="number">1</span>) )</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = dp[i][j] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>( match(s, p, i, j) )</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[slen][plen];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(String s, String p, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 不直接用 char a,b 是因为 i = 0 的可能</span></span><br><span class="line">        <span class="keyword">if</span>( i == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>) || (s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 这脑回路我是想不到 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper面试题</title>
      <link href="/2022/03/01/zookeeper%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/03/01/zookeeper%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="Zookeeper-是做什么的（工作机制）"><a href="#Zookeeper-是做什么的（工作机制）" class="headerlink" title="Zookeeper 是做什么的（工作机制）"></a>Zookeeper 是做什么的（工作机制）</h3><p>​        Zookeeper用于为分布式框架提供协调服务。从设计模式的角度看，Zookeeper是一个基于观察者模式设计的分布式服务管理框架，负责存储和管理一些重要的数据，并接受观察者的注册，这样当数据的状态发生变化，Zookeeper就会通知这些观察者数据的状态变化。</p><p>​        Zookeeper的特点有：</p><ol><li>Zookeeper中存在多个服务器，这些服务器包含了一个Leader节点和多个Follower节点，Leader负责读写， Follower负责读，如果Follower接收到写请求，会提交给Leader。</li><li>集群中只要有半数以上的节点存活，Zookeeper就可以正常服务，所以适合安装奇数台服务器。</li><li>每个服务器中都保存了相同的数据副本，可以保证客户端无论连接哪台服务器，数据都是一致的。</li><li>对于客户端的更新请求，会按照发送的顺序依次执行。</li><li>数据的更新具有原子性，要么成功，要么失败。</li><li>具有实时性，在一定的时间范围内，客户端能读到最新的数据。说是一定时间范围，是因为服务器中的同步操作肯定会有一定的延迟，但是由于Zookeeper中存储的数据量小，只能存储1M的数据，所以同步的时间不会很长。</li></ol><span id="more"></span><h3 id="数据结构（底层存储原理）"><a href="#数据结构（底层存储原理）" class="headerlink" title="数据结构（底层存储原理）"></a>数据结构（底层存储原理）</h3><p>​        Zookeeper的底层结构和Linux文件系统很像，整体可以看成一棵树，每个节点被称作一个znode，默认存储容量是1M，所以不适合存储海量的数据，只能存储一些简单的配置。每个znode都可以通过它的路径被唯一标识。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>​        Zookeeper能提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器动态上下线、分布式锁和软负载均衡等。</p><h4 id="统一命名服务"><a href="#统一命名服务" class="headerlink" title="统一命名服务"></a>统一命名服务</h4><p>​        在分布式系统中，经常需要对应用或服务进行统一命名，以便于识别。它有两个应用方向：</p><ol><li>利用zookeeper的树形分层结构，存储系统中各种服务的名称、地址和目录信息，需要的时候再到zookeeper中读取。</li><li>利用zookeeper的顺序节点的特性，做分布式系统中全局唯一的序号生成器，比如往数据库插入数据，在单机器下，使用自增主键生成是没有问题的，但是如果是多台机器就无法保证这个自增主键的全局唯一性，可以使用zookeeper的顺序节点生成唯一的序号。</li></ol><h4 id="统一配置管理"><a href="#统一配置管理" class="headerlink" title="统一配置管理"></a>统一配置管理</h4><p>​        一般要求一个集群中，所有的节点的配置信息必须是一致的，比如kafka集群。当某个节点上的配置信息发生更改，就希望能够快速的同步到其他的所有的节点上。Zookeeper会在一个znode上存储这个配置信息，然后kafka集群中的所有节点监听这个znode，当这个znode上的配置文件发生更改的时候，监听的节点就能马上接收到修改的信息，立刻同步。</p><h4 id="统一集群管理"><a href="#统一集群管理" class="headerlink" title="统一集群管理"></a>统一集群管理</h4><p>​        在分布式系统中需要实时掌握每个节点的状态，可以将这些节点的信息写入一个znode中，然后集群可以通过注册和监听这个znode获取实时的状态变化。</p><h4 id="服务器动态上下线"><a href="#服务器动态上下线" class="headerlink" title="服务器动态上下线"></a>服务器动态上下线</h4><p>​        为了让客户端能够实时监控服务器上下线的变化，服务器启动后会在Zookeeper上创建一个临时节点，并写入参数，如主机名称和目前已经连接的客户端个数，假设这些服务器都在servers节点下创建子节点存储信息。然后客户端可以监听这个servers节点，当这个节点下某个服务器断开连接，这个临时节点会被自动删除，这个节点的状态发生变化，就会发送给这个客户端这个服务器下线的通知，之后客户端要再次连接服务器就只知道哪些服务器可以连接了。</p><h4 id="软负载均衡"><a href="#软负载均衡" class="headerlink" title="软负载均衡"></a>软负载均衡</h4><p>​        比如登录服务，在Zookeeper中记录这个登陆域名下每台服务器的访问数，然后让访问数最少的服务器去处理最新的客户端请求。</p><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>​        首先简单说明一下分布式锁的概念，假设有多个线程要对一个资源进行操作，为了保证数据的一致性，需要对这个资源上锁。只要取到这个锁的线程才能对资源进行访问，这个线程用完该资源后会释放锁，让其他线程来争取。通过锁机制可以保证在分布式情况下多线程能够有序的访问该资源。我们把分布式环境下的这个锁称为分布式锁。</p><p>​        在Zookeeper中实现的思路是：接收到客户端请求后，会在父节点 &#x2F;locks 下创建一个临时的顺序节点，使用顺序节点的目的是，让请求能够按照这个节点的顺序依次次获取锁执行业务；这些临时节点会判断自己当前是不是最小的节点，如果是就获取锁执行业务；否则就监听前一个节点；一个节点获取锁执行完业务被释放后，会通知监听它的节点，让他它去获取锁执行业务。</p><p>​        Yarn的高可用机制使用分布式锁实现的。</p><h3 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h3><p>​        Zookeeper的选举机制在第一次启动和非第一次启动的情况是不一致的。</p><p>​        首先说明选举机制的三个核心原则：</p><ol><li>Zookeeper集群的服务器数量必须是奇数个，只有超过半数以上的服务器启动，集群才算启动成功；</li><li>服务器中myid小的服务器会给myid大的服务器投票，直到选出Leader；</li><li>选出Leader之后，之前的服务器状态会从Looking转变为Following，之后的服务器状态也都会自动变为Following。</li></ol><h4 id="第一次启动的情况"><a href="#第一次启动的情况" class="headerlink" title="第一次启动的情况"></a>第一次启动的情况</h4><ol><li>假设有3台服务器，第一台服务器启动，会给自己投一票，此时票数为1，不过半，处于Looking状态；</li><li>接着第二台服务器启动，会给自己投一票，由于第二台服务器的myid比第一台的大，第一台服务器将票改投给第二胎，此时票数为2，过半了，第二台服务器的状态修改为Leading，同时第一台服务器状态从Looking转变为Following；</li><li>最后第三台服务器启动，由于前两台的状态已经固定，票数不可更改，第三胎服务器的状态自动转变为Following。</li></ol><h4 id="非第一次启动的情况"><a href="#非第一次启动的情况" class="headerlink" title="非第一次启动的情况"></a>非第一次启动的情况</h4><p>首先需要简单介绍三个概念：</p><ol><li>zxid：每个写操作都有一个事务id，这个事务id被称为zxid，在某一时刻zxid不一定是一致的，因为只要超过半数的服务器执行成功，就算这个写操作成功了；</li><li>sid：是服务器id，用来唯一标识一台服务器，和myid一致；</li><li>epoch：每个leader任期时的代号，每投完一次票这个值会增加。</li></ol><p>​        当一台服务器在运行期间无法和Leader保持连接，会自动认为集群中的Leader已经挂掉了，就会触发选举。进入选举流程时，当前集群可能处于两种状态：</p><ol><li><p>集群中的Leader没有挂掉，只是这个服务器没有连上。</p><p>​        在这个服务器视图去选举Leader的时候，会被告知Leader的信息，然后这个服务器只需要和Leader重新建立连接，并行状态同步即可。</p></li><li><p>Leader确实挂掉了。</p><p>​        还是三台服务器，此时myid&#x3D;2的Leader服务器挂掉了，剩下的服务器，假设SID分别是 1和 3，ZXID分别是 8和7，EPOCH都是 1，会先比较EPOCH值，EPOCH大的直接胜出；如果相等，ZXID大的胜出；如果还相等，SID大的胜出。</p></li></ol><h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><p>有四种：</p><ol><li>持久节点：除非Zookeeper手动删除，否则就算客户端和服务器断开也不会被删掉。</li><li>持久顺序节点：和持久节点的特性一样，只是给节点名称结尾增加了自增序号，这个序号由父节点维护。</li><li>临时节点：当客户端和服务器断开连接，这个客户端创建的节点会被自动删除。</li><li>临时顺序节点：和临时节点具有相同的特性，只是节点名后面会跟一个父节点维护的自增序号。</li></ol><p><strong>带序号和不带序号的区别：创建同名节点时，带序号创建不报错，不带序号创建回报已经存在节点的错。</strong></p><p><strong>序号的作用：可以为所有事件做全局排序，方便客户端梳理事件的顺序。</strong></p><p>持久节点的创建：create &#x2F;abc “abc”</p><p>持久顺序节点的创建：create -s &#x2F;bcd “bcd”</p><p>临时节点的创建：create -e &#x2F;cdf “cdf”</p><h3 id="监听器原理"><a href="#监听器原理" class="headerlink" title="监听器原理"></a>监听器原理</h3><ol><li>首先在客户端创建一个main方法；</li><li>然后在这个main方法中会创建一个zkClient，这个client会创建两个线程，一个用于连接对应的服务端，一个负责监听连接的服务器中数据的变化；</li><li>其中，连接服务端的线程在连上后，会告诉服务端要监听哪些信息，当这些信息发生变化，就会回调给监听的线程，监听线程内部会调用 process 方法进行后续的处理。</li></ol><p>常见的监听内容包括：</p><ol><li>监听节点数据的变化。</li><li>监听子节点增删的变化。</li></ol><p>监听的实现是注册一次监听一次，回调一次更新的变化后，想要再次监听，需要再次注册。</p><h3 id="写数据流程"><a href="#写数据流程" class="headerlink" title="写数据流程"></a>写数据流程</h3><p>请求发送的目标有两种：发给Leader和发给Follower。</p><h4 id="发给Leader"><a href="#发给Leader" class="headerlink" title="发给Leader"></a>发给Leader</h4><p>​        Leader执行写请求，写完后将请求广播给Follower执行，有超过半数的服务器完成了请求的操作并返回给leaderack码，就被认为是执行成功了，Leader返回给客户端成功的ack码。</p><p>​        因为不需要等到全部同步成功才返回结果，所以效率很高。</p><h4 id="发给Follower"><a href="#发给Follower" class="headerlink" title="发给Follower"></a>发给Follower</h4><p>​        Follower接收到写请求，会将请求传给Leader，然后Leader执行完后将请求广播给Follower，超过半数的follower执行完成并发回ack，Leader会将ack码发送给接收客户端请求的Follower，由这个Follower将ack码发回给客户端。</p><h3 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a>数据一致性问题</h3><h4 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h4><p>​        这个军队需要全体将军一致决定是否攻击某个敌军，但是这些将军在地理上是分开的，并且军中存在叛徒，如果这些叛徒从中作梗，促成了一个并不是所有将军都同意的决定，这个行动就会失败。</p><h4 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h4><p>​        Paxos算法是一种基于消息传递机制且具有高度容错特性的一致性算法，这个算法会保证集群中不管出现什么意外，所有节点的数据都是一致的。</p><p>​        这个算法将节点分为三种类型：提议者、接受者和学习者，每个节点都可以身兼数职。提议者是提出决议的人，接收者是参与投票的人，学习者弃权，只负责执行通过的决策。</p><p>​        具体的算法流程通过一个例子简单说明。假设有五个节点 A1、A2、A3、A4、A5，需要A2~A5通过A1提出的税率降低10%的提议。</p><ol><li>A1会生成全局唯一且递增的ID号，并发送给A2~A5，此时发送的信息只包含一个ID号；</li><li>然后A2~A5都会返回给A1同意接受的应答；</li><li>A1收到两份回复时再次发出请求，此时带上了税率降低10%的提议内容和ID号；</li><li>A2~A5返回同意的应答；</li><li>超过半数接受，提议通过。</li></ol><p>这是只有一个提议者的场景，如果有两个提议者，比如A1提议税率降低10%，A5提议降低15%。</p><ol><li>A1和A5同时发决议，ID号分别是1和2；</li><li>此时A2同意了A1，A4同意了A5，A3成为关键；</li></ol><p>接下来出现两种情况：</p><p>第一种：</p><ol><li>如果A3先接收到A1的请求，会答应A1；</li><li>这个时候A1收到半数以上的应答，开始发送实际的请求，A2和A3接受；</li><li>之后A3又接收到A5的第一次请求，因为A5的ID号比A1的大，所以也接受了A5的请求；</li><li>然后A5发出实际请求，A3、A4接受。</li><li>最后A1、A5同时广播决议。</li></ol><p>第二种：</p><ol><li>A3接受了A1的第一次请求后，A1的实际请求还没发出，又接收到A5的第一次请求，因为A5的ID号比A1的大，所以也接受了A5的请求；</li><li>接着A1发送实际的请求，但是没有足够的响应，就会重新发起只带ID号的请求，此时ID自增为3；这个时候A1的ID号比A5的大了，A3又接受来自A1的请求；</li><li>那么A5又会由于接收不到足够的回应而开始下一次的新请求，最终A1和A5就会陷入死循环。</li></ol><p>​        造成这种问题的原因是系统中存在一个以上的提议者互相争夺接受者而无法达成一致的决策。针对这种情况，提出了ZAB协议：也就是从系统中选出一个节点作为Leader，只有Leader才能发起决议。</p><h4 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h4><p>​        ZAB协议是特别为Zookeeper设计的支持崩溃恢复的原子广播协议，基于这种协议，Zookeeper设计为只有一个Leader负责处理写请求，然后由Leader将数据同步到其他的Follower节点。也就是只有Leader能发起决议。</p><p>​        ZAB有两种模式：消息广播和崩溃恢复。</p><p><strong>消息广播的流程：</strong></p><ol><li>客户端向Leader发送一个写数据的请求；</li><li>Leader会将这个请求转换为一个事务提案，并同时为这个提案提供全局ID，也就是zxid；</li><li>Leader会向每个Follower分配一个单独的FIFO队列，然后将需要广播的请求放到队列中；</li><li>Follower会根据这个队列的顺序先将请求以事务日志的方式写入本地磁盘，写成功后向Leader返回ack响应；</li><li>一旦Leader接收到半数以上的应答信息，就认为发送成功，开始广播commit信息，同时自身也完成事务的提交；Follower接收到commit信息后，也开始提交事务。</li></ol><p>这个过程可能会出现两个一致性问题：</p><ol><li>Leader发送提案后就宕机了，导致Follower接收不到；</li><li>Leader接收到半数应答后宕机了，来不及发送commit。</li></ol><p>这就引入了崩溃恢复模式。</p><p>这个模式要求满足两个条件：对于Leader已经发出的提案，Follower必须执行；必须丢弃Leader还没有发出的提案。</p><p>这个模式主要包括两个部分：Leader选举和数据恢复。</p><p>对于Leader选举，ZAB协议需要保证新选的Leader满足两个条件：</p><ol><li>新Leader不能包含未提交的事务；</li><li>新Leader必须含有最新的zxid。</li></ol><p>这样是为了保证新Leader不会丢弃掉一些工作。</p><p>数据同步的步骤是：</p><ol><li>选出新Leader后，需要先将之前未完成的事务完成；</li><li>等到Follower将所有事务提交完毕，新Leader才会认为这个Follower是合法可用的，否则不会把这个Follower放到可用列表中继续使用。</li></ol><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>即一致性、可用性和分区容错性。</p><ol><li>一致性：保证所有节点在同一时间数据是一致的；</li><li>可用性：保证每个请求不管成功还是失败，在一定时间内都能返回响应；</li><li>分区容错性：保证系统中任意信息的丢失或失败都不会影响系统的正常运行。</li></ol><p>三个条件最多只能同时满足两个，因为分布式系统必须要满足分区容错性，所以一般都是在一致性和可用性上做选择。</p><p>Zookeeper保证的是一致性和分区容错。这就在一些极端情况下，可能会丢弃一些请求，客户端需要重新提交才能获得结果。并且在leader选举的时候，集群不可用，因为此时follower中的数据不一定是最新的。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 560. 和为 K 的子数组</title>
      <link href="/2022/02/23/LeetCode-560-%E5%92%8C%E4%B8%BA-K-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2022/02/23/LeetCode-560-%E5%92%8C%E4%B8%BA-K-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">https://leetcode-cn.com/problems/subarray-sum-equals-k/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="枚举（暴力）"><a href="#枚举（暴力）" class="headerlink" title="枚举（暴力）"></a>枚举（暴力）</h3><p>遍历每个元素，以当前元素为最后一个必取的元素，往前计算，如果结果与 <code>k</code> 相等则 <code>count++</code> 。</p><p>具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; --j )</span><br><span class="line">            &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>( sum == k )</span><br><span class="line">                &#123;</span><br><span class="line">                    ++res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前缀和-哈希表"><a href="#前缀和-哈希表" class="headerlink" title="前缀和 - 哈希表"></a>前缀和 - 哈希表</h3><p>使用前缀和的思想，可以得到如下式子：<br>$$<br>preSum[i] - preSum[j] &#x3D;&#x3D; k \<br>&#x3D;&gt;\<br>preSum[i] - k &#x3D;&#x3D; preSum[j]\<br>$$<br>式子中，preSum存储 <code>从 0 到 i </code> 的累加，<code>i &lt;= j</code> 。</p><p>那么我们可以在哈希表中存储 <code>preSum[j]</code> 的值和出现的次数，这样能够保证一个前缀值出现多次的情况下能够一次获取所有的个数。需要默认，表中存在 <code>(0, 1)</code> ，因为其他的 <code>preSum[i] - k</code> 需要对应的 <code>preSum[j]</code> ，但是 <code>preSum[i] - k == 0</code> 的情况是肯定不用的。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> num : nums )</span><br><span class="line">        &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            <span class="keyword">if</span>( map.containsKey(sum - k) )</span><br><span class="line">            &#123;</span><br><span class="line">                count += map.get(sum - k);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 581. 最短无序连续子数组</title>
      <link href="/2022/02/22/LeetCode-581-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2022/02/22/LeetCode-581-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/">https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据题目，可以将数组分为三段：<code>numsA, numsB, numsC</code> ，其中 <code>numsA、numsC</code> 均为升序数组，计算最短子数组，即计算最短的 <code>numsB</code> 。</p><h3 id="数组克隆"><a href="#数组克隆" class="headerlink" title="数组克隆"></a>数组克隆</h3><p>将原始数组克隆一份到新数组，对新数组排序，然后找出两个数组的最长前缀 <code>numsA</code> 和最长后缀 <code>numsC</code> ，数组的总个数减去头尾就是中间 <code>numsB</code> 的个数。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] sort_nums = nums.clone();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(sort_nums);</span><br><span class="line">        <span class="keyword">while</span>( i &lt; nums.length &amp;&amp; nums[i] == sort_nums[i] )</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( j &gt;= i &amp;&amp; nums[j] == sort_nums[j] )</span><br><span class="line">        &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j - i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h3><p>以 <code>numsA</code> 数组来看，其中的元素 <code>i</code> 应该都满足：<br>$$<br>nums[i] &lt;&#x3D; min(nums[j]), nums[j]∈numsB + numsC<br>$$<br>​        那么此时应该要获取 <code>numsA</code> 数组中最大的元素所在的下标为 <code>left</code>；可以很容易的发现，在 <code>numsA</code> 中的元素都是升序排列的，也就是如果存在一个元素i，使得当前最小的元素j比这个元素大（i &lt; j），那么当前元素肯定存在 <code>numsB + numsC</code> 数组中，此时需要置 <code>left = i</code>。</p><p>​        相似的，可以得到 <code>numsC</code> 中的最小值。 </p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> max = nums[len - <span class="number">1</span>], left = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> min = nums[<span class="number">0</span>], right = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( max &gt;= nums[len - i - <span class="number">1</span>] )</span><br><span class="line">            &#123;</span><br><span class="line">                max = nums[len - i - <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = len - i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( min &lt;= nums[i] )</span><br><span class="line">            &#123;</span><br><span class="line">                min = nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left + right &lt; <span class="number">0</span> ? <span class="number">0</span> : right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一次遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 621. 任务调度器</title>
      <link href="/2022/02/22/LeetCode-621-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
      <url>/2022/02/22/LeetCode-621-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/task-scheduler/">https://leetcode-cn.com/problems/task-scheduler/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>已知 <code>tasks</code> 元素的范围是26个大写字母，可以给定26个桶计算元素的个数。</li><li>然后按照个数倒序排列，因为仅需要得到时间，所以可以使用一维数组计算，但是此处使用 <code>Comparator</code> 进行倒序排序，不能传入基本数据类型，所以多了一列空列来占位。</li><li>排序后使用两个指针 <code>i</code> 和 <code>j</code> 指向实际的范围。</li><li>在实际遍历之前，需要知道，一个周期的长度是 <code>n + 1</code> ，也就是 <code>res % (n + 1) == 0</code> 才是一个周期。</li><li>先从个数最多的元素 <code>i</code> 开始遍历，当遍历到 <code>count[i][1] == 1</code> 的时候，为了确保个数是从 <code>j</code> 到 <code>i</code> 逐步为0的，这个时候切换到 <code>count[j]</code> 开始计算，当 <code>count[j] == 0</code>，<code>--j</code> 。</li><li>此处有一个是否待命的判断：当 <code>i &gt;= j</code> 也就是里面不为0的元素都遍历了一遍，一个周期还没有结束，这个时候 <code>i</code> 和 <code>j</code> 都不动，仅 <code>++res</code> 直到这个周期结束。</li><li>执行下一个周期，则 <code>i = 0</code>。</li></ol><p>具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">char</span> c : tasks )</span><br><span class="line">        &#123;</span><br><span class="line">            ++count[c - <span class="string">&#x27;A&#x27;</span>][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(count, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2[<span class="number">1</span>] - o1[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">while</span>( j &lt; <span class="number">26</span> &amp;&amp; count[j][<span class="number">1</span>] != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        j -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( i &lt; <span class="number">26</span> &amp;&amp; j &gt;= <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( count[i][<span class="number">1</span>] &gt; <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                ++res;</span><br><span class="line">                --count[i++][<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( i &lt;= j &amp;&amp; count[j][<span class="number">1</span>] != <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                ++res;</span><br><span class="line">                --count[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>( count[j][<span class="number">1</span>] == <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    --j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( res % (n + <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 347. 前K个高频元素</title>
      <link href="/2022/02/19/LeetCode-347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/"/>
      <url>/2022/02/19/LeetCode-347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">https://leetcode-cn.com/problems/top-k-frequent-elements/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>​        涉及到计算元素个数，并且元素值没有固定范围，使用 <code>HashMap</code> 存储。已知时间复杂度为 <code>O(nlogn)</code> 的算法有归并排序和堆排序，相比于堆排序这种必须全部排序的算法，堆排序这种可以仅排序指定大小为 <code>k</code> 的算法更适合在此处，时间复杂度会从 <code>O(nlogn)</code> 优化为 <code>O(nlogk)</code> 。</p><p>​        具体的操作就是构建小顶堆，已知 <code>PriorityQueue</code> 的底层就是堆排序，所有可以直接使用它。先初始化堆，当 <code>size() == k</code> 时判断队首元素的个数是否小于当前元素的个数，如果小于，就说明此时队首元素不再属于k个元素，将其删掉，插入当前元素。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// HashMap存储个数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> num : nums )</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// PriorityQueue建小顶堆</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">1</span>] - o2[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>( Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( queue.size() == k )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( queue.peek()[<span class="number">1</span>] &lt; entry.getValue() )</span><br><span class="line">                &#123;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存储前k个元素</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            res[i] = queue.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>购物车结算系统-Redis篇-项目小记</title>
      <link href="/2022/02/18/%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%BB%93%E7%AE%97%E7%B3%BB%E7%BB%9F-Redis%E7%AF%87-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/"/>
      <url>/2022/02/18/%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%BB%93%E7%AE%97%E7%B3%BB%E7%BB%9F-Redis%E7%AF%87-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><blockquote><p>ClassNotFoundException: redis.clients.jedis.JedisPoolConfig</p></blockquote><p>就是没有找到类的意思。有两种可能：</p><ol><li><p>没有导包：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.9</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>没有put到tomcat中：</p><p>步骤：Project Structure -&gt; Artifacts -&gt; 在Available Elements中找到对应的包 -[右键] -&gt; Put into &#x2F;WEB-INF&#x2F;lib</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 283. 移动零</title>
      <link href="/2022/02/15/LeetCode-283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
      <url>/2022/02/15/LeetCode-283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/move-zeroes/">https://leetcode-cn.com/problems/move-zeroes/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用两个指针，都从头出发，<code>right</code> 指向第一个非零元素的时候换。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( right &lt; len )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[right] != <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums, left, right);</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 239. 滑动窗口最大值</title>
      <link href="/2022/02/15/LeetCode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
      <url>/2022/02/15/LeetCode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">https://leetcode-cn.com/problems/sliding-window-maximum/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>优先队列其实就是堆，这里维护的是大顶堆，而堆的底层实现的是 <code>PriorityQueue</code> 。</p><p>由此，可以实现一个 <code>PriorityQueue</code>，因为其中涉及比较的内容包括下标和值，所以需要存两个元素，或者将其列为一个数组 <code>new int[]&#123;nums[i], i&#125;</code>，所以需要自定义一个 <code>Comparator</code> 排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> p1[], <span class="keyword">int</span> p2[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1[<span class="number">0</span>] != p2[<span class="number">0</span>] ? p2[<span class="number">0</span>] - p1[<span class="number">0</span>] : p2[<span class="number">1</span>] - p1[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>之后每遍历到一个元素就存进去，取出来的时候要取出下标在 <code>k</code> 区间内的最大值，也就是说如果当前最大值，也就是 <code>queue.peek()[1] &lt;= i - k</code> 时，可以永久删除了。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> p1[], <span class="keyword">int</span> p2[])</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> p1[<span class="number">0</span>] != p2[<span class="number">0</span>] ? p2[<span class="number">0</span>] - p1[<span class="number">0</span>] : p2[<span class="number">1</span>] - p1[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>( ; i &lt; k; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        res[r++] = queue.peek()[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>( ; i &lt; nums.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[i], i&#125;);</span><br><span class="line">            <span class="keyword">while</span>( queue.peek()[<span class="number">1</span>] &lt;= i - k )</span><br><span class="line">            &#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            res[r++] = queue.peek()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>对第一个解法优化：单调队列一般指的是满足单调性递增或递减的双端队列。仅存储元素的下标，需要保证其中包含的下标对应的元素值是单调递减的，也就是遇上 <code>nums[deque.peek()] &lt;= nums[i]</code> 则会弹出。</p><ol><li><code>deque.size() &lt;= k</code> 是为了维护 <code>k</code> 区间，可以保证单调队列中的所有元素都不超出范围。</li><li>当 <code>deque.size() &gt;= k</code> 需要弹出头元素，因为后续需要加入一个元素，所以其实应该是在 <code>deque.size() == k</code> 的时候弹出头元素，保证一次遍历结束时 <code>deque.size() + 1 == k</code> 。</li><li>因为是单调递减的，所以从尾部插入的时候，需要保证插入的是最小值，否则就弹出之前的值，这里能够确定不会误删之后的最大值。</li></ol><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len - k + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>( ; i &lt; k; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( !deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt;= nums[i] )</span><br><span class="line">            &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 赋值</span></span><br><span class="line">        res[r++] = nums[deque.peekFirst()];</span><br><span class="line">        <span class="keyword">for</span>( ; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从头删除不满足k区间的节点</span></span><br><span class="line">            <span class="keyword">while</span>( !deque.isEmpty() &amp;&amp; deque.peekFirst() &lt;= i - k )</span><br><span class="line">            &#123;</span><br><span class="line">                deque.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从尾增加当前节点，保证是递减的</span></span><br><span class="line">            <span class="keyword">while</span>( !deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt;= nums[i] )</span><br><span class="line">            &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">            res[r++] = nums[deque.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PriorityQueue </tag>
            
            <tag> Deque </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 279. 完全平方数</title>
      <link href="/2022/02/14/LeetCode-279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
      <url>/2022/02/14/LeetCode-279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/perfect-squares/">https://leetcode-cn.com/problems/perfect-squares/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用动态规划遍历到当前 i 之内（包括当前 i ）的所有可能的内容。使用嵌套循环，因为从 1 到 n 的每一个元素都会被重复使用，所以无法省略数组为单一的值。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= i; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                min = Math.min(min, dp[i - j * j]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = min + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>dp[i] = min + 1</code> 中的 <code>+1</code> 的操作是因为 <code>j * j</code> 为一个完全平方的整数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux - 学习笔记</title>
      <link href="/2022/02/13/Linux-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/02/13/Linux-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="ps-ef-和-ps-aux"><a href="#ps-ef-和-ps-aux" class="headerlink" title="ps -ef 和 ps aux"></a>ps -ef 和 ps aux</h3><p>都用来显示全部进程，<code>-ef</code> 显示标准格式，<code>aux</code> 显示BSD格式。</p><span id="more"></span><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>查找输入的内容中符合指定内容的字符串。</p><p><strong>grep [指定内容] [输入内容，一般此处放文件]</strong></p><h4 id="ps-ef-grep-指定内容"><a href="#ps-ef-grep-指定内容" class="headerlink" title="ps -ef | grep [指定内容]"></a>ps -ef | grep [指定内容]</h4><p>显示所有进程中与指定内容相同的进程。</p><h4 id="grep-v"><a href="#grep-v" class="headerlink" title="grep -v"></a>grep -v</h4><p><code>grep -v grep</code>：取出不包含grep的进程行。</p><p><code>grep -v &quot;name&quot;</code>：取出不包含字符串 name 的行。</p><h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h3><p>计算字数。</p><h4 id="wc-l"><a href="#wc-l" class="headerlink" title="wc -l"></a>wc -l</h4><p>显示行数</p><h4 id="wc-L"><a href="#wc-L" class="headerlink" title="wc -L"></a>wc -L</h4><p>显示当前行的长度。</p><h3 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h3><p>不挂断的执行命令。</p><h4 id="nohup-amp"><a href="#nohup-amp" class="headerlink" title="nohup &amp;"></a>nohup &amp;</h4><p>在后台执行。会返回一个进程号用于查该进程。</p><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>查看网络相关的信息。</p><h4 id="netstat-ap-grep-端口号"><a href="#netstat-ap-grep-端口号" class="headerlink" title="netstat -ap | grep [端口号]"></a>netstat -ap | grep [端口号]</h4><p>查看指定端口有哪些进程。</p><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>删除执行中的程序或工作。</p><h4 id="kill-9"><a href="#kill-9" class="headerlink" title="kill -9"></a>kill -9</h4><p>强制杀死进程。</p><h3 id="统计文件行数"><a href="#统计文件行数" class="headerlink" title="统计文件行数"></a>统计文件行数</h3><p>两种方式：</p><p><strong>1. wc -l test.txt | awk ‘{print $1}’</strong></p><p><code>wc -l test.txt</code> 显示行数和 ‘test.txt’ 两列。</p><p><code>awk &#39;&#123;print $1&#125;&#39;</code> 显示管道前输出的第一列。</p><p><strong>2. awk ‘{print NR}’ test.txt | tail -n1</strong></p><p><code>awk &#39;&#123;print NR&#125;&#39; test.txt</code> 显示 <code>test.txt</code> 文件的行号，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>tail -n 1</code> 最后一行。</p><p><strong>3. awk ‘END{print NR}’ test.txt</strong></p><p><code>END</code> 必须大写。</p><p><strong>4. grep -c “” test.txt</strong></p><p><code>grep -c</code> 输出文件 <code>test.txt</code> 中匹配字符串 <code>&quot;&quot;</code> 的行。</p><p><strong>5. grep -n “” test.txt | awk -F “:” ‘{print $1}’</strong></p><p><code>grep -n &quot;&quot; test.txt</code> 输出文件 <code>test.txt</code> 中匹配字符串 <code>&quot;&quot;</code> 的行号及行，格式为：<code>行号:行内容</code> ；</p><p><code>awk -F &quot;:&quot; &#39;&#123;print $1&#125;&#39;</code> 将输入依照 <code>:</code> 分隔符切分，并输出第一列。</p><h2 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h2><p>如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!bin/bash</span></span><br><span class="line">num=0</span><br><span class="line"><span class="keyword">while</span> (( num &lt;= 500 ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> (( num % 7 == 0 ))</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$num</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">    ((num++))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> &#123;0..500..7&#125;; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$num</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>其中 <code>&#123;0..500..7&#125;</code> 的含义是输出 0 - 500 中 7 的倍数。</p><h2 id="头n行和后n行"><a href="#头n行和后n行" class="headerlink" title="头n行和后n行"></a>头n行和后n行</h2><p>头n行：<code>head -n n</code></p><p>后n行：<code>tail -n n</code></p><h3 id="实现打印第五行"><a href="#实现打印第五行" class="headerlink" title="实现打印第五行"></a>实现打印第五行</h3><p><strong>1. head -n 5 test.txt | tail -n 1</strong></p><p><strong>2. sed -n 5p</strong></p><h2 id="SHELL5打印空行的行号"><a href="#SHELL5打印空行的行号" class="headerlink" title="SHELL5打印空行的行号"></a>SHELL5打印空行的行号</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;if(NF == 0) print NR&#125;&#x27;</span> nowcoder.txt</span><br></pre></td></tr></table></figure><h3 id="awk内建变量"><a href="#awk内建变量" class="headerlink" title="awk内建变量"></a>awk内建变量</h3><p><code>NF</code> 和 <code>NR</code> 是内建变量，<code>NF</code> 计算一行内单词的总数，默认以空格为分隔符计算，<code>NR</code> 显示当前行数。</p><p><code>RS</code> 指定行分隔符，使用 <code>awk &#39;BEGIN&#123;RS=&quot;|&quot;&#125;&#123;print $0&#125;&#39;</code> ，将一行按照分隔符 <code>|</code> 分割为多列并显示。</p><h3 id="awk流程控制语句"><a href="#awk流程控制语句" class="headerlink" title="awk流程控制语句"></a>awk流程控制语句</h3><p>if语句：以奇偶数为例。</p><p>判断偶数：<code>awk &#39;BEGIN &#123;num = 10; if (num % 2 == 0) printf &quot;%d 是偶数\n&quot;, num&#125;&#39;</code></p><p>判断奇偶数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN &#123;</span></span><br><span class="line"><span class="string">num = 11;</span></span><br><span class="line"><span class="string">if (num % 2 == 0) printf &quot;%d 是偶数\n&quot;, num;</span></span><br><span class="line"><span class="string">else printf &quot;%d 是奇数\n&quot;, num</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>for语句：以打印字母数小于8的单词为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># nowcoder.txt</span><br><span class="line">how they are implemented and applied in computer </span><br></pre></td></tr></table></figure><p>解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;for(i=0;i&lt;NF;++i) if(length($i) &lt; 8) print $i&#125;&#x27;</span> nowcoder.txt</span><br></pre></td></tr></table></figure><h3 id="去掉空行"><a href="#去掉空行" class="headerlink" title="去掉空行"></a>去掉空行</h3><p>已知 <code>$0</code> 表示输出整行，可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;if(NF != 0) print $0&#125;&#x27;</span> nowcoder.txt</span><br></pre></td></tr></table></figure><p>也可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat nowcoder.txt | awk NF</span><br></pre></td></tr></table></figure><h2 id="计算文件中所有行的第六列"><a href="#计算文件中所有行的第六列" class="headerlink" title="计算文件中所有行的第六列"></a>计算文件中所有行的第六列</h2><p><a href="https://www.nowcoder.com/practice/fb24140bac154e5b99e44e0cee45dcaf?tpId=195&tqId=36218&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=/exam/oj?tab=SHELL%25E7%25AF%2587&topicId=195&difficulty=undefined&judgeStatus=undefined&tags=&title="><strong>SHELL8</strong> <strong>统计所有进程占用内存大小的和</strong></a></p><p>整行获取：</p><ol><li>read p &lt; file</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> p</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">done</span> &lt; nowcode.txt</span><br></pre></td></tr></table></figure><ol start="2"><li>awk ‘{print $0}’</li></ol><p>累加第六列：</p><ol><li>awk的三种方式：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line">sum=0</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `awk <span class="string">&#x27;&#123;print $6&#125;&#x27;</span> nowcode.txt`</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    ((sum+=<span class="variable">$i</span>))</span><br><span class="line">    <span class="keyword">done</span>    </span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">awk <span class="string">&#x27;&#123;sum+=$6&#125;END&#123;print sum&#125;&#x27;</span> nowcode.txt</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;sum=0&#125;&#123;sum+=$6&#125;END&#123;print sum&#125;&#x27;</span> nowcode.txt</span><br></pre></td></tr></table></figure><ol start="2"><li>read p的两种方式，第二种性能最好：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line">sum=0</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> p</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">((sum+=$(<span class="built_in">echo</span> <span class="variable">$p</span>|awk <span class="string">&#x27;print $6&#x27;</span>)))</span><br><span class="line"><span class="keyword">done</span> &lt; nowcode.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$sum</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">sum=0</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> p:</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">arr=(<span class="variable">$p</span>)</span><br><span class="line">((sum+=arr[5]))</span><br><span class="line"><span class="keyword">done</span> &lt; nowcode.txt</span><br><span class="line"><span class="built_in">echo</span></span><br></pre></td></tr></table></figure><p>没有使用 <code>awk</code> ，而是使用定义数组接收，性能最好。</p><h2 id="SHELL9-统计每个单词出现的个数"><a href="#SHELL9-统计每个单词出现的个数" class="headerlink" title="SHELL9 统计每个单词出现的个数"></a><strong>SHELL9</strong> <strong>统计每个单词出现的个数</strong></h2><p>已知 <code>NF</code> 指的是一行中单词的总数，<code>$i</code> 指的是对应的字段。</p><p>如果使用 <code>for(i in list) print i, list[i]</code> 表示遍历数组 <code>list</code> ，取出对应的下标 <code>i</code> 和 下标中的值。这里的下标 <code>i</code> 往往指的是实际的字段。</p><p>具体代码是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;for(i=1;i&lt;=NF;i++) list[$i]+=1&#125;END&#123;for(i in list) print i, list[i]&#125;&#x27;</span> nowcoder.txt</span><br></pre></td></tr></table></figure><h2 id="SHELL11-转置文件的内容（for语句和内建变量的详细理解）"><a href="#SHELL11-转置文件的内容（for语句和内建变量的详细理解）" class="headerlink" title="SHELL11 转置文件的内容（for语句和内建变量的详细理解）"></a><strong>SHELL11</strong> <strong>转置文件的内容</strong>（for语句和内建变量的详细理解）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">for(i=1;i&lt;=NF;i++)&#123;</span></span><br><span class="line"><span class="string">    if(NR==1)&#123;</span></span><br><span class="line"><span class="string">        row[i]=$i</span></span><br><span class="line"><span class="string">    &#125;else</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        row[i]=row[i]&quot; &quot;$i</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;END&#123;</span></span><br><span class="line"><span class="string">    for(i=1;i&lt;=NF;i++)&#123;</span></span><br><span class="line"><span class="string">        print row[i]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> nowcoder.txt</span><br></pre></td></tr></table></figure><p>已知文件内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注释：nowcoder.txt</span></span><br><span class="line">job salary</span><br><span class="line">c++ 13</span><br><span class="line">java 14</span><br><span class="line">php 12</span><br></pre></td></tr></table></figure><p>先看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print NF&#125;&#x27;</span> nowcode.txt</span><br></pre></td></tr></table></figure><p>得到结果：</p><blockquote><p>2<br>2<br>2<br>2</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span> nowcode.txt</span><br></pre></td></tr></table></figure><blockquote><p>salary<br>13<br>14<br>12</p></blockquote><p><strong>得到结论：内建变量NF本身用于计算一行的单词个数，使用 $ 符号后与 $2 得到的结果一致，都用于取文件中第二列的内容，所以 $ 符号可以用于取某一列的数据。</strong></p><p>可以推出如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;for(i=1;i&lt;=NF;++i) print i,$i&#125;&#x27;</span> nowcode.txt</span><br></pre></td></tr></table></figure><p>得到结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1 job</span><br><span class="line">2 salary</span><br><span class="line">1 c++</span><br><span class="line">2 13</span><br><span class="line">1 java</span><br><span class="line">2 14</span><br><span class="line">1 php</span><br><span class="line">2 12</span><br></pre></td></tr></table></figure><p>其中 <code>for(i=1;i&lt;=NF;++i)</code> 用于遍历每一行单词的个数，然后 <code>print i,$i</code> 用于取出每一行的列号及该列对应的单词。</p><p>看第一个 <code>&#123;&#125;</code> 内的具体内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=1;i&lt;=NF;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(NR==1)&#123;</span><br><span class="line">        row[i]=<span class="variable">$i</span></span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        row[i]=row[i]<span class="string">&quot; &quot;</span><span class="variable">$i</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外层的 <code>for循环</code> 用于遍历每一行的单词数目，也就是 <code>i∈[1, NF]</code> ，如果该行是第一行 <code>NR==1</code> ，第一行的该列转置为第一列的改行。也就是将</p><blockquote><p>job salary</p></blockquote><p>转置为</p><blockquote><p>job</p><p>salary</p></blockquote><p>使用一维数组 <code>row</code> 来保存，<code>row[1]</code> 表示第一行，<code>row[2]</code> 表示第二行。</p><p>然后使用 <code>row[i]=row[i]&quot; &quot;$i</code> 拼接一列数据。</p><p>最后在如下代码中将每一行输出即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=1;i&lt;=NF;i++)&#123;</span><br><span class="line">    <span class="built_in">print</span> row[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SHELL12-打印每一行出现的数字个数"><a href="#SHELL12-打印每一行出现的数字个数" class="headerlink" title="SHELL12 打印每一行出现的数字个数"></a><strong>SHELL12</strong> <strong>打印每一行出现的数字个数</strong></h2><p>具体代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">linecount=1</span><br><span class="line">sum=0</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    count=0</span><br><span class="line">    <span class="keyword">for</span> (( i=0; i&lt;<span class="variable">$&#123;#line&#125;</span>; ++i ))</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [[ <span class="variable">$&#123;line:$i:1&#125;</span> =~ [1-5] ]]</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">            ((++count))</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;line<span class="variable">$linecount</span> number:<span class="variable">$count</span>&quot;</span></span><br><span class="line">    sum=$((<span class="variable">$sum</span> + <span class="variable">$count</span>))</span><br><span class="line">    ((++linecount))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;sum is <span class="variable">$sum</span>&quot;</span></span><br></pre></td></tr></table></figure><p>说明：</p><p>诸如 <code>linecount=1</code> 这种都是对变量的定义。这里对空格有严格的规定：</p><p><strong>赋值语句等号两边不能有空格，而字符串比较，等号两边必须有空格</strong></p><p><code>if</code> 语句和 <code>for</code> 语句的 <code>[[ ]]</code> 和 <code>(( ))</code> 左右和中间都需要空格隔开，否则会报错。</p><p><code>while</code> 语句中的 <code>line</code> 会显示一行的数据，<code>$&#123;#line&#125;</code> 会显示一行的字符个数，<code>$&#123;line:$i:1&#125;</code> 显示一行字符从 <code>$i</code> 开始取一个字符。</p><p><code>=~</code> 左侧的内容是否包含右侧<strong>正则匹配</strong>内容的模式。</p><p><code>$(($sum + $count))</code> 两个变量相加，<code>((++linecount))</code> 变量自增。</p><h2 id="SHELL14-求平均值（保留三位小数）"><a href="#SHELL14-求平均值（保留三位小数）" class="headerlink" title="SHELL14 求平均值（保留三位小数）"></a><strong>SHELL14</strong> <strong>求平均值</strong>（保留三位小数）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    if(NR == 1)</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        count=$1</span></span><br><span class="line"><span class="string">    &#125;else</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        sum+=$1</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;END&#123;</span></span><br><span class="line"><span class="string">    printf(&quot;%.3f&quot;, sum / count)</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> nowcoder.txt</span><br></pre></td></tr></table></figure><h2 id="SHELL16-判断输入的是否为IP地址（指定分隔符，or）"><a href="#SHELL16-判断输入的是否为IP地址（指定分隔符，or）" class="headerlink" title="SHELL16 判断输入的是否为IP地址（指定分隔符，or）"></a><strong>SHELL16</strong> <strong>判断输入的是否为IP地址</strong>（指定分隔符，or）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">awk -F <span class="string">&#x27;.&#x27;</span> <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    if(NF==4)</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        for(i=1;i&lt;=NF;++i)</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            if($i &lt; 0 || $i &gt; 255)</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                print(&quot;no&quot;)</span></span><br><span class="line"><span class="string">                break</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        if(i == 5)</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">        print(&quot;yes&quot;)</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;else</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        print(&quot;error&quot;)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> nowcoder.txt</span><br></pre></td></tr></table></figure><p><code>awk -F &#39;.&#39;</code> 对一行数据指定 <code>.</code> 为分隔符，<code>awk</code> 中使用 <code>print</code> 相关作为输出，<code>echo</code> 不行。</p><h2 id="数组计数并sort-排序"><a href="#数组计数并sort-排序" class="headerlink" title="数组计数并sort 排序"></a>数组计数并sort 排序</h2><p><a href="https://www.nowcoder.com/practice/f076c0a3c1274cbe9d615e0f3fd965f1?tpId=195&tags=&title=&difficulty=0&judgeStatus=0&rp=1"><strong>SHELL18</strong> <strong>域名进行计数排序处理</strong></a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk -F <span class="string">&quot;/&quot;</span> <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    arr[$3] = arr[$3] + 1</span></span><br><span class="line"><span class="string">&#125;END&#123;for(a in arr)&#123;print(arr[a], a)&#125;&#125;&#x27;</span> | sort -r</span><br></pre></td></tr></table></figure><p><code>sort</code> 语法：</p><ol><li><code>-u</code> ：去除重复行</li><li><code>-n</code> ：按数字顺序进行排序；</li><li><code>-r</code> ：逆序；</li><li><code>-o</code> ：将结果重定向到某个文件，<code>sort -n -r number.txt -o number.txt</code> ；</li><li><code>-t</code> ：设置间隔符；</li><li><code>-k</code> ：按第几列排序。</li></ol><h2 id="echo、print和printf"><a href="#echo、print和printf" class="headerlink" title="echo、print和printf"></a>echo、print和printf</h2><p><a href="https://www.nowcoder.com/practice/d91a06bfaff443928065e611b14a0e95?tpId=195&tqId=39430&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=/exam/oj?tab=SHELL%25E7%25AF%2587&topicId=195&difficulty=undefined&judgeStatus=undefined&tags=&title="><strong>SHELL21</strong> <strong>格式化输出</strong></a></p><p><a href="https://www.cnblogs.com/f-ck-need-u/p/5915076.html">借鉴1</a></p><p><a href="https://www.runoob.com/linux/linux-shell-printf.html">借鉴2</a></p><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>主要注意点在于单双引号的特殊情况。</p><ol><li><p><code>!</code> 的使用：</p><p>可以直接打印，也可以单引号打印。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello world!</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello world!&#x27;</span></span><br></pre></td></tr></table></figure><p>但是不能使用双引号打印：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello world!&quot;</span> <span class="comment"># 会报错：-bash: !&quot;: event not found</span></span><br><span class="line"><span class="comment"># 如果一定要双引号，可以把 ! 单独拎出来单引</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span><span class="string">&#x27;!&#x27;</span></span><br></pre></td></tr></table></figure><p>当后面还要输出内容，必须使用单引号括住，或者放到最后输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello world!; <span class="built_in">echo</span> <span class="string">&#x27;hello world!&#x27;</span> <span class="comment"># 会报错：-bash: !: event not found</span></span><br><span class="line"><span class="comment"># 应该这么写</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello world!&#x27;</span>; <span class="built_in">echo</span> hello world!</span><br></pre></td></tr></table></figure></li><li><p>转义字符的识别：</p><p>需要加 <code>-e</code> 来识别。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Hello World!\n&#x27;</span>;<span class="built_in">echo</span> <span class="string">&quot;Hello World&quot;</span>!  </span><br></pre></td></tr></table></figure><blockquote><p>会输出：</p><p>Hello World!\n</p><p>Hello World!</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;hello world!\n&#x27;</span>; <span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span>!</span><br></pre></td></tr></table></figure><blockquote><p>会输出：</p><p>hello world!</p><p>#换行</p><p>hello world!</p></blockquote></li><li><p>写入文件的分行处理：</p><p>默认每次写入会分行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World&quot;</span>! &gt; a.sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World&quot;</span>! &gt;&gt; a.sh <span class="comment"># &gt; 覆盖，&gt;&gt; 追加</span></span><br></pre></td></tr></table></figure><blockquote><p>#a.sh</p><p>Hello World!</p><p>Hello World!</p></blockquote><p>使用 <code>-n</code> 取消分行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;Hello World&quot;</span>! &gt; a.sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World&quot;</span>! &gt;&gt; a.sh</span><br></pre></td></tr></table></figure><blockquote><p>#a.sh</p><p>Hello World!Hello World!</p></blockquote></li><li><p>颜色输出：</p><p>（1）常见的字体颜色：重置&#x3D;0，黑色&#x3D;30，红色&#x3D;31，绿色&#x3D;32，黄色&#x3D;33，蓝色&#x3D;34，紫色&#x3D;35，天蓝色&#x3D;36，白色&#x3D;37。</p><p>（2）常见的背景颜色：重置&#x3D;0，黑色&#x3D;40，红色&#x3D;41，绿色&#x3D;42，黄色&#x3D;43，蓝色&#x3D;44，紫色&#x3D;45，天蓝色&#x3D;46，白色&#x3D;47。</p><p>（3）字体控制选项：1表示高亮，4表示下划线，5表示闪烁等。</p><p><strong>因为需要使用特殊符号，所以需要配合-e选项来识别特殊符号。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\e[1;41m Red Bcakground \e[0m&quot;</span></span><br></pre></td></tr></table></figure><p>使用 <code>\e[字体色;背景色m ... \e[字体色:背景色m</code> 的格式定义开始的颜色和结束的颜色。<code>[0m</code> 是重置为默认色。</p></li></ol><h3 id="print"><a href="#print" class="headerlink" title="print"></a>print</h3><p>是ksh的内置命令，不能使用 <code>%s、%d、%c</code> 等占位符，会自动换行。</p><h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><p>是bash的内置命令，支持使用占位符，不会自动换行，所以要换行的时候需要使用 <code>\n</code> 。</p><p>常见的：**%s %c %d %f** 都是格式替代符，<strong>％s</strong> 输出一个字符串，<strong>％d</strong> 整型输出，<strong>％c</strong> 输出一个字符，<strong>％f</strong> 输出实数，以小数形式输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-5s %-5s&quot;</span>, hello world) <span class="comment"># -表示左对齐，默认是右对齐，5表示占5个位</span></span><br></pre></td></tr></table></figure><h2 id="substr、split-函数的使用"><a href="#substr、split-函数的使用" class="headerlink" title="substr、split 函数的使用"></a>substr、split 函数的使用</h2><p><a href="https://www.nowcoder.com/practice/3f2f45c74a1b415db17234f9cfd51469?tpId=195&tqId=39432&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=/exam/oj?tab=SHELL%25E7%25AF%2587&topicId=195&difficulty=undefined&judgeStatus=undefined&tags=&title="><strong>SHELL23</strong> <strong>nginx日志分析1-IP统计</strong></a></p><h3 id="1-知识点"><a href="#1-知识点" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p><code>substr(str, start, num)</code> ：对 str 字符串取子串，从 start 下标开始，取 num 个字符。下标从1开始计数。</p><blockquote><p>substr($4, 2, 11)</p></blockquote><p><code>split(str,arr,sep)</code> ：对 str 字符串切分，将切分后的数据存到 arr，使用 sep 字符切分。</p><blockquote><p>split($0,a,”:”)</p></blockquote><h3 id="2-具体代码"><a href="#2-具体代码" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="comment">&#x27;&#123;</span></span><br><span class="line">    <span class="keyword">if</span>(substr($<span class="number">4</span>, <span class="number">2</span>, <span class="number">11</span>) == <span class="string">&quot;23/Apr/2020&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arr[$<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">END</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i in arr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">print</span>(arr[i]<span class="string">&quot; &quot;</span>i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">&#x27; nowcoder.txt | sort -r</span></span><br></pre></td></tr></table></figure><h2 id="去重-和-str转int"><a href="#去重-和-str转int" class="headerlink" title="去重 和 str转int"></a>去重 和 str转int</h2><p><a href="https://www.nowcoder.com/practice/ddbdd73859fa4fd48bbae7dd2e55f4b9?tpId=195&tags=&title=&difficulty=0&judgeStatus=0&rp=1&sourceUrl=/exam/oj?tab=SHELL%25E7%25AF%2587&topicId=195"><strong>SHELL24</strong> <strong>nginx日志分析2-统计某个时间段的IP</strong></a></p><h3 id="1-知识点-1"><a href="#1-知识点-1" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p><strong>去重</strong> - <code>uniq</code> 和 <code>sort -u</code> 的区别：</p><ol><li>uniq：对连续重复的内容进行去重；</li><li>sort -u：对输出中重复的内容去重。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; cat <span class="built_in">test</span></span><br><span class="line">jason</span><br><span class="line">jason</span><br><span class="line">jason</span><br><span class="line">fffff</span><br><span class="line">jason</span><br><span class="line"></span><br><span class="line">&gt; sort -u <span class="built_in">test</span></span><br><span class="line">fffff</span><br><span class="line">jason</span><br><span class="line"></span><br><span class="line">&gt; uniq <span class="built_in">test</span></span><br><span class="line">jason</span><br><span class="line">fffff</span><br><span class="line">jason </span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/zzyoucan/p/9986440.html">借鉴</a></p><p><strong>str转int：</strong> 使用 <code>int()</code> 转换。</p><h3 id="2-具体代码："><a href="#2-具体代码：" class="headerlink" title="2. 具体代码："></a>2. 具体代码：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    if(substr($4, 2, 11) == &quot;23/Apr/2020&quot; &amp;&amp; int(substr($4, 14, 2)) &gt;= 20 &amp;&amp; int(substr($4, 14, 2)) &lt;= 23)</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        print($1)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> nowcoder.txt | sort -u | wc -l</span><br></pre></td></tr></table></figure><p>也可以写成更简单的用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;23/Apr/2020:2[0-3]&quot;</span> nowcoder.txt | awk <span class="string">&#x27;&#123;print($1)&#125;&#x27;</span> | sort -u | wc -l</span><br></pre></td></tr></table></figure><h2 id="定时任务-crontab"><a href="#定时任务-crontab" class="headerlink" title="定时任务 crontab"></a>定时任务 crontab</h2><ol><li><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">分钟 小时 天 月 周 命令</span><br></pre></td></tr></table></figure><p>分钟：[0, 59]</p><p>小时：[0, 23]</p><p>天：[0, 31]</p><p>月：[1, 12]</p><p>周：[0, 7]，周日可以是0或7</p><p>如：<code>30 23 * * * /opt/data/test.sh</code></p></li><li><p>选项：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">crontab –e <span class="comment">-- 修改 crontab 文件. 如果文件不存在会自动创建。</span></span><br><span class="line">crontab –l <span class="comment">-- 显示 crontab 文件。 </span></span><br><span class="line">crontab <span class="operator">-</span>r <span class="comment">-- 删除 crontab 文件。</span></span><br><span class="line">crontab <span class="operator">-</span>ir <span class="comment">-- 删除 crontab 文件前提醒用户。</span></span><br></pre></td></tr></table></figure></li><li><p>启动：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">service crond <span class="keyword">start</span> <span class="comment">-- 启动服务</span></span><br><span class="line">service crond stop <span class="comment">-- 关闭服务</span></span><br><span class="line">service crond restart <span class="comment">-- 重启服务</span></span><br><span class="line">service crond reload <span class="comment">-- 重新载入配置</span></span><br><span class="line">service crond status <span class="comment">-- 查看服务状态</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="map用法"><a href="#map用法" class="headerlink" title="map用法"></a>map用法</h2><p><a href="https://www.nowcoder.com/practice/5ce76fd1513d4eacae68ad3b2aca1fbb?tpId=195&tqId=39441&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=/exam/oj?tab=SHELL%25E7%25AF%2587&topicId=195&difficulty=undefined&judgeStatus=undefined&tags=&title=">SHELL32 netstat练习4-输出和3306端口建立连接总的各个状态的数目</a></p><h3 id="1-知识点-2"><a href="#1-知识点-2" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><ol><li><p>切分字符串为数组：<code>array=($&#123;str//pattern/replace_str&#125;)</code> ，当 <code>replace_str = &quot; &quot;</code> 的时候，就可以按照 <code>patten</code> 切分字符串 <code>str</code> ；</p></li><li><p>声明名称为 m 的map：<code>declare -A m</code></p></li><li><p>赋值：单一赋值 - <code>m[key]=value</code>，多个赋值 - <code>m=([key1]=val1 [key2]=val2)</code></p></li><li><p>输出：所有的key - <code>$&#123;!map[@]&#125;</code>，所有的value - <code>$&#123;map[@]&#125;</code>，长度 - <code>$&#123;#map[@]&#125;</code></p></li></ol><h3 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">declare</span> -A map</span><br><span class="line">TOTAL_IP=()</span><br><span class="line">TOTAL_LINK=0</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    array=(<span class="variable">$&#123;line//\t/ &#125;</span>)</span><br><span class="line">    ip=(<span class="variable">$&#123;array[4]//:/ &#125;</span>)</span><br><span class="line">    <span class="keyword">if</span> [[ <span class="variable">$&#123;ip[1]&#125;</span> = 3306 ]];</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        ((++TOTAL_LINK))</span><br><span class="line">        <span class="keyword">if</span> [[ !(<span class="string">&quot;<span class="variable">$&#123;TOTAL_IP[*]&#125;</span>&quot;</span> =~ <span class="variable">$&#123;ip[0]&#125;</span>) ]];</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">            TOTAL_IP+=(<span class="variable">$&#123;ip[0]&#125;</span>)</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">        val=<span class="variable">$&#123;map[<span class="variable">$&#123;array[5]&#125;</span>]&#125;</span></span><br><span class="line">        <span class="keyword">if</span> [[ val -eq <span class="string">&quot;&quot;</span> ]];</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">            map[<span class="variable">$&#123;array[5]&#125;</span>]=1</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            val=$((<span class="variable">$val</span> + <span class="number">1</span>))</span><br><span class="line">            map[<span class="variable">$&#123;array[5]&#125;</span>]=<span class="variable">$val</span></span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;TOTAL_IP &quot;</span><span class="variable">$&#123;#TOTAL_IP[@]&#125;</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> <span class="variable">$&#123;!map[@]&#125;</span>;<span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$key</span><span class="string">&quot; &quot;</span><span class="variable">$&#123;map[$key]&#125;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;TOTAL_LINK &quot;</span><span class="variable">$TOTAL_LINK</span></span><br></pre></td></tr></table></figure><p>其中有一段代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val=<span class="variable">$&#123;map[<span class="variable">$&#123;array[5]&#125;</span>]&#125;</span></span><br><span class="line"><span class="keyword">if</span> [[ val -eq <span class="string">&quot;&quot;</span> ]];</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    map[<span class="variable">$&#123;array[5]&#125;</span>]=1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    val=$((<span class="variable">$val</span> + <span class="number">1</span>))</span><br><span class="line">    map[<span class="variable">$&#123;array[5]&#125;</span>]=<span class="variable">$val</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>用于判断 <code>map</code> 数组中是否存在相应的 key ，如果存在自增，否则赋值为1。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 236. 二叉树的最近公共祖先</title>
      <link href="/2022/02/11/LeetCode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
      <url>/2022/02/11/LeetCode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先分析两个节点出现的可能性：</p><ol><li>其中一个为祖先节点；</li><li>都为祖先节点的子孙节点。</li></ol><p>可以递归当前节点的左右节点：</p><ol><li>如果左右节点中不包含指定节点，判断当前节点是否是其中一个指定节点，是就返回该节点，否则就返回空；</li><li>如果左右节点中其中一个包含指定节点，返回这个节点，这里不能返回当前节点，因为有可能这个其中一个包含的是所有指定的节点，返回的这个子节点可能是最近的公共祖先；</li><li>如果左右子节点都包含指定节点，就说明当前节点为最近公共祖先，返回当前节点。</li></ol><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (root == p || root == q) ? root : <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( left == <span class="keyword">null</span> || right == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( root == p || root == q )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 234. 回文链表</title>
      <link href="/2022/02/09/LeetCode-234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/02/09/LeetCode-234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">https://leetcode-cn.com/problems/palindrome-linked-list/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="遍历存储，暴力解法"><a href="#遍历存储，暴力解法" class="headerlink" title="遍历存储，暴力解法"></a>遍历存储，暴力解法</h3><p>遍历链表，将节点值存储到可变数组ArrayList中，在数组中判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head.next == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; val = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( head != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            val.add(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = val.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( i &lt; j )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( val.get(i) != val.get(j) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="部分递归"><a href="#部分递归" class="headerlink" title="部分递归"></a>部分递归</h3><p>递归的回溯部分可以看成是逆序遍历链表，所以可以先遍历到链表的最后一个节点，然后存储一个不在递归内的头节点，每次回退都比较当前回退的节点值和从头结点开始往下遍历的节点值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ListNode front;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        front = head;</span><br><span class="line">        <span class="keyword">return</span> reverseListNode(head);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">reverseListNode</span><span class="params">(ListNode head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( !reverseListNode(head.next) || head.val != front.val )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            front = front.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快慢指针-反转链表"><a href="#快慢指针-反转链表" class="headerlink" title="快慢指针 + 反转链表"></a>快慢指针 + 反转链表</h3><p>回文链表可以看程前半部分和后半部分。通过快慢指针获取前半部分的最后一个节点，然后反转后半部分的链表，最后获取两个部分的头节点依次比较。</p><p>有一个小点：奇数节点的中间节点算哪边？都可以，只要判断短的一边是否为null就可以。</p><p>注意：因为这种操作会修改链表，所以在并发操作需要锁。一般情况下，不是程序要求，最好不要修改链表结构，如果修改了，最后需要将其恢复原样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode frontEnd = endOfFrontHelf(head);</span><br><span class="line">        ListNode secondStart = reverseList(frontEnd.next); </span><br><span class="line">        ListNode front = head, second = secondStart;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( secondStart != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( front.val != secondStart.val )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            front = front.next;</span><br><span class="line">            secondStart = secondStart.next;</span><br><span class="line">        &#125;</span><br><span class="line">        reverseList(second);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取前半部分的最后一个节点，如果是奇数个节点，中间节点应该属于前半部分</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">endOfFrontHelf</span><span class="params">( ListNode head )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span>( fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>, next = head.next;</span><br><span class="line">        <span class="keyword">while</span>( head != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">            <span class="keyword">if</span>( next != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                next = next.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 快慢指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 208. 实现 Trie (前缀树)</title>
      <link href="/2022/02/08/LeetCode-208-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91/"/>
      <url>/2022/02/08/LeetCode-208-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">https://leetcode-cn.com/problems/implement-trie-prefix-tree/</a></p><span id="more"></span><h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><p>首先需要了解多叉树的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    VALUE_TYPE value; <span class="comment">// 节点值</span></span><br><span class="line">    TreeNode[] children; <span class="comment">// 所有孩子节点</span></span><br><span class="line">    <span class="comment">// 创建一个它的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(VALUE_TYPE value, <span class="keyword">int</span> children_size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        children = <span class="keyword">new</span> TreeNode[children_size];</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么可以推出字典树的结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isEnd; <span class="comment">// 当前节点是否为一个字符串的结尾</span></span><br><span class="line">    Trie[] children; <span class="comment">// 当前节点的孩子节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        children = <span class="keyword">new</span> Trie[<span class="number">26</span>]; <span class="comment">// 默认每个节点的孩子节点都包含26个字母</span></span><br><span class="line">        isEnd = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体的解题思路"><a href="#具体的解题思路" class="headerlink" title="具体的解题思路"></a>具体的解题思路</h3><p>上述推出字典树的结构，接着实现其中的方法：Insert、search、startWith。其实就是两个方法：插入、查找前缀，其中如果前缀的最后一个字母的 isEnd 值为 true，就表示存在这个字符串，否则仅存在前缀。</p><ol><li>插入字符串：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    Trie node = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>( node.children[index] == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            node.children[index] = <span class="keyword">new</span> Trie();</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    node.isEnd = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Trie node = this</code> ，获取以当前对象为头节点的引用。开始遍历字符串。代码中可以明显看出，判断一个节点是否存在某个孩子节点只需要判断这个孩子节点是否被实例化。同理，如果想要扩展一个孩子节点，也只需要将这个孩子节点实例化即可。最终对这个字符串的最后一个字符对应的 isEnd 变量赋值为 true ，这个字符串插入成功。</p><ol start="2"><li>查找前缀：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Trie <span class="title">isPrefix</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    Trie node = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>( node.children[index] == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值设置为 <code>Trie</code> 类型返回这个前缀最后一个字符对应的节点，是为了判断这个节点是否是这个字符串的结尾。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    Trie[] children;</span><br><span class="line">    <span class="keyword">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        children = <span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>( node.children[index] == <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie node = isPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="keyword">null</span> &amp;&amp; node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isPrefix(prefix) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Trie <span class="title">isPrefix</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>( node.children[index] == <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多叉树 </tag>
            
            <tag> 字典树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 207. 课程表</title>
      <link href="/2022/02/01/LeetCode-207-%E8%AF%BE%E7%A8%8B%E8%A1%A8/"/>
      <url>/2022/02/01/LeetCode-207-%E8%AF%BE%E7%A8%8B%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/course-schedule/">https://leetcode-cn.com/problems/course-schedule/</a></p><span id="more"></span><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>**借鉴：<a href="https://www.cnblogs.com/bigsai/p/11489260.html">拓扑排序详解与实现</a>**，这个文章已经解释的很详细，下面简单总结一下自己的理解。</p><p><img src="/LeetCode-207-%E8%AF%BE%E7%A8%8B%E8%A1%A8.assets/20190904123849168.png" alt="侵删"></p><p>​        首先存储所有节点以及该节点指向的所有节点，可以使用 <code>ArrayList</code> 存储所有被指向的节点。</p><p>​        其次遍历获取没有被指向的节点，也就是图中的 1、2，将这些节点存入队列或栈。可以使用数组来存放每个节点被指向的次数，如果指向它的前驱节点被删除，就将次数减一，当次数为0就存入队列或栈。</p><p>​        重复上述过程，直到最后一个节点被删除，表示这个图遍历完成，或者不存在环。</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>遍历所有节点，以 <code>Map(int curnode, List&lt;Integer&gt; prenode)</code> 形式存储；</li><li>然后创建一个 <code>prenodessize</code> 数组来存储每个节点被指向的次数；</li><li>创建一个队列，存储被指向次数为0的节点；</li><li>每次出一个节点，将这个节点指向的所有节点的被指向次数减一，如果这个被指向的节点的次数为0，存入队列；</li><li>上述以此类推，当队列为空，退出循环；</li><li>最后判断最先创建的 <code>map.size()</code> 是否为0，如果不为0，表示存在类似 <code>[[1,0],[0,1]]</code> 的环；否则不存在环。</li></ol><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( numCourses == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] precoursesize = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; courses = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; curcourses = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 map 和 precoursesize</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( courses.containsKey(prerequisites[i][<span class="number">1</span>]) )</span><br><span class="line">            &#123;</span><br><span class="line">                courses.get(prerequisites[i][<span class="number">1</span>]).add(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                courses.put(prerequisites[i][<span class="number">1</span>], <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(prerequisites[i][<span class="number">0</span>])));</span><br><span class="line">            &#125;</span><br><span class="line">            ++precoursesize[prerequisites[i][<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化 curcourses</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( precoursesize[i] == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                curcourses.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( !curcourses.isEmpty() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> curcourse = curcourses.poll();</span><br><span class="line">            <span class="keyword">if</span>( !courses.containsKey(curcourse) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Integer&gt; course = courses.get(curcourse);</span><br><span class="line">            courses.remove(curcourse);</span><br><span class="line">            <span class="comment">// 对当前被连接的课程减1</span></span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> c : course )</span><br><span class="line">            &#123;</span><br><span class="line">                --precoursesize[c];</span><br><span class="line">                <span class="keyword">if</span>( precoursesize[c] == <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    curcourses.offer(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( courses.size() != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度优先遍历DFS和广度优先遍历BFS算法</title>
      <link href="/2022/01/30/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86DFS%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86BFS%E7%AE%97%E6%B3%95/"/>
      <url>/2022/01/30/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86DFS%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86BFS%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="实例（题目）"><a href="#实例（题目）" class="headerlink" title="实例（题目）"></a>实例（题目）</h2><p><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></p><span id="more"></span><h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><p>对每一个分支走到最后一个节点，再往上回溯，走当前节点的下一个分支。下面给出深度优先遍历的过程图：</p><p><img src="/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86DFS%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86BFS%E7%AE%97%E6%B3%95.assets/%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86.png"></p><p>递归代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    grid[i][j] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>( i + <span class="number">1</span> &lt; m &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        dfs(grid, i + <span class="number">1</span>, j, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        dfs(grid, i - <span class="number">1</span>, j, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( j + <span class="number">1</span> &lt; n &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        dfs(grid, i, j + <span class="number">1</span>, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        dfs(grid, i, j - <span class="number">1</span>, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; inds = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    inds.push(i * n + j);</span><br><span class="line">    <span class="keyword">while</span>( !inds.empty() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = inds.pop();</span><br><span class="line">        i = ind / n;</span><br><span class="line">        j = ind % n;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>( i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            inds.push((i - <span class="number">1</span>) * n + j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( i + <span class="number">1</span> &lt; m &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            inds.push((i + <span class="number">1</span>) * n + j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            inds.push(i * n + j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( j + <span class="number">1</span> &lt; n &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            inds.push(i * n + j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><p>没有递归调用，使用队列（Queue）存放元素，遍历当前元素相连的所有元素并记录。</p><p><img src="/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86DFS%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86BFS%E7%AE%97%E6%B3%95.assets/%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86.png"></p><p>具体代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; inds = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    inds.add(i * n + j);</span><br><span class="line">    <span class="keyword">while</span>( !inds.isEmpty() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = inds.poll();</span><br><span class="line">        i = ind / n;</span><br><span class="line">        j = ind % n;</span><br><span class="line">        <span class="keyword">if</span>( i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            inds.add((i - <span class="number">1</span>) * n + j);</span><br><span class="line">            grid[i - <span class="number">1</span>][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( i + <span class="number">1</span> &lt; m &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            inds.add((i + <span class="number">1</span>) * n + j);</span><br><span class="line">            grid[i + <span class="number">1</span>][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            inds.add(i * n + j - <span class="number">1</span>);</span><br><span class="line">            grid[i][j - <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( j + <span class="number">1</span> &lt; n &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            inds.add(i * n + j + <span class="number">1</span>);</span><br><span class="line">            grid[i][j + <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，为了剪枝，将 <code>grid[i][j + 1] = &#39;0&#39;</code> 在每个 if 语句中实现。</p><h2 id="题中具体代码"><a href="#题中具体代码" class="headerlink" title="题中具体代码"></a>题中具体代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( grid[i][j] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                    dfs(grid, i, j, m, n);</span><br><span class="line">                    <span class="comment">// grid[i][j] = &#x27;0&#x27;;</span></span><br><span class="line">                    <span class="comment">// bfs(grid, i, j, m, n);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// public void dfs(char[][] grid, int i, int j, int m, int n)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">// grid[i][j] = &#x27;2&#x27;;</span></span><br><span class="line">        <span class="comment">// if( i + 1 &lt; m &amp;&amp; grid[i + 1][j] == &#x27;1&#x27; )</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     dfs(grid, i + 1, j, m, n);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if( i - 1 &gt;= 0 &amp;&amp; grid[i - 1][j] == &#x27;1&#x27; )</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     dfs(grid, i - 1, j, m, n);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if( j + 1 &lt; n &amp;&amp; grid[i][j + 1] == &#x27;1&#x27; )</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     dfs(grid, i, j + 1, m, n);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if( j - 1 &gt;= 0 &amp;&amp; grid[i][j - 1] == &#x27;1&#x27; )</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     dfs(grid, i, j - 1, m, n);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//     Stack&lt;Integer&gt; inds = new Stack&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     inds.push(i * n + j);</span></span><br><span class="line">    <span class="comment">//     while( !inds.empty() )</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         int ind = inds.pop();</span></span><br><span class="line">    <span class="comment">//         i = ind / n;</span></span><br><span class="line">    <span class="comment">//         j = ind % n;</span></span><br><span class="line">    <span class="comment">//         grid[i][j] = &#x27;2&#x27;;</span></span><br><span class="line">    <span class="comment">//         if( i - 1 &gt;= 0 &amp;&amp; grid[i - 1][j] == &#x27;1&#x27; )</span></span><br><span class="line">    <span class="comment">//         &#123;</span></span><br><span class="line">    <span class="comment">//             inds.push((i - 1) * n + j);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         if( i + 1 &lt; m &amp;&amp; grid[i + 1][j] == &#x27;1&#x27; )</span></span><br><span class="line">    <span class="comment">//         &#123;</span></span><br><span class="line">    <span class="comment">//             inds.push((i + 1) * n + j);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         if( j - 1 &gt;= 0 &amp;&amp; grid[i][j - 1] == &#x27;1&#x27; )</span></span><br><span class="line">    <span class="comment">//         &#123;</span></span><br><span class="line">    <span class="comment">//             inds.push(i * n + j - 1);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         if( j + 1 &lt; n &amp;&amp; grid[i][j + 1] == &#x27;1&#x27; )</span></span><br><span class="line">    <span class="comment">//         &#123;</span></span><br><span class="line">    <span class="comment">//             inds.push(i * n + j + 1);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; inds = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        inds.add(i * n + j);</span><br><span class="line">        <span class="keyword">while</span>( !inds.isEmpty() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ind = inds.poll();</span><br><span class="line">            i = ind / n;</span><br><span class="line">            j = ind % n;</span><br><span class="line">            <span class="keyword">if</span>( i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                inds.add((i - <span class="number">1</span>) * n + j);</span><br><span class="line">                grid[i - <span class="number">1</span>][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( i + <span class="number">1</span> &lt; m &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                inds.add((i + <span class="number">1</span>) * n + j);</span><br><span class="line">                grid[i + <span class="number">1</span>][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                inds.add(i * n + j - <span class="number">1</span>);</span><br><span class="line">                grid[i][j - <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( j + <span class="number">1</span> &lt; n &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                inds.add(i * n + j + <span class="number">1</span>);</span><br><span class="line">                grid[i][j + <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非专业综合面试题</title>
      <link href="/2022/01/29/%E9%9D%9E%E4%B8%93%E4%B8%9A%E7%BB%BC%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/01/29/%E9%9D%9E%E4%B8%93%E4%B8%9A%E7%BB%BC%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="面临压力最大（困难）的一次是什么时候，你是用什么方法解决的？"><a href="#面临压力最大（困难）的一次是什么时候，你是用什么方法解决的？" class="headerlink" title="面临压力最大（困难）的一次是什么时候，你是用什么方法解决的？"></a>面临压力最大（困难）的一次是什么时候，你是用什么方法解决的？</h3><p>​        应该是在我实习第一次接到实际需求的时候，我在开始做的时候逼自己尽量做一个完整的计划，并且去尽量核对需求的细节来保证理解不出偏差，以免走弯路，耗费不必要的时间。这样在后面做的时候我才会比较安心。</p><h3 id="你为什么想来我们公司"><a href="#你为什么想来我们公司" class="headerlink" title="你为什么想来我们公司"></a>你为什么想来我们公司</h3><p>点：地理位置、公司情况（业务、发展前景、文化）、个人（和岗位的匹配度）</p><p>​        首先就地理位置来说，广州是我首选的城市，气候、美食、距离等都是最理想的城市。而4399作为龙头企业，平台大，并且我在网上了解到公司对应届生的培训体系是很完善的。而就我本身而言，专业是对口的，并且也有大数据方面的实习经历，所以实际工作中也可以更快更好的投入进去。</p><h3 id="期望薪资"><a href="#期望薪资" class="headerlink" title="期望薪资"></a>期望薪资</h3><p>我相信贵公司一定有自己的薪酬规则，我也愿意遵守公司规定。我能了解下贵公司对于这个岗位的薪酬安排是什么样的吗？</p><h3 id="目前手头有其他offer吗"><a href="#目前手头有其他offer吗" class="headerlink" title="目前手头有其他offer吗"></a>目前手头有其他offer吗</h3><p>最近才开始看机会，暂时没有offer。不过有两家公司也进入终面阶段了。但是我还是更看重现在的这个机会，因为从公司的地理位置和发展前景来看，是我最理想的一个选择。</p><p>（追问是什么公司：都是互联网行业的，也是数据研发的岗位）</p><h3 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h3><p>业务面：</p><p>您觉得对于校招应届生，最重要的能力是什么呢？</p><p>您觉得在这一岗位表现优异的员工主要具备哪些特质呢？</p><p>如果我能拿到offer，我应该怎样做才能尽快的适应环境，然后为团队做出贡献呢？</p><p>hr面：</p><p>入职前是否有相应的培训机制呢？</p><p>新员工2-3年内在公司会有怎样的发展？</p><p>请问转正的考核标准是什么呢？</p><p>对于表现优秀的员工会有什么样的激励机制？</p><h3 id="未来两三年的规划"><a href="#未来两三年的规划" class="headerlink" title="未来两三年的规划"></a>未来两三年的规划</h3><p>第一阶段，一年内我要求自己通过快速高效的学习，努力踏实的做好本职工作，不断提高自己的专业技能水平；在第二阶段，自己入职的两年内，希望可以稳步提升，持续学到更多的知识，能够独当一面，负责某个项目，去解决问题；第三阶段，差不多入职2-3年，我希望能在工作中有更多的创新和发展，成为一个专业性的人才，为公司带来更大的价值。对于三年内的目标，我在暂时是这么考虑的。</p><h3 id="月底交付，时间赶，怎么处理风险问题"><a href="#月底交付，时间赶，怎么处理风险问题" class="headerlink" title="月底交付，时间赶，怎么处理风险问题"></a>月底交付，时间赶，怎么处理风险问题</h3><h3 id="如果录用你，这份工作对你来说最大的困难是什么"><a href="#如果录用你，这份工作对你来说最大的困难是什么" class="headerlink" title="如果录用你，这份工作对你来说最大的困难是什么"></a>如果录用你，这份工作对你来说最大的困难是什么</h3><p>我觉得工作中的困难是在所难免的，但是不能因为存在困难就不去做，我会努力去解决，办法总比困难多。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：团队协作意识不错，遇到问题解决不了会及时反应，不会拖着；学习能力不错，会通过多种途径充实自己，比如B站刷视频，看看CSDN的博客这种；做事善始善终，不会放弃。</p><p>缺点：缺少工作经验；遇到大事可能不够沉着冷静，不能当机立断；不够自信。</p><h3 id="大学四年都做了什么"><a href="#大学四年都做了什么" class="headerlink" title="大学四年都做了什么"></a>大学四年都做了什么</h3><p>​        主要还是不断学习充实自己吧。利用课余的时间去整合框架的知识，会去刷一些相关的视频。然后也参加比赛，比如中国计算机高校大赛做了一个微信小程序，得了华南赛区的二等奖；还参加了中青杯数学建模比赛，得了二等奖。接着在大三的暑期去实习，在实习的过程中，让我学习了很多在学校学不到的东西，比如在实习之前我都没有对结果数据进行测试的习惯，就光想代码的实现没有考虑实际的数据，以及在工作过程中对时间的规划。</p><p>​        中青杯数学建模：主题是给股票投资人利益最大化的投资策略和建议。我负责求出合适的选股方案，使用matlab来实现。具体实现的模型是优劣解距离模型。优劣解距离模型用于对股票的投资价值进行排序，针对高风险高收益人群和低风险低收益人群，先对原始数据进行正向化处理，都转换为极大型指标，然后进行数据的标准化和归一化。</p><h3 id="看了什么书，一天看多久"><a href="#看了什么书，一天看多久" class="headerlink" title="看了什么书，一天看多久"></a>看了什么书，一天看多久</h3><p>​        最近没怎么看书，但是每天都会坚持刷B站和博客，有时候在复习框架的时候会出现一些可能之前没有想到的问题，我会先去翻相关的视频解读，如果没有解决问题再到csdn和百度查相关的资料。</p><p>​        比如昨天我在看hive的存储时，就发现自己没有了解到它们的具体应用场景，我就百度了。</p><h3 id="兴趣爱好"><a href="#兴趣爱好" class="headerlink" title="兴趣爱好"></a>兴趣爱好</h3><p>点：正向爱好、喜欢原因、案例描述</p><p>​        平时喜欢刷博客。</p><h3 id="觉得自己需要提升什么"><a href="#觉得自己需要提升什么" class="headerlink" title="觉得自己需要提升什么"></a>觉得自己需要提升什么</h3><h3 id="对加班了解吗，可不可以接受大小周"><a href="#对加班了解吗，可不可以接受大小周" class="headerlink" title="对加班了解吗，可不可以接受大小周"></a>对加班了解吗，可不可以接受大小周</h3><p>​        首先我觉得对于任何一家公司，加班赶进度是肯定很正常的事情，我目前没有成家，有充足的时间和精力投入到工作中。但是我也会提高自己的业务水平，加强时间管理的能力，提高工作的效率，来尽量避免不必要的加班。</p><h3 id="针对游戏说一点自己的见解"><a href="#针对游戏说一点自己的见解" class="headerlink" title="针对游戏说一点自己的见解"></a>针对游戏说一点自己的见解</h3><h3 id="秋招有投简历吗？秋招到现在在干什么？"><a href="#秋招有投简历吗？秋招到现在在干什么？" class="headerlink" title="秋招有投简历吗？秋招到现在在干什么？"></a>秋招有投简历吗？秋招到现在在干什么？</h3><p>​        没有，因为前面一段时间学业有些繁重，回来之后在准备期末，然后之后又准备开题报告的事情，就耽误了一些时间。</p><h3 id="在应届毕业生中，你觉得你有哪些优势？"><a href="#在应届毕业生中，你觉得你有哪些优势？" class="headerlink" title="在应届毕业生中，你觉得你有哪些优势？"></a>在应届毕业生中，你觉得你有哪些优势？</h3><p>​        我认为自己最大的优势在于勤奋好学，有责任心。对于出现的问题我会积极主动的去解决，不会拖欠；对于接下的需求会去核对细节，不会盲目开工。</p><h3 id="你觉得大学期间你最有成就感的事情是什么（重要！！）"><a href="#你觉得大学期间你最有成就感的事情是什么（重要！！）" class="headerlink" title="你觉得大学期间你最有成就感的事情是什么（重要！！）"></a>你觉得大学期间你最有成就感的事情是什么（重要！！）</h3><p>点：不需要很大，主要突出成长、意义、积极主动、想法、目标、努力。</p><p>​        那应该是做这个小程序吧。这算是我第一次独立完成的一个项目，从构思设计到小程序内容的学习到完成最终的成果，我在保证质量的前提下在预期的时间内完成了，并且也取得了不错的成绩，这算是我对自己的一个突破吧。</p><h3 id="实习经历"><a href="#实习经历" class="headerlink" title="实习经历"></a>实习经历</h3><p>困难：第一次接实际需求，我虽然已经核对过需求的细节来保证自己的做的内容是符合需求设想的，但是没有考虑实际数据的分布问题，比如存在一些未被过滤的异常数据，以及不同账期数据量的差异，这就导致最后的结果并不符合预期，以及两个不同账期的数据差值太大我以为写错了。</p><p>怎么解决：分析了原始数据的分布，向需求人员询问异常数据的解决方式，然后再编写逻辑并测试正确性。</p><p>后续有想怎么优化吗：在最开始写需求前，需要先查数据的内容，起码先看数据的异常情况，避免因为异常数据导致结果的不同，然后将逻辑从原始数据上逆推，再判断从逻辑触发得到的结果与逆推结果的差异是否在正常区间内。</p><h3 id="问父母的工作"><a href="#问父母的工作" class="headerlink" title="问父母的工作"></a>问父母的工作</h3><p>​        都是普通的上班族。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 160. 相交链表</title>
      <link href="/2022/01/28/LeetCode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/01/28/LeetCode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表的思想很明显，先遍历一个链表，存储其中的节点，再遍历另一个链表，第一个在表中查到的节点就是相交的起始节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( headA != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            set.add(headA);</span><br><span class="line">            headA = headA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( headB != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( set.contains(headB) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> headB;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                headB = headB.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nul</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>整个结构简单来看就是三个部分：链表A不重合的部分节点数为a，链表B不重合的部分节点数为b，重合的部分节点数为c。可以得到下述等式：<br>$$<br>a + c + b &#x3D;&#x3D; b + c + a<br>$$<br>也就是设置两个指针 <code>pa = headA</code> 和 <code>pb = headB</code> 开始遍历，如果 <code>a == b</code> ，那么同时遍历完两侧指针没有重合，就说明 <code>c == 0</code> ，即无重合；如果 <code>a != b</code> ，同时遍历，当 <code>pa</code> 遍历 <code>a + c + b</code> 时，<code>pb</code> 一定也遍历了 <code>b + c + a</code> ，此时两个指针不是同时为 <code>null</code> ，必定重合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( headA == headB )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> headA;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pa = headA, pb = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( pa != <span class="keyword">null</span> || pb != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( pa != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                pa = pa.next;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pa = headB;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( pb != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                pb = pb.next;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pb = headA;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( pa == pb )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> pa;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记</title>
      <link href="/2022/01/28/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/01/28/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​        Redis是一款基于键值对的NoSQL数据库，它的值支持多种数据结构：字符串(strings)、哈希(hashes)、列表(lists)、集合(sets)、有序集合(sorted sets)等。</p><span id="more"></span><p>​        Redis将所有的数据都存放在内存中，所以它的读写性能十分惊人。同时，Redis还可以将内存中的数据以快照或日志的形式保存到硬盘上，以保证数据的安全性。</p><p>​        其中快照的形式，也叫RDB的形式，这种形式就是将内存中的数据原原本本存到硬盘上，这种形式的优点是数据体积小，如果想从硬盘恢复数据到内存里，速度会很快；而缺点是，因为是一次性将数据存到硬盘，这个过程会比较耗时，而且在存储的时候会产生阻塞，如果这个时候还在处理其他业务，会对其他业务有影响。所以快照的形式不适合实时的场景，而是适用于隔一段时间做一次备份的场景。</p><p>​        以日志的形式存数据到硬盘，这种形式叫AOF。每执行一次redis命令，就会以日志的形式把这个命令存下来。因为一个命令通俗来看就是一句话的记录，所以会比较快，适用于实时的场景。AOF以追加的形式存储，数据的体积会比较大，比较占磁盘空间；另外，如果想从磁盘把数据恢复到内存，就需要将记录的命令从头到尾再跑一遍，所以恢复的速度会比较慢。</p><p>​        Redis典型的应用场景包括:缓存、排行榜、计数器、社交网络、消息队列等。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h4 id="windows下安装："><a href="#windows下安装：" class="headerlink" title="windows下安装："></a>windows下安装：</h4><p>网址：<a href="https://github.com/microsoftarchive/redis/releases">https://github.com/microsoftarchive/redis/releases</a></p><p>选择最新版本安装：<code>Redis-x64-3.0.504.msi</code></p><p>然后一路 <code>next</code> 默认安装。</p><h4 id="linux下安装"><a href="#linux下安装" class="headerlink" title="linux下安装"></a>linux下安装</h4><p><a href="https://blog.csdn.net/qq_39135287/article/details/83474865">https://blog.csdn.net/qq_39135287/article/details/83474865</a></p><h3 id="测试是否安装成功（出现的报错）"><a href="#测试是否安装成功（出现的报错）" class="headerlink" title="测试是否安装成功（出现的报错）"></a>测试是否安装成功（出现的报错）</h3><blockquote><p>Could not connect to Redis at 127.0.0.1:6379: 由于目标计算机积极拒绝，无法连接。</p></blockquote><p>问题：没有启动 redis-server.exe</p><p>解决：</p><ol><li>使用两个cmd命令行，第一个输入 <code>redis-server redis.windows.conf</code>；</li><li>第二个cmd输入 <code>redis-cli</code></li></ol><blockquote><p> Can’t handle RDB format version 7</p></blockquote><p>问题：版本无法兼容。</p><p>解决：删除redis文件夹下的 <code>dump.rdb</code> 文件。</p><h3 id="maven项目-Java连接redis"><a href="#maven项目-Java连接redis" class="headerlink" title="maven项目 Java连接redis"></a>maven项目 Java连接redis</h3><ol><li><p>粘贴 <code>dependency</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>如下代码完成基本测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.121.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">jedis.auth(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;服务正在运行：&quot;</span> + jedis.ping());</span><br></pre></td></tr></table></figure></li></ol><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="redis数据库"><a href="#redis数据库" class="headerlink" title="redis数据库"></a>redis数据库</h3><p>默认有16个内置的库，这些库没有名字，使用 <code>0 ~ databases.size() - 1</code> 的序列号来区分，客户端与redis建立连接后默认选择0号数据库。</p><ol><li>可以通过 <code>select num</code> 来更换库，其中 <code>num</code> 为库的序列号。</li><li>如果想删除一个库中的数据，在该库下执行 <code>flushdb</code> 命令；</li></ol><h3 id="操作String类型数据"><a href="#操作String类型数据" class="headerlink" title="操作String类型数据"></a>操作String类型数据</h3><p>存：<code>set key value </code></p><p>取：<code>get key</code></p><p>其中，对于 key，如果是多个单词组成，使用 <code>:</code> 连接。对于 key 和 value，类型都是 String。</p><p>让 value 自增1：<code>incr test:count</code>，会自动将 value 转换为 Integer 类型并加一。</p><p>让 value 自减1：<code>decr test:count</code>，自动将value减一。</p><h3 id="操作哈希类型的数据"><a href="#操作哈希类型的数据" class="headerlink" title="操作哈希类型的数据"></a>操作哈希类型的数据</h3><p>存：<code>hset key field value</code>，此处可以将 key 看成哈希表名称，将 field看成是 key。</p><p>取：<code>hget key field</code>。</p><p>具体实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hset test:user <span class="built_in">id</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hset test:user name zhangsan</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hget test:user <span class="built_in">id</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hget test:user name</span><br><span class="line"><span class="string">&quot;zhangsan&quot;</span></span><br></pre></td></tr></table></figure><h3 id="操作列表类型的数据"><a href="#操作列表类型的数据" class="headerlink" title="操作列表类型的数据"></a>操作列表类型的数据</h3><p>按照插入顺序排序，可以从两侧侧插入取出。所以可以实现队列和栈。</p><ol><li>左侧进：<code>lpush test:ids 101 102 103</code></li><li>查看长度：<code>llen test:ids</code></li><li>查看某一个索引对应的元素：<code>lindex test:ids 0</code></li><li>查看子列表：<code>lrange test:ids 0 2</code></li><li>右侧出：<code>rpop test:ids</code></li></ol><p>具体实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lpush test:ids <span class="number">101</span> <span class="number">102</span> <span class="number">103</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; llen test:ids</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lindex test:ids <span class="number">0</span></span><br><span class="line"><span class="string">&quot;103&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange test:ids <span class="number">0</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;103&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;102&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;101&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; rpop test:ids</span><br><span class="line"><span class="string">&quot;101&quot;</span></span><br></pre></td></tr></table></figure><h3 id="操作集合类型的数据"><a href="#操作集合类型的数据" class="headerlink" title="操作集合类型的数据"></a>操作集合类型的数据</h3><p>集合中的数据是无序的，不能存在重复数据。</p><ol><li>增数据：<code>sadd test:teachers aaa bbb ccc ddd</code></li><li>查看个数：<code>scard test:teachers</code></li><li>从集合随机删除一个元素：<code>spop test:teachers</code>，这个方式可以用于实现抽奖场景</li><li>查看集合中具体有哪些元素：<code>smembers test:teachers</code></li></ol><p>具体实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd test:teachers aaa bbb ccc ddd</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; scard test:teachers</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; spop test:teachers</span><br><span class="line"><span class="string">&quot;aaa&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers test:teachers</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;ddd&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;bbb&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;ccc&quot;</span></span><br></pre></td></tr></table></figure><h3 id="操作有序集合类型的数据"><a href="#操作有序集合类型的数据" class="headerlink" title="操作有序集合类型的数据"></a>操作有序集合类型的数据</h3><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。</p><p>不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。分数可以重复。</p><ol><li>增数据：<code>zadd test:students 10 aaa 20 bbb 1 ccc 30 ddd</code></li><li>查看个数：<code>zcard test:students</code></li><li>查看某个元素的分数：<code>zscore test:students ccc</code></li><li>查看某个元素的排名，默认从小到大，从0开始：<code>zrank test:students ccc</code></li><li>取某个范围内的数据：<code>zrange test:students 0 3</code></li></ol><p>具体实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd test:students <span class="number">10</span> aaa <span class="number">20</span> bbb <span class="number">1</span> ccc <span class="number">30</span> ddd</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zcard test:students</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zscore test:students ccc</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrank test:students ccc</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange test:students <span class="number">0</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;ccc&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;aaa&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;bbb&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;ddd&quot;</span></span><br></pre></td></tr></table></figure><h3 id="操作全局，对所有数据都有效"><a href="#操作全局，对所有数据都有效" class="headerlink" title="操作全局，对所有数据都有效"></a>操作全局，对所有数据都有效</h3><ol><li>查看库中目前有多少个key：<code>keys *</code></li><li>查看库中目前以 test 开头的key有多少个：<code>keys test*</code></li><li>查看key对应的值的类型：<code>type test:user</code></li><li>查看某个key是否存在：<code>exists test:User</code></li><li>删除某个key：<code>del test:user</code></li><li>设置key的过期时间，key 过期后将不再可用。单位以秒计：<code>expire test:teachers 5</code></li></ol><p>具体实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;test:count&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;test:user&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;test:students&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;test:list&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;test:ids&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;test:teachers&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys test*</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;test:count&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;test:user&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;test:students&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;test:list&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;test:ids&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;test:teachers&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">type</span> test:user</span><br><span class="line"><span class="built_in">hash</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; exists test:User</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; exists test:user</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">del</span> test:user</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; exists test:user</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; expire test:students <span class="number">2</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;test:count&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;test:list&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;test:ids&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;test:teachers&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; expire test:teachers <span class="number">5</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;test:count&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;test:list&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;test:ids&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;test:teachers&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;test:count&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;test:list&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;test:ids&quot;</span></span><br></pre></td></tr></table></figure><h2 id="借鉴"><a href="#借鉴" class="headerlink" title="借鉴"></a>借鉴</h2><p><a href="https://www.nowcoder.com/study/live/246/4/1">https://www.nowcoder.com/study/live/246/4/1</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 152. 乘积最大子数组</title>
      <link href="/2022/01/26/LeetCode-152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/2022/01/26/LeetCode-152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">https://leetcode-cn.com/problems/maximum-product-subarray/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目本身实现动态规划是大致思路，主要看怎么实现 O(n) 时间复杂度的动态规划。</p><h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><p>以每个元素为连续子数组的第一个元素，遍历相乘取最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( nums.length == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxpro = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> curpro = nums[i];</span><br><span class="line">            maxpro = Math.max(maxpro, curpro);</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                curpro *= nums[j];</span><br><span class="line">                maxpro = Math.max(maxpro, curpro);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxpro;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一次循环"><a href="#一次循环" class="headerlink" title="一次循环"></a>一次循环</h3><p>相乘的连续子数组与一般的连续子数组的区别在于：一般连续子数组取的每个小部分都是最大值；但是相乘的连续子数组可能小部分是最小值，也可能是最大值。所以我们需要同时获取以当前元素为连续子数组的最后一个元素的最大积和最小积。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( nums.length == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> curmax = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> curmin = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxpro = curmax;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmpmax = curmax, tmpmin = curmin;</span><br><span class="line">            curmax = Math.max(Math.max(nums[i], tmpmax * nums[i]), tmpmin * nums[i]);</span><br><span class="line">            curmin = Math.min(Math.min(nums[i], tmpmax * nums[i]), tmpmin * nums[i]);</span><br><span class="line">            maxpro = Math.max(maxpro, curmax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxpro;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 142. 环形链表 II</title>
      <link href="/2022/01/26/LeetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/"/>
      <url>/2022/01/26/LeetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>使用 <code>HashSet</code> 存已经遍历过的节点，第一个二次遍历的节点就是入口结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( head != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( !set.add(head) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>这道题的重点是获取入口节点，但是快慢指针重合的第一个节点不一定是这个入口结点。下面进行简单的推导：</p><p><img src="/LeetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II.assets/142_fig1.png" alt="引用官方图"></p><p><em><u>[上图引用自官方题解]</u></em></p><p>上图假设快慢指针在紫色圆点出重合，此时慢指针走过 <code>a + b</code>，快指针走过 <code>a + n(b + c) + b</code>。<br>$$<br>\begin{cases}<br>fast &#x3D; a + n(b + c) + b\<br>slow &#x3D; a + b\<br>fast &#x3D; 2 * slow<br>\end{cases}<br>$$<br>上述方程组可以推导出：<br>$$<br>\begin{align*}<br>&amp;\qquad a + n(b + c) + b &#x3D; 2(a + b)\<br>&amp;&#x3D;&gt; a + (n + 1)b + nc &#x3D; 2a + 2b\<br>&amp;&#x3D;&gt; a &#x3D; c + (n - 1)(b + c)<br>\end{align*}<br>$$<br>也就是，将指针从 <code>head</code> 开始，<code>head = head.next; slow = slow.next</code> ，这二者第一次重合的节点为入口结点。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( slow == <span class="keyword">null</span> || fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;<span class="keyword">while</span>(slow != fast);</span><br><span class="line">        <span class="keyword">if</span>( slow == fast )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( head != slow )</span><br><span class="line">            &#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法的时空复杂度比较 &amp; 冒泡排序 &amp; 归并排序</title>
      <link href="/2022/01/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%AF%94%E8%BE%83-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/01/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%AF%94%E8%BE%83-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="一-排序算法介绍"><a href="#一-排序算法介绍" class="headerlink" title="一. 排序算法介绍"></a>一. 排序算法介绍</h3><h4 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h4><p>排序算法分为比较类排序和非比较类排序，其中：</p><p>比较类排序有 冒泡排序、快速排序、插入排序、希尔排序、选择排序、堆排序、归并排序；</p><span id="more"></span><p>非比较类排序有 计数排序、桶排序、基数排序。</p><p>算法复杂度如下：</p><table><thead><tr><th align="center">比较类排序</th><th align="center">时间复杂度</th><th align="center">空间复杂度</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center">插入排序</td><td align="center">O(n2)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">希尔排序</td><td align="center">O(n1.3)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">选择排序</td><td align="center">O(n2)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">堆排序</td><td align="center">O(nlog2n)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">冒泡排序</td><td align="center">O(n2)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">快速排序</td><td align="center">O(nlog2n)</td><td align="center">O(nlog2n)</td><td align="center">不稳定</td></tr><tr><td align="center">归并排序</td><td align="center">O(nlog2n)</td><td align="center">O(n)</td><td align="center">稳定</td></tr></tbody></table><table><thead><tr><th align="center">非比较类排序</th><th align="center">时间复杂度</th><th align="center">空间复杂度</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center">计数排序</td><td align="center">O(n+k)</td><td align="center">O(n+k)</td><td align="center">稳定</td></tr><tr><td align="center">桶排序</td><td align="center">O(n+k)</td><td align="center">O(n+k)</td><td align="center">稳定</td></tr><tr><td align="center">基数排序</td><td align="center">O(n*k)</td><td align="center">O(n+k)</td><td align="center">稳定</td></tr></tbody></table><h4 id="算法选择"><a href="#算法选择" class="headerlink" title="算法选择"></a>算法选择</h4><p>参考 <code>Java</code> 中的 <code>Arrays.sort()</code> 的使用，可以大致划分：</p><ol><li>元素个数 <strong>少于47</strong> 进行插入排序；</li><li>元素个数 <strong>大于等于47、小于286</strong> 进行快速排序；</li><li>元素个数 <strong>大于等于286</strong> 时，检查数组是否是接近已经排序好的结构，如果是，进行归并排序，如果数组不是（即非高度结构化的），使用快速排序。</li></ol><h3 id="二-冒泡排序"><a href="#二-冒泡排序" class="headerlink" title="二. 冒泡排序"></a>二. 冒泡排序</h3><p>最基本的排序算法。</p><ol><li>比较相邻元素，如果两个元素之间不满足指定要求（比如降序或升序），则进行交换；</li><li>每次比较循环都是从第一个元素开始（下标为0），直到所有元素都排序完毕。</li></ol><p>实例：</p><blockquote><p>按升序排列：</p><p>第一次循环 - [2,1,4,3,7,5] </p><p>2&gt;1 -&gt; 1,2 -&gt; [1,2,4,3,7,5]</p><p>2&lt;4 ✔</p><p>4&gt;3 -&gt; 3,4 -&gt; [1,2,3,4,7,5]</p><p>4&lt;7 ✔</p><p>7&gt;5 -&gt; 5,7 -&gt; [1,2,3,4,5,7]</p><p>第二次循环：[1,2,3,4,5]    &#x2F;&#x2F;7是上次循环后得到的最大值，不再参与循环</p><p>1&lt;2 ✔</p><p>2&lt;3 ✔</p><p>3&lt;4 ✔</p><p>4&lt;5 ✔</p><p>…</p></blockquote><p>可以进行一个小优化：设置一个参数<code>flag=0</code>来判断该次循环是否存在交换，如果有，置<code>flag=1</code>，则继续进行循环；没有，则退出循环。</p><p>具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] list = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>; <span class="comment">// 开辟一个临时空间, 存放交换的中间值</span></span><br><span class="line"><span class="comment">// 要遍历的次数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">//设置一个标志位</span></span><br><span class="line">    <span class="comment">//依次的比较相邻两个数的大小，遍历一次后，把数组中第i小的数放在第i个位置上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; list.length-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">        <span class="comment">// 比较相邻的元素，如果前面的数小于后面的数，交换</span></span><br><span class="line">        <span class="keyword">if</span> (list[j] &lt; list[j+<span class="number">1</span>]) &#123;</span><br><span class="line">            temp = list[j+<span class="number">1</span>];</span><br><span class="line">            list[j+<span class="number">1</span>] = list[j];</span><br><span class="line">            list[j] = temp;</span><br><span class="line">            flag = <span class="number">0</span>;  <span class="comment">//发生交换，标志位置0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.format(<span class="string">&quot;第 %d 遍最终结果：&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> count:list) &#123;</span><br><span class="line">        System.out.print(count);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;<span class="comment">//如果没有交换过元素，则已经有序</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="三-归并排序"><a href="#三-归并排序" class="headerlink" title="三. 归并排序"></a>三. 归并排序</h3><p>摘自 <a href="https://www.cnblogs.com/chengxiao/p/6194356.html">图解排序算法(四)之归并排序</a></p><p>适用于元素个数比较多的数组。</p><ol><li><p>分治：将数组对半分开，直到区间内只剩一个元素，开始向上递归；</p><p><img src="/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%AF%94%E8%BE%83-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.assets/1024555-20161218163120151-452283750.png" alt="img"></p></li><li><p>合并：当区间内的元素大于1个时，可以进行合并。</p></li></ol><p><img src="/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%AF%94%E8%BE%83-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.assets/1024555-20161218194508761-468169540.png" alt="img"></p><p>具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        devide(nums, <span class="number">0</span>, len - <span class="number">1</span>, tmp);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i] == nums[i+<span class="number">1</span>] )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">devide</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span>[] tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>( l &gt;= r )</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">          devide(nums, l, mid, tmp);</span><br><span class="line">          devide(nums, mid+<span class="number">1</span>, r, tmp);</span><br><span class="line">          merge(nums, l, r, mid, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> mid, <span class="keyword">int</span>[] tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( mid &gt;= r + <span class="number">1</span> || mid &lt; <span class="number">0</span> || l &gt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( i &lt;= mid &amp;&amp; j &lt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i] &lt;= nums[j] )</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[t++] = nums[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmp[t++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( i &lt;= mid )</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[t++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( j &lt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[t++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        i = l;</span><br><span class="line">        <span class="keyword">while</span>( l &lt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            nums[l++] = tmp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 冒泡排序 </tag>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 139. 单词拆分</title>
      <link href="/2022/01/25/LeetCode-139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/"/>
      <url>/2022/01/25/LeetCode-139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/word-break/">https://leetcode-cn.com/problems/word-break/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>​        一开始的思路是逐个计算每个 <code>word</code> 出现在字符串的次数，然后加上长度，等于字符串长度就看成是可以拼接。但是这种思路的实现较为复杂，就没有实现。</p><p>​        可以换另一种思考方式，不求时间复杂度的优化，使用动态规划进行嵌套查询，遍历字符串的元素，将每个元素作为一个单词的截至字符，从头开始查是否存在到当前元素位置的字符串能够拼接成功。边界条件为：空串默认可以拼接。</p><p>具体代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;   <span class="comment">// 空串为 true</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( dp[j] &amp;&amp; wordDict.contains(s.substring(j, i)) )</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 85. 最大矩形</title>
      <link href="/2022/01/21/LeetCode-85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/"/>
      <url>/2022/01/21/LeetCode-85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximal-rectangle/">https://leetcode-cn.com/problems/maximal-rectangle/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>大致思路：求每一个元素在每一行作为宽的和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( j == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            mat[i][j] = matrix[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( matrix[i][j] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                mat[i][j] = mat[i][j - <span class="number">1</span>] + matrix[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着求每一个元素在每一列作为宽的最大和。下面两种方式都是在对这个步骤使用不同角度求解。</p><h3 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h3><p>在上述的计算之后，每一列的每个值都是所在行的以当前元素为右下角的高为1的矩形，现在遍历每个元素，从当前元素开始在列上往前遍历最小的和作为 <code>width</code> ，计算 <code>area = (i - k + 1) * width</code> 为当前最小 <code>width</code> 的对应面积，取最大面积。</p><p>具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] mat = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> maxarea = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( j == <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    mat[i][j] = matrix[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>( matrix[i][j] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        mat[i][j] = mat[i][j - <span class="number">1</span>] + matrix[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( i == <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    maxarea = Math.max(maxarea, mat[i][j]);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( mat[i][j] != <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> width = mat[i][j];</span><br><span class="line">                    <span class="keyword">for</span>( <span class="keyword">int</span> k = i; k &gt;= <span class="number">0</span> &amp;&amp; mat[k][j] != <span class="number">0</span>; --k )</span><br><span class="line">                    &#123;</span><br><span class="line">                        width = Math.min(width, mat[k][j]);</span><br><span class="line">                        maxarea = Math.max(maxarea, (i - k + <span class="number">1</span>) * width);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxarea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>可以先看这个题解的思路去思考：<a href="%5Bhttp://lannaie.top/2022/01/18/LeetCode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/#more%5D(http://lannaie.top/2022/01/18/LeetCode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/#more)">LeetCode - 84. 柱状图中最大的矩形</a>，思路是一样的。</p><p>我们将每一列横向看，作为一个柱状图，就可以套上面题解中单调栈的解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] mat = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> maxarea = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( j == <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    mat[i][j] = matrix[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>( matrix[i][j] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        mat[i][j] = mat[i][j - <span class="number">1</span>] + matrix[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>( !ind.empty() &amp;&amp; mat[ind.peek()][i] &gt;= mat[j][i] )</span><br><span class="line">                &#123;</span><br><span class="line">                    ind.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                left[j] = ind.empty() ? -<span class="number">1</span> : ind.peek();</span><br><span class="line">                ind.push(j);</span><br><span class="line">            &#125;</span><br><span class="line">            ind.clear();</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>( !ind.empty() &amp;&amp; mat[ind.peek()][i] &gt;= mat[j][i] )</span><br><span class="line">                &#123;</span><br><span class="line">                    ind.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                right[j] = ind.empty() ? m : ind.peek();</span><br><span class="line">                ind.push(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                maxarea = Math.max(maxarea, (right[j] - left[j] - <span class="number">1</span>) * mat[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxarea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 84. 柱状图中最大的矩形</title>
      <link href="/2022/01/18/LeetCode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/"/>
      <url>/2022/01/18/LeetCode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">https://leetcode-cn.com/problems/largest-rectangle-in-histogram/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>大致的解题方向：以当前元素为高，向左向右找到第一个小于这个高的边界 <code>left</code> 和 <code>right</code> ，<code>left + 1</code> 到 <code>right - 1</code> 为宽。</p><h3 id="1-暴力方式"><a href="#1-暴力方式" class="headerlink" title="1. 暴力方式"></a>1. 暴力方式</h3><p>遍历每个元素，为每个元素找到 <code>left</code> 和 <code>right</code> ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = heights.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> left = i, right = i;</span><br><span class="line">            <span class="keyword">while</span>( left &gt;= <span class="number">0</span> &amp;&amp; heights[left] &gt;= heights[i] )</span><br><span class="line">            &#123;</span><br><span class="line">                --left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>( right &lt; n &amp;&amp; heights[right] &gt;= heights[i] )</span><br><span class="line">            &#123;</span><br><span class="line">                ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max( res, (right - left - <span class="number">1</span>) * heights[i] );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为 <code>O(n2)</code> ，会超出时间限制。</p><h3 id="2-单调栈"><a href="#2-单调栈" class="headerlink" title="2. 单调栈"></a>2. 单调栈</h3><p>使用单调栈来存储元素，当栈顶元素比当前元素大，就出栈，直到找到第一个小于它的元素下标，因为要计算宽，所以栈中存放的是下标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = heights.length;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Stack&lt;Integer&gt; sta = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( !sta.empty() &amp;&amp; heights[sta.peek()] &gt;= heights[i] )</span><br><span class="line">            &#123;</span><br><span class="line">                sta.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( sta.empty() )</span><br><span class="line">            &#123;</span><br><span class="line">                left[i] = -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left[i] = sta.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            sta.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        sta.clear();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( !sta.empty() &amp;&amp; heights[sta.peek()] &gt;= heights[i] )</span><br><span class="line">            &#123;</span><br><span class="line">                sta.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( sta.empty() )</span><br><span class="line">            &#123;</span><br><span class="line">                right[i] = n;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right[i] = sta.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            sta.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        heights[<span class="number">0</span>] = (right[<span class="number">0</span>] - left[<span class="number">0</span>] - <span class="number">1</span>) * heights[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            heights[i] = Math.max(heights[i - <span class="number">1</span>], (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heights[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>此URL不支持Http方法GET</title>
      <link href="/2022/01/16/%E6%AD%A4URL%E4%B8%8D%E6%94%AF%E6%8C%81Http%E6%96%B9%E6%B3%95GET/"/>
      <url>/2022/01/16/%E6%AD%A4URL%E4%B8%8D%E6%94%AF%E6%8C%81Http%E6%96%B9%E6%B3%95GET/</url>
      
        <content type="html"><![CDATA[<h3 id="具体错误"><a href="#具体错误" class="headerlink" title="具体错误"></a>具体错误</h3><p><strong>类型</strong> 状态报告</p><p><strong>消息</strong> 此URL不支持Http方法GET</p><p><strong>描述</strong> 请求行中接收的方法由源服务器知道，但目标资源不支持</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ol><li>必须要实现 <code>doGet</code> 和 <code>doPost</code> 方法</li><li>必须要删除默认的 <code>super</code> 内容。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 报错 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java与MySQL读取和获取图片</title>
      <link href="/2022/01/15/Java%E4%B8%8EMySQL%E8%AF%BB%E5%8F%96%E5%92%8C%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87/"/>
      <url>/2022/01/15/Java%E4%B8%8EMySQL%E8%AF%BB%E5%8F%96%E5%92%8C%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h3 id="数据库的代码"><a href="#数据库的代码" class="headerlink" title="数据库的代码"></a>数据库的代码</h3><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS goods_settlement.COMMODITY(</span><br><span class="line">imgid int AUTO_INCREMENT PRIMARY KEY NOT NULL COMMENT &#x27;图片ID&#x27;,</span><br><span class="line">name VARCHAR(200) NOT NULL COMMENT &#x27;名称&#x27;,</span><br><span class="line">picture LONGBLOB COMMENT &#x27;图片&#x27;,</span><br><span class="line">cost DECIMAL(10, 2) COMMENT &#x27;价格&#x27;</span><br><span class="line">)</span><br><span class="line">COMMENT &#x27;商品表&#x27;</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>其中，MySQL有四种Blob类型：</p><ol><li>TinyBlob 最大 255B</li><li>Blob 最大 65K</li><li>MediumBlob 最大 16M </li><li>LongBlob 最大 4G</li></ol><p>插入图像的时候，注意下图像大小，图像超过该类型所能容纳的最大字节的时候，会报错。</p><h3 id="插入图片的二进制文件到mysql"><a href="#插入图片的二进制文件到mysql" class="headerlink" title="插入图片的二进制文件到mysql"></a>插入图片的二进制文件到mysql</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">( String name, String pic_url, <span class="keyword">double</span> cost )</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;INSERT INTO COMMODITY(name, picture, cost) values(?, ?, ?)&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span>(Connection conn = getConnection();</span><br><span class="line">        PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line">        FileInputStream input = <span class="keyword">new</span> FileInputStream(pic_url); )</span><br><span class="line">    &#123;</span><br><span class="line">        ps.setString(<span class="number">1</span>, name);</span><br><span class="line">        ps.setBinaryStream(<span class="number">2</span>, input, input.available());</span><br><span class="line">        ps.setBigDecimal(<span class="number">3</span>, BigDecimal.valueOf(cost));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = ps.executeUpdate();</span><br><span class="line">        <span class="keyword">if</span>( num &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;插入成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;插入失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取图片"><a href="#获取图片" class="headerlink" title="获取图片"></a>获取图片</h3><h4 id="获取非图片内容"><a href="#获取非图片内容" class="headerlink" title="获取非图片内容"></a>获取非图片内容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getGoods</span><span class="params">()</span> <span class="keyword">throws</span> SQLException, ClassNotFoundException </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;SELECT * FROM goods_settlement.COMMODITY&quot;</span>;</span><br><span class="line">        List&lt;Good&gt; goods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>(Connection conn = getConnection(); PreparedStatement ps = conn.prepareStatement(sql); ResultSet rs = ps.executeQuery())</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//            System.out.println(rs.getRow());</span></span><br><span class="line">            <span class="keyword">while</span>( rs.next() )</span><br><span class="line">            &#123;</span><br><span class="line">                Good good = <span class="keyword">new</span> Good();</span><br><span class="line">                Blob pic = rs.getBlob(<span class="string">&quot;picture&quot;</span>);</span><br><span class="line">                good.setImgid(rs.getInt(<span class="string">&quot;imgid&quot;</span>));</span><br><span class="line">                good.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                good.setCost(rs.getBigDecimal(<span class="string">&quot;cost&quot;</span>));</span><br><span class="line">                goods.add(good);</span><br><span class="line">            &#125;</span><br><span class="line">            Commodity.setGoods(goods);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="获取图片-1"><a href="#获取图片-1" class="headerlink" title="获取图片"></a>获取图片</h4><p>使用 <code>OutputStream.flush()</code> 映射上去，不知道怎么在同一页面操作。</p><p>通用的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">String imgid = request.getParameter(<span class="string">&quot;imgid&quot;</span>);</span><br><span class="line">String sql = <span class="string">&quot;SELECT picture FROM COMMODITY WHERE imgid = 1&quot;</span>;<span class="comment">// + imgid;</span></span><br><span class="line"><span class="keyword">try</span>(Connection conn = getConnection(); PreparedStatement ps = conn.prepareStatement(sql); ResultSet rs = ps.executeQuery()) &#123;</span><br><span class="line">    <span class="keyword">if</span>( rs.next() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建输入输出流</span></span><br><span class="line">        InputStream inputStream = rs.getBinaryStream(<span class="string">&quot;picture&quot;</span>);</span><br><span class="line">        OutputStream outputStream = response.getOutputStream(); <span class="comment">// 发送给jsp页面</span></span><br><span class="line">        <span class="keyword">int</span> num = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((num = inputStream.read()) != -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            outputStream.write(num);</span><br><span class="line">        &#125;</span><br><span class="line">        outputStream.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭输入输出流</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果类型是Blob，可以使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> String imgid = request.getParameter(<span class="string">&quot;imgid&quot;</span>);</span><br><span class="line"> String sql = <span class="string">&quot;SELECT picture FROM COMMODITY WHERE imgid = 1&quot;</span>;<span class="comment">// + imgid;</span></span><br><span class="line"> <span class="keyword">try</span>(Connection conn = getConnection(); PreparedStatement ps = conn.prepareStatement(sql); ResultSet rs = ps.executeQuery()) &#123;</span><br><span class="line">     <span class="keyword">if</span>( rs.next() )</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// 创建输入输出流</span></span><br><span class="line">         Blob b = rs.getBlob(<span class="string">&quot;photo_image&quot;</span>); </span><br><span class="line"><span class="keyword">long</span> size = b.length(); </span><br><span class="line"><span class="keyword">byte</span>[] bs = b.getBytes(<span class="number">1</span>, (<span class="keyword">int</span>)size); </span><br><span class="line">response.setContentType(<span class="string">&quot;image/jpeg&quot;</span>); </span><br><span class="line">OutputStream outs = response.getOutputStream(); </span><br><span class="line">outs.write(bs); </span><br><span class="line">outs.flush(); </span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 关闭输入输出流</span></span><br><span class="line">         inputStream.close();</span><br><span class="line">         outputStream.close();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="借鉴"><a href="#借鉴" class="headerlink" title="借鉴"></a>借鉴</h3><p><a href="https://www.cnblogs.com/nashiyue/p/4528155.html">Java BLOB 数据的插入与读取 操作</a></p><p><a href="https://www.cnblogs.com/jokerjason/p/5747690.html">JSP 实现 之 读取数据库显示图片</a></p>]]></content>
      
      
      <categories>
          
          <category> 项目小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>com.mysql.jdbc.MysqlDataTruncation: Data truncation: Data too long for column &#39;picture&#39; at row 1</title>
      <link href="/2022/01/14/com-mysql-jdbc-MysqlDataTruncation-Data-truncation-Data-too-long-for-column-picture-at-row-1/"/>
      <url>/2022/01/14/com-mysql-jdbc-MysqlDataTruncation-Data-truncation-Data-too-long-for-column-picture-at-row-1/</url>
      
        <content type="html"><![CDATA[<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>表字段设置长度不够。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>修改表字段长度设置。</p><p>本项目使用 <code>blob</code> 存储图片的二进制数报错，应改成 <code>longblob</code> 。</p>]]></content>
      
      
      <categories>
          
          <category> 报错 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSP页面中文乱码</title>
      <link href="/2022/01/14/JSP%E9%A1%B5%E9%9D%A2%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
      <url>/2022/01/14/JSP%E9%A1%B5%E9%9D%A2%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>将 <code>&lt;%@ page contentType=&quot;text/html;charset=udf-8&quot; language=&quot;java&quot; %&gt;</code></p><p>改为 <code>&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot; language=&quot;java&quot; %&gt;</code></p><p>修改地方：<code>udf-8</code> -&gt; <code>gb2312</code></p>]]></content>
      
      
      <categories>
          
          <category> 项目小记 </category>
          
          <category> 报错 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jsp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 55. 跳跃游戏</title>
      <link href="/2022/01/13/LeetCode-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"/>
      <url>/2022/01/13/LeetCode-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/jump-game/">https://leetcode-cn.com/problems/jump-game/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="HashSet去重-队列"><a href="#HashSet去重-队列" class="headerlink" title="HashSet去重 + 队列"></a>HashSet去重 + 队列</h3><p>使用队列按照插入顺序获取下标，插入前在 <code>HashSet</code> 中查找是否已经存在过此下标，直到队列中没有可以到达的下标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; unq_idxs = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; idxs = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        idxs.offer(<span class="number">0</span>);</span><br><span class="line">        unq_idxs.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>( !idxs.isEmpty() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = idxs.poll();</span><br><span class="line">            <span class="keyword">if</span>( nums[idx] + idx &gt;= nums.length - <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( nums[idx] == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>( <span class="keyword">int</span> i = idx + <span class="number">1</span>; i &lt;= idx + nums[idx]; ++i )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>( unq_idxs.add(i) )</span><br><span class="line">                    &#123;</span><br><span class="line">                        idxs.offer(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>记录每次能够到达的最远的下标位置，在这个 <code>maxlen</code> 的最远下标之前的所有下标都可以到达。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxlen = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( i &lt;= maxlen )</span><br><span class="line">            &#123;</span><br><span class="line">                maxlen = Math.max(maxlen, i + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( maxlen &gt;= len - <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( maxlen &gt;= nums.length - <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
            <tag> 队列 </tag>
            
            <tag> HashSet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习笔记 - 《深度学习入门：基于 Python 的理论与实现》</title>
      <link href="/2022/01/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%9A%E5%9F%BA%E4%BA%8E-Python-%E7%9A%84%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B/"/>
      <url>/2022/01/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%9A%E5%9F%BA%E4%BA%8E-Python-%E7%9A%84%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="注明"><a href="#注明" class="headerlink" title="注明"></a>注明</h2><p>使用环境：<strong>Python3.x</strong></p><p>使用外部库：<strong>Numpy</strong>用于数值计算，提供许多高级数学算法和遍历的矩阵操作方法、<strong>Matplotlib</strong>用于画图。</p><span id="more"></span><h2 id="Python入门"><a href="#Python入门" class="headerlink" title="Python入门"></a>Python入门</h2><h3 id="python解释器（基本的使用）"><a href="#python解释器（基本的使用）" class="headerlink" title="python解释器（基本的使用）"></a>python解释器（基本的使用）</h3><h4 id="版本查询"><a href="#版本查询" class="headerlink" title="版本查询"></a>版本查询</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;python --version</span><br></pre></td></tr></table></figure><p>进入 python 命令行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;python</span><br></pre></td></tr></table></figure><h4 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h4><ol><li><p>加（+）减（-）乘（*）与Java一致；</p></li><li><p><strong>除</strong>有两种情况：<code>/</code> 结果是小数，<code>//</code> 结果是整数；</p></li><li><p>** 乘方。</p></li></ol><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>使用 <code>type()</code> 获取。</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>直接赋值。如 <code>x = 10</code> 即可。</p><p>变量的类型是根据赋值情况自动决定的，赋值的是计算结果，也会自动转换为更大的一边。</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>使用 <code>#</code> 后的内容会被注释。</p><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>如 <code>arr = [1,2,3,4]</code></p><p>提供切片的方式访问某个值或某个子列表。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;arr[<span class="number">0</span>] <span class="comment"># == 1</span></span><br><span class="line">&gt;&gt;&gt;arr[<span class="number">1</span>:] <span class="comment"># == [2,3,4]</span></span><br><span class="line">&gt;&gt;&gt;arr[<span class="number">1</span>:<span class="number">3</span>] <span class="comment"># == [2,3]</span></span><br><span class="line">&gt;&gt;&gt;arr[:<span class="number">3</span>] <span class="comment"># == [1,2,3]</span></span><br><span class="line">&gt;&gt;&gt;arr[:-<span class="number">1</span>] <span class="comment"># 从第一个元素到最后一个元素，不包括最后一个元素，即 [1,2,3]</span></span><br><span class="line">&gt;&gt;&gt;arr[:-<span class="number">2</span>] <span class="comment"># 从第一个元素到倒数第二个元素，不包括最后两个元素，即[1,2]</span></span><br></pre></td></tr></table></figure><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>me = &#123;<span class="string">&#x27;height&#x27;</span>:<span class="number">180</span>&#125; <span class="comment"># 生成字典 </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>me[<span class="string">&#x27;height&#x27;</span>]        <span class="comment"># 访问元素 180 </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>me[<span class="string">&#x27;weight&#x27;</span>] = <span class="number">70</span>   <span class="comment"># 添加新元素 </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(me) &#123;<span class="string">&#x27;height&#x27;</span>: <span class="number">180</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">70</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h4><p>取 <code>True</code> 或 <code>False</code>，针对的运算符有：<code>and</code> 、<code>or</code> 、<code>not</code> 。</p><h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><p>参考以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> hungry:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;赶紧去吃饭&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> sleepy:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;赶紧去睡觉&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;那就再运动一会&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h4><p>参考一下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]:</span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># 1 2 3 4</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># 0 1 2 3</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># 1 2 3</span></span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span> </span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>) ... </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hello() </span><br><span class="line">Hello World!</span><br><span class="line"><span class="comment"># 此外，函数可以取参数。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params"><span class="built_in">object</span></span>):</span> </span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span>(<span class="string">&quot;Hello &quot;</span> + <span class="built_in">object</span> + <span class="string">&quot;!&quot;</span>) ... </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hello(<span class="string">&quot;cat&quot;</span>) </span><br><span class="line">Hello cat!</span><br></pre></td></tr></table></figure><h3 id="python脚本文件"><a href="#python脚本文件" class="headerlink" title="python脚本文件"></a>python脚本文件</h3><h4 id="保存为文件的步骤"><a href="#保存为文件的步骤" class="headerlink" title="保存为文件的步骤"></a>保存为文件的步骤</h4><ol><li><p>新建一个名为 <code>hungry.py</code> 的文件，内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;I am hungry!&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>执行命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python hungry.py</span><br></pre></td></tr></table></figure></li></ol><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>模板：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, 参数, …</span>):</span> <span class="comment"># 构造函数</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> 方法名1(<span class="params">self, 参数, …</span>):</span> <span class="comment"># 方法1</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> 方法名2(<span class="params">self, 参数, …</span>):</span> <span class="comment"># 方法2</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>其中， <code>__init__</code> 进行初始化的方法，也称为构造 函数（constructor），只在生成类的实例时被调用一次。</p><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Initialized!&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello &quot;</span> + self.name + <span class="string">&quot;!&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">goodbye</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Good-bye &quot;</span> + self.name + <span class="string">&quot;!&quot;</span>)</span><br><span class="line">m = Man(<span class="string">&quot;David&quot;</span>)</span><br><span class="line">m.hello()</span><br><span class="line">m.goodbye()</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python man.py</span><br><span class="line">Initialized!</span><br><span class="line">Hello David!</span><br><span class="line">Good-bye David!</span><br></pre></td></tr></table></figure><h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h4 id="Numpy数组"><a href="#Numpy数组" class="headerlink" title="Numpy数组"></a>Numpy数组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.array([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(x)</span><br><span class="line">[ <span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(x)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">numpy</span>.<span class="title">ndarray</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h4 id="一维数组算术运算"><a href="#一维数组算术运算" class="headerlink" title="一维数组算术运算"></a>一维数组算术运算</h4><p>两个数组进行算术运算要求元素个数必须相同，否则会报错。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 准备两个数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.array([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = np.array([<span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>])</span><br><span class="line"><span class="comment"># 相加</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x + y </span><br><span class="line">array([ <span class="number">3.</span>,  <span class="number">6.</span>, <span class="number">9.</span>]) </span><br><span class="line"><span class="comment"># 相减</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x - y</span><br><span class="line">array([ -<span class="number">1.</span>,  -<span class="number">2.</span>, -<span class="number">3.</span>])</span><br><span class="line"><span class="comment"># 相乘</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x * y </span><br><span class="line">array([  <span class="number">2.</span>,   <span class="number">8.</span>,  <span class="number">18.</span>])</span><br><span class="line"><span class="comment"># 相除</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x / y</span><br><span class="line">array([ <span class="number">0.5</span>,  <span class="number">0.5</span>,  <span class="number">0.5</span>])</span><br><span class="line"><span class="comment"># 和单一数值计算，也叫广播</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x / <span class="number">2.0</span></span><br><span class="line">array([ <span class="number">0.5</span>,  <span class="number">1.</span> ,  <span class="number">1.5</span>])</span><br></pre></td></tr></table></figure><h4 id="多维数组算术运算"><a href="#多维数组算术运算" class="headerlink" title="多维数组算术运算"></a>多维数组算术运算</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(A)</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>] [<span class="number">3</span> <span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.shape</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.dtype</span><br><span class="line">dtype(<span class="string">&#x27;int64&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B = np.array([[<span class="number">3</span>, <span class="number">0</span>],[<span class="number">0</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A + B</span><br><span class="line">array([[ <span class="number">4</span>,  <span class="number">2</span>],</span><br><span class="line">  [ <span class="number">3</span>, <span class="number">10</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A * B</span><br><span class="line">array([[ <span class="number">3</span>,  <span class="number">0</span>],</span><br><span class="line">       [ <span class="number">0</span>, <span class="number">24</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A * <span class="number">10</span></span><br><span class="line">array([[ <span class="number">10</span>, <span class="number">20</span>], </span><br><span class="line">       [ <span class="number">30</span>, <span class="number">40</span>]])</span><br></pre></td></tr></table></figure><p><code>shape</code> 查看行列数，<code>dtype</code> 查看数据类型。</p><h4 id="不同行列数的数组计算"><a href="#不同行列数的数组计算" class="headerlink" title="不同行列数的数组计算"></a>不同行列数的数组计算</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B = np.array([<span class="number">10</span>, <span class="number">20</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A * B</span><br><span class="line">array([[ <span class="number">10</span>, <span class="number">40</span>],</span><br><span class="line">       [ <span class="number">30</span>, <span class="number">80</span>]])</span><br></pre></td></tr></table></figure><p>上述例子，会将 <code>[10, 20]</code> 扩展成 <code>[[10,20],[10,20]]</code>，这种扩展功能叫广播。</p><h4 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h4><p>以下面数组为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = np.array([[<span class="number">51</span>, <span class="number">55</span>], [<span class="number">14</span>, <span class="number">19</span>], [<span class="number">0</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(X)</span><br><span class="line">[[<span class="number">51</span> <span class="number">55</span>]</span><br><span class="line"> [<span class="number">14</span> <span class="number">19</span>]</span><br><span class="line"> [ <span class="number">0</span>  <span class="number">4</span>]]</span><br><span class="line"><span class="comment"># 正常使用，获取(0, 1) 的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"><span class="number">55</span></span><br></pre></td></tr></table></figure><p>获取第0行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X[<span class="number">0</span>]    <span class="comment"># 第0行 </span></span><br><span class="line">array([<span class="number">51</span>, <span class="number">55</span>])</span><br><span class="line"><span class="comment"># 循环所有行</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> X:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(row)</span><br><span class="line">...</span><br><span class="line">[<span class="number">51</span> <span class="number">55</span>]</span><br><span class="line">[<span class="number">14</span> <span class="number">19</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>将多维数组转换为一维数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = X.flatten() <span class="comment"># 将X转换为一维数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(X)</span><br><span class="line">[<span class="number">51</span> <span class="number">55</span> <span class="number">14</span> <span class="number">19</span>  <span class="number">0</span>  <span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>过滤获取元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X &gt; <span class="number">15</span> </span><br><span class="line">array([ <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>], dtype=<span class="built_in">bool</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X[X&gt;<span class="number">15</span>]</span><br><span class="line">array([<span class="number">51</span>, <span class="number">55</span>, <span class="number">19</span>])</span><br><span class="line"><span class="comment"># 获取某几个下标的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X[np.array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>])] <span class="comment"># 获取索引为0、2、4的元素</span></span><br><span class="line">array([<span class="number">51</span>, <span class="number">14</span>,  <span class="number">0</span>])</span><br></pre></td></tr></table></figure><h3 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h3><h4 id="绘制简单图形"><a href="#绘制简单图形" class="headerlink" title="绘制简单图形"></a>绘制简单图形</h4><p>绘制 sin 函数图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 生成数据</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">6</span>, <span class="number">0.1</span>) <span class="comment"># 以0.1为单位，生成0到6的数据</span></span><br><span class="line">y = np.sin(x)</span><br><span class="line"><span class="comment"># 绘制图形</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="pyplot"><a href="#pyplot" class="headerlink" title="pyplot"></a>pyplot</h4><p>追加cos函数的图形，并尝试使用 pyplot的添加标题和x轴标签名等其他功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 生成数据</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">6</span>, <span class="number">0.1</span>) <span class="comment"># 以0.1为单位，生成0到6的数据</span></span><br><span class="line">y1 = np.sin(x)</span><br><span class="line">y2 = np.cos(x)</span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">plt.plot(x, y1, label=<span class="string">&quot;sin&quot;</span>)</span><br><span class="line">plt.plot(x, y2, linestyle = <span class="string">&quot;--&quot;</span>, label=<span class="string">&quot;cos&quot;</span>) <span class="comment"># 用虚线绘制</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;x&quot;</span>) <span class="comment"># x轴标签</span></span><br><span class="line">plt.ylabel(<span class="string">&quot;y&quot;</span>) <span class="comment"># y轴标签</span></span><br><span class="line">plt.title(<span class="string">&#x27;sin &amp; cos&#x27;</span>) <span class="comment"># 标题</span></span><br><span class="line">plt.legend() <span class="comment"># 显示图中标签</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h4 id="显示图像"><a href="#显示图像" class="headerlink" title="显示图像"></a>显示图像</h4><p>pyplot中的 <code>imshow()</code> 显示图像，image 的 <code>imread</code> 读取图像路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.image <span class="keyword">import</span> imread</span><br><span class="line">img = imread(<span class="string">&#x27;lena.png&#x27;</span>) <span class="comment"># 读入图像（设定合适的路径！）</span></span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>购物车结算系统-配置文件篇-项目小记</title>
      <link href="/2022/01/11/%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%BB%93%E7%AE%97%E7%B3%BB%E7%BB%9F-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AF%87-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/"/>
      <url>/2022/01/11/%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%BB%93%E7%AE%97%E7%B3%BB%E7%BB%9F-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AF%87-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="编写Properties文件"><a href="#编写Properties文件" class="headerlink" title="编写Properties文件"></a>编写Properties文件</h3><ol><li><p>文件名：<code>xxx.properties</code></p></li><li><p>内容格式：<code>key=value</code>，如 <code>driver=com.mysql.jdbc.Driver</code></p><p>如果 key 是多个单词组成，需要使用空格，可以使用反斜杠(\)对空格进行转移。如 <code>main form firstName=Stone</code> 可以修改为 <code>main\ form\ firstName=Stone</code></p></li></ol><span id="more"></span><h3 id="获取Properties文件的内容"><a href="#获取Properties文件的内容" class="headerlink" title="获取Properties文件的内容"></a>获取Properties文件的内容</h3><p>参考如下代码使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">      InputStream input;</span><br><span class="line">      String profile = <span class="string">&quot;jdbc.properties&quot;</span>;</span><br><span class="line">      <span class="comment">// 加载配置文件到输入流</span></span><br><span class="line">      input = DBUtil.class.getClassLoader().getResourceAsStream(profile);</span><br><span class="line">      <span class="comment">// 从输入流读取属性列表</span></span><br><span class="line">      pro.load(input);</span><br><span class="line">      <span class="comment">// 获取指定参数</span></span><br><span class="line">      String driver = pro.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">      String url = pro.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">      String username = pro.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">      String password = pro.getProperty(<span class="string">&quot;password&quot;</span>);</span><br></pre></td></tr></table></figure><p>其中，需要将 <code>jdbc.properties</code> 文件放到 <code>resource</code> 目录下。</p>]]></content>
      
      
      <categories>
          
          <category> 项目小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>购物车结算系统-MySQL篇-项目小记</title>
      <link href="/2022/01/11/%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%BB%93%E7%AE%97%E7%B3%BB%E7%BB%9F-MySQL%E7%AF%87-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/"/>
      <url>/2022/01/11/%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%BB%93%E7%AE%97%E7%B3%BB%E7%BB%9F-MySQL%E7%AF%87-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="JDBC连接数据库"><a href="#JDBC连接数据库" class="headerlink" title="JDBC连接数据库"></a>JDBC连接数据库</h3><p>参考以下代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String driver = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">String url = <span class="string">&quot;jdbc:mysql://192.168.186.100:3306/goods_settlement&quot;</span>;</span><br><span class="line">String username = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">Class.forName(driver);</span><br><span class="line">System.out.println(<span class="string">&quot;连接数据库 -----------------&quot;</span>);</span><br><span class="line">Connection conn = DriverManager.getConnection(url, username, password);</span><br><span class="line"><span class="keyword">return</span> conn;</span><br></pre></td></tr></table></figure><p>需要导入 <code>mysql-connector-java-xxx.jar</code> 包，我从 <code>pom.xml</code> 导入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Java执行SQL语句"><a href="#Java执行SQL语句" class="headerlink" title="Java执行SQL语句"></a>Java执行SQL语句</h3><h4 id="有三种接口"><a href="#有三种接口" class="headerlink" title="有三种接口"></a>有三种接口</h4><p>Statement、PreparedStatement、CallableStatement 。常见的是前两种，下面说明前两种。</p><p>其中Statement适用于普通不带参的语句，如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Statement s = conn.createStatement();</span><br><span class="line">String sql = <span class="string">&quot;select * from User where username = &quot;</span>abc<span class="string">&quot;&quot;</span>;</span><br><span class="line">s.executeQuery(sql);</span><br></pre></td></tr></table></figure><p>而PreparedStatement支持可变参数的语句，如  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">&quot;select * from User where username = ?&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.preparedStatement(sql);</span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">ps.executeQuery();</span><br></pre></td></tr></table></figure><p><strong>SQL的执行需要编译和解析</strong></p><p><strong>Statement每次的执行都需要编译SQL</strong></p><p><strong>PreparedStatement会预编译，会被缓冲，在缓存区中可以发现预编译的命令，虽然会被再次解析，但不会被再次编译，能够有效提高系统性能</strong></p><h4 id="有四种执行形式"><a href="#有四种执行形式" class="headerlink" title="有四种执行形式"></a>有四种执行形式</h4><p>executeQuery、executeUpdate、execute、batch。</p><ol><li><strong>executeQuery</strong>：用于执行 select 语句，返回单个结果集 ResultSet；</li><li><strong>executeUpdate</strong>：用于执行 INSERT、UPDATE 或 DELETE 语句以及 SQL DDL（数据定义语言）语句，例如 CREATE TABLE 和 DROP TABLE。返回值是一个整数，指示受影响的行数（即更新计数）。对于 CREATE TABLE 或 DROP TABLE 等不操作行的语句，executeUpdate 的返回值总为零。</li><li><strong>execute</strong>：可以执行所有SQL，返回值用于区分是返回的结果集还是受影响的行，换句话说，true表示SELECT false表示INSERT UPDATE DELETE。如果是返回结果集，必须使用方法 getResultSet 或 getUpdateCount 来获取结果，使用 getMoreResults 来移动后续结果。</li><li><strong>batch</strong>：即批处理，此处不做详述。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 42. 接雨水</title>
      <link href="/2022/01/09/LeetCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"/>
      <url>/2022/01/09/LeetCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/">https://leetcode-cn.com/problems/trapping-rain-water/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>​        已知一个常识，如果想要存水，我们至少需要一个凹面。即左右下标的高度要高于中间下标的高度才能成功存水。那应该怎么计算存水量呢：<br>$$<br>存水量 &#x3D; min(height_{left}, height_{right}) * (right - left - 1)<br>$$<br>​        但是这里面又有一个问题，就是当多个凹面嵌套时，可能会导致重复计算。此处再分析导致重复计算的原因：内层的凹面比外层的凹面小，所以会导致计算外层凹面时将内层凹面也计算进去，那就是说，在距离无法更改的情况下，应该是 <code>min(left_height, right_height)</code> 取的较小值，外层比内层大导致的。</p><p>​        基于上述思考，我们可以得到一个方法：使用两个数组：<code>leftmax</code> 和 <code>rightmax</code> ，将从左到右和从右到左的最大高度记录下来，这样，定位每一个下标的时候，就可以取对当前下标来说的两个最大高度的较小值作为它的高度，由于当前定位下标计算，所以距离始终为 <code>1</code> ，只要减去当前下标占据的高度，就可以得到当前下标对应的存水量。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = height.length;</span><br><span class="line">        <span class="keyword">int</span>[] left_max = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] right_max = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        left_max[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            left_max[i] = Math.max(height[i], left_max[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        right_max[len - <span class="number">1</span>] = height[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i )</span><br><span class="line">        &#123;</span><br><span class="line">            right_max[i] = Math.max(height[i], right_max[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            res += Math.min(left_max[i], right_max[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>基于动态规划的思路，可以进行优化：将两个数组转换为两个指针 <code>left = 0</code> 和 <code>right = len - 1</code> ， 使用两个元素存储当前左右两边的最大高度：<code>leftmax</code> 和 <code>rightmax</code> 。</p><p>注意的是思路会有所不同：</p><ol><li>先分别获取当前左右下标的最大高度；</li><li>然后取左右最大高度的较小值；</li><li>我们应该能有一个理解：比如当 <code>leftmax &lt; rightmax</code> 时，这个 <code>&lt;</code> 的意思是，左侧的 <code>left</code> 指针，它的左右两边的较小高度是 <code>leftmax</code> ，因为比较的不是当前这个凹面的左右，而是当前这个下标所在的最大凹面的左右，而对于当前这个 <code>left</code> 下标来说，右侧的 <code>rightmax</code> 对它不一定是更小的右侧，但是 <code>leftmax</code> 一定是最大的左侧。当右侧有比 <code>rightmax</code> 小的，一定会有 <code>rightmax</code> 这个比它大的外层；当右侧有比 <code>rightmax</code> 大的，左侧小于 <code>rightmax</code> 一定会小于比它大的。所以综上，当 <code>leftmax &lt; rightmax</code> 时，<code>leftmax</code> 一定是当前下标左右两侧最大高度的较小值。</li><li>后续计算与动态规划一致。</li></ol><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftmax = <span class="number">0</span>, rightmax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( left &lt;= right )</span><br><span class="line">        &#123;</span><br><span class="line">            leftmax = Math.max(leftmax, height[left]);</span><br><span class="line">            rightmax = Math.max(rightmax, height[right]);</span><br><span class="line">            <span class="keyword">if</span>( leftmax &lt; rightmax )</span><br><span class="line">            &#123;</span><br><span class="line">                res += leftmax - height[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res += rightmax - height[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>和上述的思想其实很近：</p><ol><li>当 <code>height[i] &lt;= height[i - 1]</code> 时，会形成左边的凹面，这时候无法计算，将 <code>i、i - 1</code> 即左侧和中间下标存储到栈中，继续遍历；</li><li>当 <code>height[i] &lt; height[i + 1]</code> 时，可能会形成完整的凹面，此时将栈顶的中间下标取出，但是左侧下标不取出，因为可能存在嵌套凹面，此时的左侧可能会成为外层凹面的中间；</li><li>之后只要计算出凹面的较小高度和距离就可以计算当前这个凹面的存水量了。</li></ol><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( !stack.empty() &amp;&amp; height[i] &gt; height[stack.peek()] )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> top = stack.pop();</span><br><span class="line">                <span class="keyword">if</span>( stack.empty() )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> left = stack.peek();</span><br><span class="line">                <span class="keyword">int</span> curheight = Math.min(height[i], height[left]) - height[top];</span><br><span class="line">                <span class="keyword">int</span> curwide = i - left - <span class="number">1</span>;</span><br><span class="line">                res += curwide * curheight;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 39. 组合总和</title>
      <link href="/2022/01/08/LeetCode-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"/>
      <url>/2022/01/08/LeetCode-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/combination-sum/">https://leetcode-cn.com/problems/combination-sum/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这里简单的区分一下递归和回溯：递归就是直接或间接的调用自己，回溯相较于递归的区别，就是它有剪枝的功能，知道这条路走不通，会换另一条路走。</p><p>我一开始使用递归的思路解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        getCombination(candidates, target, res, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCombination</span><span class="params">( <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tmp )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( target &lt;= <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( target == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmp));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> can : candidates )</span><br><span class="line">        &#123;</span><br><span class="line">            tmp.add(can);</span><br><span class="line">            getCombination(candidates, target - can, res, tmp);</span><br><span class="line">            tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种方法的结果是错的，相当于将结果内部全排序了。所以必须用到<strong>剪枝的思想</strong>。</p><p>应该对 <code>candidates</code> 数组升序排序，然后为了防止全排序，又因为元素可以重复，所以应该从当前下标开始遍历。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        getCombination(candidates, target, res, <span class="keyword">new</span> ArrayList&lt;&gt;(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCombination</span><span class="params">( <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tmp, <span class="keyword">int</span> idx )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( target == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( ; idx &lt; candidates.length; ++idx )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( target - candidates[idx] &lt; <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.add(candidates[idx]);</span><br><span class="line">            getCombination(candidates, target - candidates[idx], res, tmp, idx);</span><br><span class="line">            tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>购物车结算系统-JS篇-项目小记</title>
      <link href="/2022/01/07/%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%BB%93%E7%AE%97%E7%B3%BB%E7%BB%9F-JS%E7%AF%87-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/"/>
      <url>/2022/01/07/%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%BB%93%E7%AE%97%E7%B3%BB%E7%BB%9F-JS%E7%AF%87-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="document"><a href="#document" class="headerlink" title="document"></a>document</h3><blockquote><p>借鉴：<a href="https://www.cnblogs.com/www1842564021/p/11830139.html">https://www.cnblogs.com/www1842564021/p/11830139.html</a></p></blockquote><ol><li><strong>document.getElementById()：返回对拥有指定 id 的第一个对象的引用。</strong></li><li><strong>document.getElementsByName()：返回带有指定名称的对象集合，也就是如果有多个相同name的元素，会返回数组。</strong></li><li><strong>document.getElementsByTagName()：返回带有指定标签名的对象集合。</strong></li><li><strong>document.getElementsByClassName()：返回对拥有指定 class 的对象集合。</strong></li></ol><span id="more"></span><h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><p>设置或返回密码域的默认值。</p><p>用法如：<code>document.getElementById(&quot;username&quot;).value</code>，返回结果为<strong>字符串</strong>。</p><h3 id="location-href"><a href="#location-href" class="headerlink" title="location.href"></a>location.href</h3><blockquote><p>借鉴：<a href="https://www.w3school.com.cn/js/js_window_location.asp">https://www.w3school.com.cn/js/js_window_location.asp</a></p></blockquote><p>一些类似的例子：</p><ul><li>window.location.href 返回当前页面的 href (URL)</li><li>window.location.hostname 返回 web 主机的域名</li><li>window.location.pathname 返回当前页面的路径或文件名</li><li>window.location.protocol 返回使用的 web 协议（http: 或 https:）</li><li>window.location.assign 加载新文档</li></ul><p>本项目将它与 &lt;form&gt; 表单的 <code>onsubmit</code> 方法连用，用于判断密码是否正确，如果正确跳转到指定的链接。</p><p>如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">checkPassword</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">document</span>.getElementById(<span class="string">&quot;username&quot;</span>).value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          alert(<span class="string">&quot;用户名为空。&quot;</span>)</span><br><span class="line">      &#125;<span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">location.href=<span class="string">&#x27;basic_info.jsp&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="alert"><a href="#alert" class="headerlink" title="alert"></a>alert</h3><blockquote><p>借鉴：<a href="https://www.w3school.com.cn/js/js_popup.asp">https://www.w3school.com.cn/js/js_popup.asp</a></p></blockquote><p>用于显示带有一条指定消息和一个 OK 按钮的警告框。</p><p>用法：<code>window.alert(&quot;I am an alert box!!&quot;)</code>，前缀 <code>window.</code> 可以省略不写。</p><p>类似的：</p><p><strong>confirm(“sometext”)</strong></p><p>确认框。如果用户单击“确定”，该框返回 true。如果用户单击“取消”，该框返回 false。</p><p>如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = confirm(<span class="string">&quot;请按按钮&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (r == <span class="literal">true</span>) &#123;</span><br><span class="line">    x = <span class="string">&quot;您按了确认！&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    x = <span class="string">&quot;您按了取消！&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>prompt(“sometext”,”defaultText”)</strong></p><p>提示框。如果用户单击“确定”，该框返回输入值。如果用户单击“取消”，该框返回 NULL。</p><p>如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = prompt(<span class="string">&quot;请输入您的姓名&quot;</span>, <span class="string">&quot;比尔盖茨&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (person != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>).innerHTML = <span class="string">&quot;你好 &quot;</span> + person + <span class="string">&quot;！今天过的怎么样？&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for，if"><a href="#for，if" class="headerlink" title="for，if"></a>for，if</h3><p>和 java 一样。</p><p>不同的是，0 和 1 可以作为 false 和 true 使用。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>购物车结算系统-CSS篇-项目小记</title>
      <link href="/2022/01/06/%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%BB%93%E7%AE%97%E7%B3%BB%E7%BB%9F-CSS%E7%AF%87-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/"/>
      <url>/2022/01/06/%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%BB%93%E7%AE%97%E7%B3%BB%E7%BB%9F-CSS%E7%AF%87-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>常用的选择器如下：</p><span id="more"></span><ol><li><code>.exam</code> ：选择所有class&#x3D;”exam”的元素；</li><li><code>#exam</code> ：选择所有id&#x3D;”exam”的元素；</li><li><code>*</code> ：选择所有元素；</li><li><code>div</code> ：选择所有&lt;div&gt;元素；</li><li><code>div,p</code> ：选择所有&lt;div&gt;元素和&lt;p&gt;元素；</li><li><code>div p</code> ：选择&lt;div&gt;元素内的所有&lt;p&gt;元素；</li><li><code>div&gt;p</code> ：选择所有父级是 &lt;div&gt; 元素的 &lt;p&gt; 元素；</li><li><code>[input=text]</code> ：选择所有 &lt;input type&#x3D;”text”&gt; 元素；</li><li><code>a:link</code>：选择所有未访问链接；</li><li><code>a:visited</code>：选择所有访问过的链接；</li><li><code>a:active</code>：选择点击后的链接；</li><li><code>a:hover</code> ：选择鼠标在链接上面时。</li></ol><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><p>应用于元素的2D或3D转换。这个属性允许你将元素旋转，缩放，移动，倾斜等。</p><p>本项目中使用：<code>transform: translate(-50%,-50%);</code></p><p>即往上（x轴）,左（y轴）移动自身长宽的 50%，以使其居于中心位置。</p><p><strong>用处：实现水平垂直居中。</strong></p><h3 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h3><p>设置一个或多个下拉阴影的框。</p><p>语法：<code>box-shadow: h-shadow v-shadow blur spread color inset;</code></p><table><thead><tr><th align="center"><em>h-shadow</em></th><th align="center">必需的。水平阴影的位置。允许负值</th></tr></thead><tbody><tr><td align="center"><em>v-shadow</em></td><td align="center">必需的。垂直阴影的位置。允许负值</td></tr><tr><td align="center"><em>blur</em></td><td align="center">可选。模糊距离</td></tr><tr><td align="center"><em>spread</em></td><td align="center">可选。阴影的大小</td></tr><tr><td align="center"><em>color</em></td><td align="center">可选。阴影的颜色。</td></tr><tr><td align="center">inset</td><td align="center">可选。从外层的阴影（开始时）改变阴影内侧阴影</td></tr></tbody></table><h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p>规定元素的定位类型。</p><table><thead><tr><th>absolute</th><th>生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</th></tr></thead><tbody><tr><td>fixed</td><td>生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</td></tr><tr><td>relative</td><td>生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。</td></tr><tr><td>static</td><td>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 position 属性的值。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 项目小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 15. 三数之和</title>
      <link href="/2022/01/04/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2022/01/04/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/3sum/">https://leetcode-cn.com/problems/3sum/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用双指针解决该题，问题是这个双指针该怎么用，因为需要获取所有满足为0的三元数组，所以固定一个元素，取头尾指针的方法行不通，可以考虑固定两个元素，然后动态遍历第三个元素。即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; ++i )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] )</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n - <span class="number">1</span>; ++j )</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>( j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>] )</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">int</span> k = j + <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">while</span>( k &lt; len )</span><br><span class="line">           &#123;</span><br><span class="line">               ......</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，因为相同元素回得到相同的答案，所以需要对每个固定元素去重，即上述代码中的 <code>if语句</code> 。</p><p>但是这种方式还是会超出时间限制，所以需要对循环进行优化。因为前两个固定元素没有优化的空间，所以需要考虑第三个元素的优化。</p><p>通过观察可以知道，在非降序数组中，固定了第一个元素，第二个元素越大，所需要的第三个元素理应更小，且会比上一个确定的第三个元素更小，所以可以优化第三个元素在遍历一次 <code>i</code> 的时候，<code>k</code> 也只遍历一次。即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; ++i )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] )</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 将 k 提出来，在本次j遍历完，k也只遍历一次</span></span><br><span class="line">       <span class="keyword">int</span> k = n - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n - <span class="number">1</span>; ++j )</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>( j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>] )</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span>( j &lt; k )</span><br><span class="line">           &#123;</span><br><span class="line">               ......</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>( len &lt; <span class="number">3</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> k = len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len - <span class="number">1</span>; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>] )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>( j &lt; k &amp;&amp; nums[i] + nums[j] + nums[k] &gt; <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    --k;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( j &gt;= k )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( nums[i] + nums[j] + nums[k] == <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(nums[i], nums[j], nums[k])));</span><br><span class="line">                    <span class="comment">// break;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>购物车结算系统 - HTML篇 - 项目小记</title>
      <link href="/2022/01/03/%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%BB%93%E7%AE%97%E7%B3%BB%E7%BB%9F-HTML%E7%AF%87-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/"/>
      <url>/2022/01/03/%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%BB%93%E7%AE%97%E7%B3%BB%E7%BB%9F-HTML%E7%AF%87-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="form"><a href="#form" class="headerlink" title="form"></a>form</h3><h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><p>使用：<code>action=&quot;[跳转页面名称].jsp&quot;</code></p><p>如：<code>action=&quot;choose_goods.jsp&quot;</code></p><span id="more"></span><h4 id="method"><a href="#method" class="headerlink" title="method"></a>method</h4><p>有两个值：<code>post</code> 不显示中间 <code>input</code> 内容，<code>get</code> 显示。</p><p><strong>get：</strong></p><ol><li>请求参数会在地址栏中显示，会封装在请求行中</li><li>请求参数的大小是有限制的</li><li>请求方式不安全</li></ol><p><strong>post：</strong></p><ol><li>请求参数不会在地址栏中显示，会封装在请求体中</li><li>请求参数的大小没有限制</li><li>请求方式比较安全</li></ol><p>请求参数为中间 <code>&lt;input&gt;</code> 元素的结果。</p><p>一般情况 <code>&lt;form&gt;</code> 与 <code>&lt;input&gt;</code> 连用，当使用 <code>&lt;input type=&quot;submit&quot;&gt;</code> 按钮的时候会将其中的 <code>&lt;input&gt;</code> 的参数传第到指定跳转页面。</p><p>具体实例：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;choose_goods.jsp&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;input_field&quot;</span>&gt;</span><br><span class="line">          &lt;input name=<span class="string">&quot;username&quot;</span> type=<span class="string">&quot;text&quot;</span> required=<span class="string">&quot;required&quot;</span> placeholder=<span class="string">&quot;用户名&quot;</span>&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;input_field&quot;</span>&gt;</span><br><span class="line">          &lt;input name=<span class="string">&quot;password&quot;</span> type=<span class="string">&quot;password&quot;</span> required=<span class="string">&quot;required&quot;</span> placeholder=<span class="string">&quot;密码&quot;</span>&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;input_field&quot;</span>&gt;</span><br><span class="line">          &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;登录&quot;</span>&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h4 id="onsubmit"><a href="#onsubmit" class="headerlink" title="onsubmit"></a>onsubmit</h4><p>点击 <code>&lt;input type=&quot;submit&quot;&gt;</code> 按钮时会触发指定函数。</p><p>使用：<code>onsubmit=&quot;checkPayword()&quot;</code>。</p><h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>常用的值如下：</p><ol><li>text：定义单行的输入字段，用户可在其中输入文本。默认宽度为 20 个字符。</li><li>submit：定义提交按钮。提交按钮会把表单数据发送到服务器。</li><li>buttom：定义可点击按钮（多数情况下，用于通过 JavaScript 启动脚本）。</li><li>password：定义密码字段。该字段中的字符被掩码。</li></ol><h4 id="required"><a href="#required" class="headerlink" title="required"></a>required</h4><p>表示该字段是必填的，不能为空。</p><h4 id="placeholder"><a href="#placeholder" class="headerlink" title="placeholder"></a>placeholder</h4><p>规定可描述输入字段预期值的简短的提示信息。也就是提示。</p><h4 id="value"><a href="#value" class="headerlink" title="value"></a>value</h4><p>input元素显示的值。</p><h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><p>该input元素的名称。</p><h4 id="maxlength"><a href="#maxlength" class="headerlink" title="maxlength"></a>maxlength</h4><p>规定输入字段的最大长度，以字符个数计。</p><h4 id="onclick"><a href="#onclick" class="headerlink" title="onclick"></a>onclick</h4><p>点击按钮事件。</p><h4 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h4><p>规定输入字段为只读，不可修改。</p><h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><h4 id="rel"><a href="#rel" class="headerlink" title="rel"></a>rel</h4><p>规定当前文档与被链接文档&#x2F;资源之间的关系，是必须的。</p><p>使用如：<code>rel=&quot;stylesheet&quot;</code></p><p>常用的值如下：</p><ol><li>stylesheet：要导入的样式表的 URL。</li><li>next： 表示该文档是集合中的一部分，且集合中的下一个文档是被引用的文档。</li><li>icon：导入表示该文档的图标。</li><li>alternate：链接到该文档的替代版本（比如打印页、翻译或镜像）。</li></ol><h4 id="href"><a href="#href" class="headerlink" title="href"></a>href</h4><p>规定外部资源（通常是样式表文件）的位置（URL）。</p><p>使用：<code>&lt;link href=&quot;URL&quot;&gt;</code></p><p>绝对URL - 指向另一个网站，如： <code>href=&quot;http://www.example.com/theme.css&quot;</code></p><p>相对URL - 指向网站内的一个文件，如： <code>href=&quot;/themes/theme.css&quot;</code></p><p><strong>此处有一个使用技巧：</strong></p><p>因为这种方式导入文件，这个文件就已经在浏览器加载过了，之后再进入此浏览器这个文件不会在被加载，为了保证每次进入浏览器的文件都是最新的，可以在导入的文件后添加这样的内容：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?v=&lt;%= System.currentTimeMillis()%&gt;</span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">href=<span class="string">&quot;/themes/theme.css?v=&lt;%= System.currentTimeMillis()%&gt;&quot;</span></span><br></pre></td></tr></table></figure><p><code>System.currentTimeMillis()</code> 就是获取系统的当前时间戳，相当于给文件一个版本号，这样每次进入浏览器，文件都会被更新。</p><h3 id="onclick-x3D-”this-form-onsubmit-”"><a href="#onclick-x3D-”this-form-onsubmit-”" class="headerlink" title="onclick&#x3D;”this.form.onsubmit()”"></a>onclick&#x3D;”this.form.onsubmit()”</h3><p>本项目使用在 点击 <code>&lt;input type=&quot;buttom&quot;&gt;</code> 按钮后检查密码是否合法。</p><p>意思就是点击这个按钮，会触发 <code>this</code> 这个 <code>form</code> 表单的 <code>obsubmit()</code> 这个方法指向的js方法。</p>]]></content>
      
      
      <categories>
          
          <category> 项目小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 11. 盛最多水的容器</title>
      <link href="/2022/01/03/LeetCode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
      <url>/2022/01/03/LeetCode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/container-with-most-water/">https://leetcode-cn.com/problems/container-with-most-water/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>双指针是立刻能想到的方向，只是可能无法运用。</p><p>可以这样思考：最终需要的结果 <code>容纳最多的水</code> 的计算公式是：<br>$$<br>容纳的水量 &#x3D; min(height[left], height[right]) * (right - left)<br>$$<br>即容纳的水量是由两个端点中的较小值和两个端点的距离决定的，所以要么扩大扩大两个端点的距离，要么增大较小值。</p><p>这里可以使用 <code>left = 0, right = height.length - 1</code> 两个指针来指定初始的两个端点，因为在距离稳定减少的情况下，如果我们移动数字较大的那个指针，那么前者「两个指针指向的数字中较小值」不会增加，后者「指针之间的距离」会减小，那么这个乘积会减小。因此，我们移动数字较大的那个指针是不合理的。因此，我们移动 数字较小的那个指针。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxwater = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( left &lt; right )</span><br><span class="line">        &#123;</span><br><span class="line">            maxwater = Math.max(Math.min(height[left], height[right]) * (right - left), maxwater);</span><br><span class="line">            <span class="keyword">if</span>( height[left] &lt; height[right] )</span><br><span class="line">            &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxwater;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 377. 组合总和 Ⅳ</title>
      <link href="/2021/12/29/LeetCode-377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A3/"/>
      <url>/2021/12/29/LeetCode-377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/combination-sum-iv/">https://leetcode-cn.com/problems/combination-sum-iv/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>首先需要知道边界条件：<code>target = 0</code> 时只有一种情况，就是不使用数组元素的时候，这种情况返回1；<code>target &lt; 0</code> 时返回0，即不会有这种情况，因为数组元素均 <code>&gt;= 1</code> ，所以就算不使用数组元素，最小也是0，不可能会存在使得 <code>target &lt; 0</code> 的排列方法；</li><li>计算区间 <code>[1, target]</code> 内的所有整数，遍历所有数组元素满足当前tar的排列。</li></ol><h3 id="1-记忆化搜索"><a href="#1-记忆化搜索" class="headerlink" title="1. 记忆化搜索"></a>1. 记忆化搜索</h3><p>记忆化搜索可以说是递归调用的优化版本，即使用一个数组来存储已经遍历过的元素，此处将 <code>target</code> 看作数组 <code>tar = &#123;1, ... , target&#125;</code> ，记录每个 <code>tar[i]</code> 的结果，已经遍历过的元素不需要重复遍历，只需要对没有遍历过的 <code>tar[i]</code> 遍历计算 <code>nums</code> 数组的元素即可，最终将最终结果 <code>tar[target]</code> 返回，即第一轮遍历的结果。</p><p>这里创建一个 <code>count</code> 数组存放每一个 <code>tar[i]</code> 遍历的结果，默认值为-1，因为有可能 <code>tar[i]</code> 遍历的结果就算0，如果默认 <code>count[i]</code> 为0，还是会导致很多重复计算，最终超时。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        count[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            count[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getCombination(count, nums, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCombination</span><span class="params">( <span class="keyword">int</span>[] count, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> target )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( target &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( count[target] != -<span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> count[target];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            cnt += getCombination(count, nums, target - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        count[target] = cnt;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2. 动态规划"></a>2. 动态规划</h3><p>该方法其实就是记忆化搜索的迭代版本，使用嵌套循环模仿递归执行，其中 <code>i</code> 即 <code>tar[i]</code> ，j遍历 <code>nums</code> ，由此得出每一个 <code>i</code> 的排列结果。</p><p>此处 有一个 <code>dp[i] += dp[i - nums[j]]</code> ，因为 <code>tar[i]</code> 的排列结果是建立在 <code>tar[0] ~ tar[i - 1]</code> 上的，比如 <code>tar[2] = 2</code> ，前面的值为 <code>dp[0] = 1; dp[1] = 1</code> ，确定一个元素 <code>i - 1 == 1</code> ，然后这个元素可以放在 <code>tar[1]</code> 元素的排列结果后，<code>dp[1]</code> 的排列记过是：<code>&#123;1&#125;</code> 构成针对于 <code>tar[2]</code> 的结果集：<code>&#123;1,1&#125;</code> ，以此类推，就可以理解为什么只需要加上 <code>dp[i - nums[j]]</code> 就可以。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( i - nums[j] &gt;= <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] += dp[i - nums[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 记忆化搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsp引用外部css文件失效</title>
      <link href="/2021/12/27/jsp%E5%BC%95%E7%94%A8%E5%A4%96%E9%83%A8css%E6%96%87%E4%BB%B6%E5%A4%B1%E6%95%88/"/>
      <url>/2021/12/27/jsp%E5%BC%95%E7%94%A8%E5%A4%96%E9%83%A8css%E6%96%87%E4%BB%B6%E5%A4%B1%E6%95%88/</url>
      
        <content type="html"><![CDATA[<h3 id="失效的内容"><a href="#失效的内容" class="headerlink" title="失效的内容"></a>失效的内容</h3><p>css：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.goodpage</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: white;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">3px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p>jsp:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;css/style.css&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;goodpage&quot;</span>&gt;</span><br><span class="line">        asdf</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><p>结果css样式没有起到作用，jsp的内容在左上角顶格出现。</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>我的代码出现这个bug的原因：因为客户端缓存了修改之前的css文件，在下次再加载的时候，客户端不会加载之前缓存的同名文件。</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>修改css文件的名称，或者给文件名称添加一个版本号，此处使用系统时间戳作为版本号：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;css/style.css?v=&lt;%= System.currentTimeMillis()%&gt;&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>不用在实际文件中添加，这种 <code>?v | ?version</code> 只是给这个链接添加一个版本号的参数，目的是让客户端区分文件。</p>]]></content>
      
      
      <categories>
          
          <category> 项目小记 </category>
          
          <category> 报错 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jsp </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 5. 最长回文子串</title>
      <link href="/2021/12/25/LeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2021/12/25/LeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-中心扩散法"><a href="#1-中心扩散法" class="headerlink" title="1. 中心扩散法"></a>1. 中心扩散法</h3><p>这种方法应该是最容易想到的思路，唯一的问题是需要判断从当前位置为 <code>left</code> 出发，<code>right</code> 究竟是 <code>i</code> 还是 <code>i + 1</code> 长度更大。具体的思路如下：</p><ol><li>单独提一个函数 <code>centralExtension( String s, int left, int right )</code> 来计算从当前 <code>left</code> 和 <code>right</code> 出发的最长子串长度；</li><li>在主函数中遍历字符串的时候，比较以<code>left = i</code> 的时候，<code>right = i</code> 和 <code>right = i + 1</code> 的情况，哪个长度更大，取最大长度，然后与当前 <code>maxlen = end - start</code> 最大长度比较，如果比它大，就替换；</li><li>此处有一个小问题，为什么 <code>start = i - (len - 1) / 2</code> ，因为我们直接获得了两种 <code>right</code> 情况的最大值，以最小的例子来看，<code>left == right == 1</code> 的时候，<code>left = i - 1 / 2 = i</code> 成立，<code>left == i, j == i + 1</code> 的时候，<code>left = i - 2 / 2 = i - 1</code> 不成立，可以推出，<code>left = i - (1 - 1) / 2 == i - (2 - 1) / 2 == i</code> 成立。</li></ol><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( s == <span class="keyword">null</span> || s.length() == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> len = Math.max(centralExtension(s, i, i), centralExtension(s, i, i + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>( len &gt; (end - start) )</span><br><span class="line">            &#123;</span><br><span class="line">                start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                end = i + len / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">centralExtension</span><span class="params">( String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right) )</span><br><span class="line">        &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2. 动态规划"></a>2. 动态规划</h3><p>以 <code>babad</code> 为例，有如下步骤：</p><ol><li><p>首先我们应该知道简单的状态转移方程：当 <code>s.charAt(i) == s.charAt(j)</code> 且 <code>s.substring(i + 1, j)</code> 即区间 <code>[i+1, j-1]</code> 的子串也是回文串，则当前区间 <code>[i, j]</code> 的字符串为回文串；</p></li><li><p>已知的边界条件：当 <code>s.length == 1</code> 的时候，肯定是回文串，如 <code>a</code> 、<code>b</code> 等，所以应该创建一个 <code>dp</code> 的二维数组，来存放当前字符串是否为回文串，初始化每个字符都是回文串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> L = <span class="number">0</span>; L &lt; n; ++L )</span><br><span class="line">&#123;</span><br><span class="line">    dp[L][L] = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>并记录一个 <code>maxlen = 1</code> 和 <code>start = 0</code> ；</p></li><li><p>接着逐步遍历长度为 <code>2 ~ n</code> 的子串，看是否有长度比 <code>maxlen</code> 更大的回文子串；</p></li><li><p>这里需要注意一点，当确定 <code>s.charAt(i) == s.charAt(j)</code> 时，有两种情况，第一种是 <code>L &lt;= 3</code> ，即 <code>j - i &lt; 3</code> ，这时当前 <code>i, j</code> 之间最多只有一个元素，而单个元素肯定是回文串，所以直接赋值 <code>true</code> ，如果 <code>L &gt; 3</code> ，则需要判断 <code>[i + 1, j - 1]</code> 这个区间内的子串是否是回文串，如果是，则当前 <code>[i, j]</code> 肯定是回文串。</p></li></ol><p>依照上述思路，我们应该得到的dp表格，类型为boolean：</p><table><thead><tr><th align="center"></th><th align="center">b</th><th align="center">a</th><th align="center">b</th><th align="center">a</th><th align="center">d</th></tr></thead><tbody><tr><td align="center">b</td><td align="center">T</td><td align="center">F</td><td align="center">T</td><td align="center">F</td><td align="center">F</td></tr><tr><td align="center">a</td><td align="center"></td><td align="center">T</td><td align="center">F</td><td align="center">T</td><td align="center">F</td></tr><tr><td align="center">b</td><td align="center"></td><td align="center"></td><td align="center">T</td><td align="center">F</td><td align="center">F</td></tr><tr><td align="center">a</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">T</td><td align="center">F</td></tr><tr><td align="center">d</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">T</td></tr></tbody></table><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">1</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> L = <span class="number">0</span>; L &lt; n; ++L )</span><br><span class="line">        &#123;</span><br><span class="line">            dp[L][L] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> L = <span class="number">2</span>; L &lt;= n; ++L )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + L - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>( j &gt;= n )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( s.charAt(i) == s.charAt(j) )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>( j - i &lt; <span class="number">3</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxlen )</span><br><span class="line">                &#123;</span><br><span class="line">                    maxlen = j - i + <span class="number">1</span>;</span><br><span class="line">                    start = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + maxlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 最长回文子串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔试刷题</title>
      <link href="/2021/12/24/%E7%AC%94%E8%AF%95%E5%88%B7%E9%A2%98/"/>
      <url>/2021/12/24/%E7%AC%94%E8%AF%95%E5%88%B7%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-阅读下面的程序："><a href="#1-阅读下面的程序：" class="headerlink" title="1. 阅读下面的程序："></a>1. 阅读下面的程序：</h3><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span> ; x &lt;=<span class="number">3</span> ; x++) &#123;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">         System.out.print(x%<span class="number">2</span> + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下列选项，哪个是结果：</p><p>A. 0 1 2 3</p><p>B. 0 1 2 1</p><p>C. 0 1 2</p><p>D. 编译失败</p><p><strong>结果：D</strong></p><blockquote><p>会报错：error: unreachable statement。</p><p>原因一：</p><p>下面的几种情况会出现 unreachable statement：<br>（1）在reutrn语句后写语句。<br>（2）在throw语句后写语句。<br>（3）break、continue语句之后定义语句。<br>（4）“\u10100”&#x2F;&#x2F;合法，相当于‘\u1010’和字符串“0”。<br>（5）移位运算符可以用于long int char short byte。<br>（6）类的访问控制符可以是public或什么都不加。<br>（7）goto是保留字但不是关键字。then什么都不是。<br>（8）把超类的类型强制转换后赋给子类的对象时，编译无异常，但运行时会出现异常。</p><p>原因二：</p><p>不可达语句的造成是因为：在此语句前面有一个返回操作，或者其他操作导致不管什么条件都无法执行到这一句。<br>最重要的是：检查前面语句是否有返回，并查看是否因为自己的疏忽，即使没有语法等错误，导致的任何条件都会在此语句前面返回。因为自己的疏忽，好几次在if 或for条件句后面加了; 导致下面的return语句不会执行之后的任何语句，就会返回1；</p></blockquote><h3 id="2-下列关于冒泡排序的描述中，正确的是（-）-多选"><a href="#2-下列关于冒泡排序的描述中，正确的是（-）-多选" class="headerlink" title="2. 下列关于冒泡排序的描述中，正确的是（ ） - 多选"></a>2. 下列关于冒泡排序的描述中，正确的是（ ） - 多选</h3><p>A. 冒泡排序是不断的比较数组中相邻的两个元素</p><p>B. 冒泡排序比较的总轮次是“数组长度-1”轮</p><p>C. 冒泡排序中会涉及到元素位置的置换</p><p>D. 其他说法均不正确</p><p><strong>结果：ABC</strong></p><blockquote><p>注意B说的是 <code>总轮次</code>。</p></blockquote><h3 id="3-下列关于二维数组定义的选项中，错误的是（-）"><a href="#3-下列关于二维数组定义的选项中，错误的是（-）" class="headerlink" title="3. 下列关于二维数组定义的选项中，错误的是（ ）"></a>3. 下列关于二维数组定义的选项中，错误的是（ ）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A. int\[][] arr = new int\[3][4];</span><br><span class="line">B. int\[][] arr = new int\[3][];</span><br><span class="line">C. int\[][] arr = new int\[][4];</span><br><span class="line">D. int[][] arr = &#123;&#123;1,2&#125;,&#123;3,4,5&#125;,&#123;6&#125;&#125;;</span><br></pre></td></tr></table></figure><p><strong>结果：C</strong></p><blockquote><p>可以省略列，不能省略行。</p></blockquote><h3 id="4-下列选项中，哪些可以作为方法重载的判断条件（-）-多选"><a href="#4-下列选项中，哪些可以作为方法重载的判断条件（-）-多选" class="headerlink" title="4. 下列选项中，哪些可以作为方法重载的判断条件（ ） - 多选"></a>4. 下列选项中，哪些可以作为方法重载的判断条件（ ） - 多选</h3><p>A. 方法名</p><p>B. 方法的参数列表</p><p>C. 方法的返回值</p><p>D. 方法的修饰符</p><p><strong>结果：AB</strong></p><blockquote><p>方法重载是可以定义多个方法名相同、参数列表不同的方法。</p></blockquote><h3 id="5-下列关于方法重载的说法中，正确的是（-）-多选"><a href="#5-下列关于方法重载的说法中，正确的是（-）-多选" class="headerlink" title="5. 下列关于方法重载的说法中，正确的是（ ） - 多选"></a>5. 下列关于方法重载的说法中，正确的是（ ） - 多选</h3><p>A. 方法名相同，参数的个数不同可以形成方法重载。</p><p>B. 方法名相同，参数的类型不同可以形成方法重载。</p><p>C. 方法名相同，参数的类型排列顺序不同可以形成方法重载。</p><p>D. 方法名相同，返回值类型不同，可以形成方法重载。</p><p><strong>结果：ABC</strong></p><blockquote><p>注意看C，是 <code>类型</code> 排列顺序不同。</p></blockquote><h3 id="6-请阅读下面的程序："><a href="#6-请阅读下面的程序：" class="headerlink" title="6. 请阅读下面的程序："></a>6. 请阅读下面的程序：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(“<span class="keyword">int</span>:” + (a+b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">float</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(“<span class="keyword">float</span>:” + (a+b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(“<span class="keyword">double</span>:” + (a+b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">long</span> b = <span class="number">20</span>;</span><br><span class="line">        sum(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下列选项中，哪一个是程序的正确运行结果（ ）</p><p>A. int:30<br>B. float:30.0<br>C. double:30.0<br>D. int:30.0</p><p><strong>结果：B</strong></p><blockquote><p>比long范围更大的是float</p></blockquote><h3 id="7-下面关于构造方法的描述中，正确的是（-）"><a href="#7-下面关于构造方法的描述中，正确的是（-）" class="headerlink" title="7. 下面关于构造方法的描述中，正确的是（ ）"></a>7. 下面关于构造方法的描述中，正确的是（ ）</h3><p>A. 构造方法在类定义的时候被调用<br>B. 构造方法在创建对象的时候被调用<br>C. 构造方法在调用对象的时候被调用<br>D. 构造方法在使用对象的时候被调用</p><p><strong>结果：B</strong></p><h3 id="8-下列关于this关键字的说法中，错误的是（-）"><a href="#8-下列关于this关键字的说法中，错误的是（-）" class="headerlink" title="8. 下列关于this关键字的说法中，错误的是（  ）"></a>8. 下列关于this关键字的说法中，错误的是（  ）</h3><p>A. this可以解决成员变量与局部变量重名的问题</p><p>B. this出现在成员方法中，代表的是调用这个方法的对象</p><p>C. this可以出现在任何方法中</p><p>D. this相当于一个引用，可以通过它调用成员属性与方法</p><p><strong>结果：C</strong></p><blockquote><p>this只能在类中的非静态方法中使用，静态方法和静态的代码块中绝对不能出现this。</p></blockquote><h3 id="9-以下代码执行后的结果是（-）"><a href="#9-以下代码执行后的结果是（-）" class="headerlink" title="9. 以下代码执行后的结果是（ ）"></a>9. 以下代码执行后的结果是（ ）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        String name = “小芳”;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            name = “小兰”;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = “小翠”;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Person p = <span class="keyword">new</span> Person(“小凤”);</span><br><span class="line">    System.out.println(p.name);</span><br><span class="line">    p.show();</span><br><span class="line">    System.out.println(p.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A. 小兰小翠</p><p>B.小凤小翠</p><p>C. 小芳小翠</p><p>D. 程序编译失败</p><p><strong>结果：C</strong></p><blockquote><p>小凤用来告诉系统应该调用一个有参的构造方法，而不是起赋值作用，至于小兰的话，name前面没有this，故小兰只是个局部变量，出不去。</p></blockquote><h3 id="10-以下关于方法重写，说法错误的是（-）-多选"><a href="#10-以下关于方法重写，说法错误的是（-）-多选" class="headerlink" title="10. 以下关于方法重写，说法错误的是（ ） - 多选"></a>10. 以下关于方法重写，说法错误的是（ ） - 多选</h3><p>A. 方法重写时，子类的函数名与参数列表必须与父类的一致</p><p>B. 方法重写时，子类的返回类型必须大于或者等于父类的返回类型</p><p>C. 方法重写时，子类的访问修饰符必须大于或者等于父类的访问修饰符</p><p>D. 方法重写与返回类型无关</p><p><strong>结果：BD</strong></p><blockquote><p>重写的规范</p><ol><li><p>子类方法的名称、参数列表与父类相同;</p></li><li><p>子类方法的返回类型与父类相同或更小;</p></li><li><p>子类方法声明的异常与父类相同或更小;</p></li><li><p>子类方法的访问权限与父类相同或更大。</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 221. 最大正方形</title>
      <link href="/2021/12/24/LeetCode-221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/"/>
      <url>/2021/12/24/LeetCode-221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximal-square/">https://leetcode-cn.com/problems/maximal-square/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>不能放图，可以简单的想象，一个右下角为 <code>(i, j)</code> 边长为3的正方形，有三个边长为2的正方形组成，其右下角坐标是：<code>(i - 1, j)、(i, j - 1)、(i - 1, j - 1)</code> ，如果其中一个子正方形的面积为0，都不能构成以当前 <code>(i, j)</code> 为右下角的正方形。如果构成当前右下角的正方形，则子边长加一，所以综上，可以得出转移方程：<br>$$<br>dp[i][j] &#x3D; Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1<br>$$<br>已知当 <code>i == 0 || j == 0</code> 最多只会有边长为1的正方形，当 <code>matrix[i][j] == 0</code> 的时候，不会构成正方形：<code>dp[i][j] = 0</code> ，可以得到如下最终结论：<br>$$<br>dp[i][j] &#x3D; \begin{cases}<br>matrix[i][j] - ‘0’ &amp;\text{i &#x3D;&#x3D; 0 || j &#x3D;&#x3D; 0}\<br>0 &amp;\text{matrix[i][j] &#x3D;&#x3D; ‘0’}\<br>Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 &amp;\text{除了上述条件}\<br>\end{cases}<br>$$<br>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( i == <span class="number">0</span> || j == <span class="number">0</span> || matrix[i][j] == <span class="string">&#x27;0&#x27;</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = matrix[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], Math.min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxlen = Math.max(maxlen, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen * maxlen;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 这脑回路我是想不到 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 322. 零钱兑换</title>
      <link href="/2021/12/21/LeetCode-322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/"/>
      <url>/2021/12/21/LeetCode-322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="记忆化搜索算法"><a href="#记忆化搜索算法" class="headerlink" title="记忆化搜索算法"></a>记忆化搜索算法</h2><p>是一种自顶而下的方法，解题思路类似树状图的结构。</p><span id="more"></span><p>记忆化搜索实际上是递归实现的，但是递归的过程中有许多结果是被反复计算的，这样会大大降低运算的效率。而记忆化搜索是在递归过程中，将已经计算出的结果保存起来，当之后的运算用到的时候直接取出结果，避免重复运算，因此极大的提高了运算效率。</p><p>以如下题为例。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/coin-change/">https://leetcode-cn.com/problems/coin-change/</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h3><p>这种方法算是暴力解题了，很容易超出时间限制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( coins.length == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        findWay(coins, amount, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res == Integer.MAX_VALUE ? -<span class="number">1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findWay</span><span class="params">( <span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount, <span class="keyword">int</span> count )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( amount &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( amount == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            res = Math.min(res, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            findWay(coins, amount - coins[i], count + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-记忆化搜索"><a href="#2-记忆化搜索" class="headerlink" title="2. 记忆化搜索"></a>2. 记忆化搜索</h3><p>​        上述递归的过程中，重复性的操作是在 <code>findWay</code> 方法中的 <code>for循环</code> 会产生重复内容，进行重复计算，可以将这些重复的数值存进数组  <code>count</code> 中，这样一旦当前操作被记录过，就不需要再次记录了。比如上述 <code>amount</code> 可能会有多种情况相减到相同的结果，这时候后续的遍历操作就是重复性操作了。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( coins.length == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> findWay(coins, amount, <span class="keyword">new</span> <span class="keyword">int</span>[amount]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findWay</span><span class="params">( <span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount, <span class="keyword">int</span>[] count )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( amount &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( amount == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( count[amount - <span class="number">1</span>] != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> count[amount - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res = findWay(coins, amount - coins[i], count);</span><br><span class="line">            <span class="keyword">if</span>( res &gt;= <span class="number">0</span> &amp;&amp; res &lt; min )</span><br><span class="line">            &#123;</span><br><span class="line">                min = res + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count[amount - <span class="number">1</span>] = min;</span><br><span class="line">        <span class="keyword">return</span> count[amount - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3. 动态规划"></a>3. 动态规划</h3><p>本题的状态转移方程很好得出：<br>$$<br>F(i) &#x3D; min_{j&#x3D;0…n−1}<br>F(i−c_j)+1<br>$$<br>可以借鉴背包问题解决。</p><p>基本思路是：</p><ol><li>首先定义一个容量长的数组 <code>dp[amount + 1]</code> ，并对其中的元素全部赋最大值 <code>MAX_VALUE = amount + 1</code> ，类似于 <code>Integer.MAX_VALUE</code>；</li><li>由于 <code>amount == 0</code> 时 <code>count == 0</code> ，所以 <code>dp[0] = 0</code> ；</li><li>后续只需要对容量 <code>1 ... amount</code> 取最小数量的硬币即可；</li><li>最后判断 <code>dp[amount]</code> 是否被赋值，没有被赋值，就说明硬币组合不可能有该数字，返回 <code>-1</code> ，否则返回 <code>dp[amount]</code> 。</li></ol><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 记忆化搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 918. 环形子数组的最大和</title>
      <link href="/2021/12/13/LeetCode-918-%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
      <url>/2021/12/13/LeetCode-918-%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/">https://leetcode-cn.com/problems/maximum-sum-circular-subarray/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>对于环形数组，一般解的思路是将数组分成三个部分：[max1,min,max2]。有以下的推导关系：</p><blockquote><p>max(前缀数组 + 后缀数组)<br>&#x3D; max(数组总和 - 中间数组)<br>&#x3D; 数组总和 + max(- 中间数组)<br>&#x3D; 数组总和 - min(中间数组)</p></blockquote><p>上述的 <code>min(中间数组)</code> 即取数组的最小值。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxsum = nums[<span class="number">0</span>], curmax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minsum = nums[<span class="number">0</span>], curmin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> num : nums )</span><br><span class="line">        &#123;</span><br><span class="line">            curmax = Math.max(curmax + num, num);</span><br><span class="line">            maxsum = Math.max(curmax, maxsum);</span><br><span class="line">            curmin = Math.min(curmin + num, num);</span><br><span class="line">            minsum = Math.min(curmin, minsum);</span><br><span class="line">            tot += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxsum &gt; <span class="number">0</span> ? Math.max(maxsum, tot - minsum) : maxsum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 这脑回路我是想不到 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵快速幂</title>
      <link href="/2021/12/09/LeetCode-509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/"/>
      <url>/2021/12/09/LeetCode-509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一-引入整数快速幂"><a href="#一-引入整数快速幂" class="headerlink" title="一. 引入整数快速幂"></a>一. 引入整数快速幂</h2><span id="more"></span><p>比如计算 **X <sup>19</sup>**。</p><p>可以使用二进制运算：<code>19 = 1 0 0 1 1</code> ，可以得出：<strong>X <sup>19</sup> &#x3D; X <sup>16 + 2 + 1</sup> &#x3D; X <sup>16</sup> * X <sup>2</sup> * X <sup>1</sup></strong> 。</p><p>这种计算方法可以减少循环的次数。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickPow</span><span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = x;</span><br><span class="line">    <span class="keyword">while</span>( N &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( (N &amp; <span class="number">1</span>) == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            res = res * x;</span><br><span class="line">        &#125;</span><br><span class="line">        x *= x;</span><br><span class="line">        N &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>和上面的思想是一样的，只是整数的次幂变成了矩阵的次幂。</p><p>回顾一下矩阵乘法的思想：</p><p><img src="/LeetCode-509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.assets/1149206-20170603085219993-768167045.png" alt="矩阵乘法"></p><p>下面使用具体的情景。</p><h3 id="具体实例分析-斐波那契数列"><a href="#具体实例分析-斐波那契数列" class="headerlink" title="具体实例分析 - 斐波那契数列"></a>具体实例分析 - 斐波那契数列</h3><p>已知递推序列：<code>F(n) = F(n-1) + F(n-2)</code> ，可以知道 <code>F(n-1) = F(n-1)</code> ，或者可以换算成：</p><p><code>F(n) = 1 * F(n-1) + 1 * F(n-2)</code> ，</p><p><code>F(n-1) = 1 * F(n-1) + 0 * F(n-2)</code> ，</p><p>则可以逆推出矩阵序列：<br>$$<br>\left(<br>\matrix{<br>F(n)\<br>F(n-1)<br>}<br>\right)<br>&#x3D;<br>\left(<br>\matrix{<br>  1 &amp; 1\<br>  1 &amp; 0<br>}<br>\right)<br>*<br>\left(<br>\matrix{<br>F(n)\<br>F(n-1)<br>}<br>\right)<br>$$<br>根据上述矩阵公式，得到斐波那契数列的一般式：<br>$$<br>\left(<br>\matrix{<br>F(n)\<br>F(n-1)<br>}<br>\right)<br>&#x3D;<br>\left(<br>\matrix{<br>1 &amp; 1\<br>1 &amp; 0<br>}<br>\right) ^ {n-1}<br>*<br>\left(<br>\matrix{<br>F(1) &#x3D; 1\<br>F(0) &#x3D; 0<br>}<br>\right)<br>$$<br>得到具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] mat = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] res = &#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        n -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( n != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( (n &amp; <span class="number">1</span>) == <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                matrixSquare(mat, res);</span><br><span class="line">            &#125;</span><br><span class="line">            matrixSquare(mat, mat);</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">matrixSquare</span><span class="params">(<span class="keyword">int</span>[][] mat1, <span class="keyword">int</span>[][] mat2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = mat2.length, m = mat2[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] new_mat = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k )</span><br><span class="line">                &#123;</span><br><span class="line">                    new_mat[i][j] += mat1[i][k] * mat2[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                mat2[i][j] = new_mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/cmmdc/p/6936196.html">矩阵快速幂基础讲解</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 矩阵快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - JZ20 表示数值的字符串</title>
      <link href="/2021/12/04/LeetCode-JZ20-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2021/12/04/LeetCode-JZ20-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.nowcoder.com/practice/e69148f8528c4039ad89bb2546fd4ff8?tpId=13&amp;tqId=1375424&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/e69148f8528c4039ad89bb2546fd4ff8?tpId=13&amp;tqId=1375424&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p><span id="more"></span><h2 id="有限状态自动机-知识简单介绍"><a href="#有限状态自动机-知识简单介绍" class="headerlink" title="有限状态自动机 - 知识简单介绍"></a>有限状态自动机 - 知识简单介绍</h2><p>一般用于字符串匹配问题。（应该）</p><p>有限状态自动机分为确定有限（DFA）和不确定有限（NFA）。</p><ol><li><p>确定有限状态自动机DFA</p><p><img src="/LeetCode-JZ20-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.assets/1423760-20180929170016855-451855187.jpg"></p><p>设初始态为 <code>0</code> ，终止态为 <code>2</code> ，当进行一系列操作，使得状态机的状态不断变化，只要最后一个输入使得状态机处于终止态，就表明当前输入可以被状态机接收。</p><p>比如，<code>abab</code> 的状态变化是 <code>&#123;0,1,2,2&#125;</code> ，由于最后一个状态是终止态 <code>2</code> ，所以该字符串可以被接收；如果字符串为 <code>bbab</code> ，状态变化是 <code>&#123;0,1,0,1&#125;</code> ，最后一个状态为 <code>1</code> ，不符合终止态，不会被接收。</p></li><li><p>不确定有限状态自动机NFA</p><p><img src="/LeetCode-JZ20-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.assets/1423760-20180929171549048-2112081040.png"></p><p>在上面这个状态转换形式中，从 <code>0</code> 开始，读取 <code>a</code> ，可以原地，也可以到 <code>1</code> ，状态不唯一，但都合法，这种状态就是不确定的。这种状态下的路径不会只有一个，只要其中一个能走到终止态，就算成功，所以会涉及到回溯内容。</p></li></ol><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-整合字符串的部分"><a href="#1-整合字符串的部分" class="headerlink" title="1. 整合字符串的部分"></a>1. 整合字符串的部分</h3><ol><li>前导空格；</li><li>正负号；</li><li>整数；</li><li>小数点；</li><li>小数点后的数字；</li><li><code>e</code> 或 <code>E</code> ；</li><li>正负号；</li><li>整数；</li><li>后导空格。</li></ol><p><strong>总结上述部分，分为以下几种：</strong></p><ol><li>空格：<code>&#39; &#39;</code> ；</li><li>正负号：<code>&#39;s&#39;</code> ；</li><li>整数：<code>&#39;d&#39;</code> ；</li><li>小数点：<code>&#39;.&#39;</code> ；</li><li><code>e</code> 或 <code>E</code> ：<code>&#39;e&#39;</code> 。</li></ol><h3 id="2-对这些部分总结规律"><a href="#2-对这些部分总结规律" class="headerlink" title="2. 对这些部分总结规律"></a>2. 对这些部分总结规律</h3><ol><li><p>如果有前导空格需要原地遍历完，之后才是真正的开头；</p></li><li><p>开头有3种：正负号、整数、小数点；</p><p>2.1 如果是正负号，后面可以跟：整数、小数点；</p><p>2.2 如果是整数，后面可以跟：没遍历完的整数、小数点、e|E、后导空格；</p><p>2.3 如果是小数点，后面必须跟整数；</p></li><li><p>延续 <code>2.1</code> 的思路，<code>正负号 + 整数</code> 后面可以跟：没遍历完的整数、小数点、e|E、后导空格；<code>正负号 + 小数点</code> 后面必须跟整数，与 <code>2.3</code>  具有同样的规则；</p></li><li><p>延续 <code>2.2</code> 的思路，遍历完整数后，<code>整数 + 小数点</code> 后面可以跟：小数点后的整数、e|E、后导空格；<code>整数 + e|E</code> 后面可以跟：正负号、整数；</p></li><li><p>延续 <code>2.3</code> 的思路，<code>小数点 + 整数</code> 后面可以跟：e|E、没遍历完的整数、后导空格；</p></li><li><p>延续 <code>3</code> 的思路，遍历完整数后，<code>正负号 + 整数 + 小数点</code> 、<code>正负号 + 小数点 + 整数</code> 后续的思路与 <code>5</code> 一致，<code>正负号 + 整数 + e|E</code> 与 <code>4</code> 的 <code>整数 + e|E</code> 的思路一致，存在后导空格结束；</p></li><li><p>延续 <code>4</code> 的思路，<code>整数 + 小数点 + 小数点后的整数</code> 与 <code>5</code> 的思路一致，<code>整数 + 小数点 + e|E</code> 与后面的 <code>整数 + e|E</code> 一致，存在后导空格结束；<code>整数 + e|E + 正负号</code> 后必须跟整数，<code>整数 + e|E + 整数</code> 后可以跟：没遍历完的整数、后导空格；</p></li><li><p>延续 <code>5</code> 的思路，遍历完整数后，<code>小数点 + 整数 + e|E</code> ，后面可以跟： 正负号、整数，存在后导空格结束；</p></li><li><p>之后把没遍历完的整数遍历完后，遇到后导空格结束。</p></li></ol><p>按照上述分析，可以有以下 7 步：</p><p>① 前导空格、正负号、整数、小数点；</p><p>② 整数、小数点；</p><p>③ 整数、小数点、e|E、后导空格；</p><p>④ 整数；</p><p>⑤ 整数、e|E、后导空格；</p><p>⑥ 正负号、整数；</p><p>⑦ 整数、后导空格。</p><h3 id="总结步骤表"><a href="#总结步骤表" class="headerlink" title="总结步骤表"></a>总结步骤表</h3><p>按照上述结论，得出步骤表：</p><p>① 前导空格：①、正负号：②、整数：③、小数点：④；</p><p>② 整数：③、小数点：④；</p><p>③ 整数：③、小数点：⑤、e|E：⑥、后导空格：⑧；</p><p>④ 整数：⑤；</p><p>⑤ 整数：⑤、e|E：⑥、后导空格：⑧；</p><p>⑥ 整数：⑧、正负号：⑦；</p><p>⑦ 整数：⑧；</p><p>⑧ 整数：⑧、后导空格：⑧。</p><p>**注意：上面的步骤多了一个 ⑦ 的步骤，这是因为此处必须出现的整数与 ④ 的整数不同，前一个是小数点后，后一个是e|E以及正负号后。 **</p><p>将所有的 <code>str</code> 字符串都添加一个后导空格，最后只需要判断最终的 <code>end</code> 是否是 ⑧ 结尾就可以了。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span> <span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        Map[] maps = </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() &#123;&#123;put(<span class="string">&#x27; &#x27;</span>, <span class="number">0</span>); put(<span class="string">&#x27;s&#x27;</span>, <span class="number">1</span>); put(<span class="string">&#x27;d&#x27;</span>, <span class="number">4</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">2</span>);&#125;&#125;,</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() &#123;&#123;put(<span class="string">&#x27;d&#x27;</span>, <span class="number">4</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">2</span>);&#125;&#125;,</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() &#123;&#123;put(<span class="string">&#x27;d&#x27;</span>, <span class="number">3</span>);&#125;&#125;,</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() &#123;&#123;put(<span class="string">&#x27;d&#x27;</span>, <span class="number">3</span>); put(<span class="string">&#x27;e&#x27;</span>, <span class="number">5</span>); put(<span class="string">&#x27; &#x27;</span>, <span class="number">7</span>);&#125;&#125;,</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() &#123;&#123;put(<span class="string">&#x27;d&#x27;</span>, <span class="number">4</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">3</span>); put(<span class="string">&#x27;e&#x27;</span>, <span class="number">5</span>); put(<span class="string">&#x27; &#x27;</span>, <span class="number">7</span>);&#125;&#125;,</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() &#123;&#123;put(<span class="string">&#x27;s&#x27;</span>, <span class="number">6</span>); put(<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>);&#125;&#125;,</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() &#123;&#123;put(<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>);&#125;&#125;,</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() &#123;&#123;put(<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>); put(<span class="string">&#x27; &#x27;</span>, <span class="number">7</span>);&#125;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        str += <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>( c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                c = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                c = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;E&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                c = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( !maps[end].containsKey(c) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            end = (<span class="keyword">int</span>)maps[end].get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> end == <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 有限状态自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - JZ51 数组中的逆序对</title>
      <link href="/2021/12/01/LeetCode-JZ51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
      <url>/2021/12/01/LeetCode-JZ51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&amp;tqId=23260&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&amp;tqId=23260&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-暴力解法"><a href="#1-暴力解法" class="headerlink" title="1. 暴力解法"></a>1. 暴力解法</h3><p>就是嵌套循环，遍历每个元素的时候，都嵌套一个往回循环到开头，然后计算逆序值。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> P = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>( j &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( array[j] &gt; array[i] )</span><br><span class="line">                &#123;</span><br><span class="line">                    ++P;</span><br><span class="line">                &#125;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(P % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2. 归并排序"></a>2. 归并排序</h3><p><strong>当提示 <code>空间复杂度 O(n)，时间复杂度 O(nlogn)</code> 就可以尝试思考是否可以套归并排序的解法了</strong>。</p><ol><li>已知归并排序分为两个部分，分治和合并，在分治阶段一般不会有什么其他操作，可以考虑在合并阶段对数据进行操作；</li><li>因为是两个部分进行合并，首先可以知道的就是 <code>left</code> 的部分肯定在 <code>right</code> 前面，所以逆序的两个数字可以分别从两个部分选择来比较；</li><li>如果确定了逆序的两个数字，可以知道 <code>left</code> 部分从当前元素 <code>i</code> 开始到该部分的结束 <code>mid</code> 对于 <code>right</code> 部分的当前元素 <code>j</code> 都是逆序的，因为此时的两个部分肯定分别是升序排序排列，都是从一个开始排起的。</li></ol><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> P = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        devide(array, <span class="number">0</span>, len - <span class="number">1</span>, tmp);</span><br><span class="line">        <span class="keyword">return</span> P;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">devide</span><span class="params">( <span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span>[] tmp )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( l &gt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        devide(arr, l, mid, tmp);</span><br><span class="line">        devide(arr, mid + <span class="number">1</span>, r, tmp);</span><br><span class="line">        merge(arr, l, r, mid, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">( <span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> mid, <span class="keyword">int</span>[] tmp )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( mid &gt; r || mid &lt; <span class="number">0</span> || l &gt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( i &lt;= mid &amp;&amp; j &lt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( arr[i] &lt;= arr[j] )</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[t++] = arr[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                P += mid + <span class="number">1</span> - i;</span><br><span class="line">                P %= <span class="number">1000000007</span>;</span><br><span class="line">                tmp[t++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( i &lt;= mid )</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[t++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( j &lt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[t++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( l &lt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            arr[l++] = tmp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - JZ56 数组中只出现一次的两个数字</title>
      <link href="/2021/11/30/LeetCode-JZ56-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"/>
      <url>/2021/11/30/LeetCode-JZ56-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.nowcoder.com/practice/389fc1c3d3be4479a154f63f495abff8?tpId=13&amp;tqId=1375231&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/389fc1c3d3be4479a154f63f495abff8?tpId=13&amp;tqId=1375231&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1. 哈希表"></a>1. 哈希表</h3><p>这个方法不再赘述，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] FindNumsAppearOnce (<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        HashSet&lt; Integer &gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( set.contains(array[i]) )</span><br><span class="line">            &#123;</span><br><span class="line">                set.remove(array[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                set.add(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( Integer s : set )</span><br><span class="line">        &#123;</span><br><span class="line">            res[r++] = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-位运算"><a href="#2-位运算" class="headerlink" title="2. 位运算"></a>2. 位运算</h3><p>可以先思考该题目的简易版：只出现一次的数字只有一个。这里就用到了异或运算。</p><p>已知一个元素和自己异或为0：<code>2 ^ 2 == 0</code> ，和0异或是其本身：<code>2 ^ 0 == 2</code> 。因为重复元素只出现两次，可以自然而然得到下列代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        x ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本题需要得到两个出现一次的数字，可以将数组分成两个部分，类似奇偶分组，但是取这样的规律进行分组：</p><p>我们需要把两个元素区分开，已知异或运算的结果是同0异1，可以取两个元素异或结果的最低位的1作为区分的关键。首先获取两个唯一元素异或的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> arr : array )</span><br><span class="line">&#123;</span><br><span class="line">    tmp ^= arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着获取最低位的1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mark = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>( tmp != <span class="number">0</span> &amp;&amp; (tmp &amp; mark) == <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    mark &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后依据这个 <code>1</code> 来分别计算两个组的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> arr : array )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( (arr &amp; mark) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        a ^= arr;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        b ^= arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码整合如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] FindNumsAppearOnce (<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> arr : array )</span><br><span class="line">        &#123;</span><br><span class="line">            tmp ^= arr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mark = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( tmp != <span class="number">0</span> &amp;&amp; (tmp &amp; mark) == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            mark &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> arr : array )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( (arr &amp; mark) == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                a ^= arr;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                b ^= arr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( a &gt; b )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c = a;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - JZ46 把数字翻译成字符串</title>
      <link href="/2021/11/30/LeetCode-JZ46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2021/11/30/LeetCode-JZ46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.nowcoder.com/practice/046a55e6cd274cffb88fc32dba695668?tpId=13&amp;tqId=1024831&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/046a55e6cd274cffb88fc32dba695668?tpId=13&amp;tqId=1024831&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>数字转变为字母的可能是一位数和两位数，可以联想到 <a href="%5Bhttp://lannaie.top/2021/07/09/LeetCode-NC68-%E8%B7%B3%E5%8F%B0%E9%98%B6/%5D(http://lannaie.top/2021/07/09/LeetCode-NC68-%E8%B7%B3%E5%8F%B0%E9%98%B6/)">爬楼梯相关题目</a> ，只是多了一些筛选条件，接下来，按照这个思路解决该题。</p><p>已知爬楼梯的递归条件是 <code>f[n] = f[n-1] + f[n-2]</code> ，此处也同样适用，前提条件是当前数值是合法的两位数才能这样计算，如果不合法，只能取 <code>f[n] = f[n-1]</code> 的结果。</p><p>除此之外，本题的难点在于对 <code>0</code> 的处理：</p><ol><li>涉及到 <code>0</code> 的数值仅有 <code>10</code> 和 <code>20</code> ，如果存在诸如 <code>002 </code>、<code>200</code> 、<code>603</code> 等都是不合法的数值，返回 <code>0</code> ；</li><li>不过在循环中不需要考虑为0的情况，只需要考虑 <strong>当前元素是否在一位数区间</strong> 和 <strong>与前一元素构成的两位数是否在两位数的区间内</strong> 的情况，其余情况都是不合法的情况，为 <code>0</code> 即可；</li><li>在两位数的区间判断中，还有一个小的判断，如果当前元素下标为 <code>1</code> ，没有 <code>f[n-2]</code> ，只需要在原来的 <code>f[n] = f[n-1]</code> 上 <code>+1</code> 即可，否则 <code>f[n] = f[n-1] + f[n-2]</code> 。</li></ol><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums string字符串 数字串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(String nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( nums == <span class="keyword">null</span> || nums.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//         char[] num = nums.toCharArray();</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length()];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length(); ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( nums.charAt(i) != <span class="string">&#x27;0&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp_num = (nums.charAt(i - <span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (nums.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>( tmp_num &gt;= <span class="number">10</span> &amp;&amp; tmp_num &lt;= <span class="number">26</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( i == <span class="number">1</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] += <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬楼梯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - JZ48 最长不含重复字符的子字符串</title>
      <link href="/2021/11/30/LeetCode-JZ48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2021/11/30/LeetCode-JZ48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.nowcoder.com/practice/48d2ff79b8564c40a50fa79f9d5fa9c7?tpId=13&amp;tqId=2276769&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/48d2ff79b8564c40a50fa79f9d5fa9c7?tpId=13&amp;tqId=2276769&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>动态规划问题肯定需要一个 <code>dp</code> 或 <code>dp[i]</code> ，本题仅涉及 <code>dp[i-1]</code> ，所以使用 <code>dp</code> 计算就可以了。</p><p>涉及到重复字符的问题，需要存储上个相同字符的位置，使用 <code>HashMap</code> 更加便捷。</p><p>获得最大值结果，使用 <code>max_length</code> 来存储。</p><p>如此其实可以推出了代码的大致方向，这里面最需要思考的问题是 <code>dp</code> 的赋值问题。</p><ol><li>如果没有重复字符最简单，直接 <code>dp += 1</code> 就可以得到当前不重复长度；</li><li>如果有重复字符，一开始的想法是 <code>dp = i - map.get(s.charAt(i))</code> ，但是这种方式的一个误区在于：如果重复元素嵌套，比如 <code>abba</code> ，结果会出错，需要重新理清思路：当前的最长字符串，不是由上个重复元素的位置决定，是由 <strong>上一个最长字符串</strong> 决定的，也就是 <code>第二个a</code> 的最长字符串长度不是由 <code>第一个a</code> 决定，而是由 <code>第二个b</code> 决定，当两个重复元素中间没有嵌套重复元素，比如 <code>abca</code> ，当前的长度才会由上一个重复元素决定，也就是说，应该取二者中更短的一边：<strong>dp &#x3D; Math.min(dp + 1, i - map.get(s.charAt(i)))</strong> 。</li></ol><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( s == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( s.length() == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line"><span class="comment">//         int[] dp = new int[chars.length];</span></span><br><span class="line">        <span class="keyword">int</span> dp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max_length = <span class="number">1</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//         dp[0] = 1;</span></span><br><span class="line">        map.put(chars[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; chars.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( !map.containsKey(chars[i]) )</span><br><span class="line">            &#123;</span><br><span class="line">                dp += <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp = Math.min(dp + <span class="number">1</span>, i - map.get(chars[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(chars[i], i);</span><br><span class="line">            max_length = Math.max(max_length, dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 剑指 Offer 44. 数字序列中某一位的数字</title>
      <link href="/2021/11/18/LeetCode-%E5%89%91%E6%8C%87-Offer-44-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>/2021/11/18/LeetCode-%E5%89%91%E6%8C%87-Offer-44-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/</a></p><span id="more"></span><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>插值查找是二分查找的变种。</p><p>二分查找是：有三个变量，<code>low = 0， high = num.length, mid = (low + high)/2</code>，这三个变量是固定的，插值查找的这三个变量是可变。</p><p>将 <code>low</code> 和 <code>high</code> 当成是上限和下限， <code>mid</code> 是一个灵活的具有规律的指定元素，可以分析该题：</p><ol><li>字符串可以分为多个区间：<code>0-9、10-99、100-999......</code> ；</li><li>因为 <code>0-9</code> 返回本身，所以直接返回可以省去一次运算；</li><li>接下来降维计算。<strong>像这种求区间中的具体值的，可以考虑这种方法</strong>；</li><li>因为是一维一维降的，所以不符合if条件的肯定会降下第一维：<code>n -= 9</code> ；</li><li>之后从第二维开始：<code>start = 10, end = 99, digit = 2</code> ；</li><li>开始一维一维的减，直到<code>n</code> 在某一维区间内，退出循环；</li><li>计算该区间的该 <code>n</code> 对应的实际数字：<code>(start + (n - 1) / digit)</code> ，该区间从 <code>start</code> 开始，<code>n - 1</code> 是因为每次以 <code>0</code> 为首个下标，所以需要 <code> - 1</code> ，为了方便取数，<code>+&quot;&quot;</code> 变成字符串；</li><li>之后 <code>(n - 1) % digit</code> 取哪一位上的数。</li></ol><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> start = <span class="number">10</span>, end = <span class="number">99</span>;</span><br><span class="line">        <span class="keyword">long</span> digit = <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        n -= <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span>( n &gt; end )</span><br><span class="line">        &#123;</span><br><span class="line">            n -= end;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            digit += <span class="number">1</span>;</span><br><span class="line">            end = start * <span class="number">9</span> * digit;</span><br><span class="line">        &#125;</span><br><span class="line">        String num = (start + (n - <span class="number">1</span>) / digit) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> idx = (<span class="keyword">int</span>)((n - <span class="number">1</span>) % digit);</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(num.charAt(idx)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插值查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 面试题</title>
      <link href="/2021/11/15/Java-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2021/11/15/Java-%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="Java语言的特点"><a href="#Java语言的特点" class="headerlink" title="Java语言的特点"></a>Java语言的特点</h2><p>Java语言的主要特点有：</p><span id="more"></span><ol><li>面向对象：Java是一门面向对象的高级编程语言，所谓的面向对象实际上是一种思考的模式，通过模拟现实世界来解决现实问题。</li><li>简单性：首先Java具有自动内存管理机制，比如c语言中会有析构函数如delete、free等，在内存使用完毕需要手动去释放内存，但是Java语言在内存使用完成后就不用再管，内存会被自动回收，这样不容易造成内存溢出；其次，Java借鉴了一些老牌编程语言的特性，简化了流程的处理，同时也简化了Java过程中的语义，比如goto这些在Java中就被顶替掉了，通过其他的方式在语义清晰的情况下达到原有的目的。</li><li>跨平台：指的是软件可以在任意计算机环境中正常运行，而不需要考虑计算机硬件和操作系统的约束，实现了Java一次编译到处运行的目标。因为Java会将源码编译为字节码，字节码是无关平台的，任意平台上的JVM都会向Java编译器提供一个相同的接口用来获取字节码，所以Java语言是具有跨平台性的。</li></ol><p>​        具体说到字节码，就肯定要先知道机器码。我们当前使用的大部分语言都是高级语言，而这些语言使用的源码，都由英文和符号组成，这种代码是无法被计算机直接识别的，我们需要将其翻译为机器码交由计算机执行。翻译的过程有两种形式：编译和解释。编译指的是在程序运行前，将源码全部翻译为机器码，再交由计算机执行；解释指的是在程序运行时，将代码解释一行，交由计算机执行一行。编译的好处是执行的效率会很高，但是由于不同计算机的机器码不同，所以可以执行很低，面对不同的计算机，就需要重新编译源代码，甚至额能要修改部分源码；而解释的效率会比较低，但是可移植性高，不同计算机的解释器和机器码是一致的，所以只需要使用一份源码交给不同的解释器执行就可以。<br>​        而Java语言使用先编译后解释的方式，其中就引出了字节码。Java语言先将源码编译为字节码文件，然后将字节码提交给计算机，在程序运行时解释i解码文件。因为字节码也是二进制文件，与机器码很像，所以从字节码转换为机器码就会更快一点。综上，Java语言相较于纯的编译型语言，可移植性更高，相较于解释型语言，解释的效率也会更高。</p><hr><h3 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h3><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><p>就是分析出系统中应包含哪些对象，以及它们之间的关系，再用特定的语法来描述这些对象和关系。</p><p>比如，使用面向对象的思想来说一下上课的过程。有电瓶车和司机，司机开电瓶车，我要坐电瓶车去上课，然后有学生，上课的点有许多学生要上车，还有教学楼，乘车到目的的教学楼然后下车前往教室上课。</p><h2 id="JDK、JRE和JVM的区别和联系"><a href="#JDK、JRE和JVM的区别和联系" class="headerlink" title="JDK、JRE和JVM的区别和联系"></a>JDK、JRE和JVM的区别和联系</h2><p>​        JDK是Java标准开发包，包括编译以及运行Java程序所需的各种工具和资源，比如Java编译器、Java运行时环境、常用的Java类库等。</p><p>​        JRE是Java运行时环境，用于解释和执行字节码文件，普通用户只需要运行Java程序安装JRE就好，如果要编译和调试程序需要安装JDK。</p><p>​        JVM即Java虚拟机，是JRE的一部分，是Java跨平台最核心的部分，用于解释和执行字节码文件。也就是说JVM相当于一个字节码翻译器，将字节码翻译成各个系统对应的机器码，确保字节码文件能在不同系统正常执行。</p><h2 id="JVM相关"><a href="#JVM相关" class="headerlink" title="JVM相关"></a>JVM相关</h2><h3 id="JVM的位置"><a href="#JVM的位置" class="headerlink" title="JVM的位置"></a>JVM的位置</h3><p>​        JVM是运行在操作系统上的，可以看成是一个软件，它上面跑的都是Java程序，其他的程序和JVM可以看成是并列的软件</p><p><img src="/Java-%E9%9D%A2%E8%AF%95%E9%A2%98.assets/bb2f637c254a208f400fe260d97183d5.png"></p><h3 id="JVM体系结构"><a href="#JVM体系结构" class="headerlink" title="JVM体系结构"></a>JVM体系结构</h3><p>​        首先简单了解一个Java程序的运行过程：</p><ol><li>一个 <code>.java</code> 文件首先会通过 <code>javac</code> 命令转换为字节码文件 <code>.class</code> ，接着这个 <code>.class</code> 会加载到类加载器，类加载器把字节码文件加载到运行时数据区，一般我们的runtime异常都是在这个地方产生的。</li><li>运行时数据区里包括方法区（Method Area）、本地方法栈（Native Method Stack）、栈（Stack）、堆（Heap）、程序计数器。</li><li>对于本地方法的调用，本地方法栈会通过一个本地接口调用本地方法库的方法，所以会有一个本地接口和运行时数据区交互。</li><li>如果是执行Java程序，是使用执行引擎和运行时数据区交互执行。</li></ol><p>​        在运行时数据区中，栈、本地方法栈和程序计数器都是线程私有的，这部分内容不会出现垃圾收集，垃圾收集的部分是线程共享的堆和方法区，这两个地方也是JVM调优的地方，其中99%的调优都是针对堆来进行的。</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>​        类加载器的作用是加载class类，这里的这个class类可以看成是一个模板，后续要比较两个实例是否相等肯定要比较他们的类加载器是否相等，一个模板类肯定是由一个类加载器来加载的。类加载器会将这个class类加载并初始化成一个反射的class对象，由这个对象进行实例化的操作。</p><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p>​        在JVM的层面，类加载器有两种：一种是由C++语言编写的启动类（根）加载器，一种是由Java语言编写的其他所有类加载器。</p><p>​        这些类加载器在Java层面构成了一个三层类加载器模型，也叫双亲委派模型：最上面一层是启动类（根）加载器，存放在jre&#x2F;lib下的rt.jar包中，因为是用C++实现，无法被Java程序直接调用的，所以到这个层面一般会返回null；下面一层是扩展类加载器，存放在 jre&#x2F;lib&#x2F;ext 目录下，由于是使用Java语言编写，所以可以显示；再下一层是应用程序（系统类）加载器，负责加载用户类路径上的类。</p><p>​        双亲委派机制的原理是：一个类加载器收到类加载的请求，先层层向上委托给父类加载器加载，直到顶层的根加载器，根加载器会检查能否加载这个类，能就在根加载器加载，不能就抛出异常再逐层往下找，如果所有的类加载器都找不到这个类，就会报错 Class Not Found。</p><p>​        双亲委派机制的目的是保证安全，如果不使用双亲委派机制，那么假设用户也编写一个java.lang.String类，不同的类加载器会加载出不同的类型，导致程序变得混乱。一个类的类型是由该类和加载它的类加载器唯一确定的。</p><h3 id="Native-Method-Stack本地方法栈"><a href="#Native-Method-Stack本地方法栈" class="headerlink" title="Native Method Stack本地方法栈"></a>Native Method Stack本地方法栈</h3><p>​        首先说明一下natve关键字，由这个关键字修饰的内容，就说明是Java范围内无法达到的，这就会取调用底层c语言的库。</p><p>​        class文件经过类加载器到运行时数据区将关于Java的内容都分配完成，会进入本地方法栈，通过调用本地方法接口JNI来使用本地方法库。JNI的作用是融合不同编程语言为Java所用，这个不同的编程语言最初就包含了C和C++。因为Java在刚诞生的时候是C和C++普遍流行的时候，想要立足就必须能调用C和C++的程序，于是，它在内存中开辟了一块标记区域：本地方法栈，用来标记 native 方法，并在最终执行的时候去加载本地方法库的方法。</p><h3 id="PC寄存器（程序计数器）"><a href="#PC寄存器（程序计数器）" class="headerlink" title="PC寄存器（程序计数器）"></a>PC寄存器（程序计数器）</h3><p>​        程序计数器就是一个指针，用来存储指向下一条指令的地址，是一个非常小的内存空间，几乎可以忽略不计。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>​        方法区是存放在堆的永久代中的，里面存储 static 静态变量、final 常量、类信息（类加载的信息、构造方法、接口定义）、运行时常量池。为了区分方法区和堆，也叫方法区为非堆。</p><p>比如要对下述代码进行内存分配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    String name = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test t = <span class="keyword">new</span> test();</span><br><span class="line">        t.a = <span class="number">1</span>;</span><br><span class="line">        t.name = <span class="string">&quot;bcd&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/Java-%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220312203227049.png" alt="image-20220312203227049"></p><h3 id="栈内存"><a href="#栈内存" class="headerlink" title="栈内存"></a>栈内存</h3><p>​        主管程序的运行，生命周期和线程是同步的。当线程结束，这个栈内存就会释放，所以不会存在垃圾回收的问题。</p><p>​        栈用于存储基本数据类型、对象的引用（reference）以及实例的方法等。运行原理就是栈帧。一个栈帧中包含方法索引、输入输出参数、本地变量、class的引用、指向上一个栈帧的父帧和指向下一个栈帧的子帧。因为栈的内存容量是有限的，所以一旦栈帧的数量超出了栈的内存，就会报错栈溢出：StackOverFlowError。</p><h3 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h3><p>​        一个JVM只会生成一个堆内存，堆内存的大小是可以调节的。堆内存中会存储对象的实例。</p><p>​        对堆内存细分，可以分为三块区域：新生代、老年代和永久代，其中新生代又会被细分为伊甸园区和幸存区。</p><p>​        新生代是一个对象诞生、成长甚至死亡的地方。new一个对象，首先会存放到伊甸园区，当伊甸园区的内存满了，就会触发一次轻GC，在这个阶段，如果有对象还存在引用就存活，否则就回收这块内存。存活的对象会被放到幸存区。如果幸存区也满了，就会触发一次重GC，也就是full GC，这次垃圾回收会清理整个新生代的内存，然后将存活的对象放到老年代。如果老年代也满了，就会触发对内存溢出的错误。不过在日常使用中，99%的对象都是临时对象，也就是只使用一次后面就不再使用的对象，所以其实进入老年代的对象并不多。</p><p>​        对于永久代，这个区域是常驻内存的，用来存放JDK自身携带的Class对象，也就是Java运行时的一些环境、类信息等，这个区域不存在垃圾回收，关闭虚拟机才会释放这个内存。在jdk1.6之前，这块区域被称作永久代，常量池是存在方法区的；jdk1.7的时候，出现了去永久代，也就是慢慢的退化了这个永久代，这个时候常量池存放在堆中；jdk1.8之后，永久代改名为元空间，常量池在元空间。</p><p>​        这块内存一般不会溢出，但是如果一个启动类加载了大量的jar包、或者Tomcat上部署了大量的应用等，这些情况是会撑爆元空间的，就会出现OOM的错误。</p><p>​        OOM解决的措施：</p><ol><li>首先扩大内存：<code>-Xms1024m -Xmx1024m -XX:+PrintGCDetails</code> ；</li><li>如果扩大之后还是出现堆内存溢出的情况，就需要使用专业工具分析内存，查哪个地方出现了问题。专业的内存快照分析工具包括MAT、JProfiler。</li></ol><h3 id="面试问题：堆空间一定是所有线程共享的么？"><a href="#面试问题：堆空间一定是所有线程共享的么？" class="headerlink" title="面试问题：堆空间一定是所有线程共享的么？"></a>面试问题：堆空间一定是所有线程共享的么？</h3><p>不是，TLAB线程在堆中独有的。</p><h3 id="JVM内存的回收GC"><a href="#JVM内存的回收GC" class="headerlink" title="JVM内存的回收GC"></a>JVM内存的回收GC</h3><p>​        JVM进行GC的区域包括：伊甸园区、幸存区和老年代，大部分时候，回收的都是伊甸园区。</p><p>​        GC有两类：轻GC，也就是普通的GC；重GC，也就是全局GC。轻GC是针对新生代的，重GC是针对老年代的。</p><p>​        新生代的幸存区分为两个部分：from区和to区，这两个区是动态的，from和to就是从哪个区到哪个区的关系，哪个区的空的，这个区就是to区，会接收from区传过来的对象。设置两个幸存区的目的是解决内存碎片化，假设只有一个幸存区，那么当伊甸园区进行GC并将存活对象存入幸存区之后，如果幸存区中也包含存活对象，这两部分的对象所在的内存空间就不是连续的，很容易产生内存碎片；如果使用两个幸存区，那么就可以将伊甸园区中的存活对象和幸存区中包含存活对象的from区一起复制给to区，也就是没有任何对象的幸存区，接着将from区和伊甸园区的内存清空，就能保证每次至少都会有一个空的幸存区作为to区。</p><p>​        默认当一个对象在幸存区经历了15次GC依然存活，就会进入老年代。</p><p>​        GC中判断对象是否可以被回收有两种方法：引用计数法和可达性分析法。</p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>​        就是给对象添加一个引用计数器，每当有一个地方引用到它就加一，引用失效就减一，任何时刻计数器为0的对象就是不能再被使用的。引用计数法实现简单，判定效率也很高，但是它很难解决对象间循环引用的问题。</p><h4 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h4><p>​        就是通过 一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过 程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p><p>​        在java语言中，常见的可作为GC Roots的对象包括下面几种：</p><ol><li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li><li>方法区中类静态属性引用的对象；</li><li>方法区中常量引用的对象；</li><li>本地方法栈中JNI（即一般所说的Native方法）引用的对象。</li></ol><p>​        这种方式可找到所以得垃圾对象，并且完美解决对象之间循环引用的问题。但是不可避免地要遍历全局所有对象，导致搜索效率不高。</p><p>​        GC中常见的回收算法有3种：标记清除算法、标记复制算法和标记整理算法。</p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>​        新生代主要使用的就是复制算法。复制算法就是将伊甸园区和from区的存活对象放到to区，然后将伊甸园区和from区都清空。</p><p>​        好处是不会产生内存碎片；坏处是浪费了幸存区的空间，必须要保证始终有一个to区存在。在100%存活率的极端情况下，这种弊端带来的影响是很严重的，甚至会出现OOM的错误。</p><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><p>​        会进行两次扫描，第一次标记存活对象，第二次清除没有标记的对象。</p><p>​        这种算法的弊端显而易见，对对象的标记肯定要占一部分内存，并且两次扫描也会消耗时间，而且存活对象不一定是连续的，这就会产生内存碎片；但是它不需要额外的空间。</p><h4 id="标记压缩算法"><a href="#标记压缩算法" class="headerlink" title="标记压缩算法"></a>标记压缩算法</h4><p>​        是在标记清除算法执行清除之前，将存活的对象移动到内存的一端存储，再清空这端以外的内存，这样虽然增加了一个移动成本，但是可以避免产生内存碎片。</p><h3 id="JVM配置参数"><a href="#JVM配置参数" class="headerlink" title="JVM配置参数"></a>JVM配置参数</h3><ol><li><code>-Xms</code> 设置初始化内存分配大小，默认是1&#x2F;64；</li><li><code>-Xmx</code> 设置最大分配的内存大小，默认是1&#x2F;4；</li><li><code>-XX:+PrintGCDetails</code> 打印GC垃圾回收的信息；</li><li><code>-XX:+HeapDumpOnOutOfMemoryError</code> 生成OOM的dump文件；</li><li><code>-XX:MaxTenuringThresold</code> 设置进入老年代前要经历的GC次数，默认是15次。</li></ol><h3 id="JVM内存的泄漏、溢出、抖动以及相关的监控问题"><a href="#JVM内存的泄漏、溢出、抖动以及相关的监控问题" class="headerlink" title="JVM内存的泄漏、溢出、抖动以及相关的监控问题"></a>JVM内存的泄漏、溢出、抖动以及相关的监控问题</h3><p>​        内存溢出，指的是程序申请的资源超出了堆内存的容量，就会造成OOM内存溢出；内存泄漏，指的是本该在GC时候被回收的对象，被其他存活对象所持有，导致无法回收，内存泄漏最终也会导致内存溢出；内存抖动就是短时间大量的创建仅使用一次的对象，从而导致需要频繁的进行GC操作，造成系统卡顿。</p><p>​        这些问题可以生成dump文件后，使用JProfiler来监控调试。</p><h3 id="JMM-Java内存模型（Java-Memory-Modal）"><a href="#JMM-Java内存模型（Java-Memory-Modal）" class="headerlink" title="JMM - Java内存模型（Java Memory Modal）"></a>JMM - Java内存模型（Java Memory Modal）</h3><p>​        JMM是缓存一致性协议，用于定义数据读写的规则。</p><p>​        JMM定义了线程工作内存和主内存之间的抽象关系：每个线程都有一个自己的工作内存，负责拷贝主内存的共享变量到本地使用。</p><p>​        解决的问题：</p><ol><li>可见性：假设有两个线程，线程A从主存拷贝对象count，并将count &#x3D; 1，这个变更对线程B是不可见的，因为此时A还没有将这个修改刷到主存中。解决的方式：volatile、synchronized。</li><li>竞争问题：假设两个线程都要读取count对象进行加一操作，如果是串行，这个对象会加2，如果是并行，那么无论哪个线程先将结果刷到主存，都是加一的操作。解决的方式：synchronized。</li></ol><p><strong>面试的思路：（主要看这个就行）</strong></p><ol><li><p>说说看线程之间的通信机制有哪些呢？Java的并发采用的是哪种？</p><p>​        线程的通信机制有两种：共享内存和消息传递，目前Java使用的是共享内存的方式。</p></li><li><p>说说看什么是JMM内存模型？有什么存在作用？</p><p>​        JMM是一种抽象的规范。在不同操作系统或硬件下，对内存的访问逻辑是会存在一定差异的，一套代码在不同的系统中可能会出现不一样的结果，JMM的作用就是解决这种不一致性。</p></li><li><p>说说JMM对内存的划分？</p><p>​        JMM规定内存分为主内存和工作内存。主内存可以看成是JVM中的堆内存，里面存储的是共享变量；工作内存可以看成是JVM中栈的部分区域，是每个线程中都独有的一块内存，线程会拷贝主内存中要用的共享变量到本地的工作内存进行操作，而不是直接读写主内存。</p><p><img src="/Java-%E9%9D%A2%E8%AF%95%E9%A2%98.assets/image-20220315170028772.png" alt="image-20220315170028772"></p></li><li><p>说说JMM定义了哪些操作来完成主内存和工作内存的交互操作？</p><p>​        有8个，lock会给主存对应的变量上锁；read将主存对应变量的值传给线程工作内存；load工作内存加载read传过来的变量值到本地；use把工作内存的变量值给执行引擎；assign把从执行引擎传过来的值赋值给工作内存的变量；store把工作内存的变量值传回给主内存；write把store传来的值放入主内存的变量；unlock对主内存的这个变量解锁。</p></li><li><p>说说对内存交互基本操作的三个特性的理解？</p><p>​        三个特性是原子性、可见性和有序性。</p><p>​        原子性要求这一个或一组操作要么全部执行要么全部不执行，中间不能被打断。CPU有一个时间分片的概念，也就是一个线程执行完这个时间片后会被中断运行，直到再次获得时间片才能继续，这样就会产生原子性问题。</p><p>​        可见性指的是当多个线程访问一个共享变量，某一个线程对其进行修改，其他线程能够马上看到。比如有多个线程同时拷贝了一个共享变量，因为线程之间是看不到的，那么如果都执行了加一的操作，无论哪个先传回给主存，都只执行了一次加一的操作，这样就产生了一致性问题。</p><p>​        有序性是程序执行的顺序应该与代码顺序一致。但是有时候编译器或CPU执行指令重排等优化，就会导致乱序问题。</p></li><li><p>以下几种情况中，哪几个操作是原子性操作？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">20</span>;    </span><br><span class="line">b = a;</span><br></pre></td></tr></table></figure><p>​        第一个操作是原子操作，第二个不是。因为第二个操作可以拆分为两个：获取a的值和将a的值赋给b，那么如果中间线程被中断，就不是原子性操作了。</p></li><li><p>如何保证三个特性？</p><p>​        synchronized关键字可以保证这三个特性。对于原子性，synchronized使用了monitorenter和monitorexit的时候，这中间只会有一个线程进入，哪怕cpu时间片用完，这个线程中断执行，也不会释放这个锁，而由于synchronized锁是可重入的，所以在下次获取到cpu时间片的时候，还是会继续执行代码，直到所有代码执行完毕才会释放锁。而由于synchronized同一时间只允许一个线程进入，所以无论是否指令重排，都不会对结果产生影响。在synchronized释放锁前，会保证先把其中的变量值都更新回主内存才会释放锁，所以后续的线程就能访问到最新的结果，从而保证了可见性。</p><p>​        对于可见性和有序性，还可以使用volatile关键字来解决<strong>（volatile的实现原理）</strong>。volatile有两个限定，保证use前必须read和load，assign后必须store和write，所以就能保证当共享变量在工作内存被修改的时候可以立刻更新到主存，从而保证可见性。同时，volatile具有禁止指令重排的功能，这里涉及到一个内存屏障的概念，这是一个cpu指令，在JMM中的load和store就是两个内存屏障，它们能保证前后的指令执行的顺序不会发生改变。</p><p>​        对于有序性，还要一个happens-before的原则。</p></li><li><p>happens-before原则，说说看对它的理解？</p><p>​    首先简单的说明这个指令重排的含义，它就是在数据之间不存在依赖性的情况下，做出的优化。而happend-before原则是保证前一个操作的结果对后一个操作是可见的。以下面的例子来说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">++i; <span class="comment">// A操作</span></span><br><span class="line">System.out.println(i); <span class="comment">// B操作</span></span><br></pre></td></tr></table></figure><p>​        在单线程的情况下，这两个操作因为是在一个工作内存中执行，所以不存在一致性的问题；又因为B操作对A操作的结果具有依赖性，所以单线程下，是天然支持happens-before的思想的。如果是在多线程下，由于每个线程都会拷贝一份共享变量，如果不对这个共享变量做同步处理，那么线程1执行操作A后，线程2执行操作B，此时A操作的结果不一定对B操作可见。</p><p>​        为了解决这个问题，JMM通过happens-before的规则来提供多线程下的内存可见性保证，也就是如果线程1的A操作对线程2的B操作存在happens-before的关系，尽管两个操作在不同线程执行，也会保证A操作的结果对B操作是可见的。</p><p>​        这并不是说happens-before禁止了重排序，事实上，JMM遵循一个基本原则，只要不改变程序的执行结果，怎么优化都可以。</p></li></ol><h2 id="数据类型和基本语法"><a href="#数据类型和基本语法" class="headerlink" title="数据类型和基本语法"></a>数据类型和基本语法</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>​        包括基本类型和引用类型。</p><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>分为三类：</p><ol><li><p>整型：byte、short、int、long、char；</p><p>（1）byte：在内存中占8位，也就是一个字节，取值范围在 <code>-2^7 ~ (2^7 - 1)</code>，也就是-128-127；</p><p>（2）short：占16位，取值在 <code>-2^15 ~ (2^16 - 1)</code>；</p><p>（3）int：占32位，取值在 <code>-2^31 ~ (2^31 - 1)</code>；</p><p>（4）long：占64位，取值在 <code>-2^63 ~ (2^63 - 1)</code>；</p><p>（5）char：占16位，取值在 <code>0 ~ 2^16</code> 。</p></li><li><p>浮点型：float、double；</p><p>（1）单精度float：占32位；</p><p>（2）双精度double：占64位。</p></li><li><p>boolean。</p><p>布尔值，占1个字节。</p></li></ol><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>​        Java中对象的引用分为四种级别，这四种级别由高到低依次为:强引用、软引用、弱引用和虚引用。提供四种引用类型的目的在于：</p><p>（1）能够让用户手动去指定对象的生命周期；</p><p>（2）有利于JVM进行垃圾回收。</p><ol><li><p>强引用</p><p>Java中默认声明的就是强引用，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = new Object(); //只要obj还指向Object对象，Object对象就不会被回收</span><br><span class="line">obj = null;  //手动置null</span><br></pre></td></tr></table></figure><p>只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显式的将强引用赋值为null。</p><p>Java的对象是位于heap 中的, heap中对象从强到弱有强可及对象、软可及对象、弱可及对象、虚可及对象和不可到<br>达对象。对于对象是属于哪种可及的对象，由他的最强的引用决定。看如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String abc=<span class="keyword">new</span> string ( <span class="string">&quot;abc&quot;</span>); <span class="comment">//1</span></span><br><span class="line">SoftReference&lt;string&gt; softRef=<span class="keyword">new</span> SoftReference&lt;string&gt; (abc); <span class="comment">//2</span></span><br><span class="line">WeakReference&lt;string&gt; weakRef = <span class="keyword">new</span> WeakReference&lt;string&gt;(abc); <span class="comment">//3</span></span><br><span class="line">abc=<span class="keyword">null</span>; <span class="comment">//4</span></span><br><span class="line">softRef.clear();<span class="comment">//5</span></span><br></pre></td></tr></table></figure><p>第一行在heap堆中创建内容为“abc”的对象，并建立abc到该对象的强引用，该对象是强可及的。<br>第二行和第三行分别建立对 heap中对象的软引用和弱引用，此时 heap 中的abc对象已经有3个用，显然此时abc 对象仍是强可及的。<br>第四行之后heap 中对象不再是强可及的，变成软可及的。<br>第五行执行之后变成弱可及的。</p></li><li><p>软引用</p><p>软引用是用来描述一些非必需但仍有用的对象。<strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong>。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。<br>在 JDK1.2 之后，用java.lang.ref.SoftReference类来表示软引用。垃圾收集器只在真正 “需要” 内存时才收集软引用对象。</p></li><li><p>弱引用</p><p>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong>。在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用。如果想要引用一个对象，但是不想介入这个对象的生命周期，就可以使用弱引用，这个引用不会在垃圾回收时对这个对象产生任何附加作用。</p></li><li><p>虚引用</p><p>虚引用是最弱的一种引用关系，任何时候都有可能被GC回收，主要用来跟踪对象被垃圾回收的活动。在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p></li><li><p>引用队列</p><p>引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。</p></li></ol><h4 id="基本数据类型和引用类型的区别"><a href="#基本数据类型和引用类型的区别" class="headerlink" title="基本数据类型和引用类型的区别"></a>基本数据类型和引用类型的区别</h4><p>​        二者的区别主要是在内存上的存储不同。首先明确一下，JVM内存中，实际的常量值是存储在常量池中的，如果是基本数据类型，栈中会存储常量池中对应数据值的引用；如果是引用类型，会先在堆中存放这个引用的对象，然后在栈中存储这个变量和这个变量的对象在堆中的地址，堆中的对象才会存储到常量池的引用。</p><h4 id="x3D-x3D-和equals的区别"><a href="#x3D-x3D-和equals的区别" class="headerlink" title="&#x3D;&#x3D;和equals的区别"></a>&#x3D;&#x3D;和equals的区别</h4><p>​        &#x3D;&#x3D;会比较栈中存放的变量对应的值是否相等，因为基本数据类型会直接存储值在常量池中的位置，当值相等时，肯定是指向同一个位置；而对于引用类型，如果两个比较的变量都没有使用new来创建，那么当这个变量创建的时候，会先在常量池中寻找这个值，如果有就返回在堆中的对象，如果没有才会在堆中创建新的对象，所以这个时候两个变量会指向同一个地址；如果这两个变量有一个使用了new来创建，那么无论如何都会新建一个对象来存放这个实际值在常量池的位置，这两个变量就不可能相等。</p><p>​        equals是引用类型比较的函数，比较堆中对象指向的常量池中的实际值，所以无论new不new，都会返回实际值的比较。</p><h4 id="equals和hashCode的联系和区别"><a href="#equals和hashCode的联系和区别" class="headerlink" title="equals和hashCode的联系和区别"></a>equals和hashCode的联系和区别</h4><p>​        equals比较的是两个引用类型的实际值，hashCode是比较两个引用类型的hash值，这个hash值是将实际值依据某种算法计算得到的一个结果，所以两个不同的数值可能会得到相同的hash值。所以hash值相同的equals不一定为true，但是equals为true的，hash值一定相等。</p><h4 id="自动装箱和自动拆箱"><a href="#自动装箱和自动拆箱" class="headerlink" title="自动装箱和自动拆箱"></a>自动装箱和自动拆箱</h4><p>​        指的是基本数据类型和引用类型直接的转换。装箱指的是将int转换为Integer，使用Integer.valueOf()来实现；拆箱指的是将Integer转换为int，使用intValue来实现。</p><ol><li>引申问题①：<strong>Integer i &#x3D; new Integer(10)</strong> 和 <strong>Integer i &#x3D; 10</strong> 的区别</li></ol><p>（1）第一种方式不会触发自动装箱，第二种会；</p><p>（2）一般情况下，第二种方式的执行效率和资源占比会比第一种方式高，但不是绝对的。</p><ol start="2"><li>引申问题②：下面程序的输出结果：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer i1 = <span class="number">100</span>;</span><br><span class="line">    Integer i2 = <span class="number">100</span>;</span><br><span class="line">    Integer i3 = <span class="number">200</span>;</span><br><span class="line">    Integer i4 = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(i1 == i2);</span><br><span class="line">    System.out.println(i3 == i4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：</p><blockquote><p>true</p><p>false</p></blockquote><p><strong>因为Integer的范围是：-128 ~ 127</strong> 。Integer、Short、Byte、Character、Long这几个类的 <code>valueOf</code> 是类似的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Double i1 = <span class="number">100.0</span>;</span><br><span class="line">    Double i2 = <span class="number">100.0</span>;</span><br><span class="line">    Double i3 = <span class="number">200.0</span>;</span><br><span class="line">    Double i4 = <span class="number">200.0</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(i1 == i2);</span><br><span class="line">    System.out.println(i3 == i4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：</p><blockquote><p>false</p><p>false</p></blockquote><p><strong>因为在某个范围整形是有限的，而浮点数不是</strong> 。Double、Float的 <code>valueOf</code> 是类似的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Boolean i1 = <span class="keyword">false</span>;</span><br><span class="line">    Boolean i2 = <span class="keyword">false</span>;</span><br><span class="line">    Boolean i3 = <span class="keyword">true</span>;</span><br><span class="line">    Boolean i4 = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(i1 == i2);</span><br><span class="line">    System.out.println(i3 == i4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：</p><blockquote><p>true</p><p>true</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="number">1</span>;</span><br><span class="line">    Integer b = <span class="number">2</span>;</span><br><span class="line">    Integer c = <span class="number">3</span>;</span><br><span class="line">    Long g = <span class="number">3L</span>;</span><br><span class="line">    Long h = <span class="number">2L</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(c==(a+b)); <span class="comment">//1</span></span><br><span class="line">    System.out.println(c.equals(a+b)); <span class="comment">//2</span></span><br><span class="line">    System.out.println(g==(a+b)); <span class="comment">//3</span></span><br><span class="line">    System.out.println(g.equals(a+b)); <span class="comment">//4</span></span><br><span class="line">    System.out.println(g.equals(a+h)); <span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：</p><blockquote><p>true<br>true<br>true<br>false<br>true</p></blockquote><p>首先我们需要知道：</p><p>（1）算术运算符仅对于基本数据类型，所以包装器类型进行运算的时候会自动拆箱；</p><p>（2）<code>equals</code> 会比较两个对象的类型和值。</p><p>所以可以得知 <code>1</code> 、<code>2</code> 和 <code>3</code> 都是 <code>true</code> ，<code>4</code> 因为 <code>Integer</code> 和 <code>Long</code> 类型不同所以是 <code>false</code>，<code>5</code> 因为 <code>h</code> 是 <code>Long</code> 类型，<code>Long</code> 比 <code>Integer</code> 的范围广泛，所以相加后自动装箱会转换为 <code>Long</code> ，之后比较值是相等的，所以是相等的。</p><h4 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h4><ol><li>字符型常量使用单引号，字符串常量使用双引号；</li><li>字符型常量使用2个字节存储，字符串常量的字节数与字符串的长度有有关，其中的每个字符都占一个字节；</li><li>字符型常量在ascii码表中都能找到对应的数值，而字符串常量是指向堆中的一个地址值。</li></ol><h4 id="String、StringBuffer和StringBuilder的区别"><a href="#String、StringBuffer和StringBuilder的区别" class="headerlink" title="String、StringBuffer和StringBuilder的区别"></a>String、StringBuffer和StringBuilder的区别</h4><p>​        String是字符串常量，底层存储的字符数组使用final修饰，所以每次的重新赋值都是在new一个对象，频繁的操作会消耗比较大的内存；Stringbuffer是线程安全的字符串变量，可以修改其中的字符，但是由于使用synchronized关键字来实现线程安全，所以会产生不可避免的开销；StringBuilder是线程不安全的字符串变量，相较于StringBuffer，可以避免锁的开销。</p><h4 id="java中char能存放汉字吗"><a href="#java中char能存放汉字吗" class="headerlink" title="java中char能存放汉字吗"></a>java中char能存放汉字吗</h4><p>能。在Java中，默认使用Unicode编码方式，及每个字符占两个字节，所以可以存储中文。</p><p>String是由char组成，但是它采用更为灵活的方式存储：英文占一个字节，中文占两个字节。这种存储方式可以减少存储的空间，提高存储效率。</p><p>所以可以使用如下方式判断String中是否包含中文：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (str.getBytes().length == str.length()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;无汉字&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;有汉字&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h4><ol><li><p>String</p><p>（1）构造函数：可以传入byte数组、char数组和String类型，同时对于数组，可以传入开始下标和长度来构造一个子数组的字符串；</p><p>（2）length()：返回长度；</p><p>（3）substring()：返回子串，可以传入开始下标和结束下标来指定子串的开始和结束，包左不包右；</p><p>（4）startsWith、endsWith：传入String类型的参数，返回该字符串是否以这个字符串为前缀或后缀；</p><p>（5）contains：返回该字符串是否包含传入的字符串；</p><p>（6）indexOf：返回传入的字符串参数在该字符串中第一次出现的开始下标。</p></li><li><p>Date</p><p>（1）构造函数：无参返回当前日期，有参传入int类型的年月日，也可以再传入小时、分钟、秒，最后使用想要的get方法取出，比如getYear；</p><p>（2）after、before：传入一个Date参数，判断当前日期是否在传入日期的之前或之后；</p><p>（3）compareTo：比较两个日期的顺序，0是相等，小于0是在参数之前，大于0是在参数之后；</p><p>（4）getTime：返回当前日期到基准时间的毫秒值，基准时间是 1970年1月1日0时0分0秒。</p></li></ol><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><p>有四种修饰符可以限制访问的权限：</p><ol><li>public：对所有类可见；</li><li>protected：对同一个包可见，如果父类和子类不在一个包，对不同包的子类可见；</li><li>default：对同一个包可见；</li><li>private：对同一个类可见。</li></ol><h4 id="循环，条件"><a href="#循环，条件" class="headerlink" title="循环，条件"></a>循环，条件</h4><p>while、for、break、continue；if、switch。</p><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><h5 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h5><p>反射的概念是在运行状态中，对于任何一个类，都能知道它的所有属性和方法；对于任何一个对象，都能调用它的任意一个方法和属性。这种动态获取信息和动态调用对象方法的功能叫做反射机制。</p><h5 id="为什么使用反射"><a href="#为什么使用反射" class="headerlink" title="为什么使用反射"></a>为什么使用反射</h5><p>先抛开概念化的定义，看下面的两段代码：</p><p>例子：实现创建一个动物对象 <code>cat</code> 并调用 <code>run</code> 方法计算它跑两公里的距离。</p><p>不用反射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal cat = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="keyword">double</span> distance = cat.run(<span class="number">2d</span>);</span><br></pre></td></tr></table></figure><p>用反射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取动物类的反射对象</span></span><br><span class="line">Class clz = Class.forName(<span class="string">&quot;com.self.example.Animal&quot;</span>);</span><br><span class="line"><span class="comment">// 获取奔跑方法的反射对象</span></span><br><span class="line">Method met = clz.getMathod(<span class="string">&quot;run&quot;</span>, <span class="keyword">double</span>.class);</span><br><span class="line"><span class="comment">// 获取构造方法的反射对象</span></span><br><span class="line">Constructor cons = clz.getConstructor();</span><br><span class="line"><span class="comment">// 通过反射实例化对象</span></span><br><span class="line">Object obj = cons.newInstance();</span><br><span class="line"><span class="comment">//通过反射调用奔跑方法</span></span><br><span class="line">Object distance = met.invoke(obj, <span class="number">2d</span>);</span><br></pre></td></tr></table></figure><p>看起来，反射将两行代码可以解决的问题扩展到了五行代码解决，将简单的事情写复杂化了，但是反射传入的是字符串，如果将字符串提出来，比如放到配置文件中，或者在程序运行的时候传参，这样的程序就会变得非常动态了。</p><p>已知Java程序要运行，需要先将源代码通过javac转变为字节码，然后通过Java解释和执行字节码。Java是静态语言，变量的类型在编译前就需要确定，否则编译不能通过，这样限制了程序的灵活性，所以许多静态语言扩展出了动态的反射机制，以能够动态的获取对象信息和调用对象的方法。</p><h5 id="反射的基本使用"><a href="#反射的基本使用" class="headerlink" title="反射的基本使用"></a>反射的基本使用</h5><p>首先创建一个 <code>Hello</code> 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bonnie.example;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2022/1/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在 <code>resource</code> 文件夹下创建一个属性文件 <code>property.properties</code> 存放 <code>hello</code> 类的信息，以便能够动态修改：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">className</span>=<span class="string">com.bonnie.example.Hello</span></span><br><span class="line"><span class="attr">methodName</span>=<span class="string">sayHello</span></span><br></pre></td></tr></table></figure><p>最后反射该类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bonnie.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2022/1/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reflectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reflect</span><span class="params">(String name )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取配置文件内容</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        ClassLoader classLoader = reflectTest.class.getClassLoader();</span><br><span class="line">        InputStream inputStream = classLoader.getResourceAsStream(<span class="string">&quot;property.properties&quot;</span>);</span><br><span class="line">        pro.load(inputStream);</span><br><span class="line">        String classname = pro.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">        String methodname = pro.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 获取类对象</span></span><br><span class="line">        Class clz = Class.forName(classname);</span><br><span class="line">        <span class="comment">// 3. 获取实例对象</span></span><br><span class="line">        Object obj = clz.getConstructor().newInstance();</span><br><span class="line">        <span class="comment">// 3. 调用set方法存数据</span></span><br><span class="line">        Method set_method = clz.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        set_method.invoke(obj, <span class="keyword">new</span> Object[]&#123;name&#125;);</span><br><span class="line">        <span class="comment">// 4. 调用 methodname 对应的方法显示</span></span><br><span class="line">        Method get_method = clz.getMethod(methodname);</span><br><span class="line">        get_method.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        reflectTest reflect = <span class="keyword">new</span> reflectTest();</span><br><span class="line">        reflect.reflect(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>Class</code> 类是 <code>Reflection API</code> 中的核心类，主要方法如下：</p><ul><li>getName()：获得类的完整名字。 getFields()：获得类的public类型的属性。</li><li>getDeclaredFields()：获得类的所有属性。</li><li>getMethods()：获得类的public类型的方法。</li><li>getDeclaredMethods()：获得类的所有方法。</li><li>getMethod(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes参数指定方法的参数类型。</li><li>getConstrutors()：获得类的public类型的构造方法。</li><li>getConstrutor(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes参数指定构造方法的参数类型。</li><li>newInstance()：通过类的不带参数的构造方法创建这个类的一个对象。</li></ul><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>优点有：</p><ol><li><p>增加程序的灵活性，避免将程序写死在代码里；</p><p>比如一个接口中有若干个实现类，这些类在程序中被频繁使用，可以编写配置文件放接口和实现类，如果改动只需要修改配置文件，就可以利用 <code>Class.forName(class_name).newInstance()</code> 反射获取对应实例。</p></li><li><p>提高代码的复用率，外部调用方便；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.yonyong.reflection.testdemo;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123; <span class="comment">//水果接口</span></span><br><span class="line">　 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>; <span class="comment">//吃水果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123; <span class="comment">//定义苹果</span></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　　　System.out.println(<span class="string">&quot;**吃苹果。&quot;</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　　　System.out.println(<span class="string">&quot;**吃橘子。&quot;</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getInstance</span><span class="params">(String className)</span></span>&#123;</span><br><span class="line">　　　　Fruit fruit = <span class="keyword">null</span> ;</span><br><span class="line">　　　　<span class="keyword">try</span>&#123;</span><br><span class="line">　　　　　　fruit = (Fruit) Class.forName(className).newInstance() ;</span><br><span class="line">　　　　&#125;<span class="keyword">catch</span>(Exception e )&#123;</span><br><span class="line">　　　　　　e.printStackTrace() ;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　<span class="keyword">return</span> fruit ;</span><br><span class="line">　 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryDemo</span></span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">　　<span class="comment">//通过工厂类取得接口实例，传入完整的包.类名称</span></span><br><span class="line">　　　　Fruit f = Factory.getInstance(<span class="string">&quot;cn.yonyong.reflection.testdemo.Apple&quot;</span>) ;</span><br><span class="line">　　　　<span class="keyword">if</span>(f!=<span class="keyword">null</span>)&#123; <span class="comment">//判断是否取得接口实例</span></span><br><span class="line">　　　　　　f.eat() ;</span><br><span class="line">　　　&#125;</span><br><span class="line">　 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要添加一个西瓜类，就只需要在 <code>FactoryDemo</code> 中的 <code>getInstance</code> 反射对应的名称即可。</p></li><li><p>对于任意一个类，都能知道它的所有属性和方法，对于任意一个对象，都能调用它的所有方法。</p></li></ol><p>缺点如下：</p><ol><li>性能问题：反射包含了一些动态类型，这些部分是不能被JVM优化的，所以反射操作的效率会比非反射操作的效率低很多，应该避免在经常被执行的代码和对性能要求较高的场景中使用；</li><li>安全限制：通常反射需要程序的运行没有安全方面的限制，因为反射可以获取类中的任意信息，包括私有信息；</li><li>程序健壮性：反射允许代码执行一些正常情况不被允许的操作，比如访问私有属性和方法，所以使用反射可能会导致代码出现功能上的错误、降低可移植性等副作用。</li></ol><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><ol><li>应用于反编译，将.class文件转变为.java文件；</li><li>常用的一些框架，如Spring的配置化就是利用反射机制来动态加载对象；</li><li>编译器，比如IDEA会有自动联想类的方法或属性的功能。</li></ol><h4 id="正则表达"><a href="#正则表达" class="headerlink" title="正则表达"></a>正则表达</h4><ol><li><p><code>.</code> 表示匹配任意单个字符；</p></li><li><p><code>[]</code> 表示方括号内的字符才参与匹配，仅匹配其中的一个字符；</p></li><li><p><code>|</code> 表示或的关系，<code>(|)</code> 与 <code>[]</code> 类似，但是它可以指定匹配多个字符，如 <code>(a|b|cc)</code> ；</p></li><li><p>匹配次数：</p><p>（1）<code>*</code> 匹配0至多次；</p><p>（2）<code>+</code> 匹配1至多次；</p><p>（3）<code>?</code> 匹配0次或1次；</p><p>（4）<code>&#123;n&#125;</code> 匹配恰好n次；</p><p>（5）<code>&#123;n, m&#125;</code> 匹配n次到m次；</p></li><li><p><code>^</code> 写在 <code>[]</code> 里面表示否，表示不想匹配其中的字符；写在 <code>[]</code> 外表示匹配开始位置；</p></li><li><p><code>$</code> 表示匹配结束位置；</p></li><li><p><code>\S</code> 匹配非空字符；</p></li><li><p><code>\s</code> 匹配一个空字符，如空格、制表符、回车、换页等；</p></li><li><p><code>\r</code> 空格符，与 <code>\n</code>、<code>\tab</code> 相同。</p></li></ol><h2 id="面向对象相关"><a href="#面向对象相关" class="headerlink" title="面向对象相关"></a>面向对象相关</h2><h3 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h3><p>三大特征为：封装、继承、多态。</p><ol><li>封装：指属性私有化，隐藏具体实现的细节，仅提供setter和getter方法来访问属性，用于提高数据安全性，类和方法也属于封装；</li><li>继承：指将多个相同的属性和方法提取出来，新建为一个父类，子类可以重写其中的方法，用于代码复用；</li><li>多态：指的是一个对象的相同方法在不同情形下有不同的表现形式。分为两种，编译时多态和运行时多态，编译时多态即重载，方法名相同而参数不同；运行时多态即重写，子类重写父类方法，用于增强代码的灵活度。</li></ol><h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>​        类和对象之间的关系就好比造车，需要先画图纸，定义好车的属性，比如颜色、大小等，以及车的行为，是要能跑。那么类就相当于图纸，其中包含了这一类事物的公共属性和行为；对象是使用这个类创建的具体的一个实例。</p><p>​        类是自定义的数据类型，通过这个类创建对象，实际上就是初始化这种类型的变量。</p><h3 id="枚举类-enum"><a href="#枚举类-enum" class="headerlink" title="枚举类 enum"></a>枚举类 enum</h3><p>​        它用于声明一组命名的常数，当一个变量有几种可能的取值时，可以将它定义为枚举类型。</p><p>​        enum相较于静态变量的好处在于：（1）类型安全，如果一个方法要传入对应的参数，静态变量的话可以传该类型的任意值，enum只能选择已经指定的常数；（2）方便识别，使用静态变量需要看这个变量名称的前缀才能知道这个变量代表什么，enum是直接从内部取值。</p><p>​        枚举类不能使用new来创建，也不能被继承和实现，可以看成是一个基本数据类型。</p><h3 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h3><p>​        包括List、Map、Set和Queue。其中List、Set和Queue属于Collection接口，Map与Collection同级。</p><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>​        包含ArrayList和LinkedList。二者都用于存储任何类型的可变长数组，不同的是，ArrayList的底层是数组；LinkedList的底层是链表。</p><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>​        包含HashMap、LinkedHashMap和TreeMap。都用于存储key-value形式的数据，其中键值不可重复。</p><p>​        不同的是，HashMap中存储的数据是无序的，底层使用数组+链表的形式存储，当数组长度超过64，链表长度大于等于8时，会转变为红黑树存储。</p><p>​        LinkedHashMap的数据可以按照插入顺序或访问顺序排序，默认是插入顺序，可以修改参数accessOrder为true使用访问顺序排序，底层基于HashMap和双向链表实现的，如果使用访问顺序，那么put或get一个已经存在的Entry时，会将这个entry移动到双向链表的表尾。</p><p>​        TreeMap的底层是红黑树的结构，可以通过指定比较器Comparator来指定排序的策略，如果没有指定，默认是升序。</p><p><strong>面试题：HashMap的底层原理（如何设计一张hash表）</strong></p><p>HashMap的底层由数组+链表+红黑树的形式实现。</p><p>具体实现如下：</p><ol><li>首先对key值进行二次哈希，然后将结果对数组长度取模，存入对应下标；</li><li>如果没有哈希冲突，直接创建Node存入下标对应的位置；</li><li>如果存在哈希冲突，先equals查看是否有相同元素，有则更新，没有则判断链表高度插入链表，如果链表高度到8、数组长度超过64转变为红黑树存储，长度低于6转变为链表存储。</li></ol><p>当数组长度不够，需要进行扩容的时候，会根据扩容因子new一个新的数组，再将旧数组的元素放入新数组使用，扩容因子默认是0.75。</p><p>其中提出的二次哈希，是为了对key的hashCode进行扰动计算，防止不同hashCode的高位不同但低位相同导致的hash冲突。简单来说就是把高位的特征和低位的特征组合起来，降低哈希冲突的概率，尽量做到任何一位的变化都对最终的结果产生影响。</p><p><strong>面试题：HashMap的扩容因子为什么是0.75</strong></p><p>​        考虑两种极端的情况，如果是1.0，那么就需要等到数组满了才会进行扩容。因为hash冲突是避免不了的，当负载因子是1.0时，会加大hash冲突发生的概率，那么底层的红黑树就会很复杂，查询效率会变低；如果是0.5，那么等到满数组的一半就会进行扩容，虽然降低了hash冲突的概率，但是原本1M的数据使用2M的空间存储，就降低了空间的利用率。所以0.75是对时间和空间的权衡得出的结果，空间利用率不会很低，也能保证底层发生hash冲突的概率不会很高。</p><p><strong>面试题：HashMap怎么处理高并发场景</strong></p><p>​        使用ConcurrentHashMap，它的底层cas+synchronized，会先确定这个key对应的数组下标是否为null，也就是是否发生hash冲突，如果没有，就使用cas算法更新；如果有，就synchronized锁住这个对象f，执行更新和扩容的操作。</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>​        包含HashSet、LinkedHashSet、TreeSet。这三者的异同与HashMap、LinkedHashMap和TreeMap的是一致的。</p><p><strong>面试题：HashSet如何检查重复</strong></p><p>当对象 <code>add</code> 到 <code>HashSet</code> 中，首先获取对应的HashCode，判断对象插入的位置，如果没有相同HashCode的对象存在，则成功加入，否则调用 <code>equals</code> 方法判断两个 <code>HashCode</code> 相同的对象是否真的相等，如果相等，加入失败。</p><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><p>​        包含LinkedList、ArrayDeque、ConcurrentLinkedQueue和ConcurrentLinkedDeque。</p><p>​        其中，LinkedList底层一个链表结构，一般用它来实现Queue。</p><p>​        ArrayDeque的底层和ArrayList一样，都是使用数组存储，二者的区别在于删除尾部元素的方式不同。ArrayList会使用System.copyArray()方法将尾部 index 之后的 index + 1 的位置开始的子数组copy到 index 这个位置，也就是通过复制的方式覆盖掉要删除的内容，会比较耗时；ArrayQueue维护了一个tail元素，也就是记录了尾部元素的位置，因此删除的时候只需要 -1 即可。所以<strong>算法中需要频繁删除尾部元素的，可以使用ArrayDeque来代替ArrayList。</strong></p><p>​        ConcurrentLinkedQueue 和 ConcurrentLinkedDeque 都是并发类，使用cas算法来保证无锁情况下的线程安全。不同在于，ConCurrentLinkedQueue是单向链表，元素操作的顺序是FIFO；ConcurrentLinkedDeque是双向链表，操作顺序可以是FIFO或FILO。二者的实现过程非常类似，下面以ConcurrentLinkedQueue为例说明offer操作和poll操作。</p><p>​        其实实现过程与Queue的过程是相似的，不同在于，ConcurrentLinkedQueue使用cas算法执行，并且为了减少cas更新的次数，会设置一个hops&#x3D;2的常量值，允许head和tail节点在这个范围内不更新到现有的头尾节点，直到head和tail节点距离现有的头尾节点的长度超过hops的值，才会进行更新。这个hops的值不能设置的太大，否则也会增加寻找现有头尾节点的时间。</p><p>​        要找尾节点，是从当前的tail节点开始往后遍历到null的前一个节点；要找头节点，是从当前head节点开始往后遍历到值不为null的节点，因为如果不更新head，为了区分，就需要将已经poll出去的节点的值设置为null。</p><h3 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>​        继承是从已有的类中派生出新的类，好处是能够减少重复代码。使用extends关键字实现，一个类只能有一个父类，但是一个类可以有多个子类。</p><p>​        <a href="https://www.cnblogs.com/chenmingjun/p/8449506.html">面试题1（程序题）</a></p><ol><li><p>为什么Java中不支持多重继承？</p><p>​        容易产生歧义。假设继承的多个父类中有相同的方法f，那么一旦调用，就不知道是要调用哪个父类中的f。在C++中使用多类继承避免歧义的方式是在调用前指定类名，它在支持多重继承的角度上也是建议要把这种多个父类中出现同名方法的情况给避免掉，所以为了避免二义性，Java不支持多重继承。</p></li><li><p>为什么 String 在 Java 中是不可变的？</p><p>（1）因为字符串是存储在字符串常量池的，为多个线程共享，如果将它设置为可变的，那么其中一个线程修改了它的值，其他线程也会被迫修改，可能发生错误；</p><p>（2）Java中反射的参数也是String，如果字符串可变会产生安全问题。</p></li><li><p>为什么 char 数组比 Java 中的 String 更适合存储密码？</p><p>​        由于String是存放在常量池中以保证重用，那么这个字符串就会一直保存在这个池中直到GC回收，这个存放的时间可能会很长那么任何有访问权限的人都可以以明文的形式找到密码；而char[]数组可以将元素置为0或空，来降低密码被窃取的风险。</p></li></ol><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>​        多态指为不同数据类型的实体提供统一的接口。</p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>​        参数化类型被称为泛型，泛型允许在创建集合时指定元素的类型，则集合中只保存这种类型的元素。泛型的作用是在编译时期提供类型的检查和强转。</p><p>​        泛型类允许在定义接口、类、方法时声明类型形参，该类型形参在整个接口、类、方法中可以作为普通类型使用，直到声明变量、创建对象或调用方法时再动态的指定实际的参数类型。如果要定义泛型类的子类，因为此时是在使用父类了，所以必须传入实参，或者不传参。</p><p>​        在定义泛型的时候也可以指定类型形参的上限，如 <code>class A&lt;T extends B&gt;</code> ，该声明表示，传入的实参为类型 <code>B</code> 及其子类。</p><p>​        而泛型擦除是指，当把一个具有泛型信息的对象赋值给一个没有泛型的对象，就会把尖括号之间的所有泛型信息都扔掉，比如List&lt;Integer&gt; 类型会转换为 List 类型，则该 List 元素的类型就会变成该类型变量的上限。如果反过来，就是泛型转换。</p><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>​        主要用于解决Java中没有多重继承的情况。</p><p>​        作用：每个内部类都能独立的继承一个类，无论外部类是否已经继承了某个类，对内部类是没有影响的。内部类可以访问创建它的外部类的内容，包括私有变量。</p><p>​        内部类有四种：</p><ol><li>成员内部类：就是普通的内部类，位于另一个类的内部，当它与外部类有同名的成员变量活方法时，默认会使用内部类的，可以使用外部类.this.xxx 来实现外部类的同名变量或方法；</li><li>方法内部类：定义在一个方法或作用域里，与成员内部类的区别在于它的访问权限仅限于这个方法或作用域，局部内部类可以看成是一个局部变量，不能使用public、protected、private、static等修饰；</li><li>静态内部类：static修饰的内部类，可以看成是外部类的一个静态成员，本身不能直接访问外部类的非静态成员，可以使用 new Outer().xxx 的方式来访问；</li><li>匿名内部类：就是一个没有名字的方法内部类，特点和方法内部类完全一致，只是，匿名内部类没有名字，所以没有构造方法，并且必须要继承一个抽象类或实现一个接口。</li></ol><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>​        因为接口不允许实例化，所以不可以有构造函数。接口只能实现，不能继承。</p><h4 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h4><p>二者都是不断抽取出来的抽象的概念。不同的是，抽象类是继承的，只能继承一个，而接口是实现的，可以实现多个。抽象类中可以定义非抽象方法，供子类直接使用；接口的方法都是抽象的，接口中的成员都要固定的修饰符。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><h3 id="异常和错误"><a href="#异常和错误" class="headerlink" title="异常和错误"></a>异常和错误</h3><h2 id="数据结构相关"><a href="#数据结构相关" class="headerlink" title="数据结构相关"></a>数据结构相关</h2><h3 id="如何理解数据结构"><a href="#如何理解数据结构" class="headerlink" title="如何理解数据结构"></a>如何理解数据结构</h3><p>​        数据结构拆开来看就是数据和结构。数据就是未被处理加工的原始素材，可以被细分为数据元素，数据元素是具有一定含义的基本单位，基本单位不是最小单位，具有一定含义表示数据元素是可以被解释的，比如猪、牛、羊等，而猪又由鼻子、嘴巴、脚等构成，这些被称为数据项，数据项就是数据的最小单位。而猪、牛、羊等又可以被划分到一个数据对象中，数据对象是相同数据元素的集合，是数据的子集。</p><p>​        数据之间会存在一些关联关系，这些关系就是结构，所以数据结构用于描述数据之间的关联关系，会研究数据元素的逻辑结构、物理结构及其计算。逻辑结构有集合、线性结构、树形结构和图形结构；物理结构有顺序存储和链式存储。</p><h3 id="常见的8种数据结构"><a href="#常见的8种数据结构" class="headerlink" title="常见的8种数据结构"></a>常见的8种数据结构</h3><h4 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 Array"></a>数组 Array</h4><p>数组在内存中使用连续空间存储，因为使用下标定位元素，所以查询和遍历都很方便，缺点是创建之后无法扩容，只能存储一种类型的元素，插入和删除元素比较耗时。</p><h4 id="链表-Linked-List（ArrayList的底层是数组，本身不属于数据结构）"><a href="#链表-Linked-List（ArrayList的底层是数组，本身不属于数据结构）" class="headerlink" title="链表 Linked List（ArrayList的底层是数组，本身不属于数据结构）"></a>链表 Linked List（ArrayList的底层是数组，本身不属于数据结构）</h4><p>包含单向链表和双向链表，和数组相比，在内存中不需要连续的空间存储，只需要每个节点能够记录下一个节点的引用，就可以通过指针查找下一个节点。所以对链表进行插入和删除的时间复杂度都是O(1)的，不需要确定容量大小，可以添加任何类型的元素。缺点是大量的引用会占用大量的堆空间，并且执行查找需要遍历整个链表。</p><h4 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h4><p>依据先进后出的原则存储数据。</p><h4 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h4><p>依据先进先出的原则存储数据。</p><p>栈和队列的底层都是数组。</p><h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>是有限个节点组成的具有层次关系的集合，每个节点有有限个子节点或没有子节点，有且仅有一个没有父节点的节点，叫根节点，每个非根节点只有一个父节点。可以使用链表或数组来存储。常见的就是二叉树，最多只有两个子节点。</p><p>二叉树中特殊的，包括满二叉树，叶子节点都在最底层；完全二叉树，叶子节点都在最底的两层，且最底层的叶子节点都在左侧；平衡二叉树，左右子树的高度差不超过1；二叉查找树，左子节点的值不会大于当前节点，右子节点的值不会小于当前节点。</p><p>其中，平衡二叉树因为要保证左右子树的高度差不超过1，经常需要通过左旋或右旋的方式保持平衡。</p><p>B树和B+树也比较常见，可以看成是平衡二叉树的矮胖版本。</p><p><strong>面试题：红黑树和AVL树有什么区别？</strong></p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>可以看成是存储结构为数组的完全二叉树，每个节点的值都不大于或不小于它的父节点。根节点最大的堆叫大根堆，根节点最小的堆叫小根堆。</p><h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><p>是复杂的非线性结构，由顶点和边组成，节点之间的关系是任意的。这个数据结构没有使用过。</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>使用键值对的形式存储数据，可以快速的实现元素的查找、插入和删除。</p><h3 id="常见的算法"><a href="#常见的算法" class="headerlink" title="常见的算法"></a>常见的算法</h3><p>常见的算法包括快速排序、归并排序、堆排序、冒泡排序、深度优先遍历、广度优先遍历、动态规划、二分查找、贪心法等。</p><h2 id="设计模式相关"><a href="#设计模式相关" class="headerlink" title="设计模式相关"></a>设计模式相关</h2><h3 id="设计模式的原则"><a href="#设计模式的原则" class="headerlink" title="设计模式的原则"></a>设计模式的原则</h3><ol><li><p>单一原则：</p><p>​    即一个类只有一个职责；</p></li><li><p>开闭原则：</p><p>​    软件实体可扩展，但不可修改。</p><p>​    就好比“一国两制”，一个国家有两种制度，没有修改原有的管理制度，而是增加了一种新的制度。对于扩展是开放的，对于更改是封闭的。</p></li><li><p>里氏代换原则：</p><p>​    子类型必须能够替换掉它们的父类型。</p><p>​    举个例子，假如现在父类是鸟类，有个属性是可以飞，子类有个企鹅类，那么很明显企鹅类不能继承鸟类，因为鸟类有会飞的属性，如果子类企鹅类继承父类鸟类，则企鹅必须会飞。</p></li><li><p>依赖倒置原则：</p><p>​    针对接口编程，不要针对实现编程。</p><p>​    举个例子，就好比你的电脑，如果CPU、内存、硬盘都需要依赖具体的主板，主板坏了，所有的部件都不能用了，这显然是不合理的。</p><p>​    换句话说，即谁也不要依赖谁，除了约定的接口，大家都可以灵活自如。</p></li><li><p>接口隔离原则：</p><p>​    应该使用多个专门的接口，而不使用单一的总接口。</p><p>​    比如有一个学生成绩管理程序，包含插入成绩、删除成绩、修改成绩、打印成绩等功能，这些功能全都放到一个统一的接口中显然是不合理的，正确的作法应该是分为输入、打印等模块进行处理。</p></li><li><p>迪米特原则：</p><p>​    尽量减少对象之间的交互，可以引入一个合理的第三方来降低现有对象之间的耦合度。</p><p>​    比如体育老师上课前清点人数，他让体育委员来替他清点人数，之后再由体育委员告知结果即可，老师本身并没有接触到其他学生。</p></li><li><p>合成&#x2F;聚合复用原则</p><p>​    尽量使用合成&#x2F;聚合，尽量不要使用类继承。</p><p>​    合成表示一种强的“拥有”关系，体现了严格的部分与整体的关系，他们的生命周期相同；而聚合表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。</p><p>​    这里再举个简单的例子，大雁与翅膀是合成关系；而每只大雁都属于一个雁群，即一个雁群可以有多只大雁，所以大雁和雁群是聚合关系。</p></li></ol><h3 id="（1）-单例模式"><a href="#（1）-单例模式" class="headerlink" title="（1） 单例模式"></a>（1） 单例模式</h3><p>使用单一的类创建对象，它只有一个实例，必须自己创建。</p><p>懒汉式 - 线程不安全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton Instance;</span><br><span class="line">    <span class="comment">//私有构造方法，保证外界无法直接实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Instance == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            Tnstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式延迟实例化，好处是没有用到该类，就不会实例化Instance，从而节约资源；坏处是线程不安全，多线程情况下会多次创建实例。</p><p>懒汉式 - 线程安全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton Instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( Instance == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            Instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对静态代码 <code>getInstance()</code> 加锁，以确保多线程环境下只会创建一个实例。</p><p>饿汉式 - 线程安全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Singleton Instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接实例化，不会产生线程不安全的问题，但是这也丢失了延迟实例化带来的节约资源的好处。</p><p>双重校验锁 - 线程安全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton Instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( Instance == <span class="keyword">null</span> )<span class="comment">//为了提高代码执行效率，如果已经创建了实例就不需要再竞争锁了。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>( Singleton.class )<span class="comment">// 类锁，表示只能进入一个实例</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( Instance == <span class="keyword">null</span> )<span class="comment">//防止二次创建实例</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><ul><li>内存中只有一个实例，减少了内存开支。</li><li>避免对资源的多重占用，比如写文件操作，只有一个实例时，避免对同一个资源文件同时写操作。</li></ul><p>缺点：</p><ul><li>没有接口，不能继承，与单一职责冲突。</li></ul><p>使用场景：</p><ul><li>应用程序的日志应用一般使用单例模式实现，因为共享的日志文件一般会一直处于打开状态，所以只能有一个实例取操作，否则内容不好追加；</li><li>操作系统的文件系统也是使用单例模式操作的，因为一个操作系统只能有一个文件系统。</li></ul><h4 id="此处可能会询问volatile的好处"><a href="#此处可能会询问volatile的好处" class="headerlink" title="此处可能会询问volatile的好处"></a>此处可能会询问volatile的好处</h4><p>​        Instance 采用 volatile 关键字修饰也是很有必要的， <code>Instance = new Singleton();</code> 这段代码其实是分为三步执行：分配内存、初始化、指向分配的地址。由于JVM具有指令重排的特性，执行顺序可能会改变，指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 抢占了 T1 的资源，调用 geteInstance() 后发现 Instance 不为空，因此返回 Instance，但此时 Instance 还未被初始化。</p><p>​        使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p><h3 id="（2）观察者模式"><a href="#（2）观察者模式" class="headerlink" title="（2）观察者模式"></a>（2）观察者模式</h3><p>观察者模式很好理解，类似于订阅模式，属于行为型模式的一种，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p><p>在观察者模式中有如下角色：</p><ol><li>Subject：抽象主题（抽象被观察者），定义增删观察者接口和通知观察者更新的接口。</li><li>ConcreteSubject：具体主题（具体被观察者），创建存储观察者的集合，并实现抽象主题的内容。</li><li>Observer：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li><li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li></ol><p>这种发布-订阅的形式我们可以拿微信公众号来举例，假设微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了这个公众号，当这个公众号更新时就会通知这些订阅的微信用户。</p><p>具体实例如下：</p><ol><li>抽象观察者：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>具体观察者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeixinUser</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 微信用户名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeixinUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;-&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象主题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加订阅者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除订阅者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知订阅者更新消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>具体主题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriptionSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//储存订阅公众号的微信用户</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;WeixinUser&gt; weixinUserlist = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(WeixinUser u)</span> </span>&#123;</span><br><span class="line">        weixinUserlist.add(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(WeixinUser u)</span> </span>&#123;</span><br><span class="line">        weixinUserlist.remove(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (WeixinUser u : weixinUserlist) &#123;</span><br><span class="line">            u.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SubscriptSubject sub = <span class="keyword">new</span> SubscriptSubject();</span><br><span class="line">        WechatUser a = <span class="keyword">new</span> WechatUser(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        WechatUser b = <span class="keyword">new</span> WechatUser(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">        sub.attach(a);</span><br><span class="line">        sub.attach(b);</span><br><span class="line">        sub.notify(<span class="string">&quot;你们订阅的内容更新了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">杨影枫-刘望舒的专栏更新了</span><br><span class="line">月眉儿-刘望舒的专栏更新了</span><br><span class="line">紫轩-刘望舒的专栏更新了</span><br></pre></td></tr></table></figure></li></ol><p>优点：</p><ul><li>观察者和被观察者是抽象耦合的</li><li>建立了一套触发机制</li></ul><p>缺点：</p><ul><li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间</li><li>如果观察者和观察目标间有循环依赖，可能导致系统崩溃</li><li>没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的</li></ul><p>使用场景：</p><ul><li>关联行为场景</li><li>事件多级触发场景</li><li>跨系统的消息变换场景，如消息队列的处理机制</li></ul><h3 id="（3）装饰模式"><a href="#（3）装饰模式" class="headerlink" title="（3）装饰模式"></a>（3）装饰模式</h3><p>定义：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</p><p>下面以一个例子来简单说明：</p><p>比如我买了一个机器人，它本身有一个对话的功能。我希望它能在此基础上还能帮我扫地。有两种方式实现：</p><ol><li>第一种方式，可以打电话给厂家，让他们可以研制新的产品，在第一代产品的基础上加两条胳膊，扩展这个功能；</li><li>第二种方式是直接给第一代产品加一个箱子，在这个箱子上面加两条胳膊，这样它也拥有了扫地的功能，这种方式更为灵活，不需要去重新研发设计。</li></ol><p>上述这两种方式都可以实现给一个类或对象增加新的功能，第一种是继承机制，就是继承一个现有的类，然后在子类进行扩展功能；第二种被称为关联机制，是把一个类的对象嵌入到另一个类的对象中，相当于把机器人嵌入到箱子中，给它套一个壳子，扩展出扫地的功能，这个壳子就是装饰器，第二种方式也被称为装饰器模式。</p><p>在开发过程中，这两种方式都经常被使用，他们主要的区别在于：对于继承模式来说，这种方式是静态的，一定要实现一个新的子类来对类层级进行扩展；装饰器模式是动态的，我们拿到一个对象就可以对其进行扩展，不需要修改原有类逻辑。</p><p>下面使用代码来实现上述例子：</p><ol><li><p>创建抽象组件，代表被装饰的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建组件实现类，实现第一代机器人：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">firstRobot</span> <span class="keyword">implements</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建装饰器对第一代机器人扩展：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">robotDecorator</span> <span class="keyword">implements</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="comment">//因为要关联使用机器人，所有要定义一个机器人对象</span></span><br><span class="line">    <span class="keyword">private</span> Robot robot;</span><br><span class="line">    <span class="comment">//接着要传这个对象进来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">robotDecorator</span><span class="params">(Robot robot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.robot = robot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接着实现机器人该有的方法，使用机器人对象实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        robot.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//需要扩展功能，新加扫地的功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doMorething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        robot.doSomething();</span><br><span class="line">        System.out.println(<span class="string">&quot;扫地&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> robotDecorator(<span class="keyword">new</span> firstRobot()).doMorething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对话</span><br><span class="line">扫地</span><br></pre></td></tr></table></figure></li></ol><p>优点：</p><ul><li>装饰类和被装饰类可以独立发展，而不会相互耦合。它有效地把类的核心职责和装饰功能分开了</li><li>装饰模式是继承关系的一个替代方案</li><li>装饰模式可以动态地扩展一个实现类的功能</li></ul><p>缺点：</p><p>多层装饰比较复杂。比如我们现在有很多层装饰，出了问题，就需要一层一层检查，工作量很大。</p><p>使用场景：</p><ul><li>需要扩展一个类的功能时</li><li>需要动态地给一个对象增加功能，并可以动态地撤销时</li><li>需要为一批的兄弟类进行改装或加装功能时</li></ul><h2 id="线程并发"><a href="#线程并发" class="headerlink" title="线程并发"></a>线程并发</h2><h3 id="进程和线程的区别和联系"><a href="#进程和线程的区别和联系" class="headerlink" title="进程和线程的区别和联系"></a>进程和线程的区别和联系</h3><ol><li>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</li><li>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；</li><li>一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；</li><li>不同进程之间的数据很难共享，而多个线程共享进程的内存。</li></ol><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><p><strong>1. 并发：</strong></p><p>指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上只是利用系统CPU的时间分片功能，使多个进程快速交替的执行。</p><p><strong>2. 并行：</strong></p><p>指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。</p><p><strong>3. 场景分析：</strong></p><p>一个应用程序可以是并发的，但不能是并行的，这意味着它可以同时处理多个任务，但是没有两个任务可以同时执行。</p><p>一个应用程序可以是并行的，但不能是并发的，这意味着它可以同时处理多核CPU中一个任务的多个子任务。</p><p>一个应用程序既不能是并行的，也不能是并发的，这意味着它一次顺序地处理所有任务。</p><p>一个应用程序可以是并行的，也可以是并发的，这意味着它可以同时在多核CPU中同时处理多个任务。</p><h3 id="线程的生命周期和状态"><a href="#线程的生命周期和状态" class="headerlink" title="线程的生命周期和状态"></a>线程的生命周期和状态</h3><p>线程一共有五种状态：新生态、就绪态、运行态、阻塞态、死亡态。这五种状态统称线程的生命周期。线程在同一时刻只会处于一种状态。下面简述这五种状态：</p><ol><li><p>新生态：当线程对象创建后，就进入了新生状态：Thread t &#x3D; new Thread();</p></li><li><p>就绪态：当调用线程对象的 <code>start()</code> 方法，就进入了就绪状态。处于就绪状态的线程，只是说明词线程已经做好准备，随时等待CPU调度执行，并不是说调用了 <code>start()</code> 方法线程就会立即执行；</p></li><li><p>运行态：当CPU开始调度处于就绪状态的线程时，该线程真正开始执行，想要进入运行态，就绪态是唯一的入口；</p></li><li><p>阻塞态：处于运行态的线程因为某种原因暂时放弃了CPU的使用权，停止执行，进入阻塞状态，阻塞态可用分为三种：</p><p>（1）等待阻塞：运行态中的线程调用 <code>wait()</code> 方法，使线程进入等待阻塞状态；</p><p>（2）同步阻塞：线程获取Synchronized锁失败，因为此时该锁被其他线程占用，该线程进入同步阻塞状态；</p><p>（3）其他阻塞：调用线程的 <code>sleep()</code> 或 <code>join()</code> 方法或发出I&#x2F;O请求时，会使得线程进入阻塞状态，当 <code>sleep()</code> 超时或 <code>join()</code> 等待线程终止或超时、或I&#x2F;O处理完毕，线程会重新进入就绪态；</p></li><li><p>死亡态：线程执行完毕或异常退出，该线程结束生命周期。</p></li></ol><p><strong>允许状态的转换：</strong></p><ol><li>就绪态转换为运行态：线程得到CPU资源；</li><li>运行态转换为就绪态：线程主动调用 <code>yield()</code> 方法或在运行过程中失去CPU资源；</li><li>运行态转换为死亡态：线程执行完毕或出现异常</li></ol><h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><ol><li><p>概念：死锁指的是两个线程互相拥有对方所需要的资源，由于synchronized的特性，一个线程持有一个资源，或者说获得了一个锁，在该线程释放这个锁之前，其他线程是获取不到这个锁的，并会一直等下去，这就造成了死锁。</p></li><li><p>死锁产生的必要条件：</p><p>（1）互斥条件：一个锁只能被一个线程占用，当一个线程占用一个锁，该锁在被该线程释放前，其他线程都不能获取这个锁；</p><p>（2）不剥夺条件：锁只能由当前占用的线程释放，不能由其他的线程强行剥夺；</p><p>（3）请求和保持条件：线程已经获得一个锁，再获取另一个锁的过程中，即使获取不到也不会释放已经获得的锁；</p><p>（4）循环等待条件：两个线程互相拥有对方需要的锁。</p></li><li><p>如何避免死锁：</p><p>（1）加锁顺序：线程按照相同的顺序加锁；</p><p>（2）加锁时限：线程获取锁的过程限制等待的时间，这需要用到锁的一些API。</p><p>（3）死锁检测：是一种更好的死锁预防机制，针对前两种方法解决不了的情况。当一个线程获得了锁，会在线程和锁相关的数据结构中记下，比如map，除此之外，每当有线程请求锁，也会记录在这个数据结构中，当一个线程获取锁失败，就可以遍历这个数据结构查看是否有死锁发生。</p></li></ol><h3 id="线程池的原理及使用"><a href="#线程池的原理及使用" class="headerlink" title="线程池的原理及使用"></a>线程池的原理及使用</h3><p>​        线程池就是在系统启动或者实例化线程池的时候创建一些空间线程，等待工作调度，执行完任务后，这些线程不会被立即销毁，而是重新处于空闲状态，等待下一次调度。由于线程的创建和销毁需要消耗大量资源，这种方式就可以节省很多不必要的花销，而且响应快，不用等待创建，需要的时候自取就可以了。</p><p>​        Java中常见的线程池有四种：</p><ol><li>newSingleThreadExecutor()单一线程池：内部只有一个线程工作，可用保证程序的执行顺序；</li><li>newCachedThreadExecutor()可缓存线程池：如果线程池中有可用的线程，就使用，没有就新建。可缓存线程池的最大线程数是Integer类型变量的最大值，通常用它来运行一些执行时间较短且经常用到的任务；</li><li>newFixedThreadPool(int nThread)定长线程池：nThread指定线程池的最大线程数，超出的线程在队列等待；</li><li>newScheduledThreadPool(int corePoolSize)定时线程池：支持定时及周期性任务执行，使用schedule方法来传时和周期；</li><li>也可以创建一个自定义线程池，使用ThreadPoolExecutor类创建。</li></ol><p>​        线程池具体的执行流程如下：</p><p>​        提交任务以后，首先查看线程池内的核心线程数有没有满，这个核心线程数指的是线程池中即使没有任何任务也会有指定数量的线程在等待调度，没有满就创建线程执行任务；如果满了，就判断等待队列有没有满，没有满就将任务放进等待队列等待；如果满了，再判断线程池有没有满，没有满，就创建线程执行任务；如果还是满了，就启动拒绝策略处理。</p><p>​        其中拒绝策略有四个：</p><ol><li>AbortPolicy()：直接抛出RejectedExecutionException异常；</li><li>CallerRunsPolicy()：调用run方法阻塞执行；</li><li>DiscardPolicy()：直接丢弃后来的任务；</li><li>DiscardOldestPolicy()：丢弃队列中队首的任务。</li></ol><p>​        线程池的具体使用如下：</p><p>先创建一个 <code>myThread</code> 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bonnie;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2022/1/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在进行......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如使用 newCachedThreadExecutor 线程池处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bonnie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2022/1/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cachedThreadExecutorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> myThread();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> myThread();</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> myThread();</span><br><span class="line"></span><br><span class="line">        pool.execute(t1);</span><br><span class="line">        pool.execute(t2);</span><br><span class="line">        pool.execute(t3);</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-2正在进行......</span><br><span class="line">pool-1-thread-3正在进行......</span><br><span class="line">pool-1-thread-1正在进行......</span><br></pre></td></tr></table></figure><p>​        线程池的相关参数有七个：</p><ol><li><p>corePoolSize：指定核心线程数；</p></li><li><p>maximunPoolSize：指定线程池的最大线程数；</p></li><li><p>keepAliveTime：指定非核心线程的空闲线程的存活时间；</p></li><li><p>timeUnit：指定参数keepAliveTime的时间单位，有七种取值，最大是天，最小是纳秒；</p></li><li><p>workQueue：指定存储等待线程的队列，有四种取值：</p><p>（1）ArrayBlockingQueue：基于数组的有限的FIFO队列，当核心线程满了会插入队列，队列满了会创建线程，如果已经达到最大线程数就会触发拒绝策略；</p><p>（2）LinkedBlockingQueue：基于链表的无限的FIFO队列，这个无限指的是最大线程数为Integer的最大值，此时当核心线程数满了且没有空闲线程时，会一直将新任务存入队列，而不会去创建新的线程，也就是此时这个maximunPoolSize其实是不起作用的；</p><p>（3）SynchronousQueue：不缓存队列，也就是存进来的任务会去直接调度线程，如果没有可用线程就去新建，如果已经达到最大线程数，就会执行拒绝策略；</p><p>（4）PriorityBlockingQueue：是优先级的无限队列，优先级通过参数Comparator实现。</p></li><li><p>threadFactory：线程工厂，可以指定线程的名称、优先级以及类型，比如是用户线程还是守护线程；</p></li><li><p>handler：指定拒绝策略。</p></li></ol><h3 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a>wait和sleep的区别</h3><p>​        二者都可以让线程进入休眠状态，且在休眠中可以接收到终止线程的通知。不同的是：</p><ol><li>sleep()属于Thread类，作用于线程，wait()属于Object类，作用于对象本身，必须和synchronized连用；</li><li>sleep()不会释放锁，wait()会释放；</li><li>sleep()可以在任何地方使用，wait()只能用在同步代码块或同步方法中；</li><li>如果要唤醒线程，sleep()休眠的线程可以等待超时或调用interrupt()方法，wait()可以调用对象的notify()方法。</li></ol><h3 id="几种线程创建方式"><a href="#几种线程创建方式" class="headerlink" title="几种线程创建方式"></a>几种线程创建方式</h3><ol><li>继承Thread类，并重写run方法；</li><li>继承Runnable类，并重写run方法；</li><li>使用线程池来分配线程。</li></ol><h2 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h2><h3 id="互斥、自旋、读写、悲观、乐观锁"><a href="#互斥、自旋、读写、悲观、乐观锁" class="headerlink" title="互斥、自旋、读写、悲观、乐观锁"></a>互斥、自旋、读写、悲观、乐观锁</h3><ol><li>互斥锁：只有一个线程能够获取锁访问资源，其他线程需要等待这个线程释放锁才能尝试获取锁。</li><li>读写锁：写锁是互斥锁，也就是同一时间只能有一个线程执行写操作；读锁是共享锁，任何线程都能进行读加锁，它们阻塞的是写锁的操作，为了避免读线程太多导致写线程一直被阻塞，当出现写锁时，回阻塞后面来的读锁。</li><li>自旋锁：与互斥锁的区别在于，自旋锁会循环查看当前锁是否被释放，这种锁虽然不会频繁的将线程唤醒和挂起，但是也会一直占用CPU，并且容易造成死锁。</li><li>乐观锁：总是假设最好的情况，每次拿数据都认为不会被修改，只会在更新的时候判断一下期间数据有没有被修改过，使用版本号+CAS算法实现。</li><li>悲观锁：总是假设最坏的情况，每次拿数据都认为会被修改，所以都会上锁。</li></ol><h3 id="Synchronized锁"><a href="#Synchronized锁" class="headerlink" title="Synchronized锁"></a>Synchronized锁</h3><h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>​        首先介绍两个概念：</p><p><strong>1. cas算法</strong></p><p>​        CAS算法的全称是比较和交换，可以看成是一个自旋锁。下面以一个例子来说明：</p><p>​        假设有多线程任务，2个线程同时完成对一个共享变量 <code>i</code> 的减法，假设该算法只有三个步骤：<code>get共享变量的值、更新值、将更新的值put回共享变量</code>，不使用CAS算法的运行过程中，可能将前两个步骤完成，然后在要执行第三个步骤的时候被CPU的时间片切出去，第二个线程开始执行，这时候由于两个线程 <code>get</code> 的值一样，最终所得的结果肯定也是一样的；CAS算法在 <code>get</code> 方法设置一个E值，即旧的值，计算步骤完成后，将E值和共享变量内的值比较，如果相同，交换共享变量内的值为更新的值，否则线程再运行一遍，重新获取值进行运算，这也可以称为自旋锁。因为这个算法的核心函数是CPU本地接口提供的，而CPU都是一行一行执行的，不会存在并行过程。</p><p>CAS机制的问题：</p><p>​        ABA问题 - 即假设有两个线程对一个共享变量进行操作，这个值初始为A，第一个线程首先将值修改成了B，然后又改回了A，第二个线程因为比较慢，它获取的E值是A，最后比较的时候第一个线程已经完成了两次修改，共享变量的值还是A，所以对第二个线程来说，共享变量值没有被其他线程改动，是安全的。</p><p>​        这种可能有两种情况：如果共享变量是基本数据类型，是否改动是不重要的；如果是引用类型，其中的属性可能会发生变化。</p><p>​        解决方案：加版本号或时间戳来区分。</p><p><strong>2. 对象头</strong></p><p>​        虚拟机中，对象的存储分为三个部分：对象头、实例数据和对齐填充。</p><p>​        其中对象头包含两部分信息：</p><p>（1）mark word：用于存储运行时数据，比如hashcode、GC分代年龄、锁状态标志等；</p><p>（2）klass pointer：是对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p>​        当对象是数组时，对象头中还需要包含数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但无法确定数组长度的大小。</p><p>​        Synchronized源码使用mark word来标识对象的加锁状态。</p><h4 id="synchronized锁实现原理"><a href="#synchronized锁实现原理" class="headerlink" title="synchronized锁实现原理"></a>synchronized锁实现原理</h4><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，临界区指的是一个用于访问共享资源的代码块，它保证同一时刻只有一个线程访问，同时synchronized关键字还可以保证共享变量的内存可见性。</p><p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p><ol><li><strong>普通同步方法，锁是当前实例对象；</strong></li><li><strong>静态同步方法，锁是当前类的class对象；</strong></li><li><strong>同步方法块，锁是括号里面的对象。</strong></li></ol><p>其中同步代码块是使用monitorenter和monitorexit指令实现的，同步方法依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。</p><p><strong>同步代码块：</strong></p><p>　　monitorenter看成是加锁，monitorexit看成是释放锁，每个对象会维护一个记录加锁次数的计数器，同一个线程每执行一个monitorenter，也就是每获取一次锁，计数器就会自增1，该线程释放一次锁，就会自减1，当计数器为0时，该线程释放锁。</p><p><strong>同步方法：</strong></p><p>　　方法的同步是隐式的，ACC_SYNCHRONIZED标志放在常量池中，每当有线程想要执行该方法，会到常量池中查该方法是否有这个标志，如果有，就会先获取这个对象的监视器锁，然后再执行方法，如果没有成功获取这个锁，就会被阻塞等待。值得注意的是，如果方法出现异常并且方法内部没有处理这个异常，那么在退出方法之前，也会自动释放这个监视器锁。</p><h4 id="锁的优化"><a href="#锁的优化" class="headerlink" title="锁的优化"></a>锁的优化</h4><p>​        JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p><p>​        首先是自旋锁，自旋锁是执行一段无意义的循环去不断查看锁的状态，如果锁被释放了就尝试获取锁。自旋锁可以减少线程被频繁唤醒和挂起的开销，但是它本身也会一直占用CPU的资源。自旋的次数默认是10次，可以通过参数-XX:PreBlockSpin来调整。</p><blockquote><p>列举一个场景，如果线程频繁的进行阻塞和唤醒，会给系统带来很大的压力，同时很多锁的持有状态只会存在很短的一段时间，为了这一段很短的时间频繁的阻塞和唤醒线程是不值得的，于是引入了自旋锁。就是让一个线程去等待一段时间，这段时间内会进行无意义的循环操作，而不会立即被挂起，会不断查看持有锁的线程有没有释放，如果释放了就可以尝试获得锁。自旋锁在jdk1.4中引用，是默认关闭的，可以使用参数开启，在jdk1.6中默认开启，同时自旋次数默认是十次，这个也可以通过参数调整。</p></blockquote><p>​        但是无论怎么调整，都不可能知道具体是多少次，不可能满足所有的情况，所以jdk1.6引入了适应性自旋。适应性自旋锁与自旋锁的区别在于它的自旋次数是会变的，如果线程上次自旋成功了，获得了锁，那么这次自旋的次数就会增加，因为虚拟机认为如果上次成功了，这次成功的可能性会很大；反之如果自旋成功的次数很少，那么之后的自旋次数就会减少，甚至直接忽略掉自旋的过程，以免浪费处理器的资源。</p><p>​        接着是锁消除。比如在一个方法里用了锁，但是JVM检测到这个方法里面不存在共享数据竞争的问题，也就是共享数据在这个方法里面是线程安全的，所以就没有必要加锁，加了锁反而会影响程序的性能。所以JVM检测到这个问题之后，就会将这个锁消除。</p><p>​        然后是锁粗化，在使用锁的时候，应该要让锁作用的程序范围越小越好，这是为了让在锁内执行的代码尽可能少，缩短持有锁的时间，让等待锁的线程能尽快拿到锁，在大多数情况下，这样的作法是正确的，但是在某些情况下，这样的做法是不对的。比如在一段程序内，持续的进行加锁，这个时候它的加锁操作和解锁操作就会特别频繁，而且被锁住的代码都是在一块的，就会导致很多没必要的性能消耗。比如是在一个for循环内加锁，那么每次for循环都要去抢锁和释放锁，那对性能的影响是非常大的，这个时候如果把锁放到for循环外，这个时候，只要抢到锁就可以进入for循环，存粹的for循环和在for循环内加锁，二者的效率肯定会差很多。这就是锁粗化的作用。</p><h4 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a>锁的升级</h4><p>​        下面说明一下synchronized锁升级的过程。从无锁状态会升级到偏向锁状态，当我们创建一个对象的时候，这个对象有一个mark word，里面存储一些数据，比如是否是偏向锁，以及它的锁标志位等，如果锁的标志位是0，说明这个对象没有被加上偏向锁，如果是1，就说明这个对象被加上了偏向锁。偏向锁可以理解成是一个偏心的锁，意思就是这个锁会偏向于第一个获得它的线程，然后在接下来的执行过程中，假如这个锁没有被其他线程竞争，那么持有偏向锁的线程就永远不需要进行同步操作；一旦有其他线程进入锁，这个时候才会撤销这个偏向锁。</p><p>​        偏向锁的撤销，会先到达一个全局的安全点，也就是当前没有字节码运行的一个状态，然后暂停拥有偏向锁的线程，然后判断这个线程是否存活，如果这个线程不存活，或者这个线程存活，但是已经执行完同步代码，就会将对象恢复成无锁状态；否则就将对象升级为轻量级锁状态。线程是否存活可以查看JVM中的所有线程，如果存在这个线程，这个线程就是存活的。偏向锁的撤销过程会使锁的效率大大降低，所以如果运行时存在大量多线程竞争，偏向锁会导致性能下降。这个时候应该要禁用这个偏向锁，如果不禁用，它的抢锁和撤销锁的过程会非常消耗资源。可以使用 UsebiasedLocking参数关闭偏向锁。</p><p>​        然后是轻量级锁。偏向锁升级之后会变成轻量级锁，轻量级锁的竞争方式是在这个mark word中使用cas算法竞争这个锁。轻量级锁就是自旋锁和适应性自旋锁，如果在自旋的这段时间里，没有获得这个锁，就会升级成重量级锁，也就是锁膨胀。</p><p>​        重量级锁依赖于对象内部的monitor，而monitor依赖于操作系统的互斥锁实现，所以重量级锁也被称为互斥锁。互斥锁的开销非常大，主要是因为当系统检测到这个锁是重量级锁后，会把想要获取这个锁的其他线程阻塞，被阻塞的线程是不会消耗cpu的，但是阻塞和唤醒的过程都需要操作系统帮忙，这个时候就需要从用户态转换为内核态，转换状态是非常耗时的，有可能比用户执行代码的时间还要长，所以重量级锁的开销非常大。</p><p>​        总结上述整个流程，偏向锁和轻量级锁都是乐观锁，而重量级锁是悲观锁，一个对象刚开始实例化的时候是没有任何线程访问的，它可以是偏向的，所以当第一个线程访问的时候，它就获得了一个偏向锁，一旦有第二个线程来访问这个对象，因为偏向锁不会主动释放，所以第二个线程就可以看到这个对象是偏向锁的状态，表明这个时候已经存在锁竞争的问题了。要竞争锁的线程，需要检查原持有锁的线程是否存活，如果不存活，就将对象转换为无锁状态，重新进行偏向锁的持有，如果原来的线程存活，就马上执行线程的操作栈，检查这个对象的使用情况，如果仍然需要持有这个偏向锁，这个时候偏向锁就会升级为轻量级锁，如果不存在这个对象的使用，就可以把这个对象恢复成无锁状态，重新进行偏向锁的竞争，然后轻量级锁会进行自旋的操作，如果超出了一定的自旋次数，还没有获取到这个锁，就会升级到重量级锁，此时除了拥有锁的这个线程的其他线程都是阻塞状态。</p><p>​        锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><h3 id="ReentrantLock的底层原理"><a href="#ReentrantLock的底层原理" class="headerlink" title="ReentrantLock的底层原理"></a>ReentrantLock的底层原理</h3><p>Reen trantLock的底层使用CAS+AQS队列来实现，它支持公平锁和非公平锁。</p><p>CAS算法不再赘述，接下来了解一下AQS队列。</p><p>​        AQS队列是一个FIFO队列，队列的头节点是一个哨兵节点，不不与任何线程关联。其他节点会与等待线程关联，每个节点会维护一个等待状态waitStatus。</p><p>ReentrantLock具体的流程是：</p><p>​        先通过CAS算法获得锁，如果此时锁被占用，则线程进入队列并挂起；当锁被释放，队首的线程会被唤醒然后通过CAS尝试获取锁，假设此时还有另一个线程也在尝试获取锁：</p><ol><li>如果是公平锁：当这个线程发现自己不在队首，会进入队列，让队首的线程获取锁；</li><li>如果是非公平锁：那么有可能让不是队首的这个线程抢先获取。</li></ol><h3 id="Synchronized和ReentrantLock的区别"><a href="#Synchronized和ReentrantLock的区别" class="headerlink" title="Synchronized和ReentrantLock的区别"></a>Synchronized和ReentrantLock的区别</h3><ol><li>底层实现上看，Synchronized是JVM层面的关键字，使用本地接口实现，不需要手动释放；ReentrantLock是API层面的实现，使用lock()和unlock()方法来加锁和释放锁，必须要手动进行释放。</li><li>是否可中断：synchronized关键字是不可中断的，除非加锁的代码出现问题；ReentrantLock是可以中断的，可以调用tryLock设置超时方法。</li><li>是否是公平锁：Synchronized是非公平锁，ReentrantLock可以是公平锁或非公平锁。</li><li>是否可以绑定Condition：ReentrantLock可以通过绑定Condition结合await、singal来实现精准唤醒；Synchronized只能通过wait、notify方法来实现随机唤醒或全部唤醒。</li><li>锁定的对象：Synchronized锁的是对象，使用对象头的mark word来表示加锁状态；ReentrantLock锁的是线程，使用waitStatus来表示加锁状态。</li></ol><h3 id="如何实现多线程（面试题回答思路）"><a href="#如何实现多线程（面试题回答思路）" class="headerlink" title="如何实现多线程（面试题回答思路）"></a>如何实现多线程（面试题回答思路）</h3><p>​        对于多线程，首先需要了解并行和并发的概念。对于多线程的执行情况，一般就是以并行或并发的顺序执行的，而不会串行执行。</p><p>​        对于这种情况，又会出现一个问题：如何去保证一个线程的安全。线程安全的意思，就是当多个线程执行时，无论执行的过程是什么样的，最终的结果应该是符合预想的正确的结果。那么如何保证线程安全，就引出了锁机制。有两种锁，乐观锁和悲观锁。</p><h2 id="5-修饰符"><a href="#5-修饰符" class="headerlink" title="5. 修饰符"></a>5. 修饰符</h2><p>分为访问修饰符和非访问修饰符。</p><p><strong>访问修饰符有：</strong></p><ol><li>public：对所有的类都可见；</li><li>protected：对同一个包可见，如果父类和子类不同包，对不同包的子类可见；</li><li>default：对同一个包可见；</li><li>private：对同一个类可见。</li></ol><p><strong>非访问修饰符有：</strong></p><ol><li>static：声明的对象初始化后不能再修改；</li><li>final：修饰的类不能被继承，修饰的方法不能重新定义，修饰的变量为常量；</li><li>synchronized：用于多线程同步；</li><li>abstract：用来创建抽象类和方法。</li></ol><h2 id="6-Object类的常用方法"><a href="#6-Object类的常用方法" class="headerlink" title="6. Object类的常用方法"></a>6. Object类的常用方法</h2><ol><li>equals() - 判断相等</li><li>hashCode() - 返回散列值；</li><li>toString() - 返回对象的字符串表示；</li><li>clone() - 创建并返回对象的克隆对象，一般子类会重写该方法；</li><li>finalized() - 当垃圾收集确定对象没有更多的引用时，由该对象的垃圾收集器调用；</li><li>getClass() - 返回此对象的运行时class类对象；</li><li>notify() - 唤醒正在此对象监视器上等待的某个线程，主要用于多线程通信，需配合wait()方法使用；</li><li>notifyAll() - 唤醒正在此对象监视器上等待的全部线程；</li><li>wait() - 导致当前线程等待，直到另一个对象调用该对象的notify() 或 notifyAll() 方法；</li><li>wait(long timeout) - 导致当前线程等待，直到另一个对象调用该对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法，或经过指定的timeout时间；</li><li>wait(long timeout, int nanos) - 导致当前线程等待，直到另一个对象调用当前对象的 <code>notify()</code> 或 <code>notifyAll()</code> 或经过指定的timeout时间或被其他线程中断当前线程。其中timeout参数是毫秒值，nanos参数是毫微秒值，二者之和用于指定超时时间。</li></ol><h2 id="8-常见的关键字"><a href="#8-常见的关键字" class="headerlink" title="8. 常见的关键字"></a>8. 常见的关键字</h2><p>private、default、public、protected、static初始化后不再更改、this表示当前类的对象引用、final避免重写等。</p><h2 id="9-标识符和关键字的区别"><a href="#9-标识符和关键字的区别" class="headerlink" title="9. 标识符和关键字的区别"></a>9. 标识符和关键字的区别</h2><p>标识符是用户编程时创建的名称，关键字是具有特殊含义的单词。</p><h2 id="13-重载和重写？深拷贝和浅拷贝？"><a href="#13-重载和重写？深拷贝和浅拷贝？" class="headerlink" title="13. 重载和重写？深拷贝和浅拷贝？"></a>13. 重载和重写？深拷贝和浅拷贝？</h2><ol><li>重载和重写：重载是方法名相同参数不同；重写是继承父类方法并重写它。</li><li>深拷贝和浅拷贝：浅拷贝是拷贝原对象的引用值；深拷贝是根据原对象创建一个新对象。</li></ol><h2 id="14-方法的四种类型"><a href="#14-方法的四种类型" class="headerlink" title="14. 方法的四种类型"></a>14. 方法的四种类型</h2><p>无参无返回值、无参有返回值、有参无返回值、有参有返回值。</p><h2 id="17-HashMap-和-HashTable、HashSet、TreeMap-的区别"><a href="#17-HashMap-和-HashTable、HashSet、TreeMap-的区别" class="headerlink" title="17. HashMap 和 HashTable、HashSet、TreeMap 的区别"></a>17. HashMap 和 HashTable、HashSet、TreeMap 的区别</h2><ol><li>HashMap底层由 <code>链表 + 数组 + 红黑树</code> 实现，当链表长度 <code>&gt;=8</code> 、数组长度 <code>超过64</code> 时转换为红黑树，非线程安全，可以存储 <code>null</code> 键和 <code>null</code> 值，初始 <code>size = 16</code> ，扩容方式为 <code>newsize = oldsize * 2</code> 先插入再扩容；</li><li>HashTable底层由 <code>链表 + 数组</code> 实现，通过在方法和对象前添加 <code>syncronized</code> 关键字来保证线程安全，不可以存储 <code>null</code> 键 <code>null</code> 值，初始 <code>size = 11</code> ，扩容方式为 <code>newsize = olesize * 2 + 1</code> 先扩容再插入；</li><li>HashSet底层由HashMap实现，其中的HashMap仅存在key，value都是同一个object，非线程安全；</li><li>TreeMap底层由红黑树实现，是有序的 <code>key-value</code> 组合，非线程安全，存入TreeMap的元素应该实现Comparable或Comparator接口，会按照排序后的顺序迭代元素，元素插入时对元素自动排序，迭代输出就按顺序输出。</li></ol><h2 id="19-ConcurrentHashMap与HashTable的区别"><a href="#19-ConcurrentHashMap与HashTable的区别" class="headerlink" title="19. ConcurrentHashMap与HashTable的区别"></a>19. ConcurrentHashMap与HashTable的区别</h2><p>有两个区别：</p><ol><li><p>底层数据结构：HashTable由 <code>数组 + 链表</code> 组成，ConcurrentHashMap 由 <code>数组 + 链表 + 红黑树</code> 组成；</p></li><li><p>实现线程安全的方式：</p><p>（1）HashTable使用 <code>Syncronized</code> 关键字实现线程安全，将所有方法和对象都上了锁，在高并发的情况下，同一时刻只能有一个线程操作，其他线程会被阻塞等待，并发度低；</p><p>（2）ConcurrentHashMap使用CAS+Synchronized实现，如果不存在Hash冲突使用cas算法插入，否则synchronized锁住下标对应的对象执行插入和扩容。</p></li></ol><h2 id="21-Comparable-和-Comparator-的区别"><a href="#21-Comparable-和-Comparator-的区别" class="headerlink" title="21. Comparable 和 Comparator 的区别"></a>21. Comparable 和 Comparator 的区别</h2><ol><li>Comparable是内部比较器，实现该接口意味着该类支持排序，不需要额外实现比较器，比较简单，但是需要修改源代码；</li><li>Comparator是外部比较器，当需要控制某个类的次序，而该类本身不支持排序，可以自定义一个该类的比较器进行排序，好处是不需要修改源代码，只需要自定义一个比较器。</li></ol><h2 id="24-静态编译和动态编译"><a href="#24-静态编译和动态编译" class="headerlink" title="24. 静态编译和动态编译"></a>24. 静态编译和动态编译</h2><ol><li>静态编译：一次编译，在程序运行前将所有模块全都编译进去；</li><li>动态编译：按需编译，在程序运行过程中，需要用到哪个模块再编译哪个模块。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 1370. 上升下降字符串</title>
      <link href="/2021/11/12/LeetCode-1370-%E4%B8%8A%E5%8D%87%E4%B8%8B%E9%99%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2021/11/12/LeetCode-1370-%E4%B8%8A%E5%8D%87%E4%B8%8B%E9%99%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><a href="https://leetcode-cn.com/problems/increasing-decreasing-string/">https://leetcode-cn.com/problems/increasing-decreasing-string/</a></p><span id="more"></span><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>因为是 <strong>字符的个数</strong> 计算，可以使用 <strong>固定大小的桶</strong> 来存放累加的个数，即大小为 26 的桶。</p><p>然后遍历原字符串，累加相应的字符下标 <code>c - &#39;a&#39;</code> ，之后按照规则，从前往后取，再从后往前取就行。注意，每取一次，减一，直到该元素为0。</p><p>具体代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sortString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] chars = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            ++chars[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(res.length() &lt; s.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(chars[i] &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    --chars[i];</span><br><span class="line">                    res += (<span class="keyword">char</span>)(i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">25</span>; i &gt;= <span class="number">0</span>; --i )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( chars[i] &gt; <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    --chars[i];</span><br><span class="line">                    res += (<span class="keyword">char</span>)(i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 桶计数 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 416. 分割等和子集</title>
      <link href="/2021/11/05/LeetCode-416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/"/>
      <url>/2021/11/05/LeetCode-416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">https://leetcode-cn.com/problems/partition-equal-subset-sum/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这与0-1背包问题大同小异，所以应该先了解0-1背包问题的原理。</p><h3 id="一-0-1背包问题"><a href="#一-0-1背包问题" class="headerlink" title="一. 0-1背包问题"></a>一. 0-1背包问题</h3><p>0-1背包问题是典型的动态规划问题。问题如下：</p><blockquote><p>有n件物品，每件物品的重量为w[i]，价值为c[i]。现有一个容量为V的背包，问如何选取物品放入背包，使得背包内物品的总价值最大。其中每种物品都只有一件。</p><table><thead><tr><th align="center">编号i</th><th align="center">重量w[i]</th><th align="center">价格v[i]</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">2</td><td align="center">3</td><td align="center">4</td></tr><tr><td align="center">3</td><td align="center">4</td><td align="center">5</td></tr><tr><td align="center">4</td><td align="center">5</td><td align="center">8</td></tr><tr><td align="center">5</td><td align="center">9</td><td align="center">10</td></tr></tbody></table><p>背包容量 V &#x3D; 20。</p></blockquote><p>可以得到的过程表格如下：</p><table><thead><tr><th align="center">capacity &#x3D;&gt;</th><th>0</th><th align="center">1</th><th>2</th><th>3</th><th align="center">4</th><th align="center">5</th><th>6</th><th>7</th><th align="center">8</th><th align="center">9</th><th align="center">10</th><th align="center">11</th><th align="center">12</th><th align="center">13</th><th align="center">14</th><th align="center">15</th><th align="center">16</th><th align="center">17</th><th align="center">18</th><th align="center">19</th><th align="center">20</th></tr></thead><tbody><tr><td align="center">no items</td><td>0</td><td align="center">0</td><td>0</td><td>0</td><td align="center">0</td><td align="center">0</td><td>0</td><td>0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">w&#x3D;2,v&#x3D;3</td><td>0</td><td align="center">0</td><td>3</td><td>3</td><td align="center">3</td><td align="center">3</td><td>3</td><td>3</td><td align="center">3</td><td align="center">3</td><td align="center">3</td><td align="center">3</td><td align="center">3</td><td align="center">3</td><td align="center">3</td><td align="center">3</td><td align="center">3</td><td align="center">3</td><td align="center">3</td><td align="center">3</td><td align="center">3</td></tr><tr><td align="center">w&#x3D;3,v&#x3D;4</td><td>0</td><td align="center">0</td><td>3</td><td>4</td><td align="center">4</td><td align="center">7</td><td>7</td><td>7</td><td align="center">7</td><td align="center">7</td><td align="center">7</td><td align="center">7</td><td align="center">7</td><td align="center">7</td><td align="center">7</td><td align="center">7</td><td align="center">7</td><td align="center">7</td><td align="center">7</td><td align="center">7</td><td align="center">7</td></tr><tr><td align="center">w&#x3D;4,v&#x3D;5</td><td>0</td><td align="center">0</td><td>3</td><td>4</td><td align="center">5</td><td align="center">7</td><td>8</td><td>9</td><td align="center">9</td><td align="center">12</td><td align="center">12</td><td align="center">12</td><td align="center">12</td><td align="center">12</td><td align="center">12</td><td align="center">12</td><td align="center">12</td><td align="center">12</td><td align="center">12</td><td align="center">12</td><td align="center">12</td></tr><tr><td align="center">w&#x3D;5,v&#x3D;8</td><td>0</td><td align="center">0</td><td>3</td><td>4</td><td align="center">5</td><td align="center">8</td><td>8</td><td>11</td><td align="center">12</td><td align="center">13</td><td align="center">15</td><td align="center">16</td><td align="center">17</td><td align="center">17</td><td align="center">20</td><td align="center">20</td><td align="center">20</td><td align="center">20</td><td align="center">20</td><td align="center">20</td><td align="center">20</td></tr><tr><td align="center">w&#x3D;9,v&#x3D;10</td><td>0</td><td align="center">0</td><td>3</td><td>4</td><td align="center">5</td><td align="center">8</td><td>8</td><td>11</td><td align="center">12</td><td align="center">13</td><td align="center">15</td><td align="center">16</td><td align="center">17</td><td align="center">17</td><td align="center">20</td><td align="center">20</td><td align="center">21</td><td align="center">22</td><td align="center">23</td><td align="center">25</td><td align="center">26</td></tr></tbody></table><p>表格说明如下：</p><ol><li>行表示前n个商品，列表示在容量为0~20的背包中是否放下；</li><li>第一行 <code>no items</code>，前0件商品在所有容量的背包中占0重量，价值为0，所以第一行为0；</li><li>接下来，假设当前商品重量为 <code>w[i]</code>，价值为 <code>v[i]</code> 。正常来说，商品重量大于容量时，即 <code>w[i] &gt; j</code> ，该商品放不进去，只能沿用之前的结果，即 <code>dp[i][j] = dp[i-1][j]</code> ；商品能放进的时候，即 <code>w[i] &lt;= j</code> ，有两种情况，当前商品如果放进去，就需要减去目前容量相应重量的体积，如果不放进去，则取前 <code>i-1</code> 个商品的结果，取二者的较大值，即 <code>dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])</code> ；</li><li>之后只需要遍历求解，得到的答案为最后的结果 <code>dp[n][m]</code>。</li><li>优化：可以将 <code>dp</code> 数组变为一维数组。</li></ol><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getValue1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum[]= <span class="keyword">new</span> <span class="keyword">int</span>[W];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=W-<span class="number">1</span>;j&gt;=<span class="number">1</span>;j--) &#123;</span><br><span class="line"><span class="keyword">if</span>(weight[i]&lt;=j) &#123;</span><br><span class="line">sum[j]=Math.max(sum[j], sum[j-weight[i]]+value[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(sum[<span class="number">20</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二-本题思路"><a href="#二-本题思路" class="headerlink" title="二. 本题思路"></a>二. 本题思路</h3><p>分析题目：如果一个数组的元素可以分成两个子集，使得两个子集的元素和相等，那么就是说，数组中存在若干个元素，它们的和等于数组总和的一半，那么使用01背包的思想获取即可。</p><p>因为此题中只有一个一维数组表示元素的值，可以考虑使用函数返回值，即 <code>boolean</code> 类型作为递推数组的值。</p><ol><li>首先考虑排除的数据，可以知道，当元素总和是奇数的时候是不可能等分的，可以排除这部分的数据；</li><li>接着，以元素个数为行，总和的一半为列，构建递推数组，也可以使用一维数组来展示，那么省略行。先考虑初始值 <code>dp[0]</code> ，表示前0个元素，肯定包含，即 <code>dp[0] = true</code> ；</li><li>递推公式为 <strong>dp[j] &#x3D; dp[j] | dp[j - nums[i]]</strong> ：与01背包的解答相似，当前元素 <code>nums[i]</code> 如果选择使用，那么取 <code>dp[j - nums[i]]</code> 的结果，如果不选择使用，那么取 <code>dp[j]</code> ，即前 <code>i-1</code> 个元素的结果；只要两种选择有一个为 <code>true</code> ，那么当前这个元素就是 <code>true</code> 。</li></ol><p>具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> n : nums )</span><br><span class="line">        &#123;</span><br><span class="line">            sum += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( sum % <span class="number">2</span> == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[sum + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = sum; j &gt;= nums[i]; --j )</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = dp[j] | dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文章引用"><a href="#文章引用" class="headerlink" title="文章引用"></a>文章引用</h2><p><a href="https://blog.csdn.net/achesong/article/details/88428895">01背包问题</a></p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 145. 二叉树的后序遍历</title>
      <link href="/2021/11/01/LeetCode-145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2021/11/01/LeetCode-145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/</a></p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>涉及到二叉树的遍历问题，自然是考虑 <strong>两种方式，递归和迭代</strong> 。</p><h3 id="一-递归"><a href="#一-递归" class="headerlink" title="一. 递归"></a>一. 递归</h3><p>需要知道一点：如果将数组作为参数传递，传递的是引用值，也就是不需要返回，在作为参数的函数中增删了元素，在作为定义该数组的函数中，也会相应的增删元素，也就是 <strong>实时</strong> 。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        getPostTra(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPostTra</span><span class="params">( TreeNode root, List&lt;Integer&gt; res )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getPostTra(root.left, res);</span><br><span class="line">        getPostTra(root.right, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二-迭代"><a href="#二-迭代" class="headerlink" title="二. 迭代"></a>二. 迭代</h3><ol><li>首先定义一个 <code>ArrayList</code> 存放最终的结果，定义一个 <code>Stack</code> 存放向左遍历时经过的节点，定义一个 <code>pre</code> 节点存放某个已经无法再遍历的节点，建立这个节点的原因是防止重复遍历；</li><li>向左遍历，直到出现 <code>null</code> ，然后判断当前节点的右子节点是否为 <code>null</code> 或者是否已经遍历过自己的右子节点，前者是为了确保该节点是这条支线上的最后一个节点，后者是为了保证已经遍历过右子节点，因为在左子节点为 <code>null</code> 的情况下，只要是两个情况出现任意一个，都可以保证当前节点是没有遍历过的最后一个节点；</li><li>之后就按照这个规则遍历，直到头节点也存储到数组成功，遍历成功。</li></ol><p>具体代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( !stack.empty() || root != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( root != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                stack.add(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>( root.right == <span class="keyword">null</span> || root.right == pre )</span><br><span class="line">            &#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                pre = root;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                stack.add(root);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 迭代 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 206. 反转链表</title>
      <link href="/2021/10/29/LeetCode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/10/29/LeetCode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="一-链表"><a href="#一-链表" class="headerlink" title="一. 链表"></a>一. 链表</h3><p>这是一种常规方法：</p><ol><li>创建两个指针 <code>pre</code> 和 <code>next</code> 表示当前头节点翻转过来后的前一个节点和后一个节点，即 <strong>pre &#x3D; NULL</strong> ，<strong>next &#x3D; head.next</strong> ，这样也就要求了，如果 <code>head == null || head.next == null</code>，可以直接 <code>return head</code>；</li><li>将当前节点的前后节点互换后，往下逐一遍历；</li><li>直到 <code>pre == null</code> ，也就是没有需要往前的节点，这时候，退出循环，将当前节点的 <code>next</code> 连接上后，完成反转。</li></ol><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>, pre = head.next;</span><br><span class="line">        <span class="keyword">while</span>( pre != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            head.next = next;</span><br><span class="line">            next = head;</span><br><span class="line">            head = pre;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二-递归"><a href="#二-递归" class="headerlink" title="二. 递归"></a>二. 递归</h3><p>这种方法只需要注意一个问题，就变得非常简单：<strong>就算递归将 node.next 的位置转换了，node.next 也不会有变化。</strong></p><p>理解如下：有一个链表如下：<code>a -&gt; b -&gt; c -&gt; NULL</code> ，当前节点为 <code>a</code> ，自然， <code>a.next == b</code> 成立，此时有一个递归如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">( ListNode head )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode node = test(head.next);</span><br><span class="line">    node.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果仅让这个函数递归到 <code>b</code> 节点久结束，此时，<code>a</code> 节点的 <code>next</code> 依然指向 <code>b</code> ，而非 <code>c</code> 。</p><p>如上所述，得到的递归方法如下：</p><ol><li>这种方式要求 <code>head != null &amp;&amp; head.next != null</code>， 否则直接 <code>return head</code>；</li><li>按上述的例子假设，<code>b</code> 节点开头的后续节点已经排好序，此时 <code>b</code> 节点应该是最后一个非空节点，而 <code>b</code> 又是当前节点 <code>a</code> 的下一个节点，所以只需要让当前节点的下一个节点的下一个节点等于自己即可：<code>a.next.next = a</code> &#x3D;&#x3D;&#x3D; <code>b.next = a</code>。</li></ol><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode node = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 36. 有效的数独</title>
      <link href="/2021/10/26/LeetCode-36-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/"/>
      <url>/2021/10/26/LeetCode-36-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/valid-sudoku/">https://leetcode-cn.com/problems/valid-sudoku/</a></p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="一-哈希表"><a href="#一-哈希表" class="headerlink" title="一. 哈希表"></a>一. 哈希表</h3><p>提到哈希表，我首先想到的是 <code>Map</code> 操作：</p><ol><li><p>创建 <code>HashMap&lt;Integer, ArrayList&lt;Integer&gt;&gt;</code> 对象存储，使用 <code>ArrayList</code> 是为了方便查重：</p><p>下标 <code>0</code> 存储每行的元素，下标 <code>1</code> 存储每列元素，<code>i</code> 值既为遍历一行的 <code>行</code> ，也是遍历一列的 <code>列</code> ，最外层指针每次往下移动一行，行列下标对应的数组均清空重建。</p></li><li><p>依次遍历每个元素：</p><p>下标 <code>2 - 10</code> 存储9个 <code>3x3</code> 的子宫格。使用 <code>i / 3 * 3 + j / 3 + 2</code> 的下标来定位是哪一个子宫格。</p><p>注意：由于子宫格不会清空，所以需要保证不会重复存储相同下标的值，则遍历行时需要保证行列交叉之前不使用：<code>if j &lt; i then continue;</code> ，遍历列时保证行列交叉及之前不使用：<code>if k &lt;= i then continue;</code></p></li><li><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, ArrayList&lt;Integer&gt;&gt; list = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">11</span>; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            list.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            list.put(<span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( board[i][j] == <span class="string">&#x27;.&#x27;</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> tmp = board[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">int</span> level = (i / <span class="number">3</span>) * <span class="number">3</span> + j / <span class="number">3</span> + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>( list.get(<span class="number">0</span>).contains(tmp) )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    list.get(<span class="number">0</span>).add(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( j &lt; i )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( list.get(level).contains(tmp) )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    list.get(level).add(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list.put(<span class="number">1</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; ++k )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( board[k][i] == <span class="string">&#x27;.&#x27;</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> tmp = board[k][i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">int</span> level = (k / <span class="number">3</span>) * <span class="number">3</span> + i / <span class="number">3</span> + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>( list.get(<span class="number">1</span>).contains(tmp) )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    list.get(<span class="number">1</span>).add(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( k &lt;= i )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( list.get(level).contains(tmp) )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    list.get(level).add(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="二-矩阵"><a href="#二-矩阵" class="headerlink" title="二. 矩阵"></a>二. 矩阵</h3><p>因为 <code>9x9</code> 宫格的行列数已经确定，所以使用数组的形式存储三种条件的数据不会出现很大的资源浪费的情况。</p><ol><li><p>准备三个数组存储三种条件：<code>rows[9][9]</code>、<code>cols[9][9]</code>、<code>subs[3][3][9]</code>；</p></li><li><p>一次遍历数组中的所有元素：<code>board[i][j]</code> ，从而得到一个合法元素的下标值 <code>index = board[i][j] - &#39;0&#39; - 1</code>，<code>-1</code> 是因为下标从 <code>0</code> 开始；</p></li><li><p>遍历一个元素，则所有数组相应增加；</p></li><li><p>最后每次遍历都判断一次是否相应数组元素相加后是否 <code>&gt; 1</code>，只要有一个满足条件，则 <code>false</code>。</p></li><li><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] rows = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">int</span>[][] cols = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">int</span>[][][] subs = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> c = board[i][j];</span><br><span class="line">                <span class="keyword">if</span>( c != <span class="string">&#x27;.&#x27;</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> index = c - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;</span><br><span class="line">                    ++rows[i][index];</span><br><span class="line">                    ++cols[index][j];</span><br><span class="line">                    ++subs[i / <span class="number">3</span>][j / <span class="number">3</span>][index];</span><br><span class="line">                    <span class="keyword">if</span>( rows[i][index] &gt; <span class="number">1</span> || cols[index][j] &gt; <span class="number">1</span> || subs[i / <span class="number">3</span>][j / <span class="number">3</span>][index] &gt; <span class="number">1</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-121-买卖股票的最佳时机</title>
      <link href="/2021/10/21/LeetCode-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
      <url>/2021/10/21/LeetCode-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p><span id="more"></span><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>该题是比较明确的动态规划实例，所以需要考虑如何进行动态规划。</p><h3 id="一-传统动态规划形式"><a href="#一-传统动态规划形式" class="headerlink" title="一. 传统动态规划形式"></a>一. 传统动态规划形式</h3><p>创建一个二维数组 <code>dp[len + 1][len + 1]</code> 来存储当前元素 <code>i - 1</code> 和 <code>j - 1</code> 之间的差值（因为多出一行一列用来存储0值，以防止越界，所以当前的两个元素需要 <code>-1</code> 来获取），然后嵌套遍历数组，如果当前差值比 <code>dp[i-1][j]</code> 和 <code>dp[i][j-1]</code> 大，则取当前差值，否则取其余两个值的最大值。最终返回 <code>dp[len - 1][len]</code> 。</p><p>具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len+<span class="number">1</span>; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = prices[j-<span class="number">1</span>] - prices[i-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>( tmp &gt; dp[i-<span class="number">1</span>] &amp;&amp; tmp &gt; dp[i] )</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = tmp;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i-<span class="number">1</span>], dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len-<span class="number">1</span>][len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将代码改进为只需要遍历一次即可"><a href="#将代码改进为只需要遍历一次即可" class="headerlink" title="将代码改进为只需要遍历一次即可"></a>将代码改进为只需要遍历一次即可</h3><p>仔细分析上述代码，发现三个值 <code>dp[i][j]</code> 、<code>dp[i-1][j]</code> 和 <code>dp[i][j-1]</code> 之间的关系是最值之间的比较，所以只需要标记两个最值 <code>minprice</code> 和 <code>maxprofit</code> 即可，存储到当前元素为止的最值，如果比最小值小，则替换最小值，否则比较最大值和当前差值的大小，取其中的最大值。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minprice = prices[<span class="number">0</span>], maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( prices[i] &lt; minprice )</span><br><span class="line">            &#123;</span><br><span class="line">                minprice = prices[i];</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                maxprofit = Math.max(maxprofit, (prices[i] - minprice));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针</title>
      <link href="/2021/10/20/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
      <url>/2021/10/20/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h2 id="双指针介绍"><a href="#双指针介绍" class="headerlink" title="双指针介绍"></a>双指针介绍</h2><p><strong>双指针</strong>，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（<em>快慢指针</em>）或者相反方向（<em>对撞指针</em>）的指针进行扫描，从而达到相应的目的。</p><span id="more"></span><h3 id="对撞指针"><a href="#对撞指针" class="headerlink" title="对撞指针"></a>对撞指针</h3><p>设计 <code>left</code> 和 <code>right</code> 两个指针，从两头开始向中间开始遍历，比如 <strong>快速排序</strong> ，使用到了对撞指针。</p><p>简易代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>( left &lt; right )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( nums[left] &lt;= nums[right] )</span><br><span class="line">    &#123;</span><br><span class="line">        left ++;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        right --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>设计 <code>fast</code> 和 <code>slow</code> 两个指针，从同一侧开始遍历，二者以不同策略移动，通常来说，慢指针一次走一步，快指针一次走多步。</p><p>经典问题为：是否存在环问题。</p><p>思路为：在慢指针遍历完之前，如果与快指针相遇，存在环，否则不存在。</p><p>具体代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">if</span>( fast.next != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( slow != <span class="keyword">null</span> &amp;&amp; fast != slow )</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>( fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( slow == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://zhuanlan.zhihu.com/p/71643340">算法一招鲜——双指针问题</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表</title>
      <link href="/2021/10/14/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
      <url>/2021/10/14/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/contains-duplicate/">https://leetcode-cn.com/problems/contains-duplicate/</a></p><span id="more"></span><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><h3 id="第一思路"><a href="#第一思路" class="headerlink" title="第一思路"></a>第一思路</h3><p>​        本人的第一思路是使用 <code>arraylist</code> 存放遍历过的元素，如果当前元素在 <code>arraylist</code> 已经存在，返回 <code>true</code>，否则返回 <code>false</code>。</p><p><strong>问题：</strong>当数组元素的个数大到一定程度，会超出时间限制。</p><p><strong>解决：</strong>使用 <code>hashset</code> 存储。</p><h4 id="ArrayList-和-HashSet-的区别"><a href="#ArrayList-和-HashSet-的区别" class="headerlink" title="ArrayList 和 HashSet 的区别"></a>ArrayList 和 HashSet 的区别</h4><p>实际上就是 <code>List</code> 和 <code>Set</code> 两种接口的区别，二者都继承 <code>Collection</code> 接口。</p><p>区别在于：</p><ol><li>ArrayList用于定义一个有序的可重复集合，HashSet用于定义一个无序的不可重复集合；</li><li>ArrayList底层用数组存储，所以如果查找某个元素，会从第一个元素开始顺序查找；HashSet底层由数组+链表的形式存储，先根据元素的 <code>hashcode</code> 值确定数组中的位置，再从该位置的链表从头开始遍历查找元素；所以，HashSet 的查询效率比 ArrayList 高。</li></ol><p><strong>HashSet存储数据的具体流程如下：</strong></p><p> 1.获取关键数据—通过元素的hashCode方法的返回值来获取；<br> 2.通过hash函数计算该数据需要存放在hash表哪个位置；<br> 3.如果没有发生hash碰撞   则放在该位置；<br> 4.如果发生了hash碰撞   形成hash桶（链表）；<br>         形成链表时会触发去重的机制  新来的元素要和链表中的每一个元素进行equals  如果不重复则插在链表末尾（JDK1.8）， 而JDK1.7则会插入在链表的最前面。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> n : nums )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( !set.add(n) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二思路"><a href="#第二思路" class="headerlink" title="第二思路"></a>第二思路</h3><p>先对数组中的元素进行排序，再遍历数组，如果 <code>nums[i] == nums[i+1]</code>，则存在重复元素。</p><p>此处的排序很有讲究，得使用语言自带的排序函数才能通过。</p><p><strong>原因：</strong> 例如Java中自带的排序函数 <code>Arrays.sort()</code> 用到了三个排序算法：插入排序、快速排序、归并排序。</p><p>以数组元素的个数为划分的依据，小于 47 插入，大于等于 47 小于 286 快排，大于等于286 - 高度结构化用归并、非高度结构化用快排。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        devide(nums, <span class="number">0</span>, len - <span class="number">1</span>, tmp);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i] == nums[i+<span class="number">1</span>] )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">devide</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span>[] tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>( l &gt;= r )</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">          devide(nums, l, mid, tmp);</span><br><span class="line">          devide(nums, mid+<span class="number">1</span>, r, tmp);</span><br><span class="line">          merge(nums, l, r, mid, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> mid, <span class="keyword">int</span>[] tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( mid &gt;= r + <span class="number">1</span> || mid &lt; <span class="number">0</span> || l &gt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( i &lt;= mid &amp;&amp; j &lt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i] &lt;= nums[j] )</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[t++] = nums[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmp[t++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( i &lt;= mid )</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[t++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( j &lt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[t++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        i = l;</span><br><span class="line">        <span class="keyword">while</span>( l &lt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            nums[l++] = tmp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表是根据关键键值进行直接访问的数据结构，查询速度非常快，时间复杂度几乎是 O(1) 。如果需要在一秒钟内查找上千条数据，通常就会使用哈希表。</p><p>获取键的哈希值：<code>hash(键)%k</code> 。但是这种方法可能会产生 <strong>哈希冲突</strong> 。实际中这种冲突不可避免，只能设法减少。</p><h4 id="生成哈希函数的方法"><a href="#生成哈希函数的方法" class="headerlink" title="生成哈希函数的方法"></a>生成哈希函数的方法</h4><ol><li><p>直接定址法</p><p>以键的线性函数作为哈希地址：hash(k) &#x3D; a * k + b(其中a,b为常数)&#96; 。</p><p>这种方法不会产生哈希冲突，但是要求键是连续的，否则产生的哈希表会造成较大的空间浪费，因此，该方法适应性不强。</p></li><li><p>数字分析法</p><p>如果键是位数比较多的数字，比如手机号有11位，且这些数字存在相同的规律，则可以抽取剩余规律不同的部分作为散列地址。</p><p>比如手机号的后四位是用户号，前7位很有可能是相同的，那么可以使用后四位作为散列地址。</p><p>如果事先知道关键字的<strong>分布</strong>且关键字的<strong>若干位分布较均匀</strong>，就可以考虑用这个方法。</p></li><li><p>折叠法</p><p>将键值从左到右分成几个部分，然后将几个部分叠加求和，并按散列表表长，取后几位作为散列地址。</p><p>比如 key &#x3D; 9876543210，散列表表长 &#x3D; 3，那么可以分为 987|654|321|0 ，叠加求和：987+654+321+0&#x3D;1962，再取后 3 位得到散列地址即为 962。</p><p>上述方式还不够分布均匀，可以尝试从一端到另一端折叠对齐相加。</p><p>还是上述例子，将 987 和 321 反转，叠加求和为：789+654+123+0&#x3D;1566，得到散列地址为 566。</p><p>折叠法事<strong>先不需要知道关键字的分布</strong>，<strong>适合</strong>关键字位数较多的情况。</p></li><li><p>平方取中法</p><p>取 键 的平方的中位数作为散列地址。</p><p>比如 key &#x3D; 4321，那么平方 &#x3D; 18671041，抽取中间的 3 位就可以是 671，也可以是 710，用做散列地址。</p><p>此方法适合不知道键值分布，而位数又不是很大的情况。</p></li><li><p>除留余数法</p><p>是最常用的构造散列函数的方法。</p><p>公式为：<code>hash(key) = key % k</code></p><p>该方法的关键在于合适的 <code>k</code> 值。根据前人的经验，若表长为 <code>m</code> ，通常 <code>k</code> 为小于等于表长（最好接近 <code>m</code>）的最小质数或不包含小于20的质因子的合数。</p></li><li><p>随机数法</p><p>取 键值 的随机函数值为它的散列地址：<code>hash(key) = random(key)</code></p><p>当键值的长度不等时，采用该方法是最合适的。</p></li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://blog.csdn.net/liu17234050/article/details/104270709/">数据结构—— 构造散列函数的六种方法</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spark - 报错</title>
      <link href="/2021/08/13/spark-%E6%8A%A5%E9%94%99/"/>
      <url>/2021/08/13/spark-%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<h3 id="Error-in-query-Detected-cartesian-product-for-INNER-join-between-logical-plans"><a href="#Error-in-query-Detected-cartesian-product-for-INNER-join-between-logical-plans" class="headerlink" title="Error in query: Detected cartesian product for INNER join between logical plans"></a>Error in query: Detected cartesian product for INNER join between logical plans</h3><p>默认sparksql版本2.x不支持笛卡尔积操作，需要手动开启支持权限：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> spark.sql.crossJoin.enabled<span class="operator">=</span><span class="literal">true</span>;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="Caused-by-org-apache-spark-SparkException-Job-aborted-due-to-stage-failure-ResultStage-98-sql-at-0-M-has-failed-the-maximum-allowable-number-of-M-times-4-M-Most-recent-failure-reason-org-apache-spark-shuffle-MetadataFetchFailedException-Missing-an-output-location-for-shuffle-33"><a href="#Caused-by-org-apache-spark-SparkException-Job-aborted-due-to-stage-failure-ResultStage-98-sql-at-0-M-has-failed-the-maximum-allowable-number-of-M-times-4-M-Most-recent-failure-reason-org-apache-spark-shuffle-MetadataFetchFailedException-Missing-an-output-location-for-shuffle-33" class="headerlink" title="Caused by: org.apache.spark.SparkException: Job aborted due to stage failure: ResultStage 98 (sql at :0)^M has failed the maximum allowable number of^M times: 4.^M Most recent failure reason: org.apache.spark.shuffle.MetadataFetchFailedException: Missing an output location for shuffle 33"></a>Caused by: org.apache.spark.SparkException: Job aborted due to stage failure: ResultStage 98 (sql at <unknown>:0)^M has failed the maximum allowable number of^M times: 4.^M Most recent failure reason: org.apache.spark.shuffle.MetadataFetchFailedException: Missing an output location for shuffle 33</h3><p>不知道具体什么原因（热烈欢迎大佬教我如何深入查找具体原因），只能通过代码大致判断可能数据量太大造成内存溢出。</p><p>解决方法：</p><p>使用 <code>mapjoin </code> 将小表放到内存，减少reduce端的压力。</p><ol><li><p>设置参数：<code>set hive.ignore.mapjoin.hint=true;</code></p><p>true 注释方式不生效，false 注释方式生效 - 用于强行指定需要加入内存走mapjoin的表。</p></li><li><p>将小表进行 <code>mapjoin</code> 操作。</p><p>具体代码为 <code>/*+ mapjoin(table_name)*/</code></p></li></ol><p>具体代码：</p><p>前：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_a <span class="keyword">join</span> table_b;</span><br></pre></td></tr></table></figure><p>其中 <code>table_b</code> 为小表。</p><p>后：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="comment">/*+ mapjoin(table_b)*/</span> <span class="operator">*</span> <span class="keyword">from</span> table_a <span class="keyword">join</span> table_b;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 报错 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hive - 报错</title>
      <link href="/2021/08/06/hive-%E6%8A%A5%E9%94%99/"/>
      <url>/2021/08/06/hive-%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<h3 id="hive-ql-io-orc-OrcSerde-OrcSerdeRow-cannot-be-cast-to-org-apache-hadoop-io-BytesWritable"><a href="#hive-ql-io-orc-OrcSerde-OrcSerdeRow-cannot-be-cast-to-org-apache-hadoop-io-BytesWritable" class="headerlink" title="hive.ql.io.orc.OrcSerde$OrcSerdeRow cannot be cast to org.apache.hadoop.io.BytesWritable"></a>hive.ql.io.orc.OrcSerde$OrcSerdeRow cannot be cast to org.apache.hadoop.io.BytesWritable</h3><span id="more"></span><p>具体报错内容如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&quot;area_flag&quot;:&quot;3&quot;,&quot;kpi_value&quot;:<span class="number">72980.5886</span>&#125;</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.mr.ExecMapper.map(ExecMapper.java:<span class="number">179</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.mapred.MapRunner.run(MapRunner.java:<span class="number">54</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.mapred.MapTask.runOldMapper(MapTask.java:<span class="number">459</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.mapred.MapTask.run(MapTask.java:<span class="number">343</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.mapred.YarnChild$<span class="number">2.</span>run(YarnChild.java:<span class="number">164</span>)</span><br><span class="line">        <span class="keyword">at</span> java.security.AccessController.doPrivileged(Native <span class="keyword">Method</span>)</span><br><span class="line">        <span class="keyword">at</span> javax.security.auth.Subject.doAs(Subject.java:<span class="number">415</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:<span class="number">1917</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.mapred.YarnChild.main(YarnChild.java:<span class="number">158</span>)</span><br><span class="line">Caused <span class="keyword">by</span>: org.apache.hadoop.hive.ql.metadata.HiveException: Hive Runtime Error while processing <span class="type">row</span> &#123;&quot;kpi_code&quot;:&quot;FFJFCW121&quot;,&quot;area_code&quot;:&quot;811&quot;,&quot;area_name&quot;:&quot;北京&quot;,&quot;area_flag&quot;:&quot;3&quot;,&quot;kpi_value&quot;:<span class="number">72980.5886</span>&#125;</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.MapOperator.process(MapOperator.java:<span class="number">507</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.mr.ExecMapper.map(ExecMapper.java:<span class="number">170</span>)</span><br><span class="line">        ... <span class="number">8</span> more</span><br><span class="line">Caused <span class="keyword">by</span>: org.apache.hadoop.hive.ql.metadata.HiveException: Unexpected exception: Unexpected exception: org.apache.hadoop.hive.ql.io.orc.OrcSerde$OrcSerdeRow cannot be cast <span class="keyword">to</span> org.apache.hadoop.io.BytesWritable</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.MapJoinOperator.processOp(MapJoinOperator.java:<span class="number">318</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.Operator.forward(Operator.java:<span class="number">815</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.TableScanOperator.processOp(TableScanOperator.java:<span class="number">98</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.MapOperator$MapOpCtx.forward(MapOperator.java:<span class="number">157</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.MapOperator.process(MapOperator.java:<span class="number">497</span>)</span><br><span class="line">        ... <span class="number">9</span> more</span><br><span class="line">Caused <span class="keyword">by</span>: org.apache.hadoop.hive.ql.metadata.HiveException: Unexpected exception: org.apache.hadoop.hive.ql.io.orc.OrcSerde$OrcSerdeRow cannot be cast <span class="keyword">to</span> org.apache.hadoop.io.BytesWritable</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.MapJoinOperator.processOp(MapJoinOperator.java:<span class="number">318</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.Operator.forward(Operator.java:<span class="number">815</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.internalForward(CommonJoinOperator.java:<span class="number">638</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.genAllOneUniqueJoinObject(CommonJoinOperator.java:<span class="number">670</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.checkAndGenObject(CommonJoinOperator.java:<span class="number">748</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.MapJoinOperator.processOp(MapJoinOperator.java:<span class="number">306</span>)</span><br><span class="line">        ... <span class="number">13</span> more</span><br><span class="line">Caused <span class="keyword">by</span>: java.lang.ClassCastException: org.apache.hadoop.hive.ql.io.orc.OrcSerde$OrcSerdeRow cannot be cast <span class="keyword">to</span> org.apache.hadoop.io.BytesWritable</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat$<span class="number">1.</span>write(HiveIgnoreKeyTextOutputFormat.java:<span class="number">91</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.FileSinkOperator.processOp(FileSinkOperator.java:<span class="number">717</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.Operator.forward(Operator.java:<span class="number">815</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.SelectOperator.processOp(SelectOperator.java:<span class="number">84</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.Operator.forward(Operator.java:<span class="number">815</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.internalForward(CommonJoinOperator.java:<span class="number">638</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.createForwardJoinObject(CommonJoinOperator.java:<span class="number">433</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.genObject(CommonJoinOperator.java:<span class="number">525</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.genObject(CommonJoinOperator.java:<span class="number">522</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.genObject(CommonJoinOperator.java:<span class="number">522</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.genJoinObject(CommonJoinOperator.java:<span class="number">451</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.checkAndGenObject(CommonJoinOperator.java:<span class="number">752</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.MapJoinOperator.processOp(MapJoinOperator.java:<span class="number">306</span>)</span><br><span class="line">        ... <span class="number">18</span> more</span><br></pre></td></tr></table></figure><p>解决：</p><ol><li><p>查看表结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="keyword">desc</span> formatted table_name;</span><br><span class="line">...                 </span><br><span class="line"># Storage Information            </span><br><span class="line">SerDe Library:          org.apache.hadoop.hive.ql.io.orc.OrcSerde        </span><br><span class="line">InputFormat:            org.apache.hadoop.mapred.TextInputFormat         </span><br><span class="line">OutputFormat:           org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat</span><br></pre></td></tr></table></figure><p>可以看到 <code>SerDe Library</code> 的格式为 <code>OrcSerde</code> 。</p><p>有两种可能性：</p><p>（1）可能是复制其他表的结构创建该表，没有复制完，有部分配置不对，这时候需要对比两个表的结构分析；</p><p>（2）创建表结构指定的格式不对。</p></li><li><p>查看表结构</p><p>如果是复制表结构创建的表，可以使用如下命令比对两个表创建时候的结构：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> table_name;</span><br></pre></td></tr></table></figure><p>本次错误是因为没有复制完，漏掉了如下设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ROW</span> FORMAT SERDE </span><br><span class="line">  <span class="string">&#x27;org.apache.hadoop.hive.ql.io.orc.OrcSerde&#x27;</span> </span><br><span class="line"><span class="keyword">WITH</span> SERDEPROPERTIES ( </span><br><span class="line">  <span class="string">&#x27;field.delim&#x27;</span><span class="operator">=</span><span class="string">&#x27;\u0005&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;serialization.format&#x27;</span><span class="operator">=</span><span class="string">&#x27;\u0005&#x27;</span>) </span><br><span class="line">STORED <span class="keyword">AS</span> INPUTFORMAT </span><br><span class="line">  <span class="string">&#x27;org.apache.hadoop.hive.ql.io.orc.OrcInputFormat&#x27;</span> </span><br><span class="line">OUTPUTFORMAT </span><br><span class="line">  <span class="string">&#x27;org.apache.hadoop.hive.ql.io.orc.OrcOutputFormat&#x27;</span></span><br><span class="line">LOCATION</span><br><span class="line">  <span class="string">&#x27;hdfs://ns/domain/ns/sc_share/dm_db/tmp_td_month&#x27;</span></span><br><span class="line">TBLPROPERTIES (</span><br><span class="line">  <span class="string">&#x27;orcfile.compress&#x27;</span><span class="operator">=</span><span class="string">&#x27;Snappy&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;transient_lastDdlTime&#x27;</span><span class="operator">=</span><span class="string">&#x27;1587809055&#x27;</span>)</span><br></pre></td></tr></table></figure><p>解决方式：</p><p>将当前出错的表删掉：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">table</span> table_name;</span><br></pre></td></tr></table></figure><p>然后将原表的结构复制，可能需要修改存储位置<code>LOCATION</code> ；</p><p>最后使用该创建语句再次创建表，成功解决。</p></li><li><p>修改表的格式</p><p>本内容摘自：<a href="https://blog.csdn.net/wawa8899/article/details/81674817">Hive表的file_format参数</a></p><p>有如下这些格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">file_format:</span><br><span class="line">  : SEQUENCEFILE</span><br><span class="line">  <span class="operator">|</span> TEXTFILE    <span class="comment">-- (Default, depending on hive.default.fileformat configuration)  # 默认存储文本格式，不能区分数据类型</span></span><br><span class="line">  <span class="operator">|</span> RCFILE      <span class="comment">-- (<span class="doctag">Note:</span> Available in Hive 0.6.0 and later)</span></span><br><span class="line">  <span class="operator">|</span> ORC         <span class="comment">-- (<span class="doctag">Note:</span> Available in Hive 0.11.0 and later)</span></span><br><span class="line">  <span class="operator">|</span> PARQUET     <span class="comment">-- (<span class="doctag">Note:</span> Available in Hive 0.13.0 and later)</span></span><br><span class="line">  <span class="operator">|</span> AVRO        <span class="comment">-- (<span class="doctag">Note:</span> Available in Hive 0.14.0 and later)</span></span><br><span class="line">  <span class="operator">|</span> JSONFILE    <span class="comment">-- (<span class="doctag">Note:</span> Available in Hive 4.0.0 and later)</span></span><br><span class="line">  <span class="operator">|</span> INPUTFORMAT input_format_classname OUTPUTFORMAT output_format_classname</span><br></pre></td></tr></table></figure><p>TEXTFILE：文本格式，为hive默认的存储格式，这种格式不能区分数据类型（Int类型的数据也只能当作文本来处理）。TEXTFILE在使用时只需要指定两个东西：列与列之间的分隔符；行与行之间的分隔符。<br>SEQUENCEFILE：二进制的，它存在一些问题，这种存储格式存储的数据size比原始数据还要大，现在基本不用。<br>RCFILE：它是一个混合的行列编成的，它保证所有行的一个列都在一个节点（block）之上，缺点是row group太小（4M）了，实际的好处只是空间节省只提升了大约10%，工作中不会大面积使用，所以现在基本也不使用了。<br>ORC：优化过后的RC（行列存储），它提供了更高效的存储方式。一个strip（250M）包含了索引文件，索引范围1~10W。查询时只会查询index范围内的strip，提高查询效率。默认每10000行为一个单位。orc默认采用zlib压缩方式。详见官网说明。<br>PARQUET：源于dremel（三秒钟完成一个T的数据处理），效率很高。<br>AVRO：不常用。<br>JSONFILE：不常用。</p><p>可以使用如下命令修改表的格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">set</span> fileformat file_format;</span><br></pre></td></tr></table></figure><p>一般情况下用来转换为 <code>ORC</code> 格式。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 报错 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hadoop - 面试题</title>
      <link href="/2021/08/03/hadoop-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2021/08/03/hadoop-%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="hadoop解决哪些问题，有哪些特性"><a href="#hadoop解决哪些问题，有哪些特性" class="headerlink" title="hadoop解决哪些问题，有哪些特性"></a>hadoop解决哪些问题，有哪些特性</h3><ol><li><p>主要用于解决海量数据的存储和分析计算的问题。</p></li><li><p>特性有如下四个：</p><p>（1）高可靠性：hadoop底层维护多个数据副本，即使某个节点的计算出现问题或存储出现故障，数据也不会丢失；</p><p>（2）高扩展性：天然支持分布式，可以方便地扩展出几千个节点；</p><p>（3）高效性：在mapreduce的思想中，hadoop是并行工作的，这就提高了任务的处理效率；</p><p>（4）高容错性：可以自动将运行失败的任务重新分配到新的节点运行。</p></li></ol><span id="more"></span><h3 id="hadoop的版本区别"><a href="#hadoop的版本区别" class="headerlink" title="hadoop的版本区别"></a>hadoop的版本区别</h3><p>1.x的版本包含辅助工具，hdfs和mapreduce。其中hdfs负责数据存储，mapreduce负责数据计算和资源调度。</p><p>2.x的版本与1.x版本大致相同，唯一的区别在于将mapreduce的任务一分为二，mapreduce继续负责数据的运算，将资源调度的任务分配给yarn框架。</p><h3 id="常用端口号"><a href="#常用端口号" class="headerlink" title="常用端口号"></a>常用端口号</h3><p>hadoop2：</p><ol><li>HDFS NameNode内部通信端口：8020、9000；</li><li>HDFS NameNode的用户查询端口：50070；</li><li>Yarn查询任务运行情况端口：8080；</li><li>查看历史服务器：19888.</li></ol><p>hadoop3：</p><ol><li>NameNode内部通信端口：8020、9000、9820；</li><li>NameNode对用户开放的查询端口：9870；</li><li>Yarn查询任务运行情况端口：8080；</li><li>查看历史服务器端口：19888.</li></ol><h3 id="常用的配置文件"><a href="#常用的配置文件" class="headerlink" title="常用的配置文件"></a>常用的配置文件</h3><p>2.x：hdfs-site.xml、mapred-site.xml、yarn-site.xml、core-site.xml、slaves；</p><p>3.x：hdfs-site.xml、mapred-site.xml、core-site.xml、yarn-site.xml、workers。</p><h3 id="HDFS相关"><a href="#HDFS相关" class="headerlink" title="HDFS相关"></a>HDFS相关</h3><h4 id="组成架构"><a href="#组成架构" class="headerlink" title="组成架构"></a>组成架构</h4><ol><li>NameNode：用于存储文件的元数据，比如文件名、文件目录结构、文件的块列表以及块所在的datanode等，并处理客户端的读写请求。</li><li>DataNode：存储实际的数据块，并执行数据块的读写操作。</li><li>SecondaryNameNode：它不是NameNode的热备，不能在NameNode挂掉时进行替换，而是辅助NameNode，分担其工作量，比如定期合并fsimage和edits，在NameNode挂掉时辅助恢复NameNode。</li></ol><h4 id="机架感知机制（副本节点的选择）"><a href="#机架感知机制（副本节点的选择）" class="headerlink" title="机架感知机制（副本节点的选择）"></a>机架感知机制（副本节点的选择）</h4><p>默认情况下是三个副本，可以通过dfs.replication参数修改副本数。该参数的范围是1-16，修改后需要重启hdfs。</p><p>默认三个副本的情况下，第一个副本存储在客户端所在的节点上 <code>localstorage</code>，如果客户端不在集群中，就任意选择一个；第二个副本保存在和第一副本不同机架的节点上 <code>chooseremoterack</code>；第三个副本保存在与第二个副本相同的机架的不同节点中，会先判断前两个副本是否在一个机架，为了保证数据的可靠性，副本需要存储在至少两个机架上；如果前两个副本不在同一机架，就将该副本存到第二副本相同机架的不同节点上，因为在保证可靠性的同时，也需要兼顾效率，同一机架的效率比跨机架的效率要高一些。</p><h4 id="NameNode和SecondaryNameNode运行机制（NameNode的容错机制）"><a href="#NameNode和SecondaryNameNode运行机制（NameNode的容错机制）" class="headerlink" title="NameNode和SecondaryNameNode运行机制（NameNode的容错机制）"></a>NameNode和SecondaryNameNode运行机制（NameNode的容错机制）</h4><p>​        首先已知元数据信息被存储在NameNode节点的磁盘中，因此如果频繁的进行读写请求，会导致NameNode的处理效率变低。但是如果将其存储在内存中，那么一旦出现断电，元数据会因为无法及时保存到磁盘而导致数据丢失。于是引入了fsimage，将元数据存储在内存，并备份到磁盘的fsimage中。</p><p>​        但是这里又会出现一个新的问题：如果将元数据保存到内存的时候，同步备份到fsimage，同样会造成NameNode的效率变低；但如果不同步进行，一旦出现断电等情况，内存中的元数据依然会丢失。于是又引入了edits文件。edits只执行追加操作，将数据的变更操作写入edits，这样断电重启的时候就可以直接合并，形成完整的元数据信息。</p><p>​        但是这种合并需要定期执行，否则edits的数据量过大也会导致执行效率变低。如果使用NameNode负责定期合并的操作，会加大NameNode的处理压力，所以引入了SecondaryNameNode来执行定期合并的操作。它的定期将fsimage和edits文件合并生成一个新的fsimage.chkpoint文件，然后拷贝到NameNode中，NameNode会将其重命名为fsimage。</p><h4 id="HDFS中小文件的处理"><a href="#HDFS中小文件的处理" class="headerlink" title="HDFS中小文件的处理"></a>HDFS中小文件的处理</h4><ol><li><p>小文件的影响：因为一个文件不管在磁盘中多大，在HDFS中至少会占用一个数据块存储，如果一个文件的大小为1M，那么存储到数据块中，这个块的其余127M空间都不能再被使用。并且，存储大量小文件，会占用NameNode的大部分内存，甚至会耗尽内存。</p></li><li><p>解决的方法：</p><p>（1）har文件：将多个小文件打包为一个har文件，在HDFS中只会存储这个har文件的元数据信息，但是实际操作中，允许对里面的文件进行透明访问，大致的访问过程是先访问文件的索引数据，然后再定位实际的数据，这种方式会比直接访问hdfs文件的速度要慢一些；</p><p>（2）sequencefile：将文件名作为key，文件内容作为value存储，可以将多个kv形式的文件合并为一个大文件进行存储，这种方式读取数据比较方便，并且不限制数目，但是不能执行追加操作，适用于一次写入大量小文件的场景；</p><p>（3）CombineTextInputFormat：是新的InputFormat的格式，可以将多个小文件从逻辑上划分到一个切片中，但是这种方式不能区分输入的来源。</p></li></ol><h4 id="HDFS的读写过程"><a href="#HDFS的读写过程" class="headerlink" title="HDFS的读写过程"></a>HDFS的读写过程</h4><ol><li>写过程：</li></ol><p>（1）客户端首先创建一个分布式文件系统，向NameNode请求上传文件，NameNode检查这个客户端是否上传的权限以及目标文件路径是否存在，如果有权限且不存在这个路径，就返回可以上传的响应；</p><p>（2）分布式文件系统接着向NameNode询问第一个block要上传到哪个DataNode中，NameNode会返回三个DataNode：dn1、dn2和dn3；</p><p>（3）然后客户端会创建一个FSDataOutputStream对象，先向dn1请求建立传输通道，dn1将请求传给dn2，dn2传给dn3，等到没有datanode，开始往回响应，此时通道建立完毕；</p><p>（4）传输之前，数据会先放到一个缓冲队列，在缓冲队列中，首先以chunk为单位接收数据，一个chunk应该有一个512字节的数据和4字节的校验位，接着这些chunk会形成一个个64k的packet；</p><p>（5）输出流以packet为单位将数据传输到dn1，dn1接收完后再传给dn2，dn再传给dn3；</p><p>（6）输出流在发送packet的同时，会创建一个ack队列，这个队列主要用于接收是否应答成功，确保数据是在应答成功后才会删除，如果没有应答成功，ack队列会将数据再放回缓冲队列中等待再次传输；</p><p>（7）输出流发送的数据先由dn1接收，接收后会向dn2发送，然后dn2向dn3发送，等到dn3接收完毕会向dn2发回应答成功的响应，dn2向dn1发回响应，dn1返回给流对象，流对象接收到响应后才会删除ack队列的数据。</p><ol start="2"><li>读过程：</li></ol><p>（1）客户端创建一个分布式文件系统对象，由这个对象向NameNode请求下载文件，NameNode先判断这个对象是否有权限查看文件，再判断是否存在这个文件，然后将文件的元数据返回给对象；</p><p>（2）客户端会创建一个fsdatainputstream对象，这个对象会依据先就近再随机的原则选择一个DataNode，请求读取数据，但是如果一直使用这个datanode，它的负载就会很高，所以在考虑就近的基础上，还会考虑负载情况来选择datanode读取；</p><p>（3）block之间会以串行的形式读取给客户端。</p><h4 id="为什么数据块不能设置太小也不能设置太大"><a href="#为什么数据块不能设置太小也不能设置太大" class="headerlink" title="为什么数据块不能设置太小也不能设置太大"></a>为什么数据块不能设置太小也不能设置太大</h4><p>HDFS文件在物理上是分块存储的，块的大小可以通过dfs.blocksize调整。默认情况下，hadoop1的块大小是64M，hadoop2的块大小是128M。</p><p>（1）如果设置太小，会增加寻址时间，并且每个块都会在NameNode中存储元数据，也会增大NameNode的开销；</p><p>（2）如果设置太大，以至于从磁盘获取数据的时间明显大于定位这个块开始位置的时间，会导致程序处理这块数据会非常慢。</p><h4 id="HDFS实现高可用"><a href="#HDFS实现高可用" class="headerlink" title="HDFS实现高可用"></a>HDFS实现高可用</h4><p>​        同时启动2个NameNode，一个处于活动状态，一个处于随时待命状态。这样可以保证运行状态的NameNode出现故障的时候，可以在数据不丢失的情况下，手动或自动将待命的NameNode切换到活动状态继续执行。</p><p>​        为了使两个NameNode保持同步，两个NameNode会与一组名为JournalNode的守护程序进行通信。当活动的NameNode修改命名空间时，会定期将执行的操作记录到editlog中，并写入JN的多数节点，比如写入 2n + 1 个守护节点上，只要 n+1 个守护节点成功写入就表示写入成功，而待命的NameNode会一直监听守护节点上editlog的变化，如果出现改动就会读取这个日志并与当前的命名空间合并，保证活动的NameNode发生错误时，待命的NameNode能够与活动的NameNode的命名空间保持一致。</p><p>​        为了让状态切换尽快完成，还需要保证待命的NameNode也实时保存了数据块的存储信息，这样在错误切换的时候，待命的NameNode就不需要等待所有数据块全部汇报完后再切换，而是直接切换到活动状态。我们只需要让DataNode同时向这两个NameNode发送块位置信息和心跳。</p><h3 id="MapReduce相关"><a href="#MapReduce相关" class="headerlink" title="MapReduce相关"></a>MapReduce相关</h3><h4 id="组成架构-1"><a href="#组成架构-1" class="headerlink" title="组成架构"></a>组成架构</h4><p>MapReduce使用主从架构，包含JobClient、JobTracker、TaskTracker和Task。</p><ol><li>在用户端使用JobClient将打包好的jar文件存储到HDFS上，然后将路径提交给JobTracker，JobTracker会创建Task，分发给多个TaskTracker执行；</li><li>JobTracker是主从结构中的主节点，会调度和监控每个Task的状态，如果某个Task执行失败，就会重新运行它；</li><li>TaskTracker是主从结构中的从节点，运行在HDFS的DataNode上，会主动和JobTracker进行通信，接收并执行从JobTracker传过来的任务；</li><li>Task分为Map Task和Reduce Task，由TaskTracker来启动，我们知道在HDFS中使用block为单位存储数据，在MapReduce中则使用split为单位处理数据，这个split是一个逻辑概念，只存储一些元数据信息，比如数据的起始位置、数据的长度、数据所在的节点等。它的划分方法由用户决定，一个split对应一个map task。</li></ol><h4 id="MapReduce核心编程思想（WordCount编程思想）"><a href="#MapReduce核心编程思想（WordCount编程思想）" class="headerlink" title="MapReduce核心编程思想（WordCount编程思想）"></a>MapReduce核心编程思想（WordCount编程思想）</h4><p>​        MapReduce一般会分为Map阶段和Reduce阶段。</p><p>​        在Map阶段，逐行读取数据，按空格分割单词，组成 &lt;单词,1&gt; 的键值对形式，假设这里存在两个分区，分别对应首字母为 a-p、q-z的单词，那么就会将对应首字母的键值对发送到相应的分区，再溢写到磁盘。Map阶段并发执行Map Task，是完全的并行操作，互不干扰。</p><p>​        在Reduce阶段，会开启两个Reduce Task，分别处理 a-p、q-z的分区。Reduce Task也是并发执行的，相互之间不干扰，但是它们的数据依赖于Map Task的输出。</p><h4 id="数据切片和Map-Task并行度"><a href="#数据切片和Map-Task并行度" class="headerlink" title="数据切片和Map Task并行度"></a>数据切片和Map Task并行度</h4><p>Split即数据切片，是逻辑存储，假设要切分130M的数据，数据块会将其切分为128M和2M使用两个数据块实现物理存储，想要切分为三片，需要记录 0-65、65-130的索引，这是数据切分的实现。切片的大小可以大于或小于一个数据块的大小，也可以等于一个数据块的大小，但是大于或小于数据块的时候，就比如刚刚的例子，将数据平分切片，就会涉及跨节点取数据的问题，效率肯定会比获取本地数据要低；如果按照数据块大小切片，在本地文件系统获取数据块，效率就会更高一些。切片不会考虑数据集整体，也就是如果有两个文件输入，不会将两个文件看成一个整体切分，而是每个文件单独切片。</p><p>具体切片的逻辑是：</p><p>首先需要获取 splitsize 一片的大小，涉及三个值：minsize默认1、maxsize默认Long类型的最大值和blocksize数据块的大小，依据max(minsize, min(maxsize, blocksize)) 的逻辑可以得到 一片的大小默认是数据块的大小，然后判断被切数据和splitsize的比值如果大于1.1，就切片，否则不再切片。</p><p>从这个逻辑可以看出，如果控制了 minsize 和 maxsize 的值，就可以控制切片的大小，如果想要调大切片修改 minsize，调小切片修改 maxsize。</p><h4 id="Job提交流程"><a href="#Job提交流程" class="headerlink" title="Job提交流程"></a>Job提交流程</h4><p>通过 <code>waitForCompletion</code> 方法进入提交流程，首先会判断输出路径是否存在，然后建立连接，<code>providerList</code> 有两种连接，YarnClient和LocalClient，选择对应的连接方式，然后给这个任务创建一个JobID，并以这个ID为名称创建存提交文件的文件夹，接着对输入数据执行切片，最后提交的内容包括配置文件、切片信息，如果是集群运行还包括jar包，最后将 DEFINE 状态修改为 RUNNING，提交Job成功。</p><h4 id="Map-Task工作机制"><a href="#Map-Task工作机制" class="headerlink" title="Map Task工作机制"></a>Map Task工作机制</h4><p>分为5个阶段：</p><p>Read阶段：<br>通过InputFormat调用RecorderReader的reader()方法读取数据，默认使用TextInputFormat，其中 k 对应偏移量，v对应一行内容。</p><p>Map阶段：<br>将读取的数据返回给Map，开始执行用户写的Mapper逻辑。</p><p>Collect阶段：</p><p>Mapper阶段的数据首先会进入Partitioner标记分区，接着输出到环形缓冲区，一半存实际数据，一半存数据的索引，分区号就在索引数据中，存储的数据到达80%的阈值或者文件输入完后，执行 <code>sortAndSpill()</code> 方法先对索引数据按分区和key值进行快排再反向溢写到磁盘。</p><p>溢写阶段：<br>遍历分区，溢写到本地文件中，这里并不是一个分区一个文件，而是存在一个文件，然后使用索引划分数据属于哪个分区，一次溢写会生成一个文件。</p><p>Merge阶段：<br>溢写操作结束后，进入 <code>mergeParts</code> 方法，将多个溢写文件归并为一个，并生成一个index文件存储归并后的文件的索引，最终Reduce Task按照index文件中对应的分区读取归并文件中的数据。</p><p><strong>MapTask并行度决定机制：</strong></p><p>​        是由切片的个数决定的，一个切片对应一个maptask，而切片的个数是由输入文件的类型和切片规则决定的。</p><ol><li>切片规则：max(minsize, min(maxsize, blocksize))。</li><li>InputFormat的类型包含了TextInputFormat、CombineInputFormat等。</li></ol><h4 id="ReduceTask工作机制"><a href="#ReduceTask工作机制" class="headerlink" title="ReduceTask工作机制"></a>ReduceTask工作机制</h4><p>包括3个阶段。</p><p>Copy阶段：</p><p>每个reducetask会从本地文件拉取对应分区的数据，数据会先被拉取到内存，等到内存不足才会溢写到磁盘；</p><p>Sort阶段：</p><p>拉取完后，每个reducetask对内存和磁盘中的数据进行统一的归并操作；</p><p>Reduce阶段：<br>相同的key会进入一个reduce中，依据用户的逻辑处理数据并输出文件。最后默认通过TextOutputFormat输出数据。</p><p><strong>并行度决定机制：</strong></p><p>ReduceTask每次拉取数据的并行数一般会通过实验求正态分布中的最大值，具体会比较不同task数目的执行时间，可以通过8088端口开启Yarn界面查看。</p><p>对于ReduceTask的个数，可以直接手动设置：job.setNumReduceTasks(num)，默认是1。ReduceTask的数量与分区数有关。</p><ol><li>当num(Partition) &lt; num(ReduceTask)：因为一个分区对应一个reducetask，所以会有闲置的reducetask，进而生成一些空文件；</li><li>当num(Partition) &#x3D;&#x3D; num(ReduceTask)：刚好一一对应，能够正常执行；</li><li>当num(Partition) &gt; num(ReduceTask)：会报错illegal partition。</li><li>当 num(ReduceTask) &#x3D; 1：会正常执行，所以分区数据都进入一个task处理。</li></ol><h4 id="shuffle过程详解"><a href="#shuffle过程详解" class="headerlink" title="shuffle过程详解"></a>shuffle过程详解</h4><p>​        Map方法之后，Reduce方法之前的混洗的过程就叫做Shuffle。</p><p>​        从Map方法出来之后，会先进入 getPartition() 方法，标记数据是哪个分区的，然后进入环形缓冲区。这个缓冲区默认100M，左侧存索引，右侧存实际的数据，存储的数据量到达80%的阈值后开始反向溢写，这样就可以让缓冲区一直高效运转，不至于在缓冲区满了以后阻塞等待。在溢写之前，还需要对数据中的key的索引，按照字典序进行快排。</p><p>​        溢出的时候，可以通过调用Combiner进行局部汇总，Combiner的过程可以看成是本地的reduce过程，目的是为了减少网络传输的数据量。溢出后，会产生两个文件，一个是实际溢出的数据文件，一个是这个数据文件的索引文件。</p><p>​        之后会对溢出文件执行归并排序。之后也可以执行Combiner操作，之后还可以执行压缩的操作。最终磁盘会产生两个文件，一个存储实际数据，一个存储索引数据，后续reducetask会通过索引文件定位拉取相应分区的数据。</p><p>​        ReduceTask会获取相应分区的数据，先将数据存到内存，等到内存不足再写入磁盘，最终将内存和磁盘的数据进行归并排序，并传给reduce端执行用户逻辑。</p><h4 id="Combiner-过程"><a href="#Combiner-过程" class="headerlink" title="Combiner 过程"></a>Combiner 过程</h4><p>​        Combiner不是MR程序默认的组件，可以看成是一个插件，父类是Reducer，使用reduce方法编写combiner的逻辑，在每个Map Task所在的节点运行。它的目的是对每个Map Task的输出进行局部汇总，以减小网络传输量，比如一个Map Task中有100个 &lt;a,1&gt;，汇总以后变成 &lt;a,100&gt;，那么原来需要传100次，现在只需要传1次。但是Combiner应用的前提是不能影响最终的业务逻辑。假设最终逻辑是求中位数，那么就不能使用combiner来解决了。</p><p>​        编写完Combiner后，需要指定执行它：job.setCombinerClass() 。</p><h4 id="压缩的配置"><a href="#压缩的配置" class="headerlink" title="压缩的配置"></a>压缩的配置</h4><p>​        数据压缩可以在三个地方进行配置：输入端、Mapper输出端以及Reducer输出端。</p><p>​        首先输入端是配置 core-site.xml 的 io.compression.codecs 参数，默认不填写内容；</p><p>​        mapper输出端，会在 mapred-site.xml 里面配置两个参数，一个是 mapreduce.map.output.compress ，默认是false，可以设置为true来启动压缩，一个是 mapreduce.map.output.compress.codecs ，用于指定使用什么类型的压缩，一般是用LZO或Snappy；</p><p>​        在reduce输出端，会在mapred-site.xml里配置两个参数，一个是 mapreduce.output.fileoutputformat.compress ，默认是false，通过设置true来启动压缩，一个是 mapreduce.output.fileoutputformat.compress.codecs，指定压缩的类型，一般是用gzip或bzip2。</p><h4 id="序列化概述"><a href="#序列化概述" class="headerlink" title="序列化概述"></a>序列化概述</h4><p>​        假设机器 hadoop102 的内存中存储数据 abc，想要将其拷贝到机器 hadoop103 上，需要先将 hadoop102 内存中的数据转换为字节码的形式存储到磁盘，然后通过网络传输到 hadoop103 中，再转换到 hadoop103 的内存上。其中，hadoop102 将内存的数据转换为字节码格式的过程叫做序列化，hadoop103 将字节码加载到内存的过程叫做反序列化。</p><p>​        Java中其实本身自带了序列化框架 Serializable，它大致的流程是在要传输数据的末尾再加上各种校验信息、头信息、继承体系等，然后一起打包传输到另一个机器后再序列化，这种机制比较复杂。对Hadoop来说，因为是在系统内部进行传输，所以只需要一个简单的校验。相比于Java的序列化机制，Hadoop序列化因为传输的信息更少，所以存储的空间更小，传输速度更快。</p><p>​        如果想要自定义序列化可以继承 Writable 接口，此处就不过多赘述。</p><h4 id="Map-Join-和-Reduce-Join"><a href="#Map-Join-和-Reduce-Join" class="headerlink" title="Map Join 和 Reduce Join"></a>Map Join 和 Reduce Join</h4><p>reduce join是在map阶段完成数据的标记，在reduce阶段完成数据的合并；</p><p>map join是直接在map阶段完成数据的合并，没有reduce阶段。</p><p>Reduce Join的缺陷：</p><p>1、合并的任务在reduce端执行，reduce端处理压力大，而map端默认情况下一次会处理一个数据块，负载比较低，那么资源利用率不高。<br>2、在Key值分布不均匀的情况下，很容易产生数据倾斜。</p><p>所以如果是一张小表和一张大表执行Join操作，可以考虑将小表加载到内存，在Map端执行Join操作，也就是使用Map Join，Map Join由于没有Reduce阶段，可以极大的减少网络传输和IO的代价。</p><h4 id="hadoop的二级排序"><a href="#hadoop的二级排序" class="headerlink" title="hadoop的二级排序"></a>hadoop的二级排序</h4><p>​        默认情况下，map输出的结果会对key值进行默认的排序，有时候想要在key排序的基础上，对value也进行排序，就用到了二次排序。</p><p>​        二次排序的具体步骤是：会实现WritableComparable接口，然后在 compareTo 方法中对key和value自定义排序的规则即可。</p><h4 id="MapReduce优化"><a href="#MapReduce优化" class="headerlink" title="MapReduce优化"></a>MapReduce优化</h4><h5 id="跑得慢的原因"><a href="#跑得慢的原因" class="headerlink" title="跑得慢的原因"></a>跑得慢的原因</h5><p>Mapreduce的瓶颈在于两点：</p><p>（1）计算机性能：CPU是否充足、内存够用、磁盘的速度是否达到了最佳、网络上的带宽是否够用等。</p><p>（2）I&#x2F;O操作：数据倾斜、Map运行时间太长导致Reduce等待过久、小文件过多。</p><h5 id="具体的优化方法"><a href="#具体的优化方法" class="headerlink" title="具体的优化方法"></a>具体的优化方法</h5><p><strong>1）数据输入</strong></p><p>​        可以通过合并小文件来减少maptask的个数。MR提供了一种新的输入格式CombineTextInputFormat，这个格式会在逻辑上将多个小文件合并为一个split，交由一个maptask执行。</p><p><strong>2）Map端的Shuffle过程</strong></p><p>（1）自定义分区以减少数据倾斜。定义类继承Partitioner接口，重写getPartition方法，在这里面将key打散，比如key+随机数，让数据能够尽量均匀的分布到reduce中；</p><p>（2）减少溢写的次数：<code>mapreduce.task.io.sort.mb</code> 可以调整环形缓冲区的大小，<code>mapreduce.map.sort.spill.percent</code> 可以调整阈值的百分比；</p><p>（3）增加每次merge的个数：<code>mapreduce.task.io.sort.factor</code> 默认值是10，也就是一次归并排序的文件数是10，如果内存充足，可以提高这个参数，以减少归并的次数；</p><p>（4）在不影响业务逻辑的前提下，可以使用Combiner对map输出的数据进行局部聚合，job.setCombinerClass()；</p><p>（5）为了减少网络传输的数据量，可以使用snappy或lzo对数据进行压缩，<code>mapreduce.map.output.compress</code> 设置为true启动压缩，<code>mapreduce.map.output.compress.codecs</code> 设置压缩的类型；</p><p>（6）提高maptask在内存中的上限，<code>mapreduce.map.memory.mb</code> 默认是1G，可以根据128M数据对应1G内存的原则来提高这个内存，修改这个参数的同时，还需要修改maptask中的堆内存 <code>mapreduce.map.java.opts</code> ，如果这个参数比<code>mapreduce.map.memory.mb</code> 设置的值要小，就会报OOM的错误；一般来说这两个参数只需要一致就行；</p><p>（7）如果maptask的任务逻辑涉及大量的运算，可以调整CPU的个数来提高效率，<code>mapreduce.map.cpu.vcores</code> 参数默认maptask中的cpu个数为1；</p><p>（8）异常重试：<code>mapreduce.map.maxattempts</code> 参数默认最多重试4次，一旦重试次数超过这个最大值，就认为该maptask运行这个任务失败。</p><p><strong>3）Reduce端的Shuffle过程</strong></p><p>（1）<code>mapreduce.reduce.shuffle.parallelcopies</code> 默认值是5个，可以通过调整它来设置每个reduce一次拉取数据的并行数。</p><p>（2）<code>mapreduce.reduce.shuffle.input.buffer.percent</code> 默认是0.7，这个参数设置的是拉取的数据在内存中存放的容量大小，默认是总内存的70%；</p><p>（3）<code>mapreduce.reduce.shuffle.merge.percent</code> 默认是0.66，这个参数设置什么时候开始写入磁盘；</p><p>（4）<code>mapreduce.reduce.memory.mb</code> 设置ReduceTask的内存上限，默认是1G，和MapTask是一样的，也有一个 <code>mapreduce.reduce.java.opts</code> 控制reducetask堆内存的大小；</p><p>（5）<code>mapreduce.reduce.cpu.vcores</code> 调整ReduceTask的cpu核数，默认是1个；</p><p>（6）<code>mapreduce.reduce.maxattempts</code> 默认值是4，设置reducetask的最大重试次数；</p><p>（7）为了避免reducettask等待过久，可以设置maptask和reducetask共存，<code>mapreduce.job.reduce.slowstart.completedmaps</code> 设置map完成的比例，达到这个比例后就可以为reducetask申请资源了，默认值是0.05；</p><p>（8）设置超时时间 <code>mapreduce.task.timeout</code> 默认10分钟，如果一个task在这个时间内既不读取也不输出，就认为这个task被卡住了，那么10分钟以后这个task会被强制停止执行；</p><p>（9）因为reduce端肯定会涉及到shuffle过程，效率就会比较低，所以可以不使用reduce，就别用了。</p><p><strong>4）数据倾斜</strong></p><p>（1）数据倾斜现象<br>大量的相同key被分配到一个分区里，map &#x2F;reduce程序执行时，reduce节点大部分执行完毕，但是有一个或者几个reduce节点运行很慢，导致整个程序的处理时间很长。<br>（2）减少数据倾斜的方法</p><p>方法一：将不均匀的key值打散。</p><p>这种方式适用于绝大部分key对应10%的数据，而很少部分的key对应90%的数据。对于这种情况，可以给key值加上随机数，将数据量很大的key值打散到不同的reduce中计算。</p><p>方法二：使用map join代替 reduce join。</p><p>适用于小表join大表的情况。可以将小表放到内存，然后将map task的数据通过hash取余的方式选择小表中对应的key值，进行join操作。在map端的每个map task中完成join操作，后续就不需要进入reduce端处理了，能够避免shuffle过程，从而避免数据倾斜。</p><p>方法三：使用group by代替distinct。</p><p>在统计数量的时候经常会用到 <code>select count(distinct name)</code> ，这样会将name的key值全都shuffle到一个reduce中处理，很容易产生数据倾斜。采用group by+聚合函数的方式可以将数据根据key值分配到不同的reduce中，避免数据倾斜。</p><h3 id="Yarn相关"><a href="#Yarn相关" class="headerlink" title="Yarn相关"></a>Yarn相关</h3><h4 id="组成架构-2"><a href="#组成架构-2" class="headerlink" title="组成架构"></a>组成架构</h4><p>Yarn使用主从架构，包含ResourceManager、NodeManager、ApplicationMaster和Container。</p><p>​        ResourceManager负责整个集群资源的管理，负责处理客户端的请求，监控所有NodeManager的运行情况，当哪个NodeManager的资源不够就可以即使分配资源；也负责启动和监控所有ApplicationMaster，当ApplicationMaster里面有任务挂了可以及时将这个任务分配到其他节点运行。</p><p>​        NodeManager负责管理单个节点的资源，并定时向RM汇报本节点的资源使用情况，它处理来自RM的命令和来自AM的命令。</p><p>​        ApplicationMaster会为应用程序向RM申请资源并分配给内部的任务，然后监控任务的执行，当任务挂掉可以及时向RM反应。</p><p>​        Container是Yarn中的集群抽象，封装了某个节点上的多维度资源，比如内存、磁盘、CPU、网络等。</p><h4 id="Yarn工作机制"><a href="#Yarn工作机制" class="headerlink" title="Yarn工作机制"></a>Yarn工作机制</h4><ol><li>首先执行Jar文件，入口main方法，走到 <code>job.waitForCompletion()</code> 方法会建立一个YarnRunner，开始向RM申请一个Application；</li><li>RM会返回Application资源提交的路径，程序会向这个路径提交三样东西：xml配置文件、jar包、切片文件；</li><li>资源提交完毕后，程序向RM申请运行这个任务的ApplicationMaster，RM会将用户的请求初始化为一个Task，保存到调度队列上，这个调度队列默认使用容量调度器；</li><li>等到NodeManager从调度队列上获取该Task，会创建一个Container，并在这个Container内启动AM，这个AM会下载对应路径下提交的资源，然后根据切片信息向RM申请对应数量的MapTask容器，这个请求也会存到调度队列上等待调度；</li><li>等到NodeManager领取到这个任务后，会创建相应数量的Container，然后将对应的jar包拷贝过来；</li><li>接着AM发送程序启动的脚本到这些Container中，让它们启动并运行MapTask；</li><li>MapTask运行结束后，将输出数据持久化到磁盘；</li><li>然后AM开始向RM申请ReduceTask数目的容器，之后向这些Container发送启动ReduceTask命令，Reduce开始向Map端拉取数据并执行业务逻辑；</li><li>等到所有程序运行完毕，AM会向RM申请注销自己。</li></ol><h4 id="调度器的种类"><a href="#调度器的种类" class="headerlink" title="调度器的种类"></a>调度器的种类</h4><p>调度器的种类有三种：</p><ol><li><p>FIFO调度器：</p><p>​        所有作业被提交到一个队列中，然后先按照优先级高低、再按照作业提交时间选择被执行的作业。这种算法简单，但是如果前一个作业占用了全部的资源，会导致后面的任务一直无法处理。</p></li><li><p>容量调度器：</p><p>（1）是apache hadoop3的默认调度器，支持多个队列，每个队列使用FIFO算法调度；</p><p>（2）管理员可以为每个队列设置最低资源保证和资源上限，这个上限不是固定的，如果一个队列的资源有剩余，可以暂时共享给其他需要资源的队列，但是一旦该队列有新的任务提交，其他队列借调的资源需要立刻归还给该队列；</p><p>（3）支持多用户共享集群和多程序同时运行，此处为了防止同一用户独占队列的资源，会对同一用户所占资源进行限定。</p><p><strong>资源分配算法：</strong></p><p>（1）先确定分配的队列：优先选择资源占用率最低的队列，也就是消耗资源最少的队列；</p><p>（2）接着定位要分配资源的作业：默认按照作业的优先级和提交顺序来执行；</p><p>（3）最后确定分配资源的容器Container：先按照容器的优先级分配，如果优先级相同，按照数据本地性原则分配：先任务和数据在同一节点、然后任务和数据在同一机架、最后任务和数据不在一个节点也不在一个机架。</p></li><li><p>公平调度器：也支持多队列，尽可能保证所有作业都能获得等量的资源，系统中只有一个作业时，会独占所有资源，有其他作业提交时再将资源平分给其他任务。</p></li></ol><p><strong>容量调度器和公平调度器的比较：</strong></p><p>二者核心的区别在于，提交任务到队列中，是采用公平调度还是FIFO调度。对于公平调度器，因为能够尽量保证任务获得等量的资源，所以能够避免因为长时间运行大任务而阻塞小任务；但是容量调度器也可以针对不同的任务创建不同的队列，然后由任务提交者根据任务的特点提交到不同队列中，也可以实现和公平调度器一样的效果。</p><p>调度器的修改参数是 <code>yarn-site.xml</code> 中的 <code>yarn.resourcemanager.scheduler.class</code> 。</p><h4 id="Yarn怎么保证高可用"><a href="#Yarn怎么保证高可用" class="headerlink" title="Yarn怎么保证高可用"></a>Yarn怎么保证高可用</h4><p>在hadoop2.4版本之前，Yarn框架的RM存在单点故障的问题，也就是如果RM挂掉了，恢复的时间会比较长，这就会导致正在运行的程序丢失，影响范围较大，所以从hadoop2.4版本开始，引入了RM高可用机制，典型的高可用集群中，默认会配置两个独立的ResourceManager，在任意时间，有且仅有一个RM处于运行状态，另一台处于待命状态，一旦运行状态的RM出现故障，就可以将待命状态的RM切换为运行状态继续执行任务。切换的方式可以是手动切换，也可以基于Zookeeper实现自动切换。</p><h3 id="三者关系的简述"><a href="#三者关系的简述" class="headerlink" title="三者关系的简述"></a>三者关系的简述</h3><p>客户端将任务提交到RM，RM到某个NM下启动一个container，并在该container内放置传输的AM；接着AM向RM申请资源，RM返回相应的资源列表，然后AM启动这些对应的资源，这些资源在对应的DN上处理相应的任务，这部分称为maptask，maptask处理完后，将所有maptask的结果传输到reduce端执行，最终将reduce端的结果对应的元数据信息传输到namenode中；2NN会每隔一段时间对NM的元数据进行备份。</p><h4 id="作业提交全过程"><a href="#作业提交全过程" class="headerlink" title="作业提交全过程"></a>作业提交全过程</h4><p>画一个大图，将这三者的整个流程全画一遍。<strong>这是必须要会的内容！！！</strong></p><h3 id="ETL的几个过程分别是什么？"><a href="#ETL的几个过程分别是什么？" class="headerlink" title="ETL的几个过程分别是什么？"></a>ETL的几个过程分别是什么？</h3><p>简单的记忆：ETL就是抽取、转换和加载这三个词的缩写，在MR中可以使用Mapper来实现，因为只是过滤数据，所以不需要经过reduce端。</p><hr><p>ETL是Extract Transform Load三个英文单词的缩写，中文意思就是抽取、转换、加载。说到ETL就必须提到数据仓库，ETL负责完成数据从数据源向目标数据仓库转化的过程，是实施数据仓库的重要步骤。<br>构建数据仓库的核心是建模，在数据仓库的构建中，ETL贯穿于项目始终，它是整个数据仓库的生命线。从数据源中抽取数据，然后对这些数据进行转化，最终加载到目标数据库或者数据仓库中去，这就是ETL 过程。<br>通常数据抽取工作分抽取、清洗、转换、装载几个步骤：</p><p>抽取主要是针对各个业务系统及不同服务器的分散数据，充分理解数据定义后，规划需要的数据源及数据定义，制定可操作的数据源，制定增量抽取和缓慢渐变的规则。</p><p>清洗主要是针对系统的各个环节可能出现的数据二义性、重复、不完整、违反业务规则等数据质量问题，允许通过数据抽取设定的数据质量规则，将有问题的记录先剔除出来，根据实际情况调整相应的清洗操作。</p><p>转换主要是针对数据仓库建立的模型，通过一系列的转换来实现将数据从业务模型到分析模型，通过ETL工具可视化拖拽操作可以直接使用标准的内置代码片段功能、自定义脚本、函数、存储过程以及其他的扩展方式，实现了各种复杂的转换，并且支持自动分析日志，清楚的监控数据转换的状态并优化分析模型。</p><p>装载主要是将经过转换的数据装载到数据仓库里面，可以通过直连数据库的方式来进行数据装载，可以充分体现高效性。在应用的时候可以随时调整数据抽取工作的运行方式，可以灵活的集成到其他管理系统中。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL - 报错</title>
      <link href="/2021/07/29/SQL-%E6%8A%A5%E9%94%99/"/>
      <url>/2021/07/29/SQL-%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p><strong>1. SQL_ERROR_INFO: ‘Operand should contain 1 column(s)’</strong></p><span id="more"></span><p>报错语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(salary) <span class="keyword">as</span> avg_salary</span><br><span class="line">  <span class="keyword">from</span> salaries</span><br><span class="line"> <span class="keyword">where</span> salary </span><br><span class="line"><span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(salary)</span><br><span class="line">       ,<span class="built_in">max</span>(salary) </span><br><span class="line">  <span class="keyword">from</span> salaries</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>解决：</p><p><code>in</code> 关键字只能对应一列数据。</p><p><strong>2.FAILED: SemanticException [Error 10044]: Line 1:12 Cannot insert into target table because column number&#x2F;types are different ‘’813’’: Table insclause-0 has 7 columns, but query has 8 columns.</strong></p><p>。。。仔细看 <code>values</code> 里面的内容，应该有多了。</p><p><strong>3. Data source rejected establishment of connection, message from server: “Too</strong></p><p><a href="https://blog.csdn.net/ljphhj/article/details/23804057">借鉴</a></p><p><strong>4. SELECT list is not in GROUP BY clause and contains nonaggregated column ‘practice_record.submit_time’ which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode&#x3D;only_full_group_by”</strong></p><p>这好像是mysql5.7以上版本默认 ONLY_FULL_GROUP_BY 模式的原因。<a href="https://www.cnblogs.com/chancy/p/10026097.html">解决</a></p><p><strong>5. BIGINT UNSIGNED value is out of range in ‘(<code>A</code>.<code>rank2</code> - <code>A</code>.<code>rank1</code>)</strong></p><p>问题出在两个 <code>bigint unsigned</code> 类型的元素相减必须是<strong>非负数</strong>，否则会报这个错。<code>rank()</code> 这种排名函数的结果就是 <code>bigint unsigned</code> 类型。</p><p>解决：类型转换，<code>cast(rank1 as signed)</code></p>]]></content>
      
      
      <categories>
          
          <category> 报错 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - NC156 数组中只出现一次的数（其它数出现k次）</title>
      <link href="/2021/07/29/LeetCode-NC156-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%EF%BC%88%E5%85%B6%E5%AE%83%E6%95%B0%E5%87%BA%E7%8E%B0k%E6%AC%A1%EF%BC%89/"/>
      <url>/2021/07/29/LeetCode-NC156-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%EF%BC%88%E5%85%B6%E5%AE%83%E6%95%B0%E5%87%BA%E7%8E%B0k%E6%AC%A1%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/5d3d74c3bf7f4e368e03096bb8857871?tpId=188&amp;&amp;tqId=38592&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/5d3d74c3bf7f4e368e03096bb8857871?tpId=188&amp;&amp;tqId=38592&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-使用map计数"><a href="#1-使用map计数" class="headerlink" title="1. 使用map计数"></a>1. 使用map计数</h3><p>该方法没有使用到变量 <code>k </code>，它将数组中的每个元素进行计数，并将数值以&lt;元素,count&gt;的形式存储到map中，遍历完数组后，返回map的值为1的键。</p><p>Java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">foundOnceNumber</span> <span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(arr[i], map.getOrDefault(arr[i], <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( Map.Entry m : map.entrySet() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( m.getValue().equals(<span class="number">1</span>) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">int</span>)m.getKey();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><p>代码中提到的map的一点基本操作：</p><p>1） map默认赋值：getOrDefault(a, b)</p><p>map使用 <code>get</code> 方法获取key对应的值，如果没有，会返回 <code>null</code>；可以使用 <code>getOrDefault</code> 方法，如果没有key <code>a</code>，会返回一个默认值 <code>b </code>。</p><p>2）Entry迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Map.Entry m: map.entrySet())</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(m.getKey()+<span class="string">&quot; &quot;</span>+m.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中， <code>m.getKey()</code> 的数据类型为 <code>Object</code> ，指定类型需要进行转换。</p><h3 id="2-排序比较"><a href="#2-排序比较" class="headerlink" title="2. 排序比较"></a>2. 排序比较</h3><p>先对数组进行排序，然后比较 <code>n-1</code> 个元素：</p><p>当前元素下标为 <code>i</code> ，如果 <code>arr[i] == arr[i+1]</code> ，则说明当前元素是重复的，因为从下标为0开始比较，如果重复肯定往后k个元素都是一样的，所以直接往后跳k步，再进行比较；</p><p>为了防止 <code>i+1</code> 的操作越界，需要设定 <code>i &lt; len(arr) - 1</code>，则可以知道，最后一个元素是肯定不会作为 <code>i</code> 进行比较的，所以如果前面所有元素都是重复的，就可以肯定，最后一个元素的个数一定为1。</p><p>python:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param arr int一维数组 </span></span><br><span class="line"><span class="comment"># @param k int </span></span><br><span class="line"><span class="comment"># @return int</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foundOnceNumber</span>(<span class="params">self , arr , k </span>):</span></span><br><span class="line">        arr.sort()</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(arr) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> arr[i] == arr[i+<span class="number">1</span>]:</span><br><span class="line">                i += k</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> arr[i]</span><br><span class="line">        <span class="keyword">return</span> arr[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="3-位运算"><a href="#3-位运算" class="headerlink" title="3. 位运算"></a>3. 位运算</h3><p>因为 <code>k</code> 不一定是偶数，所以不能使用异或运算。可以计算每一位上的1的个数，相同元素肯定会在同一位存在 <code>k</code> 的倍数个 <code>1</code> 。因为 <code>int</code> 的二进制是32位，所以创建长度为32的数组来存储每一位的 <code>1</code> 的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">foundOnceNumber</span> <span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] binary_sum = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> n : arr )</span><br><span class="line">            &#123;</span><br><span class="line">                sum += (n &gt;&gt; i &amp; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            binary_sum[i] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( binary_sum[i] % k != <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                res += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java, python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - NC3 链表中环的入口结点</title>
      <link href="/2021/07/28/LeetCode-NC3-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/"/>
      <url>/2021/07/28/LeetCode-NC3-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=188&amp;&amp;tqId=38577&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=188&amp;&amp;tqId=38577&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking</a></p><span id="more"></span><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><h3 id="1-使用栈留存比较"><a href="#1-使用栈留存比较" class="headerlink" title="1. 使用栈留存比较"></a>1. 使用栈留存比较</h3><p>pHead一次走一步，先与栈中元素进行比较，如果存在当前节点，说明该链表存在环，如果不存在，将当前节点存入，继续进行比较。第一个在栈中出现的节点为入口结点。</p><p>Java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( pHead == <span class="keyword">null</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">        Stack&lt;ListNode&gt; list = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>( pHead != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( list.contains(pHead) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> pHead;</span><br><span class="line">            &#125;</span><br><span class="line">            list.push(pHead);</span><br><span class="line">            pHead = pHead.next;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        arr = []</span><br><span class="line">        <span class="keyword">while</span> pHead:</span><br><span class="line">            <span class="keyword">if</span> pHead <span class="keyword">in</span> arr:</span><br><span class="line">                <span class="keyword">return</span> pHead</span><br><span class="line">            arr.append(pHead)</span><br><span class="line">            pHead = pHead.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="2-使用快慢指针"><a href="#2-使用快慢指针" class="headerlink" title="2. 使用快慢指针"></a>2. 使用快慢指针</h3><p>一开始想到的就是这种方法，但是陷入一个<strong>误区</strong>：快慢指针相等时的节点为入口结点。这个错误的认知就是无知无畏……</p><p>忽略掉的核心步骤：</p><p>快慢指针会进行两次 - </p><p>（1）找到第一个相同的节点，将该节点置为此链表的最后一个节点，此时slow节点至少会遍历完所有的节点一次；</p><p>（2）第二次将fast和slow节点放在头和最后一个节点，每次各走一步：fast走两格、slow走一格；二者第一次相遇的节点即为入口结点。</p><blockquote><p>比如 {1,2},{3,4,5}，其中前面括号是环外的节点，后面是环中的节点。</p><p>第一次遍历：fast - 1 3 5 4；slow - 1 2 3 4 -&gt; 同为4，将链表变为 {1,2},{3,4}；</p><p>第二次便利，fast - 1 3 4；slow - 4 3 -&gt; 同为3，可知入环节点为3.</p></blockquote><p>Java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( pHead == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast = pHead, slow = pHead;</span><br><span class="line">        Stack&lt;ListNode&gt; slow_list = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>( fast != <span class="keyword">null</span> &amp;&amp; slow != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( fast.next != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            slow_list.push(slow);</span><br><span class="line">            <span class="keyword">if</span>( fast == slow )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( fast == <span class="keyword">null</span> || slow == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span>( fast != slow_list.peek() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( fast.next != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            slow_list.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow_list.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        fast, slow = pHead, pHead</span><br><span class="line">        slow_list = []</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> slow:</span><br><span class="line">            <span class="keyword">if</span> fast.<span class="built_in">next</span>:</span><br><span class="line">                fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            slow_list.append(slow)</span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> slow:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        fast = pHead</span><br><span class="line">        <span class="keyword">while</span> fast != slow_list[-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">if</span> fast.<span class="built_in">next</span>:</span><br><span class="line">                fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow_list.pop()</span><br><span class="line">        <span class="keyword">return</span> fast</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java, python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - NC40 两个链表生成相加链表</title>
      <link href="/2021/07/24/LeetCode-NC40-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%94%9F%E6%88%90%E7%9B%B8%E5%8A%A0%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/07/24/LeetCode-NC40-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%94%9F%E6%88%90%E7%9B%B8%E5%8A%A0%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/c56f6c70fb3f4849bc56e33ff2a50b6b?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/c56f6c70fb3f4849bc56e33ff2a50b6b?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p><span id="more"></span><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="1-思路"><a href="#1-思路" class="headerlink" title="1. 思路"></a>1. 思路</h3><p>一开始的思路是将链表转换为具体的值，计算后再转换为最终的链表，但是行不通，因为很有可能会溢出。所以应该要使用类似于数组的结构，可以使用栈Stack来灵活的存取链表的值；也可以更简单粗暴一点，反转链表进行操作。</p><h3 id="2-使用栈解决"><a href="#2-使用栈解决" class="headerlink" title="2. 使用栈解决"></a>2. 使用栈解决</h3><p>Java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head1 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head2 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addInList</span> <span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; h1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; h2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        ListNode res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>( head1 != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            h1.push(head1.val);</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( head2 != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            h2.push(head2.val);</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>( !h1.isEmpty() || !h2.isEmpty() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( !h1.isEmpty() )</span><br><span class="line">            &#123;</span><br><span class="line">                sum += h1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( !h2.isEmpty() )</span><br><span class="line">            &#123;</span><br><span class="line">                sum += h2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ListNode tmp = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            tmp.next = res;</span><br><span class="line">            res = tmp;</span><br><span class="line">            </span><br><span class="line">            sum = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( sum != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode tmp = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            tmp.next = res;</span><br><span class="line">            res = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param head1 ListNode类 </span></span><br><span class="line"><span class="comment"># @param head2 ListNode类 </span></span><br><span class="line"><span class="comment"># @return ListNode类</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addInList</span>(<span class="params">self , head1 , head2 </span>):</span></span><br><span class="line">        h1, h2, res = [], [], <span class="literal">None</span></span><br><span class="line">        sum_ = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> head1:</span><br><span class="line">            h1.append(head1.val)</span><br><span class="line">            head1 = head1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> head2:</span><br><span class="line">            h2.append(head2.val)</span><br><span class="line">            head2 = head2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> h1 <span class="keyword">or</span> h2:</span><br><span class="line">            <span class="keyword">if</span> h1:</span><br><span class="line">                sum_ = sum_ + h1.pop(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> h2:</span><br><span class="line">                sum_ = sum_ + h2.pop(-<span class="number">1</span>)</span><br><span class="line">            tmp = ListNode(sum_ % <span class="number">10</span>)</span><br><span class="line">            tmp.<span class="built_in">next</span> = res</span><br><span class="line">            res = tmp</span><br><span class="line">            sum_ = sum_ // <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> sum_ &gt; <span class="number">0</span>:</span><br><span class="line">            tmp = ListNode(sum_)</span><br><span class="line">            tmp.<span class="built_in">next</span> = res</span><br><span class="line">            res = tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="2-反转链表"><a href="#2-反转链表" class="headerlink" title="2. 反转链表"></a>2. 反转链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head1 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head2 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addInList</span> <span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        ListNode res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        head1 = reverse(head1);</span><br><span class="line">        head2 = reverse(head2);</span><br><span class="line">        <span class="keyword">while</span>( head1 != <span class="keyword">null</span> || head2 != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( head1 != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                sum += head1.val;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( head2 != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                sum += head2.val;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode tmp = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            sum /= <span class="number">10</span>;</span><br><span class="line">            tmp.next = res;</span><br><span class="line">            res = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( sum != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode tmp = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            tmp.next = res;</span><br><span class="line">            res = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode chan = root.next, pre = root;</span><br><span class="line">        <span class="keyword">while</span>( root != <span class="keyword">null</span> &amp;&amp; chan != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            root.next = chan.next;</span><br><span class="line">            chan.next = pre;</span><br><span class="line">            pre = chan;</span><br><span class="line">            <span class="keyword">if</span>( root != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                chan = root.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java, python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - NC137 表达式求值</title>
      <link href="/2021/07/22/LeetCode-NC137-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
      <url>/2021/07/22/LeetCode-NC137-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/c215ba61c8b1443b996351df929dc4d4?tpId=188&amp;&amp;tqId=38548&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/c215ba61c8b1443b996351df929dc4d4?tpId=188&amp;&amp;tqId=38548&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking</a></p><span id="more"></span><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="1-设测试用例"><a href="#1-设测试用例" class="headerlink" title="1. 设测试用例"></a>1. 设测试用例</h3><p>通过题目可以知道，该题解决的是简易计算器问题。</p><p>结合题目和用例，可以得出5个测试维度：<code>+ 、- 、 * 、 ( 、)</code></p><p>分析几个维度之间的联系：</p><ol><li>使用 <code>-</code> ，则后面一个计算符号为 <code>-</code> 或 <code>+</code> 会变号；</li><li>使用 <code>*</code> ，该符号的优先级应高于 <code>+</code> 和 <code>-</code> ；</li><li>使用 <code>(</code> ，该符号的优先级应该最高，不对数据做任何改变；</li><li>使用 <code>)</code> ，此时应该优先将 <code>()</code> 中的算式进行计算。</li></ol><p>通过上述描述，得到如下测试用例：</p><blockquote><ol><li><p>全是 +<br>“1+2”</p></li><li><p>全是 -<br>“1-2-2”</p></li><li><p>加减乘</p><p>“1-2 * 3 * 4+2”</p></li><li><p>加减在括号里面 </p><p>“2*(1+2)”</p></li><li><p>混合</p><p>“2 * (1+2*4)+1”</p></li><li><p>负数计算</p><p>“-2+1”</p></li></ol></blockquote><h3 id="2-代码思路"><a href="#2-代码思路" class="headerlink" title="2. 代码思路"></a>2. 代码思路</h3><ol><li><p>存储：应该使用两个容器分别将数字和运算符号存储起来，因为并不一定是在当前获取的时候进行运算。此处使用两个栈进行存储：</p></li><li><p>遍历字符串：</p><p><strong>2.1</strong> 先判断是数字还是字符串，如果是数字，要注意，数字不一定只有一位，需要使用一个变量来获取完整的数字；</p><p><strong>2.2</strong> 如果是运算符，则先判断 <code>+</code> 或 <code>-</code> 的情况，它们只有一种需要验证的可能，即优先级。比二者大的只有 <code>*</code> 和 <code>(</code> ，因为 <code>(</code> 不做处理，所以只判断是否存在 <code>*</code> ，如果存在，取出来运算。</p><p><strong>2.3</strong> 然后判断 <code>)</code> 的情况，不需要验证，直接取运算符进行计算，直到遇到 <code>(</code> ；</p><p><strong>2.4</strong> 最后如果是 <code>*</code> 和 <code>(</code> ，直接进行存储。</p></li><li><p>最后查看两个栈中是否还存在元素，如果存在：</p><p><strong>2.1</strong> 如果是 <code>+</code> 或 <code>-</code> ：判断前一个运算符是否是 <code>-</code> ，是则变号，不是不变号；</p><p><strong>2.2</strong> 如果是 <code>*</code> ，直接运算；</p><p><strong>2.3</strong> 这里不会存在 <code>()</code> ，因为在遍历时已经清除了 -  <code>)</code> 不进栈。</p></li><li><p>最终输出位于 <code>num</code> 数字元素栈的最后一个元素，即最终结果。</p></li></ol><h3 id="3-具体代码"><a href="#3-具体代码" class="headerlink" title="3. 具体代码"></a>3. 具体代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 返回表达式的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 待计算的表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; num = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;Character&gt; ope = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; ++ i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>( i &lt; str.length &amp;&amp; str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                n = n * <span class="number">10</span> + str[i] - <span class="number">48</span>;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//             System.out.println(n);</span></span><br><span class="line">            <span class="keyword">if</span>( n!=<span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                num.push(n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( i &gt;= str.length )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( str[i] == <span class="string">&#x27;+&#x27;</span> || str[i] == <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( !ope.isEmpty() &amp;&amp; ope.peek() == <span class="string">&#x27;*&#x27;</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span>( !ope.isEmpty() &amp;&amp;  ope.peek() == <span class="string">&#x27;*&#x27;</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> a = num.pop();</span><br><span class="line">                        <span class="keyword">int</span> b = num.pop();</span><br><span class="line">                        ope.pop();</span><br><span class="line">                        num.push(a * b);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ope.push(str[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( str[i] == <span class="string">&#x27;*&#x27;</span> || str[i] == <span class="string">&#x27;(&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                ope.push(str[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>( ope.peek() != <span class="string">&#x27;(&#x27;</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>( !num.isEmpty() )</span><br><span class="line">                    &#123;</span><br><span class="line">                        b = num.pop();</span><br><span class="line">                    &#125;<span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>( !num.isEmpty())</span><br><span class="line">                    &#123;</span><br><span class="line">                        a = num.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">char</span> c = ope.pop();</span><br><span class="line">                    <span class="keyword">if</span>( c == <span class="string">&#x27;+&#x27;</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        num.push(a + b);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>( c == <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        num.push(a - b);</span><br><span class="line">                    &#125;<span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        num.push(a * b);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ope.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( !ope.isEmpty() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>( !num.isEmpty() )</span><br><span class="line">            &#123;</span><br><span class="line">                b = num.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( !num.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                a = num.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> c = ope.pop();</span><br><span class="line"><span class="comment">//             System.out.println(a+&quot; &quot;+b+&quot; &quot;+c);</span></span><br><span class="line">            <span class="keyword">if</span>( c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( !ope.isEmpty() &amp;&amp; ope.peek() == <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( c == <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">&#123;</span><br><span class="line">num.push(a + b);</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">num.push(a - b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>( c == <span class="string">&#x27;+&#x27;</span> )</span><br><span class="line">&#123;</span><br><span class="line">num.push(a + b);</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">num.push(a - b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">num.push(a * b);</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hive面试题</title>
      <link href="/2021/07/21/hive%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2021/07/21/hive%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="Hive的架构"><a href="#Hive的架构" class="headerlink" title="Hive的架构"></a>Hive的架构</h3><p>Hive架构包含客户端Client、元数据Metastore、Hadoop和驱动器Driver。</p><ol><li>Client：包括CLI，即hive shell、JDBC&#x2F;ODBC、WEBUI。</li><li>Metastore：元数据，表示文件从HDFS到Hive的映射信息，包括表名、表所属数据库(默认是default)、表的拥有者、表的类型(是否是外部表)、列和分区字段等，默认使用Derby数据库存储，但是derby属于嵌套式数据库，一次只能支持一个会话，所以建议使用Mysql存储元数据。</li><li>Hadoop：使用HDFS进行存储，Mapreduce进行计算。</li><li>Driver：包括解析器、编译器、优化器和执行器，其中解析器检查基本的语法；编译器将hql语句翻译为MR程序；优化器对程序进行优化；执行器将程序提交到Yarn。</li></ol><span id="more"></span><p><strong>简单的记录：</strong></p><p>hive表的关联条件不支持不等值连接，比如 !&#x3D; 、&lt;&gt; 、between…and…</p><h3 id="Hive的优缺点以及和数据库的区别"><a href="#Hive的优缺点以及和数据库的区别" class="headerlink" title="Hive的优缺点以及和数据库的区别"></a>Hive的优缺点以及和数据库的区别</h3><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点是：</p><ol><li>使用类SQL语法编写MR程序的逻辑，可以快速开发，也能减少学习成本；</li><li>因为底层是Hadoop，所以延迟肯定比较高，主要用于进行数据分析，适用于对实时性能要求不高的场景；</li><li>Hive的优势是处理大数据，因为无论文件大小，都会使用MR对文件进行处理，对于小文件来说，可能开关虚拟机的时间都比执行程序的时间长，不值得；</li><li>Hive支持用户根据自身需求自定义函数。</li></ol><p>缺点是：</p><ol><li>HQL语言的表达能力有限：迭代算法无法表达，假设要反复的对结果数据进行处理，这是迭代，这种处理的方式在Hive实现上需要不断的创建新的MR程序进行运算，速度太慢；所以数据挖掘方面也不擅长，因为数据挖掘方面也是通过不断迭代找到合适结果的。</li><li>效率比较低：由于是自动生成的MR作业，通常情况下不够智能；并且调优比较困难，力度较粗，因为调优肯定是在SQL层面或者资源层面进行调优，而不能修改生成的模板。</li></ol><h4 id="Hive和数据库比较"><a href="#Hive和数据库比较" class="headerlink" title="Hive和数据库比较"></a>Hive和数据库比较</h4><ol><li>查询语言：数据库使用SQL语言，Hive使用类SQL的HQL语言。</li><li>数据存储位置：Hive所有数据的存储都在HDFS中；而数据库存储在自己的系统中。</li><li>数据更新：Hive不支持数据的改写和添加，数据是在加载的时候就确定好了的；数据库可以对数据进行增删改查。</li><li>索引：Hive没有索引，每次查询都会扫描所有的数据，底层使用mr并行计算，适用于大数据量；数据库有索引，适合在线查询。</li><li>执行：Hive中大多数的查询是通过MapReduce来完成的，而数据库有自己的执行引擎，比如MySQL使用的是InnoDB。</li><li>可扩展性：由于Hive建立在Hadoop之上，所以二者的扩展性是一致的；而数据库由于ACID语义的严格限制，扩展性非常有限。</li></ol><h3 id="外部表和内部表（hive表有几种）"><a href="#外部表和内部表（hive表有几种）" class="headerlink" title="外部表和内部表（hive表有几种）"></a>外部表和内部表（hive表有几种）</h3><p>删除外部表只会删除元数据，保留原始数据，这样的数据是可以恢复的；</p><p>删除内部表会将元数据和原始数据全都删掉，这样的数据不可恢复。</p><h3 id="分区和分桶的区别"><a href="#分区和分桶的区别" class="headerlink" title="分区和分桶的区别"></a>分区和分桶的区别</h3><p>​        分区和分桶都是用于提高查询的效率，避免全表扫描。</p><p>​        分区使用partition by，是针对存储路径的，从hdfs上看是将不同分区的数据存储到不同的文件夹上；分桶使用clustered by into n buckets，是针对数据文件的，从hdfs上看是将n个桶的数据划分到一个文件夹下的n个数据文件中存储。</p><p>​        分桶的粒度比分区更细，由于是使用hash值分桶，所以数据分布会更加均匀，适合用于抽样检测，也可以用于优化大表之间join的效率。大表的join操作不适合在reduce端执行，很容易导致数据倾斜，但是map端只适合小表join大表的操作，但是如果将大表的连接字段分桶，然后按桶多次加载到map端执行join，效率肯定会比直接使用大表join要快。</p><h3 id="排序的4个By区别"><a href="#排序的4个By区别" class="headerlink" title="排序的4个By区别"></a>排序的4个By区别</h3><ol><li>order by：全局排序，只会有一个Reducer；</li><li>sort by：局部排序，只在每个Reducer内部排序，对全局结果集来说是无序的；</li><li>distribute by：类似MR中的partition，需要结合sort by使用，且reduce个数要大于1，否则最终还是到一个reduce中处理，分区没有意义；</li><li>cluster by：当distribute by所用字段和sort by所用字段相同时，就使用cluster by，它兼具了前二者的功能，但是只能升序排序，不能降序。</li></ol><h3 id="常用的系统函数"><a href="#常用的系统函数" class="headerlink" title="常用的系统函数"></a>常用的系统函数</h3><h4 id="1-聚合函数"><a href="#1-聚合函数" class="headerlink" title="1. 聚合函数"></a>1. 聚合函数</h4><ol><li>sum() - 求和；</li><li>count() - 求个数；</li><li>avg() - 求平均值；</li><li>distict - 去重；</li><li>min() - 求最小值;</li><li>max() - 求最大值；</li></ol><h4 id="2-分析函数"><a href="#2-分析函数" class="headerlink" title="2. 分析函数"></a>2. 分析函数</h4><ol><li>rank()：生成的数据项是在组内的排名，如果排名相等会在名次中留下空位；</li><li>row_number()：生成的数据项从1开始，按照顺序生成在组内的序列号；</li><li>dense_rank()：与rank()类似，但是如果排名相等，不会留下空位；</li><li>cume_dist() &#x3D; 小于等于<code>当前元素的值</code>的行数&#x2F;总行数；</li><li>percent_rank() &#x3D; 分组内当前行的rank值-1&#x2F;总行数-1。</li></ol><h4 id="3-字符串连接函数"><a href="#3-字符串连接函数" class="headerlink" title="3. 字符串连接函数"></a>3. 字符串连接函数</h4><ol><li>concat(str1, str2, …)：用于将多个字符串连接成一个字符串；</li><li>concat_ws(sep, str1, str2, …)：指定分隔符将多个字符串连接成一个，其中，<code>sep</code>为分隔符；</li><li>collect_set(字段)：根据指定内容分组后，将分在一组的该字段的列值合并为数组，默认分隔符为<code>,</code>，可以将concat_ws和concat_set组合指定分隔符；</li><li>collect_list(字段)：与collect_set相似，区别是collect_set可以去重，collect_list不行。</li></ol><h4 id="4-还有一些其他类型函数"><a href="#4-还有一些其他类型函数" class="headerlink" title="4. 还有一些其他类型函数"></a>4. 还有一些其他类型函数</h4><ol><li>cast(字段名 as 转换的类型)：转换字段的类型；</li><li>if(表达式, trueValue, falseValue_or_NULL)：相当于Java的三目运算符。</li></ol><h3 id="sql语句的顺序"><a href="#sql语句的顺序" class="headerlink" title="sql语句的顺序"></a>sql语句的顺序</h3><p>11个关键字，有两种顺序：</p><p>（1）关键字顺序：</p><blockquote><p>select -&gt; distinct -&gt; from -&gt; join -&gt; on -&gt; where -&gt; group by -&gt; with -&gt; having -&gt; order by -&gt; limit</p></blockquote><p>（2）执行顺序</p><blockquote><p>from -&gt; on -&gt; join -&gt; where -&gt; group by -&gt; with -&gt; having -&gt; select -&gt; distinct -&gt; order by -&gt; limit</p></blockquote><h3 id="是否了解数仓分层"><a href="#是否了解数仓分层" class="headerlink" title="是否了解数仓分层"></a>是否了解数仓分层</h3><p>首先我们知道数仓即数据仓库，是为企业制定决策，提供数据支持的，可以帮助企业，改进业务流程、提高产品质量等。</p><h4 id="数据仓库的来源"><a href="#数据仓库的来源" class="headerlink" title="数据仓库的来源"></a>数据仓库的来源</h4><ol><li>爬虫数据；</li><li>用户行为数据：比如用户和网站交互产生的数据；</li><li>业务数据：存储在后台MySQL对应的数据库中。</li></ol><h4 id="具体分层"><a href="#具体分层" class="headerlink" title="具体分层"></a>具体分层</h4><ol><li>ODS：原始数据层，存放原始数据，用来直接加载原始日志、数据，数据保持原貌不做处理；</li><li>DWD：明细数据层，对ODS层数据进行清洗(去除空值，脏数据，超过极限范围的数据)；</li><li>DWM：数据中间层，在DWD的基础上对数据进行轻微聚合，算出相应的统计指标；</li><li>DWS：服务数据层，在DWM层的基础上，进行汇总，一般聚集到以用户当日，设备当日，商家当日，商品当日等等的粒度；</li><li>ADS：数据应用层，面向实际的数据需求，以DWD或者DWS层的数据为基础，组成各种统计报表，一般ADS层的指标是提供给高层来进行决策的。</li></ol><h4 id="全量表、增量表和拉链表"><a href="#全量表、增量表和拉链表" class="headerlink" title="全量表、增量表和拉链表"></a>全量表、增量表和拉链表</h4><ol><li>拉链表：记录新增和变化的数据，适用于当数据量比较大，但是每天都会有新数据的插入和旧数据的更改的情况；</li><li>增量表：记录周期内新增的数据，适用于数据量大，并且每天都有新数据插入的情况；</li><li>全量表：记录周期内全部的数据，包括原来全部的数据和新增的数据，适用于表的数据量不大，并且每天会有新数据的插入或旧数据的更改的情况。</li></ol><h4 id="雪花模型和星形模型的理解以及优劣对比"><a href="#雪花模型和星形模型的理解以及优劣对比" class="headerlink" title="雪花模型和星形模型的理解以及优劣对比?"></a>雪花模型和星形模型的理解以及优劣对比?</h4><p>星型模型：是一张事实表与多张维度表直接关联；</p><p>雪花模型：是一张事实表和多张维度表，维度表之间可以有关联</p><p><strong>比较：</strong></p><p>1）星型模型因为数据的冗余所以很多统计查询不需要做外部的连接，因此一般情况下效率比雪花模型要高。<br> 2）星型模型不用考虑很多正规化的因素，设计和实现都比较简单。<br> 3）雪花模型由于去除了冗余，有些统计就需要通过表的连接才能产生，所以效率不一定有星型模型高。<br> 4）正规化也是一种比较复杂的过程，相应的数据库结构设计、数据的ETL、以及后期的维护都要复杂一些。因此在冗余可以接受的前提下，实际运用中星型模型使用更多，也更有效率。</p><h3 id="udf、udaf、udtf自定义函数的实现过程"><a href="#udf、udaf、udtf自定义函数的实现过程" class="headerlink" title="udf、udaf、udtf自定义函数的实现过程"></a>udf、udaf、udtf自定义函数的实现过程</h3><h4 id="UDF、UDAF、UDTF"><a href="#UDF、UDAF、UDTF" class="headerlink" title="UDF、UDAF、UDTF"></a>UDF、UDAF、UDTF</h4><p>UDF是一进一出；UDAF是多进一出，比如count等聚合函数；UDTF是一进多出，比如lateral view explode()一行转多行操作。</p><h4 id="自定义的步骤"><a href="#自定义的步骤" class="headerlink" title="自定义的步骤"></a>自定义的步骤</h4><ol><li><p>自定义UDF：继承UDF，实现evaluate()方法；</p></li><li><p>自定义UDTF：继承GenericUDTF，重写三个方法 - initialize、process、close；</p></li><li><p>自定义UDAF：</p><p>​        需要继承两个抽象类：AbstreactGenericUDAFResolver和GenericUDAFEvaluator。</p><p>1）在AbstractGenericUDAFResolver，需要重写一个getEvaluator方法，在这个方法中校验输入参数，并可以根据参数的数据格式指定调用哪个Evaluator；</p><p>2）GenericUDAFEvaluator用于实现UDAF的逻辑，这个抽象类使用ObjectInspector接口解析数据格式，使用Model来区分mapreduce的各个阶段：PARTIAL1表示map阶段，从原始数据到部分聚合，会调用iterate()和terminatePartial()方法；PARTIAL2表示Combiner阶段，会调用merge()和terminatePartial()方法；FINAL表示reduce阶段，会调用merge()和terminate()方法；COMPLETE表示map join阶段，没有reduce，会调用iterate()和terminate()方法。</p><p>​        具体的方法包括：</p><p>（1）init()：初始化各个输入输出参数的数据格式；</p><p>（2）AggregationBuffer()：保存数据聚合的结果；</p><p>（3）reset()：用于重置聚合结果；</p><p>（4）iterate()：逐行处理原始数据；</p><p>（5）terminatePartial()：输出部分聚合的结果；</p><p>（6）merge()：用于合并部分聚合的结果；</p><p>（7）terminate()：返回最终的输出结果。</p></li></ol><h4 id="hive为什么需要自定义函数"><a href="#hive为什么需要自定义函数" class="headerlink" title="hive为什么需要自定义函数"></a>hive为什么需要自定义函数</h4><ol><li>内置函数不能满足所有的业务需求；</li><li>自定义函数可以自己打印日志，方便调试。</li></ol><h3 id="Hive常见的存储文件类型？"><a href="#Hive常见的存储文件类型？" class="headerlink" title="Hive常见的存储文件类型？"></a>Hive常见的存储文件类型？</h3><p>​        Hive支持的存储格式主要包含：textfile、sequencefile、orc、parquent。</p><p>​        从存储格式上看，hive有两种存储格式：行存储和列存储。两个存储格式的区别在于，如果使用select *，列存储需要到每个聚集的字段中取对应的每个列的值，而行存储只需要找到其中一个值，这一行中其余的值都在相邻的地方，此时行存储的速度回避列存储快；如果是select少数几个字段，列存储的查找时间肯定会比行存储要快。textfile和sequncefile是行存储格式，orc和parquent是列存储格式，其中sequencefile和parquent都以二进制的形式存储。</p><p>​        行存储适用于处理事务数据，列存储适用于数据分析。</p><h3 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h3><p>​        窗口函数over()是分析函数的一种，一般会和聚合函数或其他分析函数一起使用，可以联合 partition by、order by等子句对前面合用的函数的数据范围进行约束。其中 partition by 用于分组，order by用于排序。</p><p>​        假设有一张明细表，需要以id分组统计总个数，但是最终输出的列除了id、总个数之外，还要有一个标签列，这样可以在 count 方法后连用 over()，在窗口函数内使用 partition by id 进行分组，这样就可以将查询 id和总个数的列与查询标签列的操作合二为一了。</p><h3 id="Hive创建表的几种方式和加载数据的几种方式"><a href="#Hive创建表的几种方式和加载数据的几种方式" class="headerlink" title="Hive创建表的几种方式和加载数据的几种方式"></a>Hive创建表的几种方式和加载数据的几种方式</h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><p>有三种：直接创建、查询创建和like创建。其中查询创建会存储数据，like 创建会构建相同结构的表，但内部没有数据。</p><h4 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h4><p>有四种方式。</p><ol><li>本地导入：load data local inpath ‘…’；</li><li>hdfs导入：load data inpath ‘…’；</li><li>创建表时查询导入：create table select；</li><li>插入查询结果：insert into table select。</li></ol><h3 id="事实表和维度表，以及事实表的种类"><a href="#事实表和维度表，以及事实表的种类" class="headerlink" title="事实表和维度表，以及事实表的种类"></a>事实表和维度表，以及事实表的种类</h3><p>​        维表就是看待某个事务有哪些方面，比如想要快递供货，我们需要一张地域维表存储省市编码等标记供货地；事实表就是这个快递供货的实际信息，比如需要记录哪个用户要供货到哪个地址。</p><p>​        事实表分为事务型事实表、周期型快照事实表和累积型快照事实表。</p><ol><li>事务型事实表以一个事务或事件为单位，比如一条支付明细，被提交之后是不能在被更改的；</li><li>周期性快照事实表会保留固定时间间隔的数据，比如每月的销售记录；</li><li>累积型快照事实表用于跟踪业务的实时变化，这种数据被提交之后可以被修改，就比如供货的实际日期没有办法提前就准确得知，可以先写一个代表未知的占位符，等到实际出货后再填写上去。</li></ol><h3 id="Hive有哪些方式保存元数据，各有哪些特点？"><a href="#Hive有哪些方式保存元数据，各有哪些特点？" class="headerlink" title="Hive有哪些方式保存元数据，各有哪些特点？"></a>Hive有哪些方式保存元数据，各有哪些特点？</h3><p>1）内嵌模式：将元数据保存在本地内嵌的derby数据库中，内嵌的derby数据库每次允许一个客户端连接，这种设置只能在本地测试，在实际的生产环境中效率会很低。 </p><p>2）本地模式：将元数据保存在本地mysql，它支持多会话连接。 </p><p>3）远程模式：把元数据保存在远程独立的mysql数据库中，避免每个客户端都去安装mysql数据库。</p><h3 id="Hive数据倾斜"><a href="#Hive数据倾斜" class="headerlink" title="Hive数据倾斜"></a>Hive数据倾斜</h3><h4 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h4><p>在两个表做join操作的时候，reducetask中一个任务处理的时间明显大于其他任务处理的时间，就会出现数据倾斜。</p><h4 id="解决的方法"><a href="#解决的方法" class="headerlink" title="解决的方法"></a>解决的方法</h4><p>设置 <code>hive.groupby.skewindata = true</code> 开启数据倾斜的负载均衡，它的思路是先随即分发再聚合处理。这里会产生两个mr程序，第一个mr中，在map阶段输出结果，partition操作时给key添加随机的标记，让数据能够随机分发到不同的reduce中，然后reduce中去除随即标记，对相同key的数据做部分聚合。这样的操作会将不同key的数据分发到同一个reduce中，就把数据打散了，也就不会出现数据倾斜的问题，就能达到负载均衡的目的。第二个mr接收第一个mr输出的结果，将相同key的数据分发到同一个reduce中处理，做最终的聚合操作。</p><h3 id="Hive里边字段的分隔符用的什么？如果这个符号是分隔符的同时还是内容应该如何处理？"><a href="#Hive里边字段的分隔符用的什么？如果这个符号是分隔符的同时还是内容应该如何处理？" class="headerlink" title="Hive里边字段的分隔符用的什么？如果这个符号是分隔符的同时还是内容应该如何处理？"></a>Hive里边字段的分隔符用的什么？如果这个符号是分隔符的同时还是内容应该如何处理？</h3><p>字段分隔符默认是<code>^A</code>，即ascII码的\001，行分隔符默认是 <code>\n</code>。<br>如果一个符号在是分隔符的同时还是具体的内容，依据代码规范约束，需要到前一级数据中去删除或者替换。<br>可以在sqoop中设置如下参数：</p><blockquote><p>–hive.drop.import.delims 导入到hive时删除分隔符；<br>–hive.delims.replacement 导入到hive时用自定义的分隔符替代</p></blockquote><h3 id="Hive优化"><a href="#Hive优化" class="headerlink" title="Hive优化"></a>Hive优化</h3><h4 id="1）-fetch抓取"><a href="#1）-fetch抓取" class="headerlink" title="1）. fetch抓取"></a>1）. fetch抓取</h4><p>​        即Hive中某些情况的查询可以不必经过MapReduce计算。<br>​        通过修改hive-default.xml中的hive.fetch.task.conversion参数为more，使得全局查找、字段查找、limit查找等都不用经过MapReduce。</p><h4 id="2）-本地模式"><a href="#2）-本地模式" class="headerlink" title="2）. 本地模式"></a>2）. 本地模式</h4><p>​        Hadoop的任务在大多数情况下都需要使用多台机器完成，有时Hive的输入数据量非常小，这种情况，为查询触发执行任务消耗的时间可能会比实际任务运行的时间要多得多，这种情况下，Hive可以通过本地模式在单台机器上处理所有的任务，对于小数据集，执行时间会被明显缩短。</p><p>​        通过修改 hive.exec.mode.local.auto &#x3D; true ，可以让hive在适当的时候启动这个优化。和它相关的参数有两个，<code>hive.exec.mode.local.auto.inputbytes.max</code>设置触发local mr的最大数据量，默认值是128M；<code>hive.exec.mode.local.auto.files.max</code> 参数设置触发local mr的最大文件数量。</p><h4 id="3）-表的优化"><a href="#3）-表的优化" class="headerlink" title="3）. 表的优化"></a>3）. 表的优化</h4><p><strong>（1）大表Join大表</strong>：<br>a）过滤：有些Join超时是因为某些key对应的数据太多，而相同的key对应的数据都会被放到同一个reducer，会导致内存不够用；此时我们可以仔细分析这些异常的key，很多情况下这些key对应的都是异常数据，我们使用SQL语句将这些异常数据过滤就行。<br>b）转换：有时候这些key对应的数据并不是异常数据，我们可以将这些key随机转换为不同的值，使得数据能随即均匀的分不到不同的reducer上。</p><p>c）分桶：将连接字段分桶，然后放到map端进行join操作。</p><p><strong>（2）小表join大表</strong>：<br>如果不指定MapJoin或者不符合MapJoin的条件，Hive解析器会将这些数据给Reduce端处理，容易造成数据倾斜，可以使用MapJoin将小表都加载到内存，在map端进行Join操作。<br><strong>（3）尽量不适用笛卡尔积</strong>：<br>因为Hive只能在一个reducer上完成笛卡尔积。<br><strong>（4）行列过滤</strong>：<br>如果是列处理，只拿需要的列，尽量使用分区过滤，少用 select *；如果是行处理，两个表进行join操作的时候，先子查询过滤出需要的行，再进行join操作，需要连接的数据量就少了。<br><strong>（5）使用动态分区</strong>：<br>动态分区可以不指定实际的内容，比如 <code>partition(dt=&#39;20210101&#39;)</code> ，这种是静态分区的实现方式，必须在编译阶段就指定分区内容，动态分区只需要指定分区字段，也就是 <code>partition(dt)</code> ，具体的分区内容等到插入数据时才会知道。使用 <code>hive.exec.dynamic.partition = true</code> 来开启动态分区，之后还需要设置 <code>hive.exec.dynamic.partition.mode = nonstrict</code>，这个参数默认是严格模式，不允许使用动态分区。</p><h4 id="4）-MR优化"><a href="#4）-MR优化" class="headerlink" title="4） MR优化"></a>4） MR优化</h4><h5 id="（1）合理设置Map数"><a href="#（1）合理设置Map数" class="headerlink" title="（1）合理设置Map数"></a>（1）合理设置Map数</h5><p>​        当Map数过大，如果一个任务有许多小文件，哪怕这些小文件的大小远小于一个块的大小，也都会使用一个块存，用一个map来完成，而一个map的启动和初始化的时间远大于逻辑处理时间，这样会对造成很大的资源浪费，而且，同时可执行的map数是有限的。</p><p>​        针对这种情况，需要合并小文件处理，Hive默认使用的CombineHiveInputFormat就具有对小文件进行合并的功能。        </p><p>但是，如果每个Map都处理将近一个块的大小的数据也不行，假设有一个127M的文件，其中只有一到两个字段，却有成千上万的数据，这时当Map处理的逻辑比较复杂的时候，也会很耗时，这时候就需要减少传入map的数据量，也就是减少切片值，设置 <code>mapreduce.input.fileinputformat.split.maxsize</code> 小于128M。</p><h5 id="（2）合理设置Reduce数"><a href="#（2）合理设置Reduce数" class="headerlink" title="（2）合理设置Reduce数"></a>（2）合理设置Reduce数</h5><p>​        reduce的个数如果很少，但是数据量很大，处理时间会很长，但是如果太多，启动和初始化也会很耗资源，而且当这个reduce的输出是下一个mr的输入也会产生过多小文件的问题，reduce的个数应该遵循大数据量要有合适的reduce数，每个reduce要有合适的数据量。</p><h5 id="（3）并行执行"><a href="#（3）并行执行" class="headerlink" title="（3）并行执行"></a>（3）并行执行</h5><p>​        hive中往往会将一个sql分为多个阶段来执行，这些阶段可能并不是相互依赖的，甚至可以并行执行，并行的越多，这个job执行的时间可能就越短，可以通过设置hive.exec.parallel参数为true，hive就可以在资源比较空闲的时候自动启用这个优化。</p><h3 id="SQL转化为MapReduce的过程"><a href="#SQL转化为MapReduce的过程" class="headerlink" title="SQL转化为MapReduce的过程"></a>SQL转化为MapReduce的过程</h3><p>SQL转化为MapReduce会经过解析器、编译器、优化器和执行器。首先解析器检查基本的语法是否符合规范；接着编译器将HQL语句转化为具体的MR程序；优化器会根据MR程序做一些优化，随着hive版本的迭代，生成mr的模板也是在不断优化的；执行器将程序提交给yarn，执行过程中，会访问元数据，查找实际数据，然后将实际数据读进来，执行mr程序。</p><h3 id="group-by和partition-by的区别"><a href="#group-by和partition-by的区别" class="headerlink" title="group by和partition by的区别"></a>group by和partition by的区别</h3><ol><li>group by是分组函数，partition by是分析函数；</li><li>在执行顺序上，对于group by而言：from&gt;where&gt;group by&gt;having&gt;order by；对于prtition by而言，在执行完select之后，会在所得结果上进行partition；</li><li>在group by结果集上进行聚合，会作用在分组下的所有记录上；而在partition by的结果集上进行聚合，就要注意聚合函数是逐条累计进行计算的；</li><li>group by将分组记录汇总成一条记录；partition by会显示所有数据。</li></ol><h3 id="数据库与数据仓库"><a href="#数据库与数据仓库" class="headerlink" title="数据库与数据仓库"></a>数据库与数据仓库</h3><p>当今的数据处理大致可以分成两大类：联机事务处理OLTP（on-line transaction processing）、联机分析处理OLAP（On-Line Analytical Processing）。<br>       基本日常的事务处理，比如数据库记录的增删查改，通常被称为OLTP（On-Line Transaction Processing，联机事务处理），OLTP是数据库的主要应用。<br>       OLAP（On-Line Analytical Processing，联机分析处理）支持复杂的分析操作，侧重提供决策支持，并且提供直观易懂的分析结果，目标是探索并挖掘数据价值，作为企业高层进行决策的参考，OLAP是数据仓库的主要应用。</p><p>OLTP的特点一般有：</p><ol><li>实时性要求高。</li><li>数据量不是很大，生产库上的数据量一般不会太大，而且会及时做相应的数据处理与转移。</li><li>OLTP是对确定性的数据进行存取。</li><li>高并发，并且要求满足ACID原则。比如两人同时操作一个银行卡账户，比如大型的购物网站秒杀活动时上万的QPS请求。</li></ol><p>OLAP的特点一般有：</p><ol><li>实时性要求不是很高，比如最常见的应用就是天级更新数据，然后出对应的数据报表。</li><li>数据量大，因为OLAP支持的是动态查询，所以用户也许要通过将很多数据进行统计后才能得到想要知道的信息，例如时间序列分析等等，所以处理的数据量很大。</li><li>OLAP系统的重点是通过数据提供决策支持。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20210721 - sum函数由于优先级计算错误 项目小记</title>
      <link href="/2021/07/21/20210721-sum%E5%87%BD%E6%95%B0%E7%94%B1%E4%BA%8E%E4%BC%98%E5%85%88%E7%BA%A7%E8%AE%A1%E7%AE%97%E9%94%99%E8%AF%AF-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/"/>
      <url>/2021/07/21/20210721-sum%E5%87%BD%E6%95%B0%E7%94%B1%E4%BA%8E%E4%BC%98%E5%85%88%E7%BA%A7%E8%AE%A1%E7%AE%97%E9%94%99%E8%AF%AF-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="摘自"><a href="#摘自" class="headerlink" title="摘自"></a>摘自</h2><p><a href="https://blog.csdn.net/a158123/article/details/91051636">传送门</a></p><span id="more"></span><h2 id="1-具体错误结果"><a href="#1-具体错误结果" class="headerlink" title="1. 具体错误结果"></a>1. 具体错误结果</h2><p>希望能通过 <code>sum</code> 函数累加表中某个字段的第一行 <code>limit 1</code>；</p><p>期望结果是：<code>0.0</code>；</p><p>得到结果是：<code>22178</code>。</p><p> 下面给出错误代码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="built_in">SUM</span>(`amount`)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    `<span class="keyword">order</span>`</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> `id`</span><br><span class="line">LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure><h2 id="2-问题所在"><a href="#2-问题所在" class="headerlink" title="2. 问题所在"></a>2. 问题所在</h2><p>没有意识到这个是优先级别的问题：</p><ol><li>FROM：FROM子句是最先执行的，确定了查询的是order这张表</li><li>SELECT：SELECT子句是第二个执行的子句，同时SUM()函数也在此时执行了。</li><li>ORDER BY：ORDER BY子句是第三个执行的子句，其处理的结果只有一个，就是订单总金额</li><li>LIMIT：LIMIT子句是最后执行的，此时结果集中只有一个结果（订单总金额）</li></ol><h2 id="3-具体解决"><a href="#3-具体解决" class="headerlink" title="3. 具体解决"></a>3. 具体解决</h2><p>使用子查询的方式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="built_in">SUM</span>(o.amount)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (<span class="keyword">SELECT</span> </span><br><span class="line">        `amount`</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        `<span class="keyword">order</span>`</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> `id`</span><br><span class="line">    LIMIT <span class="number">5</span>) <span class="keyword">AS</span> o;</span><br></pre></td></tr></table></figure><h2 id="4-select语句的执行顺序"><a href="#4-select语句的执行顺序" class="headerlink" title="4. select语句的执行顺序"></a>4. select语句的执行顺序</h2><blockquote><ol><li>FROM <left_table></li><li>ON <join_condition></li><li><join_type> JOIN <right_table></li><li>WHERE <where_condition></li><li>GROUP BY <group_by_list></li><li>HAVING <having_condition></li><li>SELECT</li><li>DISTINCT <select_list></li><li>ORDER BY <order_by_condition></li><li>LIMIT <limit_number></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 项目小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - NC19 子数组的最大累加和问题</title>
      <link href="/2021/07/15/LeetCode-NC19-%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E7%B4%AF%E5%8A%A0%E5%92%8C%E9%97%AE%E9%A2%98/"/>
      <url>/2021/07/15/LeetCode-NC19-%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E7%B4%AF%E5%8A%A0%E5%92%8C%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/554aa508dd5d4fefbf0f86e5fe953abd?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/554aa508dd5d4fefbf0f86e5fe953abd?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p><span id="more"></span><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="1-理解"><a href="#1-理解" class="headerlink" title="1. 理解"></a>1. 理解</h3><p>我之前一直想的方法：获取每个子数组的最大连续累加和。</p><p>但是这种方法并不适用于这里，因为这种方式求的是并不能连续的最大和。</p><p>正确的方法：将之前累加的值永远与当前的值进行比较，将比当前值小的累加抛弃，最小的和是0，即所有值都不取。</p><h3 id="2-具体代码"><a href="#2-具体代码" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * max sum of the subarray</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxsumofSubarray</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Math.max(<span class="number">0</span>, arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = Math.max(arr[i], arr[i-<span class="number">1</span>]+arr[i]);</span><br><span class="line">            max = Math.max(max, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序算法</title>
      <link href="/2021/07/15/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2021/07/15/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-知识点"><a href="#1-知识点" class="headerlink" title="1. 知识点"></a>1. 知识点</h2><p>一般情况下，将第一个元素作为基准，设置两个指针 <code>i = 0, j = n - 1</code> ，先用 <code>j</code> 从后往前找第一个小于基准的值，赋给 <code>i</code> 所在位置；然后再用 <code>i</code> 从前往后找第一个大于基准的值，赋给 <code>j</code> 所在位置。最终 <code>i &gt;= j </code> 的时候退出循环，以 <code>i == j</code> 的这个位置为分割线，将数组划分为两个，分别继续进行排序。</p><span id="more"></span><h2 id="2-具体实例和代码"><a href="#2-具体实例和代码" class="headerlink" title="2. 具体实例和代码"></a>2. 具体实例和代码</h2><h3 id="1-题目链接"><a href="#1-题目链接" class="headerlink" title="1. 题目链接"></a>1. 题目链接</h3><p><a href="https://www.nowcoder.com/practice/e016ad9b7f0b45048c58a9f27ba618bf?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/e016ad9b7f0b45048c58a9f27ba618bf?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p><h3 id="2-具体代码"><a href="#2-具体代码" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><p>通用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        quickSort(a, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> a[n-K];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( l &gt;= a.length || r &lt; <span class="number">0</span> || l &gt; r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = l, j = r;</span><br><span class="line">        <span class="keyword">int</span> f = a[l];</span><br><span class="line">        <span class="keyword">while</span>( i &lt; j )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( i &lt; j &amp;&amp; a[j] &gt;= f )</span><br><span class="line">            &#123;</span><br><span class="line">                -- j;</span><br><span class="line">            &#125;</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            <span class="keyword">while</span>( i &lt; j &amp;&amp; a[i] &lt;= f )</span><br><span class="line">            &#123;</span><br><span class="line">                ++ i;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        a[i] = f;</span><br><span class="line">        quickSort(a, l, i-<span class="number">1</span>);</span><br><span class="line">        quickSort(a, j+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对具体问题进行改进：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKth</span>(<span class="params">self, a, n, K</span>):</span></span><br><span class="line">        self.findK(a, <span class="number">0</span>, n-<span class="number">1</span>, K-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> a[K-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findK</span>(<span class="params">self, a, l, r, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> l &gt;= <span class="built_in">len</span>(a) <span class="keyword">or</span> r &lt; <span class="number">0</span> <span class="keyword">or</span> k &lt; <span class="number">0</span> <span class="keyword">or</span> l &gt; r:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        i, j = l, r</span><br><span class="line">        f = a[i]</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> a[j] &lt;= f:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            a[i] = a[j]</span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> a[i] &gt;= f:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            a[j] = a[i]</span><br><span class="line">        a[i] = f</span><br><span class="line">        <span class="keyword">if</span> i &gt; k:</span><br><span class="line">            self.findK(a, l, i-<span class="number">1</span>, k)</span><br><span class="line">        <span class="keyword">elif</span> i &lt; k:</span><br><span class="line">            self.findK(a, j+<span class="number">1</span>, r, k)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - NC45 实现二叉树先序，中序和后序遍历</title>
      <link href="/2021/07/14/LeetCode-NC45-%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%88%E5%BA%8F%EF%BC%8C%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2021/07/14/LeetCode-NC45-%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%88%E5%BA%8F%EF%BC%8C%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/a9fec6c46a684ad5a3abd4e365a9d362?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/a9fec6c46a684ad5a3abd4e365a9d362?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-常见思路-递归遍历"><a href="#1-常见思路-递归遍历" class="headerlink" title="1. 常见思路 - 递归遍历"></a>1. 常见思路 - 递归遍历</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param root TreeNode类 the root of binary tree</span></span><br><span class="line"><span class="comment"># @return int整型二维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeOrders</span>(<span class="params">self , root </span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 先序遍历</span></span><br><span class="line">        pre = []</span><br><span class="line">        self.preOrder(root, pre)</span><br><span class="line">        <span class="comment"># 中序遍历</span></span><br><span class="line">        mid = []</span><br><span class="line">        self.midOrder(root, mid)</span><br><span class="line">        <span class="comment"># 后序遍历</span></span><br><span class="line">        post = []</span><br><span class="line">        self.postOrder(root, post)</span><br><span class="line">        <span class="keyword">return</span> [pre, mid, post]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preOrder</span>(<span class="params">self, root, arr</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        arr.append(root.val)</span><br><span class="line">        self.preOrder(root.left, arr)</span><br><span class="line">        self.preOrder(root.right, arr)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">midOrder</span>(<span class="params">self, root, arr</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.midOrder(root.left, arr)</span><br><span class="line">        arr.append(root.val)</span><br><span class="line">        self.midOrder(root.right, arr)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postOrder</span>(<span class="params">self, root, arr</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.postOrder(root.left, arr)</span><br><span class="line">        self.postOrder(root.right, arr)</span><br><span class="line">        arr.append(root.val)</span><br></pre></td></tr></table></figure><h3 id="2-对第一个代码进行一点改进"><a href="#2-对第一个代码进行一点改进" class="headerlink" title="2. 对第一个代码进行一点改进"></a>2. 对第一个代码进行一点改进</h3><p>将上面代码的三个排序函数合并为一个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param root TreeNode类 the root of binary tree</span></span><br><span class="line"><span class="comment"># @return int整型二维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeOrders</span>(<span class="params">self , root </span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 先序遍历</span></span><br><span class="line">        pre, mid, post = [], [], []</span><br><span class="line">        self.order(root, pre, mid, post)</span><br><span class="line">        <span class="keyword">return</span> [pre, mid, post]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">order</span>(<span class="params">self, root, pre, mid, post</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        pre.append(root.val)</span><br><span class="line">        self.order(root.left, pre, mid, post)</span><br><span class="line">        mid.append(root.val)</span><br><span class="line">        self.order(root.right, pre, mid, post)</span><br><span class="line">        post.append(root.val)</span><br></pre></td></tr></table></figure><h3 id="3-迭代查询"><a href="#3-迭代查询" class="headerlink" title="3. 迭代查询"></a>3. 迭代查询</h3><p>迭代这种就容易想复杂。。。特别是后序遍历！！</p><p>以下描述基础思想：</p><ol><li><p>先序遍历：跟左右</p><p>（1）头节点先入栈，然后进入循环；</p><p>（2）先出跟，获取其值，然后将右左节点入栈 - 因为栈是先进后出，所以放入应该是先右后左；</p><p>（3）然后遍历获取就行了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preOrder</span>(<span class="params">self, root, arr</span>):</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(stack) != <span class="number">0</span>:</span><br><span class="line">            tmp = stack.pop()</span><br><span class="line">            arr.append(tmp.val)</span><br><span class="line">            <span class="keyword">if</span> tmp.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(tmp.right)</span><br><span class="line">            <span class="keyword">if</span> tmp.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(tmp.left)</span><br></pre></td></tr></table></figure></li><li><p>中序遍历：左跟右</p><p>那么存放仅栈的顺序就应该是右跟左，但是不可能从右子树开始遍历，那么就只能存根，遍历左子树，等到没有左子树了，再开始遍历右子树并存值，即出此时没有左子树的跟，取跟值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">midOrder</span>(<span class="params">self, root, arr</span>):</span></span><br><span class="line">    stack = []</span><br><span class="line">    cur = root</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(stack) != <span class="number">0</span> <span class="keyword">or</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> cur.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            stack.append(cur.left)</span><br><span class="line">            cur = cur.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            arr.append(cur.val)</span><br><span class="line">            cur = cur.right</span><br></pre></td></tr></table></figure></li><li><p>后序遍历（就先序遍历反操作就是了）</p><p>也就是先序遍历的反操作，逆序取跟左右，最终输出左右跟。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postOrder</span>(<span class="params">self, root, arr</span>):</span></span><br><span class="line">    stack = [root]</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(stack) != <span class="number">0</span>:</span><br><span class="line">        tmp = stack.pop()</span><br><span class="line">        arr.append(tmp.val)</span><br><span class="line">        <span class="keyword">if</span> tmp.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            stack.append(tmp.left)</span><br><span class="line">        <span class="keyword">if</span> tmp.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            stack.append(tmp.right)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - NC22 合并两个有序的数组</title>
      <link href="/2021/07/14/LeetCode-NC22-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84/"/>
      <url>/2021/07/14/LeetCode-NC22-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/89865d4375634fc484f3a24b7fe65665?tpId=188&amp;&amp;tqId=38585&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/89865d4375634fc484f3a24b7fe65665?tpId=188&amp;&amp;tqId=38585&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-从前往后遍历"><a href="#1-从前往后遍历" class="headerlink" title="1. 从前往后遍历"></a>1. 从前往后遍历</h3><p>将两个数组从前往后遍历，如果遇到A数组有值比B当前元素大，则插入；在比较极端的情况下，B数组可能在A数组的两端。</p><p>Java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( i &lt; m &amp;&amp; j &lt; n )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( A[i] &lt;= B[j] )</span><br><span class="line">            &#123;</span><br><span class="line">                ++ i;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                move(A, m - <span class="number">1</span>, i);</span><br><span class="line">                A[i] = B[j];</span><br><span class="line">                ++ m;</span><br><span class="line">                ++ j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( i &lt; A.length )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( j &lt; n )</span><br><span class="line">            &#123;</span><br><span class="line">                A[i++] = B[j];</span><br><span class="line">                ++ j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> m, <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( m + <span class="number">1</span> &gt;= A.length )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=m; i&gt;=s; --i )</span><br><span class="line">        &#123;</span><br><span class="line">            A[i+<span class="number">1</span>] = A[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param A int整型一维数组 </span></span><br><span class="line"><span class="comment"># @param B int整型一维数组 </span></span><br><span class="line"><span class="comment"># @return void</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self , A, m, B, n</span>):</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> j &lt; n:</span><br><span class="line">            <span class="keyword">if</span> A[i] &lt;= B[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.move(A, m - <span class="number">1</span>, i)</span><br><span class="line">                A[i] = B[j]</span><br><span class="line">                m += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(A):</span><br><span class="line">            <span class="keyword">while</span> j &lt; n:</span><br><span class="line">                A[i] = B[j]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self, A, m, s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> m &gt;= <span class="built_in">len</span>(A):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m, s-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            A[i + <span class="number">1</span>] = A[i]</span><br></pre></td></tr></table></figure><p>###2. 从后往前遍历</p><p>将两张表的当前最后一个元素进行比较，将大的值放到A数组的最后一个空间，循环直到某个表遍历完，如果是B表遍历完结束，A表遍历完就意味着可能B表还有元素没有插入，但是此时A表已经全部存在数据，就意味着A表的前n个数据在后面已经存在，只需要将这些位置的数据替换成B表相应位置的数据就行。</p><p>Java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( m &gt; <span class="number">0</span> &amp;&amp; n &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( A[m - <span class="number">1</span>] &gt;= B[n - <span class="number">1</span>] )</span><br><span class="line">            &#123;</span><br><span class="line">                A[m + n - <span class="number">1</span>] = A[m - <span class="number">1</span>];</span><br><span class="line">                m -= <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                A[m + n - <span class="number">1</span>] = B[n - <span class="number">1</span>];</span><br><span class="line">                n -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( n &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i )</span><br><span class="line">            &#123;</span><br><span class="line">                A[i] = B[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param A int整型一维数组 </span></span><br><span class="line"><span class="comment"># @param B int整型一维数组 </span></span><br><span class="line"><span class="comment"># @return void</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self , A, m, B, n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A: <span class="keyword">return</span> B</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> B: <span class="keyword">return</span> A</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> A <span class="keyword">and</span> <span class="keyword">not</span> B: <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">while</span> m &gt; <span class="number">0</span> <span class="keyword">and</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> A[m - <span class="number">1</span>] &lt; B[n - <span class="number">1</span>]:</span><br><span class="line">                A[m + n - <span class="number">1</span>] = B[n - <span class="number">1</span>]</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A[m + n - <span class="number">1</span>] = A[m - <span class="number">1</span>]</span><br><span class="line">                m -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            A[:n] = B[:n]</span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure><p><strong>上述两种方法并没有实质上的区别</strong></p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java, python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆排序算法</title>
      <link href="/2021/07/13/%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2021/07/13/%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>简单来说就是完全二叉树，大顶堆的每个父节点会大于等于它的子节点；小顶堆的每个父节点会小于等于它的子节点。</p><span id="more"></span><h2 id="思路拆解"><a href="#思路拆解" class="headerlink" title="思路拆解"></a>思路拆解</h2><p>一般情况下，堆排序是针对数组的排序（应该吧。。。）：</p><ol><li><p>首先会将可能无序的数组初始化为一个堆，即构建堆；</p></li><li><p>对于堆的构建，是从数组的末尾、即最后一个父节点开始循环进行构建 - 也就是把三个节点中值最小的换到父节点；</p></li><li><p>但是这里有一个小问题 - 这样的构建方式相当于是在上一次构建完成的基础上进行构建，那么很有可能会破坏之前构建的结果；</p></li><li><p>针对这个问题，需要写一个函数对这样的部分堆进行从上往下的调整；</p></li><li><p>之后，初步构造的堆就完成了；</p></li><li><p>之后的升序或降序排序，只要将头尾的元素互换，数组的最后一个元素就是当前数组中最小的元素，然后将该元素去除（简单一点就是len-1），对剩余的前<code>n-1</code>个元素从头进行由上往下的调整，再将第一个元素和当前数组的最后一个元素交换，就可以得到第二小的元素，以此类推。</p></li></ol><p>下面以小顶堆为例说明上述思路。</p><h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><ol><li><p>先写一个会经常使用的元素交换函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = input[a];</span><br><span class="line">    input[a] = input[b];</span><br><span class="line">    input[b] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构建小顶堆</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initHeap</span><span class="params">(<span class="keyword">int</span>[] input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( input.length &lt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = input.length;</span><br><span class="line">    <span class="keyword">int</span> f = len / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(f &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = f * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        heapSort(input, i, len);</span><br><span class="line">        -- f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）<code>f = len / 2 - 1</code>：</p><p>默认元素从0开始取最后一个元素的父节点，如果从1开始就是<code>f = len / 2</code>；</p><p>（2）<code>i = f * 2 + 1</code>：</p><p>从0开始的父节点，子节点为<code>left = f * 2 + 1; right = f * 2 + 2</code>，从1开始的父节点，子节点为<code>left = f * 2; right = f * 2+ 1;</code> ；</p><p>（3）两个 <code>if</code> 语句：</p><p>先获取两个子节点中值最小的节点；然后判断父节点与最小子节点的大小，如果父节点比最小子节点大，则交换元素；</p><p>（4）<code>heapSort(input, i, len);</code></p><p>进行部分堆的调整。</p></li><li><p>排序（小顶堆就是逆序了）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> f, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 重新调整为小顶堆</span></span><br><span class="line">    <span class="keyword">while</span>( f &lt; len )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = f * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>( i + <span class="number">1</span> &lt; len &amp;&amp; input[i] &gt; input[i + <span class="number">1</span>] )</span><br><span class="line">        &#123;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( i &lt; len &amp;&amp; input[f] &gt; input[i] )</span><br><span class="line">        &#123;</span><br><span class="line">            swap(input, i, f);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - NC102 在二叉树中找到两个节点的最近公共祖先</title>
      <link href="/2021/07/10/LeetCode-NC102-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
      <url>/2021/07/10/LeetCode-NC102-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/e0cc33a83afe4530bcec46eba3325116?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/e0cc33a83afe4530bcec46eba3325116?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>可以有两种思路：</p><h3 id="1-从局部看：看两个值和公共节点的关系"><a href="#1-从局部看：看两个值和公共节点的关系" class="headerlink" title="1. 从局部看：看两个值和公共节点的关系"></a>1. 从局部看：看两个值和公共节点的关系</h3><p>有三种关系：</p><ol><li>o1和o2在公共节点的两边；</li><li>o1是公共节点；</li><li>o2是公共节点。</li></ol><p>对于第一个关系，就说明该节点的左右子节点都不可能为<code>NULL</code>，则可以得到下述：</p><p>java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( root.left != <span class="keyword">null</span> &amp;&amp; root.right!=<span class="keyword">null</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第二和三的关系，假设当前节点就是公共节点，可以返回该节点。然后由上面一个节点判断此时本节点是公共节点还是一个节点的长辈节点：</p><p>java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( root == <span class="keyword">null</span> || root.val == o1 || root.val == o2 )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止有节点只有左节点和右节点中的一个：</p><p>java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br></pre></td></tr></table></figure><p>总体代码如下：</p><p>java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o1 int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o2 int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="keyword">int</span> o1, <span class="keyword">int</span> o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CommonAncestor(root, o1, o2).val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">CommonAncestor</span><span class="params">(TreeNode root, <span class="keyword">int</span> o1, <span class="keyword">int</span> o2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span> || root.val == o1 || root.val == o2 )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = CommonAncestor(root.left, o1, o2);</span><br><span class="line">        TreeNode right = CommonAncestor(root.right, o1, o2);</span><br><span class="line">        <span class="keyword">if</span>( left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param root TreeNode类 </span></span><br><span class="line"><span class="comment"># @param o1 int整型 </span></span><br><span class="line"><span class="comment"># @param o2 int整型 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self , root , o1 , o2 </span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">CommonAncestor</span>(<span class="params">root, o1, o2</span>):</span></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> root.val <span class="keyword">in</span> [o1, o2]:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            left = CommonAncestor(root.left, o1, o2)</span><br><span class="line">            right = CommonAncestor(root.right, o1, o2)</span><br><span class="line">            <span class="keyword">if</span> left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">return</span> left <span class="keyword">if</span> left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> right</span><br><span class="line">        <span class="keyword">return</span> CommonAncestor(root, o1, o2).val</span><br></pre></td></tr></table></figure><h3 id="2-从整体看：看每个值之间的区别"><a href="#2-从整体看：看每个值之间的区别" class="headerlink" title="2. 从整体看：看每个值之间的区别"></a>2. 从整体看：看每个值之间的区别</h3><p>可以记录从顶点到每个值的路径，然后比较两个路径是从哪个顶点开始聚合或分道扬镳的，该节点就算最近公共节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o1 int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o2 int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="keyword">int</span> o1, <span class="keyword">int</span> o2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        getPath(root, o1, s1);</span><br><span class="line">        getPath(root, o2, s2);</span><br><span class="line">        <span class="keyword">int</span> res = root.val;</span><br><span class="line">        <span class="keyword">while</span>( !(s1.isEmpty() || s2.isEmpty()) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> f1 = s1.pop(), f2 = s2.pop();</span><br><span class="line">            System.out.println(f1+<span class="string">&quot; &quot;</span>+f2);</span><br><span class="line">            <span class="keyword">if</span>( f1 != f2 )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            res = f1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">getPath</span><span class="params">(TreeNode root, <span class="keyword">int</span> o, Stack&lt;Integer&gt; stack)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( root.val == o || getPath(root.left, o, stack) || getPath(root.right, o, stack) )</span><br><span class="line">        &#123;</span><br><span class="line">            stack.push(root.val);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择元素不相等时退出是因为<code>getPath</code>函数是从下往上<code>push</code>元素的。</p><p>python：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param root TreeNode类 </span></span><br><span class="line"><span class="comment"># @param o1 int整型 </span></span><br><span class="line"><span class="comment"># @param o2 int整型 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self , root , o1 , o2 </span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getPath</span>(<span class="params">root, o, s</span>):</span></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> root.val == o <span class="keyword">or</span> getPath(root.left, o, s) <span class="keyword">or</span> getPath(root.right, o, s):</span><br><span class="line">                s.append(root.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        s1, s2 = [], []</span><br><span class="line">        res = root.val</span><br><span class="line">        getPath(root, o1, s1)</span><br><span class="line">        getPath(root, o2, s2)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(s1) != <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(s2) != <span class="number">0</span>:</span><br><span class="line">            f1, f2 = s1.pop(), s2.pop()</span><br><span class="line">            <span class="keyword">if</span> f1 != f2:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            res = f1</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java, python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - NC68 跳台阶</title>
      <link href="/2021/07/09/LeetCode-NC68-%E8%B7%B3%E5%8F%B0%E9%98%B6/"/>
      <url>/2021/07/09/LeetCode-NC68-%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=188&amp;&amp;tqId=38622&amp;rp=1&amp;ru=/ta/job-code-high-week&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=188&amp;&amp;tqId=38622&amp;rp=1&amp;ru=/ta/job-code-high-week&amp;qru=/ta/job-code-high-week/question-ranking</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>在中间的某个台阶<code>f[n]</code>，走到这个台阶有两种可能，走一步或走两步，得到公式：<code>f[n] = f[n-1] + f[n-2]</code>，根据常识可以知道，<code>n为1或0时</code>，即<code>f[1] = f[0] = 1</code>，默认排除n小于0的可能性，可以计算结果。</p><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( target &lt;= <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jumpFloor(target-<span class="number">1</span>) + jumpFloor(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法在python中运算时间过长。</p><h3 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2. 动态规划"></a>2. 动态规划</h3><p>Java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=target; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上述代码进行改动，简化了数组的使用。python：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        a, b, c = <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, number+<span class="number">1</span>):</span><br><span class="line">            c = a + b</span><br><span class="line">            a = b</span><br><span class="line">            b = c</span><br><span class="line">        <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬楼梯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL刷题 &amp; 笔记</title>
      <link href="/2021/07/09/SQL%E5%88%B7%E9%A2%98%20&amp;%20%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/07/09/SQL%E5%88%B7%E9%A2%98%20&amp;%20%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="获取每一个分组中的最大元素"><a href="#获取每一个分组中的最大元素" class="headerlink" title="获取每一个分组中的最大元素"></a>获取每一个分组中的最大元素</h2><p><a href="https://www.nowcoder.com/practice/4a052e3e1df5435880d4353eb18a91c6?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL12 获取每个部门中当前员工薪水最高的相关信息</a></p><span id="more"></span><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-知识点"><a href="#1-知识点" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p>要求获取每一个分组中的最大元素（也可以看作获取每个分组的第一个元素）。</p><p>错误的思考：在同一个语句中group by+order by - </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 错误</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a <span class="keyword">order</span> <span class="keyword">by</span> b</span><br></pre></td></tr></table></figure><p>原因：group by后显示的就会是每个分组的第一条数据；之后进行order by就是对每个分组的第一条数据进行排序，即组间排序，并没有意义。</p><p>分析：有一种方法是可以先order by limit再进行group by，但是这种方法不够灵活有效；还有一种方法就算下述，先获取每个分组的目标元素的最大值和目标分组的字段，然后联表获取所有所需字段和目标分组字段，将两个部分进行连接就可以了。</p><h4 id="2-具体题解"><a href="#2-具体题解" class="headerlink" title="2. 具体题解"></a>2. 具体题解</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> B1.dept_no</span><br><span class="line">      ,B2.emp_no</span><br><span class="line">      ,B1.maxSalary</span><br><span class="line">  <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">        <span class="keyword">select</span> A1.dept_no, <span class="built_in">max</span>(A2.salary) <span class="keyword">as</span> maxSalary</span><br><span class="line">          <span class="keyword">from</span> dept_emp <span class="keyword">as</span> A1</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> salaries <span class="keyword">as</span> A2</span><br><span class="line">            <span class="keyword">on</span> A1.emp_no <span class="operator">=</span> A2.emp_no</span><br><span class="line">      <span class="keyword">group</span> <span class="keyword">by</span> A1.dept_no</span><br><span class="line">) B1</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">(</span><br><span class="line">        <span class="keyword">select</span> A1.dept_no, A1.emp_no, A2.salary</span><br><span class="line">          <span class="keyword">from</span> dept_emp <span class="keyword">as</span> A1</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> salaries <span class="keyword">as</span> A2</span><br><span class="line">            <span class="keyword">on</span> A1.emp_no <span class="operator">=</span> A2.emp_no</span><br><span class="line">) B2</span><br><span class="line">     <span class="keyword">on</span> B1.dept_no <span class="operator">=</span> B2.dept_no</span><br><span class="line">     <span class="keyword">and</span> B1.maxSalary <span class="operator">=</span> B2.salary</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> B1.dept_no</span><br><span class="line">;</span><br></pre></td></tr></table></figure><h2 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h2><p><a href="https://www.nowcoder.com/practice/a32669eb1d1740e785f105fa22741d5c?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL15 查找employees表emp_no与last_name的员工信息</a></p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-知识点-1"><a href="#1-知识点-1" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p>不相等的三种表达：<code>!=、&lt;&gt;、is not</code>；</p><p>求余：<code>%、MOD</code>；</p><p>判断是否为奇数：<code>val%2 = 1、val&amp;1</code>；</p><p>判断是否为偶数：<code>val = (val &gt;&gt; 1 &lt;&lt; 1)</code> - 即先右移一位再左移一位，如果是奇数，二进制最后一位一定是1，右移一位后再左移一位最后一个二进制数会补0而不是1，此时如果是奇数会与原值不等，如果是偶数会相等；</p><p>除法计算：默认 - <code>/</code>、取指定小数位 - <code>convert(val1 / val2, decimal(10, 2))</code> - 取两位小数，为0取整不保留小数、直接取整 - <code>val1 DIV val2</code>；</p><h4 id="2-具体代码"><a href="#2-具体代码" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">from</span> employees</span><br><span class="line">   <span class="keyword">where</span> emp_no <span class="operator">%</span> <span class="number">2</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">     <span class="keyword">and</span> last_name <span class="operator">&lt;&gt;</span> &quot;Mary&quot;</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> hire_date</span><br><span class="line">    <span class="keyword">desc</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">--或者</span></span><br><span class="line">  <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">from</span> employees</span><br><span class="line">   <span class="keyword">where</span> emp_no <span class="operator">&amp;</span> <span class="number">1</span></span><br><span class="line">     <span class="keyword">and</span> last_name <span class="operator">&lt;&gt;</span> &quot;Mary&quot;</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> hire_date</span><br><span class="line">    <span class="keyword">desc</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><h2 id="生成序号"><a href="#生成序号" class="headerlink" title="生成序号"></a>生成序号</h2><p><a href="https://www.nowcoder.com/practice/b9068bfe5df74276bd015b9729eec4bf?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL23 对所有员工的薪水按照salary降序进行1-N的排名</a></p><h3 id="求解思路"><a href="#求解思路" class="headerlink" title="求解思路"></a>求解思路</h3><h4 id="1-知识点-2"><a href="#1-知识点-2" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><ol><li><code>row_number</code> - 生成连续唯一的序号，即序号不重复：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>)</span><br></pre></td></tr></table></figure><p>得到结果：</p><blockquote><p>1</p><p>2</p><p>2</p><p>3</p></blockquote><ol start="2"><li><code>rank</code> - 分区内排名，即一个分区的排名一致，但会产生间断：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>)</span><br></pre></td></tr></table></figure><p>得到结果：</p><blockquote><p>1</p><p>2</p><p>2</p><p>4</p></blockquote><ol start="2"><li><code>dense_rank</code> - 分区内排名，不会产生间断：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ... <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>)</span><br></pre></td></tr></table></figure><p>得到结果：</p><blockquote><p>1</p><p>2</p><p>2</p><p>3</p></blockquote><ol start="2"><li><code>ntile</code> - 按照指定的排序规则均分成指定数目的组</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ntile</span>(<span class="number">2</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>)</span><br></pre></td></tr></table></figure><p>得到结果：</p><blockquote><p>1</p><p>1</p><p>2</p><p>2</p></blockquote><h4 id="2-具体代码-1"><a href="#2-具体代码-1" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> emp_no</span><br><span class="line">       ,salary</span><br><span class="line">       ,<span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>) <span class="keyword">as</span> t_rank</span><br><span class="line">  <span class="keyword">from</span> salaries</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> t_rank <span class="keyword">asc</span>, emp_no <span class="keyword">asc</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><h2 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h2><p><a href="https://www.nowcoder.com/practice/979b1a5a16d44afaba5191b22152f64a?tpId=199&tags=&title=&difficulty=0&judgeStatus=0&rp=0">SQL25 查找山东大学或者性别为男生的信息</a></p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题第一个想到的解法是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> university <span class="operator">=</span> <span class="string">&#x27;山东大学&#x27;</span> <span class="keyword">or</span> gender <span class="operator">=</span> <span class="string">&#x27;male&#x27;</span></span><br></pre></td></tr></table></figure><p>但是题目中有两个提示：</p><ol><li>结果不去重；</li><li>注意输出的顺序，先输出学校为山东大学再输出性别为男生的信息。</li></ol><p>从第一个提示看应该会有去不去重两种可能，这道题其实有两种思路：<code>or</code> 和 <code>union</code>。对于 <code>or</code> 肯定不会存在去不去重的问题，确定是 <code>union</code> 的关键是第二个提示，使用 <code>union</code> 方法都会默认 <code>union</code> 前的结果会放在 <code>union</code> 后的结果前。</p><p>去重的问题：union会去重，union all 不会去重。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> device_id, gender, age, gpa</span><br><span class="line">  <span class="keyword">from</span> user_profile</span><br><span class="line"> <span class="keyword">where</span> university <span class="operator">=</span> <span class="string">&#x27;山东大学&#x27;</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> device_id, gender, age, gpa</span><br><span class="line">  <span class="keyword">from</span> user_profile</span><br><span class="line"> <span class="keyword">where</span> gender <span class="operator">=</span> <span class="string">&#x27;male&#x27;</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><h2 id="insert-ignore-和-replace-into"><a href="#insert-ignore-和-replace-into" class="headerlink" title="insert ignore 和 replace into"></a>insert ignore 和 replace into</h2><p><a href="https://www.nowcoder.com/practice/153c8a8e7805400ba8e384e03acc6b3e?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL35 批量插入数据，不使用replace操作</a></p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>主要是insert ignore 和 replace into 的区别：</strong></p><p>使用 <code>ignore</code> 关键字。</p><p><code>insert ignore</code>  - 如果数据库中不存在这条数据就插入，存在就跳过。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> </span><br><span class="line">ignore </span><br><span class="line">  <span class="keyword">into</span> actor </span><br><span class="line"><span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;ED&#x27;</span>, <span class="string">&#x27;CHASE&#x27;</span>, <span class="string">&#x27;2006-02-15 12:34:33&#x27;</span>);</span><br></pre></td></tr></table></figure><p>使用 <code>replace</code> 关键字。</p><p><code>replace into</code> - 如果存在 <code>primary key</code> 或 <code>unique</code> 相同的记录，先删除原有记录，再添加此新记录。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">replace </span><br><span class="line">   <span class="keyword">into</span> actor</span><br><span class="line"> <span class="keyword">select</span> <span class="number">3</span></span><br><span class="line">        ,<span class="string">&#x27;ED&#x27;</span></span><br><span class="line">        ,<span class="string">&#x27;CHASE&#x27;</span></span><br><span class="line">        ,<span class="string">&#x27;2006-02-15 12:34:33&#x27;</span></span><br><span class="line">   <span class="keyword">from</span> actor</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p><strong>ignore 和 replace 是mysql8之后有的内容。</strong></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><a href="https://www.nowcoder.com/practice/e1824daa0c49404aa602cf0cb34bdd75?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL37 对first_name创建唯一索引uniq_idx_firstname</a></p><p><a href="https://www.nowcoder.com/practice/4963f6d63dde48d787aaa2b43460fb4b?tpId=240&tags=&title=&difficulty=0&judgeStatus=0&rp=0"><strong>SQL13</strong> <strong>删除索引</strong></a></p><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><h3 id="1-知识点-3"><a href="#1-知识点-3" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>有以下几种索引 <code>index</code> ：</p><ul><li>UNIQUE:可选。表示索引为唯一性索引。</li><li>FULLTEXT:可选。表示索引为全文索引。</li><li>SPATIAL:可选。表示索引为空间索引。</li><li>默认上述关键字都不加，表示索引为普通索引。</li></ul><p>添加索引的几种方式：</p><ol><li>创建表时添加：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test</span><br><span class="line">(</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    filename <span class="type">VARCHAR</span> (<span class="number">512</span>),</span><br><span class="line">    fileurl <span class="type">VARCHAR</span> (<span class="number">512</span>),</span><br><span class="line">    filesize <span class="type">BIGINT</span>,</span><br><span class="line">    <span class="comment">-- 带关键字索引</span></span><br><span class="line">    <span class="keyword">unique</span> index (id),</span><br><span class="line">    <span class="comment">-- 普通索引</span></span><br><span class="line">    index (filename),</span><br><span class="line">    <span class="comment">--组合索引</span></span><br><span class="line">    index (fileurl, filesize)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="2"><li>为已有表添加：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 带关键字的索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test <span class="keyword">add</span> <span class="keyword">unique</span> index (id);</span><br><span class="line"><span class="comment">-- 不带关键字的索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test <span class="keyword">add</span> index (filename);</span><br></pre></td></tr></table></figure><ol start="3"><li>删除索引：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">drop</span> index index_name;</span><br></pre></td></tr></table></figure><h4 id="2-具体代码-2"><a href="#2-具体代码-2" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> actor <span class="keyword">add</span> <span class="keyword">unique</span> index uniq_idx_firstname (first_name);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> actor <span class="keyword">add</span> index idx_lastname (last_name);</span><br></pre></td></tr></table></figure><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p><a href="https://www.nowcoder.com/practice/b9db784b5e3d488cbd30bd78fdb2a862?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL38 针对actor表创建视图actor_name_view</a></p><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-知识点-4"><a href="#1-知识点-4" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p>创建视图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br></pre></td></tr></table></figure><p>查询视图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> view_name;</span><br></pre></td></tr></table></figure><p>更新视图：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br></pre></td></tr></table></figure><p>撤销视图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW view_name</span><br></pre></td></tr></table></figure><h4 id="2-具体解决代码"><a href="#2-具体解决代码" class="headerlink" title="2. 具体解决代码"></a>2. 具体解决代码</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> actor_name_view <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">select</span> first_name <span class="keyword">as</span> first_name_v</span><br><span class="line">       ,last_name <span class="keyword">as</span> last_name_v</span><br><span class="line">  <span class="keyword">from</span> actor;</span><br></pre></td></tr></table></figure><h2 id="强制使用索引"><a href="#强制使用索引" class="headerlink" title="强制使用索引"></a>强制使用索引</h2><p><a href="https://www.nowcoder.com/practice/f9fa9dc1a1fc4130b08e26c22c7a1e5f?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL39 强制使用索引</a></p><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-知识点-5"><a href="#1-知识点-5" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p>强制使用索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> TABLE1 FORCE INDEX (索引名或<span class="keyword">PRIMARY</span>) ;</span><br></pre></td></tr></table></figure><h4 id="2-具体代码-3"><a href="#2-具体代码-3" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> salaries FORCE INDEX (idx_emp_no) <span class="keyword">where</span> emp_no <span class="operator">=</span> <span class="number">10005</span>;</span><br></pre></td></tr></table></figure><h2 id="给已有表新建列"><a href="#给已有表新建列" class="headerlink" title="给已有表新建列"></a>给已有表新建列</h2><p><a href="https://www.nowcoder.com/practice/119f04716d284cb7a19fba65dd876b03?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL40 在指定列后添加新列</a></p><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-知识点-6"><a href="#1-知识点-6" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">alter</span> </span><br><span class="line">  <span class="keyword">table</span> table_name</span><br><span class="line">    <span class="keyword">add</span></span><br><span class="line"> <span class="keyword">COLUMN</span> column_name column_type [<span class="keyword">not</span> <span class="keyword">NULL</span>]</span><br><span class="line">[<span class="keyword">DEFAULT</span> default_context]</span><br><span class="line">[  after column_name]</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>其中，<code>after</code> 用来指定在某个列后面添加新列，<code>default</code> 指定默认值。</p><h4 id="2-具体代码-4"><a href="#2-具体代码-4" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">alter</span> </span><br><span class="line">  <span class="keyword">table</span> actor</span><br><span class="line">    <span class="keyword">add</span></span><br><span class="line"> <span class="keyword">COLUMN</span> create_date datetime <span class="keyword">not</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="string">&#x27;2020-10-01 00:00:00&#x27;</span></span><br><span class="line">  after last_update</span><br><span class="line">;</span><br></pre></td></tr></table></figure><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p><a href="https://www.nowcoder.com/practice/7e920bb2e1e74c4e83750f5c16033e2e?tpId=82&&tqId=29809&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking">SQL41 构造一个触发器</a></p><h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-知识点-7"><a href="#1-知识点-7" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p>Trigger创建的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">       trigger_time trigger_event </span><br><span class="line">    <span class="keyword">ON</span> tbl_name</span><br><span class="line">   <span class="keyword">FOR</span> </span><br><span class="line">  <span class="keyword">EACH</span> </span><br><span class="line">   <span class="type">ROW</span></span><br><span class="line">       trigger_stmt</span><br></pre></td></tr></table></figure><p>其中：</p><blockquote><p><strong>参数解析</strong></p><p>trigger_name：标识触发器名称，用户自行指定；<br>trigger_time：标识触发时机，取值为 BEFORE 或 AFTER；<br>trigger_event：标识触发事件，取值为 INSERT、UPDATE 或 DELETE；<br>tbl_name：标识建立触发器的表名，即在哪张表上建立触发器；<br>trigger_stmt：触发器程序体，可以是一句SQL语句，或者用 BEGIN 和 END 包含的多条语句，每条语句结束要分号结尾。</p><p><strong>new 和 old</strong></p><p>MySQL 中定义了 NEW 和 OLD，用来表示触发器的所在表中，触发了触发器的那一行数据。<br>具体地：</p><ol><li>在 INSERT 型触发器中，NEW 用来表示将要（BEFORE）或已经（AFTER）插入的新数据；</li><li>在 UPDATE 型触发器中，OLD 用来表示将要或已经被修改的原数据，NEW 用来表示将要或已经修改为的新数据；</li><li>在 DELETE 型触发器中，OLD 用来表示将要或已经被删除的原数据；</li><li>使用方法： NEW.columnName （columnName 为相应数据表某一列名）</li></ol></blockquote><h4 id="2-具体代码-5"><a href="#2-具体代码-5" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">create</span> </span><br><span class="line">     <span class="keyword">trigger</span> audit_log</span><br><span class="line">       after </span><br><span class="line">      <span class="keyword">insert</span> </span><br><span class="line">          <span class="keyword">on</span> employees_test</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line">       <span class="keyword">begin</span></span><br><span class="line">             <span class="keyword">insert</span> <span class="keyword">into</span> audit <span class="keyword">values</span>(new.ID, new.NAME);</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><h4 id="3-摘自"><a href="#3-摘自" class="headerlink" title="3. 摘自"></a>3. 摘自</h4><p><a href="https://blog.csdn.net/haut_ykc/article/details/110226668">SQL编程：构造触发器</a></p><h2 id="表的更新和删除"><a href="#表的更新和删除" class="headerlink" title="表的更新和删除"></a>表的更新和删除</h2><p><a href="https://www.nowcoder.com/practice/3d92551a6f6d4f1ebde272d20872cf05?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL42 对表进行条件删除</a></p><p><a href="https://www.nowcoder.com/practice/859f28f43496404886a77600ea68ef59?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL43 对表进行条件更新</a></p><h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-知识点-8"><a href="#1-知识点-8" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p>删除语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name [<span class="keyword">WHERE</span> Clause]</span><br></pre></td></tr></table></figure><p>更新语法：</p><ol><li>设置为新值：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name <span class="keyword">SET</span> field1<span class="operator">=</span><span class="keyword">new</span><span class="operator">-</span>value1, field2<span class="operator">=</span><span class="keyword">new</span><span class="operator">-</span>value2</span><br><span class="line">[<span class="keyword">WHERE</span> Clause]</span><br></pre></td></tr></table></figure><ol start="2"><li>根据已有值替换：</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name <span class="keyword">SET</span> key1<span class="operator">=</span>replace(key1, <span class="string">&#x27;查找内容&#x27;</span>, <span class="string">&#x27;替换成内容&#x27;</span>)</span><br><span class="line">[<span class="keyword">WHERE</span> Clause]</span><br></pre></td></tr></table></figure><h4 id="2-具体代码-6"><a href="#2-具体代码-6" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> titles_test</span><br><span class="line"><span class="keyword">where</span> id <span class="keyword">not</span> <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">select</span> <span class="built_in">min</span>(id)</span><br><span class="line">        <span class="keyword">from</span> titles_test</span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span> emp_no</span><br><span class="line">    )A1</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">--更新</span></span><br><span class="line">UPDATE titles_test</span><br><span class="line">   <span class="keyword">SET</span> to_date<span class="operator">=</span><span class="keyword">NULL</span></span><br><span class="line">       ,from_date<span class="operator">=</span><span class="string">&#x27;2001-01-01&#x27;</span></span><br><span class="line"> <span class="keyword">WHERE</span> to_date <span class="operator">=</span> <span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>这里有一个犯过的错误：</p><p><strong>group by前面的select语句中要用聚合函数！！！不然是没有作用的。</strong></p><h2 id="alter和update"><a href="#alter和update" class="headerlink" title="alter和update"></a>alter和update</h2><p><a href="https://www.nowcoder.com/practice/5277d7f92aa746ab8aa42886e5d570d4?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL44 alter</a></p><p><a href="https://www.nowcoder.com/practice/2bec4d94f525458ca3d0ebf3bc8cd240?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL45 update</a></p><h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-知识点-9"><a href="#1-知识点-9" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p>update和alter的<strong>区别</strong>：</p><p>alter 是DDL语句，是修改数据库中对象（表，数据库，视图。。）的语句；update是DML语句，是修改表中数据的语句。</p><p>alter中：</p><p>（1）添加列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">        <span class="keyword">ADD</span> column_name column_type</span><br><span class="line">           [, column_name colum_type ...];</span><br></pre></td></tr></table></figure><p>（2）删除列：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">       <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> column_name;</span><br></pre></td></tr></table></figure><p>（3）改变数据类型：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">MODIFY <span class="keyword">COLUMN</span> column_name column_type;</span><br></pre></td></tr></table></figure><p>（4）修改表名：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> old_name</span><br><span class="line">  RENAME <span class="keyword">TO</span> new_name;</span><br></pre></td></tr></table></figure><p>（5）同时修改字段名和数据类型：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">CHANGE <span class="keyword">COLUMN</span> old_column_name new_column_name new_column_type;</span><br></pre></td></tr></table></figure><p>update中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name </span><br><span class="line">   <span class="keyword">SET</span> field1<span class="operator">=</span><span class="keyword">new</span><span class="operator">-</span>value1, field2<span class="operator">=</span><span class="keyword">new</span><span class="operator">-</span>value2</span><br><span class="line">[<span class="keyword">WHERE</span> Clause]</span><br></pre></td></tr></table></figure><p>特殊的，题中出现替代值,这就用到了 <code>replace函数</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replace(<span class="keyword">column</span>, old_value, new_value)</span><br></pre></td></tr></table></figure><p>出现在 <code>update</code> 也是一样：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">set</span> column_name <span class="operator">=</span> replace(column_name, <span class="keyword">old</span>, <span class="keyword">new</span>)</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure><h4 id="2-具体代码-7"><a href="#2-具体代码-7" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- sql44</span></span><br><span class="line"> UPDATE titles_test </span><br><span class="line">    <span class="keyword">SET</span> emp_no <span class="operator">=</span> REPLACE(emp_no, <span class="number">10001</span>, <span class="number">10005</span>)</span><br><span class="line">  <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">--sql45</span></span><br><span class="line"> <span class="keyword">alter</span> </span><br><span class="line"> <span class="keyword">table</span> titles_test </span><br><span class="line">rename </span><br><span class="line">    <span class="keyword">to</span> titles_2017</span><br><span class="line">;</span><br></pre></td></tr></table></figure><h2 id="group-concat"><a href="#group-concat" class="headerlink" title="group_concat"></a>group_concat</h2><p><a href="https://www.nowcoder.com/practice/6e86365af15e49d8abe2c3d4b5126e87?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL53 按照dept_no进行汇总</a></p><h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-知识点-10"><a href="#1-知识点-10" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p><code>group_concat(column, delim)</code></p><p>将聚合后的字段进行连接， <code>delim</code> 参数默认是 <code>,</code> 逗号。</p><h4 id="2-具体代码-8"><a href="#2-具体代码-8" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">select</span> dept_no</span><br><span class="line">         ,GROUP_CONCAT(emp_no)</span><br><span class="line">    <span class="keyword">from</span> dept_emp </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_no;</span><br></pre></td></tr></table></figure><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p><a href="https://www.nowcoder.com/practice/f24966e0cb8a49c192b5e65339bc8c03?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL55 分页查询employees表，每5行一页，返回第2页的数据</a></p><h3 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-知识点-11"><a href="#1-知识点-11" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p><strong>分页查询。每页n行，取第k页的全部数据。</strong></p><h4 id="1-limit进行分页"><a href="#1-limit进行分页" class="headerlink" title="1. limit进行分页"></a>1. limit进行分页</h4><p>公式：<code>limit n * (k - 1), n </code></p><p>具体代码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> emp_no</span><br><span class="line">limit <span class="number">5</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>在具体代码中，<strong>limit后不支持计算</strong>。</p><h4 id="2-row-number实现分页查询"><a href="#2-row-number实现分页查询" class="headerlink" title="2. row_number实现分页查询"></a>2. row_number实现分页查询</h4><p>具体代码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> emp_no,birth_date,first_name,last_name,gender,hire_date</span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">       ,<span class="built_in">floor</span>(rn <span class="operator">/</span> <span class="number">5</span>) <span class="keyword">as</span> dr</span><br><span class="line">  <span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> e.<span class="operator">*</span></span><br><span class="line">       ,<span class="built_in">row_number</span>() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> emp_no) <span class="operator">-</span> <span class="number">1</span> <span class="keyword">as</span> rn</span><br><span class="line">  <span class="keyword">from</span> employees e</span><br><span class="line">)e1</span><br><span class="line">)e2 <span class="keyword">where</span> dr <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>思路是：</p><ol><li>首先对整体数据添加序号：<code>row_number() over</code> 至少需要用 <code>order by</code> 进行排序；</li><li>先使用 <code>rn / 5</code> 对数据分页，已知 <code>0/5 == 1/5 == 2/5 == 3/5 == 4/5 == 0</code>（仅整数部分），但是由于此处的计算结果是小数，使用 <code>floor()</code> 函数向下取整。</li><li>最终取分页值为 <code>(k-1)</code> 的数据即可。</li></ol><h2 id="切分字符串"><a href="#切分字符串" class="headerlink" title="切分字符串"></a>切分字符串</h2><p><a href="%5Bhttps://www.nowcoder.com/practice/f04189f92f8d4f6fa0f383d413af7cb8?tpId=199&tqId=1975682&ru=/exam/oj&qru=/ta/sql-quick-study/question-ranking&sourceUrl=/exam/oj?tab=SQL%25E7%25AF%2587&topicId=199%5D(https://www.nowcoder.com/practice/f04189f92f8d4f6fa0f383d413af7cb8?tpId=199&tqId=1975682&ru=/exam/oj&qru=/ta/sql-quick-study/question-ranking&sourceUrl=/exam/oj?tab=SQL%E7%AF%87&topicId=199)">SQL30 统计每种性别的人数</a></p><h3 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-知识点-12"><a href="#1-知识点-12" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p>使用 <code>SUBSTRING_INDEX(str, delim, pos)</code>。</p><h4 id="2-具体代码-9"><a href="#2-具体代码-9" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> gender, <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line">  <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> SUBSTRING_INDEX(profile, <span class="string">&#x27;,&#x27;</span>, <span class="number">-1</span>) gender</span><br><span class="line">  <span class="keyword">from</span> user_submit</span><br><span class="line">)A</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> gender</span><br><span class="line">;</span><br></pre></td></tr></table></figure><h2 id="表中记录替换"><a href="#表中记录替换" class="headerlink" title="表中记录替换"></a>表中记录替换</h2><p><a href="https://www.nowcoder.com/practice/978bcee6530a430fb0be716423d84082?tpId=240&tqId=2223554&ru=/exam/oj&qru=/ta/sql-advanced/question-ranking&sourceUrl=/exam/oj?tab=SQL%25E7%25AF%2587&topicId=240">SQL3 插入记录（三）</a></p><h3 id="1-知识点-13"><a href="#1-知识点-13" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>可以先删除 <code>delete</code> ，再添加。</p><p>也可以直接使用 <code>replace</code> 关键字替换。</p><h3 id="2-具体代码-10"><a href="#2-具体代码-10" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># replace <span class="keyword">into</span> examination_info <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">9003</span>, <span class="string">&#x27;SQL&#x27;</span>, <span class="string">&#x27;hard&#x27;</span>, <span class="string">&#x27;90&#x27;</span>, <span class="string">&#x27;2021-01-01 00:00:00&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> examination_info <span class="keyword">where</span> exam_id <span class="operator">=</span> <span class="number">9003</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> examination_info <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">9003</span>, <span class="string">&#x27;SQL&#x27;</span>, <span class="string">&#x27;hard&#x27;</span>, <span class="string">&#x27;90&#x27;</span>, <span class="string">&#x27;2021-01-01 00:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="日期相减"><a href="#日期相减" class="headerlink" title="日期相减"></a>日期相减</h2><p><a href="https://www.nowcoder.com/practice/d331359c5ca04a3b87f06b97da42159c?tpId=240&tags=&title=&difficulty=0&judgeStatus=0&rp=0">SQL6删除记录（一）</a></p><p><a href="https://www.nowcoder.com/practice/9dcc0eebb8394e79ada1d4d4e979d73c?tpId=240&tqId=2183405&ru=/exam/oj&qru=/ta/sql-advanced/question-ranking&sourceUrl=/exam/oj?tab=SQL%25E7%25AF%2587&topicId=240"><strong>SQL29</strong> <strong>连续两次作答试卷的最大时间窗</strong></a></p><h3 id="1-知识点-14"><a href="#1-知识点-14" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><ul><li>TIMESTAMPDIFF(interval, time_start, time_end)可计算time_start-time_end的时间差，单位以指定的interval为准，常用可选：<ul><li>SECOND 秒</li><li>MINUTE 分钟（返回秒数差除以60的整数部分）</li><li>HOUR 小时（返回秒数差除以3600的整数部分）</li><li>DAY 天数（返回秒数差除以3600*24的整数部分）</li><li>MONTH 月数</li><li>YEAR 年数</li></ul></li><li>DATEDIFF(next_date, cur_date)返回两个日期间的<strong>天数</strong>。</li></ul><h3 id="2-具体代码-11"><a href="#2-具体代码-11" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> exam_record </span><br><span class="line"> <span class="keyword">where</span> TIMESTAMPDIFF(<span class="keyword">MINUTE</span>, start_time, submit_time) <span class="operator">&lt;</span> <span class="number">5</span> </span><br><span class="line">   <span class="keyword">and</span> score <span class="operator">&lt;</span> <span class="number">60</span>;</span><br></pre></td></tr></table></figure><h2 id="删除表中所有记录并重置自增主键"><a href="#删除表中所有记录并重置自增主键" class="headerlink" title="删除表中所有记录并重置自增主键"></a>删除表中所有记录并重置自增主键</h2><p><a href="https://www.nowcoder.com/practice/3abefc6fc73e4f219dad0ab66e6b1e3f?tpId=240&tags=&title=&difficulty=0&judgeStatus=0&rp=0"><strong>SQL8</strong> <strong>删除记录（三）</strong></a></p><h3 id="1-知识点-15"><a href="#1-知识点-15" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>truncate删除表中的所有行,但表结构及其列、约束、索引等保持不变。新行标识所用的计数值<strong>重置</strong>为该列的种子。也就是<strong>truncate可以删除所有记录以及重置自增主键。</strong></p><h3 id="2-具体代码-12"><a href="#2-具体代码-12" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> exam_record;</span><br></pre></td></tr></table></figure><h2 id="创建自增主键和唯一键"><a href="#创建自增主键和唯一键" class="headerlink" title="创建自增主键和唯一键"></a>创建自增主键和唯一键</h2><p><a href="https://www.nowcoder.com/practice/a61ee5519d14444aa99e530309a8e043?tpId=240&tags=&title=&difficulty=0&judgeStatus=0&rp=0"><strong>SQL9</strong> <strong>创建一张新表</strong></a></p><h3 id="1-知识点-16"><a href="#1-知识点-16" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>自增关键字：<code>auto_increment</code>；唯一关键字：<code>unique</code>；注释：<code>comment</code>。</p><h3 id="2-具体代码-13"><a href="#2-具体代码-13" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> user_info_vip</span><br><span class="line">(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment comment <span class="string">&#x27;自增ID&#x27;</span>,</span><br><span class="line">    uid <span class="type">int</span> <span class="keyword">unique</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">    nick_name <span class="type">varchar</span>(<span class="number">64</span>) comment <span class="string">&#x27;昵称&#x27;</span>,</span><br><span class="line">    achievement <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span> comment <span class="string">&#x27;成就值&#x27;</span>,</span><br><span class="line">    level <span class="type">int</span> comment <span class="string">&#x27;用户等级&#x27;</span>,</span><br><span class="line">    job <span class="type">varchar</span>(<span class="number">32</span>) comment <span class="string">&#x27;职业方向&#x27;</span>,</span><br><span class="line">    register_time datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> comment <span class="string">&#x27;注册时间&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="日期匹配"><a href="#日期匹配" class="headerlink" title="日期匹配"></a>日期匹配</h2><p><a href="https://www.nowcoder.com/practice/9e2fb674b58b4f60ac765b7a37dde1b9?tpId=240&tags=&title=&difficulty=0&judgeStatus=0&rp=0"><strong>SQL17</strong> <strong>平均活跃天数和月活人数</strong></a></p><h3 id="1-知识点-17"><a href="#1-知识点-17" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p><code>date_format(date_, &quot;%Y%m%d&quot;)</code> 格式匹配字符串。具体匹配字符参照 <a href="https://www.w3school.com.cn/sql/func_date_format.asp">此文章</a>。</p><p><code>year(date_)</code> 取日期中的年份。类似的有：</p><ol><li><code>month()</code> 获取月份；</li><li><code>dayofmonth()</code>显示日期；</li><li><code>day()</code> 显示天；</li><li><code>last_day()</code> 显示所传日期的最后一天。</li></ol><h3 id="2-具体代码-14"><a href="#2-具体代码-14" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><p>注意题意，用户平均月活跃天数的计算应该是有 m 个人，活跃了 n 天，然后 n &#x2F; m 就是平均月活跃天数。那么这个 m 个人应该取 <code>distinct</code> ，而活跃 n 天应该取 <code>distinct 人+天</code> 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> date_format(submit_time, &quot;%Y%m&quot;), </span><br><span class="line">       round(<span class="built_in">count</span>(<span class="keyword">distinct</span> uid, DATE_FORMAT(submit_time, &quot;%Y%m%d&quot;)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> uid), <span class="number">2</span>), </span><br><span class="line">       <span class="built_in">count</span>(<span class="keyword">distinct</span> uid)</span><br><span class="line"><span class="keyword">from</span> exam_record </span><br><span class="line"><span class="keyword">where</span> submit_time <span class="keyword">like</span> &quot;2021%&quot; <span class="keyword">and</span> score <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> date_format(submit_time, &quot;%Y%m&quot;)</span><br><span class="line">;</span><br></pre></td></tr></table></figure><h2 id="some、all、any的用法"><a href="#some、all、any的用法" class="headerlink" title="some、all、any的用法"></a>some、all、any的用法</h2><p><a href="https://leetcode-cn.com/problems/game-play-analysis-ii/">512. 游戏玩法分析 II</a></p><h3 id="1-知识点-18"><a href="#1-知识点-18" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p><a href="https://github.com/astak16/blog-mysql/issues/19">借鉴</a></p><p>这三个关键字是子查询的关键词之一，必须和比较操作符一起使用。</p><ol><li>any和some：和子查询返回的列中任一值比较为true，返回true。二者的区别在于，在 <code>!=</code> 的场景下，使用some更容易理解。</li><li>all：和子查询返回的列中的所有值比较为true，返回true。</li></ol><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 (id <span class="type">int</span>, <span class="keyword">value</span> <span class="type">int</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 (id <span class="type">int</span>, <span class="keyword">value</span> <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">10</span>), (<span class="number">2</span>, <span class="number">300</span>), (<span class="number">3</span>, <span class="number">40</span>), (<span class="number">4</span>, <span class="number">60</span>), (<span class="number">5</span>, <span class="number">70</span>), (<span class="number">6</span>, <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">100</span>), (<span class="number">2</span>, <span class="number">300</span>), (<span class="number">3</span>, <span class="number">40</span>), (<span class="number">4</span>, <span class="number">600</span>), (<span class="number">5</span>, <span class="number">70</span>), (<span class="number">6</span>, <span class="number">800</span>);</span><br></pre></td></tr></table></figure><h4 id="all："><a href="#all：" class="headerlink" title="all："></a>all：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="keyword">value</span> <span class="operator">&lt;=</span> <span class="keyword">all</span>(</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">value</span> <span class="keyword">from</span> t2</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>子查询 <code>t2</code> 的结果返回 <code>(100,300,40,600,70,800)</code> ，当 <code>t1.value = 10</code> 是 <code>&lt;=</code> 子查询的所有结果，返回 <code>true</code> ；<code>t1.value = 300</code>  并没有 <code>&lt;=</code> 子查询的所有结果，如 <code>100</code> ，返回 <code>false</code> 。</p><h5 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h5><ul><li>如果子查询中结果为 <strong>空</strong>，结果为 <code>true</code></li><li>如果有一条数据为 <code>null</code> ，结果为 <code>false</code> ，也就是说查不出结果</li><li>如果有所有数据为 <code>null</code> ，结果为 <code>false</code> ，和结果为空不是一个概念</li></ul><h4 id="any："><a href="#any：" class="headerlink" title="any："></a>any：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="keyword">value</span> <span class="operator">&lt;=</span> <span class="keyword">any</span>(</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">value</span> <span class="keyword">from</span> t2</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如上，子查询结果为 <code>(100,300,40,600,70,800)</code> ，当 <code>t1.value = 10 &lt;=</code> 子查询列表中的 <code>100</code>，返回true；<code>t1.value = 300 &lt;=</code> 子查询列表中的 <code>600</code> ，返回 <code>true</code> 。</p><h5 id="tips："><a href="#tips：" class="headerlink" title="tips："></a>tips：</h5><ul><li>如果子查询中结果为 <strong>空</strong>，结果为 <code>false</code>，也就是说查不出结果</li><li>如果子查询中所有结果都为 <code>null</code> ，结果为 <code>false</code></li></ul><h4 id="some："><a href="#some：" class="headerlink" title="some："></a>some：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="keyword">value</span> <span class="operator">!=</span> <span class="keyword">some</span>(</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">value</span> <span class="keyword">from</span> t2</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>t1</code> 列表与 <code>t2</code> 列表有部分数据不相等；或者从 <code>any</code> 来看，<code>t1</code> 列表的值与 <code>t2</code> 列表的任意值不相等，二者结果相等。</p><h3 id="2-具体代码-15"><a href="#2-具体代码-15" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"># <span class="number">1.</span></span><br><span class="line"># <span class="keyword">select</span> A.player_id, B.device_id <span class="keyword">from</span> Activity B <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line"># (</span><br><span class="line">#     <span class="keyword">select</span> player_id, <span class="built_in">min</span>(event_date) first_login <span class="keyword">from</span> Activity <span class="keyword">group</span> <span class="keyword">by</span> player_id</span><br><span class="line"># )A</span><br><span class="line"># <span class="keyword">on</span> A.player_id <span class="operator">=</span> B.player_id <span class="keyword">and</span> B.event_date <span class="operator">=</span> A.first_login;</span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span></span><br><span class="line"># <span class="keyword">select</span> player_id, device_id <span class="keyword">from</span></span><br><span class="line"># (</span><br><span class="line">#     <span class="keyword">select</span> player_id, device_id, <span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> player_id <span class="keyword">order</span> <span class="keyword">by</span> event_date) num</span><br><span class="line">#     <span class="keyword">from</span> Activity</span><br><span class="line"># )A</span><br><span class="line"># <span class="keyword">where</span> num <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">3.</span></span><br><span class="line"><span class="keyword">select</span> player_id, device_id <span class="keyword">from</span> Activity A2 <span class="keyword">where</span> A2.event_date <span class="operator">&lt;=</span></span><br><span class="line"><span class="keyword">all</span>(</span><br><span class="line">    <span class="keyword">select</span> event_date <span class="keyword">from</span> Activity A1 <span class="keyword">where</span> A1.player_id <span class="operator">=</span> A2.player_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="over-函数的使用"><a href="#over-函数的使用" class="headerlink" title="over() 函数的使用"></a>over() 函数的使用</h2><p><a href="https://leetcode-cn.com/problems/game-play-analysis-iii/">534. 游戏玩法分析 III</a></p><h3 id="1-知识点-19"><a href="#1-知识点-19" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p><a href="https://blog.csdn.net/qq_43725031/article/details/104785986">借鉴</a></p><p><code>over(partition by ... order by ...)</code> 函数不能单独使用，要和分析函数一起使用。</p><p>常见的分析函数如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ...)<span class="comment">--分组排序</span></span><br><span class="line"><span class="operator">-</span> <span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ...)<span class="comment">--分组排序</span></span><br><span class="line"><span class="operator">-</span> <span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ...)<span class="comment">--分组排序</span></span><br><span class="line"><span class="operator">-</span> <span class="built_in">count</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ...)<span class="comment">--分组计数</span></span><br><span class="line"><span class="operator">-</span> <span class="built_in">max</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ...) <span class="comment">--分组取最大值</span></span><br><span class="line"><span class="operator">-</span> <span class="built_in">min</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span>    ... <span class="keyword">order</span> <span class="keyword">by</span> ...)<span class="comment">--分组取最小值</span></span><br><span class="line"><span class="operator">-</span> <span class="built_in">sum</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ...)<span class="comment">--分组求和</span></span><br><span class="line"><span class="operator">-</span> <span class="built_in">avg</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ...)<span class="comment">--分组取平均值</span></span><br><span class="line"><span class="operator">-</span> <span class="built_in">first_value</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ...)<span class="comment">--取分组第一条</span></span><br><span class="line"><span class="operator">-</span> <span class="built_in">last_value</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ...)<span class="comment">--取分组最后一条</span></span><br><span class="line"><span class="operator">-</span> <span class="built_in">lag</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ...)<span class="comment">--取出同一字段的前N行的数据</span></span><br><span class="line"><span class="operator">-</span> <span class="built_in">lead</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ...)<span class="comment">--取出同一字段的前N行的数据</span></span><br></pre></td></tr></table></figure><h3 id="2-具体代码-16"><a href="#2-具体代码-16" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><h4 id="和-sum-的连用"><a href="#和-sum-的连用" class="headerlink" title="和 sum()的连用"></a>和 sum()的连用</h4><p>此处和 <code>sum()</code> 函数连用，实现逐层累加。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> player_id, </span><br><span class="line">       event_date, </span><br><span class="line">       <span class="built_in">sum</span>(games_played) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> player_id <span class="keyword">order</span> <span class="keyword">by</span> event_date) games_played_so_far</span><br><span class="line"><span class="keyword">from</span> Activity</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> player_id, event_date <span class="keyword">desc</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>这道题的常规解法是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> A.player_id, B.event_date, <span class="built_in">sum</span>(A.games_played) <span class="keyword">as</span> games_played_so_far</span><br><span class="line"><span class="keyword">from</span> Activity A <span class="keyword">inner</span> <span class="keyword">join</span> Activity B</span><br><span class="line"><span class="keyword">on</span> A.player_id <span class="operator">=</span> B.player_id </span><br><span class="line"><span class="keyword">where</span> A.event_date <span class="operator">&lt;=</span> B.event_date</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> A.player_id, B.event_date</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> A.player_id, A.event_date <span class="keyword">desc</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>此处有一个可能没有考虑到的点：就是这里取的 <code>event_date</code> 应该是 <code>&lt;=</code> 后的变量或 <code>&gt;=</code> 前的变量。</p><h4 id="和min-的连用，和-datediff函数的嵌套"><a href="#和min-的连用，和-datediff函数的嵌套" class="headerlink" title="和min()的连用，和 datediff函数的嵌套"></a>和min()的连用，和 datediff函数的嵌套</h4><p><a href="https://leetcode-cn.com/problems/game-play-analysis-iv/">550. 游戏玩法分析 IV</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">round((<span class="keyword">select</span> <span class="built_in">count</span>(player_id) <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> player_id, datediff(event_date, <span class="built_in">min</span>(event_date) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> player_id)) date_diff</span><br><span class="line">    <span class="keyword">from</span> Activity</span><br><span class="line">)A <span class="keyword">where</span> date_diff <span class="operator">=</span> <span class="number">1</span>) <span class="operator">/</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> player_id), <span class="number">2</span>) fraction</span><br><span class="line"><span class="keyword">from</span> Activity;</span><br></pre></td></tr></table></figure><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><h3 id="字符串连接函数（普通连接和组内连接）"><a href="#字符串连接函数（普通连接和组内连接）" class="headerlink" title="字符串连接函数（普通连接和组内连接）"></a>字符串连接函数（普通连接和组内连接）</h3><p><a href="https://www.nowcoder.com/practice/46cb7a33f7204f3ba7f6536d2fc04286?tpId=240&tqId=2183007&ru=/exam/oj&qru=/ta/sql-advanced/question-ranking&sourceUrl=/exam/oj?tab=SQL%25E7%25AF%2587&topicId=240"><strong>SQL19</strong> <strong>未完成试卷数大于1的有效用户</strong></a></p><h4 id="1-知识点-20"><a href="#1-知识点-20" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p><strong>（1）concat(str1, str2, str3, …)</strong> </p><p>不能专门指定分隔符，默认逗号连接。</p><p><strong>（2）concat_ws(sep, str1, str2, …)</strong></p><p><code>sep</code> 指定分隔符，默认逗号连接。</p><p>如本例中使用：<code>CONCAT_WS(&quot;:&quot;, date_format(A.start_time, &quot;%Y-%m-%d&quot;), B.tag)</code></p><p><strong>（3）group_concat([DISTINCT] 要连接的字段 [Order BY ASC&#x2F;DESC 排序字段] [Separator ‘分隔符’])</strong></p><p>如本例中使用的：<code>GROUP_CONCAT(distinct date_tag SEPARATOR &quot;;&quot;)</code></p><h4 id="2-具体代码-17"><a href="#2-具体代码-17" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> uid, incomplete_cnt, complete_cnt, GROUP_CONCAT(<span class="keyword">distinct</span> date_tag SEPARATOR &quot;;&quot;) detail</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> A.uid, </span><br><span class="line">       A.incomplete_cnt, </span><br><span class="line">       A.complete_cnt,</span><br><span class="line">       CONCAT_WS(&quot;:&quot;, date_format(A.start_time, &quot;%Y-%m-%d&quot;), B.tag) date_tag</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line"># 获取有效用户</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> uid, exam_id, start_time, complete_cnt, incomplete_cnt</span><br><span class="line">    <span class="keyword">from</span> </span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">select</span> uid, exam_id, start_time,</span><br><span class="line">               <span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> submit_time <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">end</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> uid) complete_cnt,</span><br><span class="line">               <span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> submit_time <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> uid) incomplete_cnt</span><br><span class="line">        <span class="keyword">from</span> exam_record</span><br><span class="line">        <span class="keyword">where</span> <span class="keyword">year</span>(start_time) <span class="operator">=</span> <span class="number">2021</span></span><br><span class="line">    )A </span><br><span class="line">    <span class="keyword">where</span> complete_cnt <span class="operator">&gt;=</span> <span class="number">1</span> <span class="keyword">and</span> incomplete_cnt <span class="operator">&lt;</span> <span class="number">5</span></span><br><span class="line">) A</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> examination_info B <span class="keyword">on</span> A.exam_id <span class="operator">=</span> B.exam_id <span class="keyword">and</span> A.incomplete_cnt <span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line">)A</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> uid, incomplete_cnt, complete_cnt</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> incomplete_cnt <span class="keyword">desc</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>注意，获取未完成应该判断字段 <code>submit_time</code> 是否为 null，因为未完成的答卷也可能会有分数。</p><h3 id="left"><a href="#left" class="headerlink" title="left()"></a>left()</h3><p><a href="https://www.nowcoder.com/practice/203d0aed8928429a8978185d9a03babc?tpId=240&tqId=2183297&ru=/exam/oj&qru=/ta/sql-advanced/question-ranking&sourceUrl=/exam/oj?tab=SQL%25E7%25AF%2587&topicId=240"><strong>SQL23</strong> <strong>每个题目和每份试卷被作答的人数和次数</strong></a></p><h4 id="1-知识点-21"><a href="#1-知识点-21" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p>返回字符串左边指定长度的子串。</p><p>语法：<code>LEFT(str,length);</code></p><p>其中，<code>str</code>是是被提取的字符串，<code>length</code> 指定提取的长度。</p><p><code>length</code> 是正整数，<code>&lt;= 0</code> 返回空字符串，<code>null</code> 返回 <code>NULL</code> ，指定长度大于字符串本身的长度，返回整个字符串。</p><h4 id="2-具体代码-18"><a href="#2-具体代码-18" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 试卷</span><br><span class="line"><span class="keyword">select</span> exam_id tid, <span class="built_in">count</span>(<span class="keyword">distinct</span> uid) uv, <span class="built_in">count</span>(<span class="operator">*</span>) pv</span><br><span class="line"><span class="keyword">from</span> exam_record </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> exam_id</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"># 做题</span><br><span class="line"><span class="keyword">select</span> question_id tid, <span class="built_in">count</span>(<span class="keyword">distinct</span> uid) uv, <span class="built_in">count</span>(<span class="operator">*</span>) pv</span><br><span class="line"><span class="keyword">from</span> practice_record </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> question_id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">left</span>(tid, <span class="number">1</span>) <span class="keyword">desc</span>, uv <span class="keyword">desc</span>, pv <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><h3 id="空值匹配"><a href="#空值匹配" class="headerlink" title="空值匹配"></a>空值匹配</h3><h4 id="1-知识点-22"><a href="#1-知识点-22" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p><code>COALESCE(v1, v2, v3, ...)</code> 可以传入多个数值，会返回第一个不为 null 的数值。</p><p><a href="https://www.nowcoder.com/practice/a32c7c8590324c96950417c57fa6ecd1?tpId=240&tags=&title=&difficulty=0&judgeStatus=0&rp=0"><strong>SQL26</strong> <strong>每个6&#x2F;7级用户活跃情况</strong></a></p><h4 id="2-具体代码-19"><a href="#2-具体代码-19" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> A.uid</span><br><span class="line">       ,<span class="built_in">COALESCE</span>(B.act_month_total, <span class="number">0</span>) act_month_total</span><br><span class="line">       ,<span class="built_in">COALESCE</span>(B.act_days_2021, <span class="number">0</span>) act_days_2021</span><br><span class="line">       ,<span class="built_in">COALESCE</span>(B.act_days_2021_exam, <span class="number">0</span>) act_days_2021_exam</span><br><span class="line">       ,<span class="built_in">COALESCE</span>(B.act_days_2021_question, <span class="number">0</span>) act_days_2021_question</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> uid <span class="keyword">from</span> user_info <span class="keyword">where</span> level <span class="keyword">in</span> (<span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">) A <span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> uid</span><br><span class="line">       ,<span class="built_in">count</span>(<span class="keyword">distinct</span> DATE_FORMAT(act_time, &quot;%Y%m&quot;)) act_month_total# 总活跃月份数</span><br><span class="line">       ,<span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">year</span>(act_time) <span class="operator">=</span> <span class="number">2021</span> </span><br><span class="line">                       <span class="keyword">then</span> date_format(act_time, &quot;%Y%m%d&quot;) </span><br><span class="line">                       <span class="keyword">end</span>) act_days_2021# <span class="number">2021</span>年活跃天数</span><br><span class="line">       ,<span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">case</span> <span class="keyword">when</span> tb <span class="operator">=</span> &quot;exam&quot; <span class="keyword">and</span> <span class="keyword">year</span>(act_time) <span class="operator">=</span> <span class="number">2021</span></span><br><span class="line">                       <span class="keyword">then</span> date_format(act_time, &quot;%Y%m%d&quot;) </span><br><span class="line">                       <span class="keyword">end</span>) act_days_2021_exam# <span class="number">2021</span>年试卷作答活跃天数</span><br><span class="line">       ,<span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">case</span> <span class="keyword">when</span> tb <span class="operator">=</span> &quot;prac&quot; <span class="keyword">and</span> <span class="keyword">year</span>(act_time) <span class="operator">=</span> <span class="number">2021</span></span><br><span class="line">                       <span class="keyword">then</span> date_format(act_time, &quot;%Y%m%d&quot;)</span><br><span class="line">                       <span class="keyword">end</span>) act_days_2021_question# <span class="number">2021</span>年答题活跃天数</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> uid, start_time act_time, &quot;exam&quot; tb <span class="keyword">from</span> exam_record</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    <span class="keyword">select</span> uid, submit_time act_time, &quot;prac&quot; tb <span class="keyword">from</span> practice_record</span><br><span class="line">) A</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> uid</span><br><span class="line">) B <span class="keyword">on</span> A.uid <span class="operator">=</span> B.uid</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> act_month_total <span class="keyword">desc</span>, act_days_2021 <span class="keyword">desc</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><h2 id="获取当前行数据的前n行或后n行"><a href="#获取当前行数据的前n行或后n行" class="headerlink" title="获取当前行数据的前n行或后n行"></a>获取当前行数据的前n行或后n行</h2><p><a href="https://www.nowcoder.com/practice/9dcc0eebb8394e79ada1d4d4e979d73c?tpId=240&tqId=2183405&ru=/exam/oj&qru=/ta/sql-advanced/question-ranking&sourceUrl=/exam/oj?tab=SQL%25E7%25AF%2587&topicId=240"><strong>SQL29</strong> <strong>连续两次作答试卷的最大时间窗</strong></a></p><h3 id="1-知识点-23"><a href="#1-知识点-23" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>当前行数据的前n行：<code>lead(col, n)</code>；</p><p>当前行数据的后n行：<code>lag(col, n)</code> 。</p><h3 id="2-具体代码-20"><a href="#2-具体代码-20" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 最大时间窗</span><br><span class="line"><span class="keyword">select</span> uid, days_window, round(exam_cnt <span class="operator">/</span> diff_day <span class="operator">*</span> days_window, <span class="number">2</span>) avg_exam_cnt</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> uid</span><br><span class="line">       ,<span class="built_in">count</span>(start_time) exam_cnt</span><br><span class="line">       ,datediff(<span class="built_in">max</span>(next_time), <span class="built_in">min</span>(start_time)) <span class="operator">+</span> <span class="number">1</span> diff_day</span><br><span class="line">       ,<span class="built_in">max</span>(DATEDIFF(next_time, start_time)) <span class="operator">+</span> <span class="number">1</span> days_window</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> uid</span><br><span class="line">       ,start_time</span><br><span class="line">       ,<span class="built_in">lead</span>(start_time, <span class="number">1</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> uid <span class="keyword">order</span> <span class="keyword">by</span> start_time) next_time</span><br><span class="line"><span class="keyword">from</span> exam_record </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">year</span>(start_time) <span class="operator">=</span> <span class="number">2021</span></span><br><span class="line">) A </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> uid</span><br><span class="line">)A</span><br><span class="line"><span class="keyword">where</span> diff_day <span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> days_window <span class="keyword">desc</span>, avg_exam_cnt <span class="keyword">desc</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><h2 id="row-number-和-dense-rank-的选择"><a href="#row-number-和-dense-rank-的选择" class="headerlink" title="row_number() 和 dense_rank() 的选择"></a>row_number() 和 dense_rank() 的选择</h2><p><a href="https://www.nowcoder.com/practice/3e598a2dcd854db8b1a3c48e5904fe1c?tpId=240&tqId=2183408&ru=/exam/oj&qru=/ta/sql-advanced/question-ranking&sourceUrl=/exam/oj?tab=SQL%25E7%25AF%2587&topicId=240">SQL31 未完成率较高的50%用户近三个月答卷情况</a></p><h3 id="1-知识点-24"><a href="#1-知识点-24" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>已知的是，row_number() 是生成不重复的序号，dense_rank() 生成组内排名，对于相同的值，排名是相同的。</p><p>题中，对 over() 内有时候只会使用 <code>order by</code> 进行全局排序，在对 uid 生成序号的时候，<code>rate</code> 相同时会产生并列的排名，这对获取前50%用户的题意来说，会产生歧义：只要包括在3以内的排名，都可以获取。但实际上是只取三个的意思。</p><h3 id="2-具体代码-21"><a href="#2-具体代码-21" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># 近三个月</span><br><span class="line"><span class="keyword">select</span> uid</span><br><span class="line">       ,date_format(start_time, &quot;%Y%m&quot;) mt</span><br><span class="line">       ,<span class="built_in">count</span>(start_time) total_cnt</span><br><span class="line">       ,<span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> submit_time <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">end</span>) complete_cnt</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> uid</span><br><span class="line">       ,start_time</span><br><span class="line">       ,submit_time</span><br><span class="line">       ,<span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> uid <span class="keyword">order</span> <span class="keyword">by</span> date_format(start_time, &quot;%Y%m&quot;) <span class="keyword">desc</span>) rank2</span><br><span class="line"><span class="keyword">from</span> exam_record</span><br><span class="line"><span class="keyword">where</span> uid <span class="keyword">in</span></span><br><span class="line">(</span><br><span class="line"># <span class="number">50</span><span class="operator">%</span><span class="number">6</span>级和<span class="number">7</span>级用户</span><br><span class="line"><span class="keyword">select</span> uid <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> uid</span><br><span class="line">       ,<span class="built_in">count</span>(uid) <span class="keyword">over</span>() tot_uid</span><br><span class="line">       ,<span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> rate <span class="keyword">desc</span>) rank1</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"># <span class="keyword">SQL</span>试卷上未完成率</span><br><span class="line"><span class="keyword">select</span> uid</span><br><span class="line">       ,<span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> submit_time <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="operator">/</span> <span class="built_in">count</span>(start_time) rate</span><br><span class="line"><span class="keyword">from</span> exam_record </span><br><span class="line"><span class="keyword">where</span> exam_id <span class="keyword">in</span> (<span class="keyword">select</span> exam_id <span class="keyword">from</span> examination_info <span class="keyword">where</span> tag <span class="operator">=</span> &quot;SQL&quot;)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> uid</span><br><span class="line">)A</span><br><span class="line">)A </span><br><span class="line"><span class="keyword">where</span> rank1 <span class="operator">&lt;=</span> <span class="built_in">ceiling</span>(tot_uid <span class="operator">/</span> <span class="number">2</span>) </span><br><span class="line"><span class="keyword">and</span> uid <span class="keyword">in</span> (<span class="keyword">select</span> uid <span class="keyword">from</span> user_info <span class="keyword">where</span> level <span class="keyword">in</span> (<span class="number">6</span>, <span class="number">7</span>))</span><br><span class="line">)</span><br><span class="line">)A <span class="keyword">where</span> rank2 <span class="operator">&lt;=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> uid, mt</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> uid, mt</span><br></pre></td></tr></table></figure><h2 id="百分比-和-排名函数的类型问题"><a href="#百分比-和-排名函数的类型问题" class="headerlink" title="百分比 和 排名函数的类型问题"></a>百分比 和 排名函数的类型问题</h2><p><a href="https://www.nowcoder.com/practice/13415dff75784a57bedb6d195262be7b?tpId=240&tqId=2183409&ru=/exam/oj&qru=/ta/sql-advanced/question-ranking&sourceUrl=/exam/oj?tab=SQL%25E7%25AF%2587&topicId=240"><strong>SQL32</strong> <strong>试卷完成数同比2020年的增长率及排名变化</strong></a></p><h3 id="1-知识点-25"><a href="#1-知识点-25" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>想要获取 <code>1 / 5</code> 的百分比参数，并保留一位小数，可以这样写：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONCAT(round(<span class="number">1</span> <span class="operator">/</span> <span class="number">5</span> <span class="operator">*</span> <span class="number">100</span>, <span class="number">1</span>), <span class="string">&#x27;%&#x27;</span>)</span><br></pre></td></tr></table></figure><p>排名函数如 <code>rank()</code> 生成的排名值的类型是 <code>bigint unsigned</code> ，也就是表示，如果要对这些元素进行加减乘除的运算，需要保证结果必须是非负数，否则会报错。可以使用 <code>cast(value as signed)</code> 进行类型转换。</p><h3 id="2-具体代码-22"><a href="#2-具体代码-22" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> tag</span><br><span class="line">       ,exam_cnt_20</span><br><span class="line">       ,exam_cnt_21</span><br><span class="line">       ,CONCAT(round((exam_cnt_21 <span class="operator">-</span> exam_cnt_20) <span class="operator">/</span> exam_cnt_20 <span class="operator">*</span> <span class="number">100</span>, <span class="number">1</span>), <span class="string">&#x27;%&#x27;</span>) growth_rate</span><br><span class="line">       ,rank1 exam_cnt_rank_20</span><br><span class="line">       ,rank2 exam_cnt_rank_21</span><br><span class="line">       ,<span class="built_in">cast</span>(rank2 <span class="keyword">as</span> signed) <span class="operator">-</span> <span class="built_in">cast</span>(rank1 <span class="keyword">as</span> signed) rank_delta</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> tag</span><br><span class="line">       ,exam_cnt_20</span><br><span class="line">       ,<span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> exam_cnt_20 <span class="keyword">desc</span>) rank1</span><br><span class="line">       ,exam_cnt_21</span><br><span class="line">       ,<span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> exam_cnt_21 <span class="keyword">desc</span>) rank2</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"># <span class="number">2021</span>年上半年 和 <span class="number">2020</span>年上半年</span><br><span class="line"><span class="keyword">select</span> B.tag</span><br><span class="line">       ,<span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> yt <span class="operator">=</span> <span class="number">2020</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">end</span>) exam_cnt_20</span><br><span class="line">       ,<span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> yt <span class="operator">=</span> <span class="number">2021</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">end</span>) exam_cnt_21</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> exam_id, <span class="keyword">year</span>(submit_time) yt <span class="keyword">from</span> exam_record </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">year</span>(submit_time) <span class="keyword">in</span> (<span class="number">2021</span>, <span class="number">2020</span>) <span class="keyword">and</span> <span class="keyword">MONTH</span>(submit_time) <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">6</span></span><br><span class="line">)A <span class="keyword">inner</span> <span class="keyword">join</span> examination_info B <span class="keyword">using</span>(exam_id)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> B.tag</span><br><span class="line">)A</span><br><span class="line">)A <span class="keyword">where</span> exam_cnt_20 <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">and</span> exam_cnt_21 <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> growth_rate <span class="keyword">desc</span>, exam_cnt_rank_21 <span class="keyword">desc</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><h2 id="ifnull和-limit…offset…-的使用"><a href="#ifnull和-limit…offset…-的使用" class="headerlink" title="ifnull和 limit…offset… 的使用"></a>ifnull和 limit…offset… 的使用</h2><p><a href="https://leetcode-cn.com/problems/second-highest-salary/">176. 第二高的薪水</a></p><h3 id="1-知识点-26"><a href="#1-知识点-26" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p><code>ifnull(val1, val2)</code> ：当 <code>val1</code> 为NULL，输出 <code>val2</code> 。</p><p><code>limit n1[, n2]</code>：<code>n1</code> 表示限制取多少行；如果使用 <code>n1, n2</code> 的形式则说明从 <code>n1</code> 行的写一行开始取 <code>n2</code> 行数据。</p><p><code>limit n1 offset n2</code> ：表示从 <code>n2</code> 行的下一行开始取 <code>n1</code> 行数据。</p><p>简单的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">limit <span class="number">2</span>; <span class="comment">-- 取前两行数据</span></span><br><span class="line">limit <span class="number">2</span>, <span class="number">3</span>; <span class="comment">-- 取3、4、5这三行的数据</span></span><br><span class="line">limit <span class="number">3</span> <span class="keyword">offset</span> <span class="number">4</span>; <span class="comment">-- 和 limit 2, 3 的结果一致</span></span><br></pre></td></tr></table></figure><h3 id="2-具体代码-23"><a href="#2-具体代码-23" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><p>​        题目中首先要求取第二大薪水的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> salary <span class="keyword">from</span> Employee <span class="keyword">group</span> <span class="keyword">by</span> salary <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span> limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>​        接着要求如果没有第二大薪水就取 null 值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ifnull(</span><br><span class="line">    (<span class="keyword">select</span> salary </span><br><span class="line">     <span class="keyword">from</span> Employee </span><br><span class="line">     <span class="keyword">group</span> <span class="keyword">by</span> salary </span><br><span class="line">     <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span> </span><br><span class="line">     limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">1</span></span><br><span class="line">    ), <span class="keyword">NULL</span></span><br><span class="line">) <span class="keyword">as</span> SecondHighestSalary;</span><br><span class="line"><span class="comment">-- 或者更简单一点，因为取不到值本身就是null，不需要再判断一次</span></span><br><span class="line"><span class="keyword">select</span> (</span><br><span class="line">     <span class="keyword">select</span> salary </span><br><span class="line">     <span class="keyword">from</span> Employee </span><br><span class="line">     <span class="keyword">group</span> <span class="keyword">by</span> salary </span><br><span class="line">     <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span> </span><br><span class="line">     limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">1</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">as</span> SecondHighestSalary;</span><br></pre></td></tr></table></figure><h2 id="group-by和partition-by的使用"><a href="#group-by和partition-by的使用" class="headerlink" title="group by和partition by的使用"></a>group by和partition by的使用</h2><p><a href="https://www.nowcoder.com/practice/5f1cbe74c682485aa73e4c2b30f04a62?tpId=240&tqId=2183422&ru=/exam/oj&qru=/ta/sql-advanced/question-ranking&sourceUrl=/exam/oj?tab=SQL%25E7%25AF%2587&topicId=240"><strong>SQL34</strong> <strong>每份试卷每月作答数和截止当月的作答总数。</strong></a></p><h3 id="1-知识点-27"><a href="#1-知识点-27" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p> <code>partition by</code> 在结果集上进行聚合，是逐条进行的，可以使用它来实现每月累加的操作。</p><p>group by进行聚合操作，会作用在分组下的所有记录。</p><h3 id="2-具体代码-24"><a href="#2-具体代码-24" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><p>​        首先实现前三个内容：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> exam_id</span><br><span class="line">       ,DATE_FORMAT(start_time, &quot;%Y%m&quot;) start_month</span><br><span class="line">       ,<span class="built_in">count</span>(<span class="operator">*</span>) month_cnt</span><br><span class="line"><span class="keyword">from</span> exam_record</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> exam_id, start_month</span><br></pre></td></tr></table></figure><p>​        接着需要对 <code>month_cnt</code> 进行累加求和计算：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> exam_id</span><br><span class="line">       ,start_month</span><br><span class="line">       ,month_cnt</span><br><span class="line">       ,<span class="built_in">sum</span>(month_cnt) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> exam_id <span class="keyword">order</span> <span class="keyword">by</span> start_month)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> exam_id</span><br><span class="line">       ,DATE_FORMAT(start_time, &quot;%Y%m&quot;) start_month</span><br><span class="line">       ,<span class="built_in">count</span>(<span class="operator">*</span>) month_cnt</span><br><span class="line"><span class="keyword">from</span> exam_record</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> exam_id, start_month</span><br><span class="line">)A</span><br></pre></td></tr></table></figure><h2 id="like和rlike"><a href="#like和rlike" class="headerlink" title="like和rlike"></a>like和rlike</h2><p>like的内容不是正则，而是通配符；rlike的内容是正则，写法与Java中的一致。</p><p><a href="https://www.runoob.com/regexp/regexp-syntax.html">正则表达式 - 语法</a></p><p><a href="https://www.cnblogs.com/2019-11-11/p/13827835.html">模糊查询like 通配符</a></p><h2 id="with-用法"><a href="#with-用法" class="headerlink" title="with 用法"></a>with 用法</h2><p><a href="https://www.nowcoder.com/practice/f72d3fc27dc14f3aae76ee9823ccca6b?tpId=240&tqId=2202378&ru=/exam/oj&qru=/ta/sql-advanced/question-ranking&sourceUrl=/exam/oj?tab=SQL%25E7%25AF%2587&topicId=240"><strong>SQL40</strong> <strong>根据指定记录是否存在输出不同情况</strong></a></p><h3 id="1-知识点-28"><a href="#1-知识点-28" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>​        把需要重复使用的sql语句放在 <code>with as</code> 里面，取一个别名，后面的查询就可以这个别名，这样对于大批量的sql语句起到一个优化的作用，而且清楚明了。类似于建临时表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> </span><br><span class="line">a <span class="keyword">as</span>(<span class="keyword">select</span> i, id <span class="keyword">from</span> cha),</span><br><span class="line">b <span class="keyword">as</span>(<span class="keyword">select</span> j, id <span class="keyword">from</span> cha)</span><br><span class="line"><span class="keyword">select</span> i, j <span class="keyword">from</span> a <span class="keyword">inner</span> <span class="keyword">join</span> b <span class="keyword">on</span> a.id <span class="operator">=</span> b.id;</span><br></pre></td></tr></table></figure><h3 id="2-具体代码-25"><a href="#2-具体代码-25" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tmp <span class="keyword">as</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> A.uid</span><br><span class="line">       ,A.level</span><br><span class="line">       ,<span class="built_in">coalesce</span>(incomplete_cnt, <span class="number">0</span>) incomplete_cnt</span><br><span class="line">       ,<span class="built_in">coalesce</span>(tot_cnt, <span class="number">0</span>) tot_cnt</span><br><span class="line">       ,<span class="built_in">coalesce</span>(round(incomplete_cnt <span class="operator">/</span> tot_cnt, <span class="number">3</span>), <span class="number">0</span>) incomplete_rate</span><br><span class="line"><span class="keyword">from</span> user_info A</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> </span><br><span class="line">(<span class="keyword">select</span> uid</span><br><span class="line">       ,<span class="built_in">count</span>(<span class="operator">*</span>) tot_cnt</span><br><span class="line">       ,<span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> submit_time <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) incomplete_cnt</span><br><span class="line"><span class="keyword">from</span> exam_record <span class="keyword">group</span> <span class="keyword">by</span> uid)B</span><br><span class="line"><span class="keyword">on</span> A.uid <span class="operator">=</span> B.uid</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> uid, incomplete_cnt, incomplete_rate</span><br><span class="line"><span class="keyword">from</span> tmp </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> uid, level <span class="keyword">from</span> tmp <span class="keyword">where</span> level <span class="operator">=</span> <span class="number">0</span> <span class="keyword">and</span> incomplete_cnt <span class="operator">&gt;</span> <span class="number">2</span></span><br><span class="line">) <span class="keyword">and</span> level <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> uid, incomplete_cnt, incomplete_rate</span><br><span class="line"><span class="keyword">from</span> tmp</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(</span><br><span class="line">    <span class="keyword">select</span> uid <span class="keyword">from</span> tmp <span class="keyword">where</span> level <span class="operator">=</span> <span class="number">0</span> <span class="keyword">and</span> incomplete_cnt <span class="operator">&gt;</span> <span class="number">2</span></span><br><span class="line">) <span class="keyword">and</span> tot_cnt <span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> incomplete_rate</span><br></pre></td></tr></table></figure><h2 id="面试-连续n天怎么计算"><a href="#面试-连续n天怎么计算" class="headerlink" title="面试 - 连续n天怎么计算"></a>面试 - 连续n天怎么计算</h2><blockquote><p>表名：steps_table</p><p>字段：date - 日期（如20210101）, id - 用户id, steps - 步数</p><p>题目：求连续5天以上（包括5天）步数都在top3的用户。</p></blockquote><p>分段求解：</p><ol><li><p>先求出每天步数top3的用户和日期：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="type">date</span>, id <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> <span class="type">date</span>, id, <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="type">date</span> <span class="keyword">order</span> <span class="keyword">by</span> steps <span class="keyword">desc</span>) r1 <span class="keyword">from</span> steps_table</span><br><span class="line">)A <span class="keyword">where</span> r1 <span class="operator">&lt;=</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>再对每个用户在其中所占的日期进行升序排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="type">date</span>, id, <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> id <span class="keyword">order</span> <span class="keyword">by</span> <span class="type">date</span>) r2 <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> <span class="type">date</span>, id <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> <span class="type">date</span>, id, <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="type">date</span> <span class="keyword">order</span> <span class="keyword">by</span> steps <span class="keyword">desc</span>) r1 <span class="keyword">from</span> steps_table</span><br><span class="line">)A <span class="keyword">where</span> r1 <span class="operator">&lt;=</span> <span class="number">3</span></span><br><span class="line">)A</span><br></pre></td></tr></table></figure></li><li><p>将日期减去排名，如果是连续的n天，减去连续的排名会是相同的日期，如20200102 - 1 day &#x3D; 20200101；20200103 - 2 day &#x3D; 20200101：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, date_sub(<span class="type">date</span>, <span class="type">interval</span> r2 <span class="keyword">day</span>) ds <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> <span class="type">date</span>, id, <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> id <span class="keyword">order</span> <span class="keyword">by</span> <span class="type">date</span>) r2 <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> <span class="type">date</span>, id <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> <span class="type">date</span>, id, <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="type">date</span> <span class="keyword">order</span> <span class="keyword">by</span> steps <span class="keyword">desc</span>) r1 <span class="keyword">from</span> steps_table</span><br><span class="line">)A <span class="keyword">where</span> r1 <span class="operator">&lt;=</span> <span class="number">3</span></span><br><span class="line">)A</span><br><span class="line">)A</span><br></pre></td></tr></table></figure></li><li><p>以id和相减得到的日期分组计算个数，超过5个即满足条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, <span class="built_in">count</span>(<span class="operator">*</span>) c <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> id, date_sub(<span class="type">date</span>, <span class="type">interval</span> r2 <span class="keyword">day</span>) ds <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> <span class="type">date</span>, id, <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> id <span class="keyword">order</span> <span class="keyword">by</span> <span class="type">date</span>) r2 <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> <span class="type">date</span>, id <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> <span class="type">date</span>, id, <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="type">date</span> <span class="keyword">order</span> <span class="keyword">by</span> steps <span class="keyword">desc</span>) r1 <span class="keyword">from</span> steps_table</span><br><span class="line">)A <span class="keyword">where</span> r1 <span class="operator">&lt;=</span> <span class="number">3</span></span><br><span class="line">)A</span><br><span class="line">)A</span><br><span class="line">)A <span class="keyword">group</span> <span class="keyword">by</span> id, ds <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></li><li><p>最终得到结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> id, <span class="built_in">count</span>(<span class="operator">*</span>) c <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> id, date_sub(<span class="type">date</span>, <span class="type">interval</span> r2 <span class="keyword">day</span>) ds <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> <span class="type">date</span>, id, <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> id <span class="keyword">order</span> <span class="keyword">by</span> <span class="type">date</span>) r2 <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> <span class="type">date</span>, id <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> <span class="type">date</span>, id, <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="type">date</span> <span class="keyword">order</span> <span class="keyword">by</span> steps <span class="keyword">desc</span>) r1 <span class="keyword">from</span> steps_table</span><br><span class="line">)A <span class="keyword">where</span> r1 <span class="operator">&lt;=</span> <span class="number">3</span></span><br><span class="line">)A</span><br><span class="line">)A</span><br><span class="line">)A <span class="keyword">group</span> <span class="keyword">by</span> id, ds <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="number">5</span></span><br><span class="line">)A</span><br></pre></td></tr></table></figure></li></ol><h2 id="rows-n-preceding-x2F-following"><a href="#rows-n-preceding-x2F-following" class="headerlink" title="rows n preceding &#x2F; following"></a>rows n preceding &#x2F; following</h2><p><a href="https://www.nowcoder.com/practice/f90ce4ee521f400db741486209914a11?tpId=268&tqId=2285070&ru=/exam/oj&qru=/ta/sql-factory-interview/question-ranking&sourceUrl=/exam/oj?tab=SQL%25E7%25AF%2587&topicId=268"><strong>SQL5</strong> <strong>国庆期间每类视频点赞量和转发量</strong></a></p><h3 id="1-知识点-29"><a href="#1-知识点-29" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>rows n preceding：向前取n行，包括本行，也可以写成 <code>rows between current row and 6 preceding</code> ；</p><p>rows n following：向后取n行，包括本行，也可以写成 <code>rows between current row and 6 following</code> 。</p><h3 id="2-具体代码-26"><a href="#2-具体代码-26" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> tag</span><br><span class="line">       ,dt</span><br><span class="line">       ,<span class="built_in">sum</span>(like_cnt) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> tag <span class="keyword">order</span> <span class="keyword">by</span> dt <span class="keyword">rows</span> <span class="number">6</span> preceding)</span><br><span class="line">       ,<span class="built_in">max</span>(retweet_cnt) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> tag <span class="keyword">order</span> <span class="keyword">by</span> dt <span class="keyword">rows</span> <span class="number">6</span> preceding)  </span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> B.tag tag</span><br><span class="line">       ,date_format(A.start_time, &quot;%Y-%m-%d&quot;) dt</span><br><span class="line">       ,<span class="built_in">sum</span>(if_like) like_cnt</span><br><span class="line">       ,<span class="built_in">sum</span>(if_retweet) retweet_cnt</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> uid, video_id, start_time, if_like, if_retweet </span><br><span class="line"><span class="keyword">from</span> tb_user_video_log </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">year</span>(start_time) <span class="operator">=</span> <span class="number">2021</span></span><br><span class="line">)A <span class="keyword">inner</span> <span class="keyword">join</span> tb_video_info B <span class="keyword">using</span> (video_id)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> B.tag, date_format(A.start_time, &quot;%Y-%m-%d&quot;)</span><br><span class="line">)A</span><br><span class="line">)A</span><br><span class="line"><span class="keyword">where</span> dt <span class="keyword">between</span> <span class="string">&#x27;2021-10-01&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2021-10-03&#x27;</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> tag <span class="keyword">desc</span>, dt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - NC15 求二叉树的层序遍历</title>
      <link href="/2021/07/08/LeetCode-NC15-%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
      <url>/2021/07/08/LeetCode-NC15-%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3?tpId=188&amp;&amp;tqId=38595&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3?tpId=188&amp;&amp;tqId=38595&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking</a></p><span id="more"></span><h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><p>使用迭代和递归的方式进行处理。</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>Java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder (TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tmp.add(root);</span><br><span class="line">        <span class="keyword">while</span>( tmp.size() &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; r = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> t_size = tmp.size();</span><br><span class="line">            <span class="keyword">while</span>( t_size -- &gt; <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode t = tmp.remove(<span class="number">0</span>);</span><br><span class="line">                r.add(t.val);</span><br><span class="line">                <span class="keyword">if</span>( t.left != <span class="keyword">null</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp.add(t.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( t.right != <span class="keyword">null</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp.add(t.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个常见的小坑：<code>if( root == null )</code>的处理 - </p><p>不能直接返回<code>null</code>，而是要返回一个空的结果：<code>new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;()</code></p><p>否则会报错。</p><p>python：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param root TreeNode类 </span></span><br><span class="line"><span class="comment"># @return int整型二维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self , root </span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        tmp = [root]</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(tmp) != <span class="number">0</span>:</span><br><span class="line">            r = []</span><br><span class="line">            size = <span class="built_in">len</span>(tmp)</span><br><span class="line">            <span class="keyword">while</span> size &gt; <span class="number">0</span>:</span><br><span class="line">                t = tmp.pop(<span class="number">0</span>)</span><br><span class="line">                r.append(t.val)</span><br><span class="line">                <span class="keyword">if</span> t.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    tmp.append(t.left)</span><br><span class="line">                <span class="keyword">if</span> t.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    tmp.append(t.right)</span><br><span class="line">                size -= <span class="number">1</span></span><br><span class="line">            res.append(r)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>Java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder (TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.add(root);</span><br><span class="line">        <span class="keyword">return</span> getList(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; getList(ArrayList&lt;TreeNode&gt; tmp)&#123;</span><br><span class="line">        <span class="keyword">if</span>( tmp.size() == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; r = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> size = tmp.size();</span><br><span class="line">        <span class="keyword">while</span>( size -- &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode t = tmp.remove(<span class="number">0</span>);</span><br><span class="line">            r.add(t.val);</span><br><span class="line">            <span class="keyword">if</span>( t.left != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.add(t.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( t.right != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.add(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(r);</span><br><span class="line">        <span class="keyword">return</span> getList(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param root TreeNode类 </span></span><br><span class="line"><span class="comment"># @return int整型二维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self , root</span>):</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getList</span>(<span class="params">tmp</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(tmp) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            r = []</span><br><span class="line">            size = <span class="built_in">len</span>(tmp)</span><br><span class="line">            <span class="keyword">while</span> size &gt; <span class="number">0</span>:</span><br><span class="line">                t = tmp.pop(<span class="number">0</span>)</span><br><span class="line">                r.append(t.val)</span><br><span class="line">                <span class="keyword">if</span> t.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    tmp.append(t.left)</span><br><span class="line">                <span class="keyword">if</span> t.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    tmp.append(t.right)</span><br><span class="line">                size -= <span class="number">1</span></span><br><span class="line">            res.append(r)</span><br><span class="line">            <span class="keyword">return</span> getList(tmp)</span><br><span class="line">        tmp = [root]</span><br><span class="line">        <span class="keyword">return</span> getList(tmp)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java, python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找算法&amp;插值查找算法</title>
      <link href="/2021/07/07/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
      <url>/2021/07/07/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="使用模型"><a href="#使用模型" class="headerlink" title="使用模型"></a>使用模型</h2><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> ( left &lt;= right )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( nums[mid] == target )</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( nums[mid] &lt; target )</span><br><span class="line">    &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二分查找算法简单又快速，对数组要求元素有序，且数组是顺序存储。</p><p>时间复杂度是O(logn)，空间复杂度是O(1)。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://www.nowcoder.com/practice/4f470d1d3b734f8aaf2afb014185b395?tpId=188&amp;&amp;tqId=38588&amp;rp=1&amp;ru=/ta/job-code-high-week&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/4f470d1d3b734f8aaf2afb014185b395?tpId=188&amp;&amp;tqId=38588&amp;rp=1&amp;ru=/ta/job-code-high-week&amp;qru=/ta/job-code-high-week/question-ranking</a></p><h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><p>Java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果目标值存在返回下标，否则返回 -1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span> <span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>( left &lt;= right )</span><br><span class="line">        &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>( nums[mid] &gt; target )</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( nums[mid] &lt; target )</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>( mid != <span class="number">0</span> &amp;&amp; nums[mid] == nums[mid-<span class="number">1</span>] )</span><br><span class="line">                &#123;</span><br><span class="line">                    -- mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 如果目标值存在返回下标，否则返回 -1</span></span><br><span class="line"><span class="comment"># @param nums int整型一维数组 </span></span><br><span class="line"><span class="comment"># @param target int整型 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self , nums , target </span>):</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        mid = (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right :</span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">while</span> mid &gt; <span class="number">0</span> <span class="keyword">and</span> nums[mid] == nums[mid - <span class="number">1</span>]:</span><br><span class="line">                    mid -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="二分查找的改进-插值查找"><a href="#二分查找的改进-插值查找" class="headerlink" title="二分查找的改进 - 插值查找"></a>二分查找的改进 - 插值查找</h2><p>插值查找和二分查找的区别在于<code>mid</code>值的选择。</p><p>二分查找：<code>mid = left + 1 / 2 * (right - left)</code>；</p><p>插值查找：<code>mid = left + (target - nums[left])/(nums[right] - nums[left]) * (right - left)</code></p><p>上述公式中，<code>mid</code>的根本区别是<code>(right - left)</code>的左边的数据：</p><p>二分查找是简单是获取居中的部分；插值查找是获取目标值与最小值之差在最值之差中的比重，可以更准确的定位范围，称这种方式为自适应。</p><p>还是以上述题目为例：</p><p>Java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果目标值存在返回下标，否则返回 -1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span> <span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( len == <span class="number">0</span> || nums[left] &gt; target || nums[right] &lt; target )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( nums[<span class="number">0</span>] == target )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>( left &lt;= right )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (target - nums[left]) / (nums[right] - nums[left]) * (right - left);</span><br><span class="line">            <span class="keyword">if</span>( nums[mid] &gt; target )</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( nums[mid] &lt; target )</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>( mid != <span class="number">0</span> &amp;&amp; nums[mid] == nums[mid-<span class="number">1</span>] )</span><br><span class="line">                &#123;</span><br><span class="line">                    -- mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 如果目标值存在返回下标，否则返回 -1</span></span><br><span class="line"><span class="comment"># @param nums int整型一维数组 </span></span><br><span class="line"><span class="comment"># @param target int整型 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self , nums , target </span>):</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> right &lt;= <span class="number">0</span> <span class="keyword">or</span> nums[<span class="number">0</span>] &gt; target <span class="keyword">or</span> nums[right] &lt; target:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[<span class="number">0</span>] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (target - nums[left]) // (nums[right] - nums[left]) * (right - left);</span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">while</span> mid &gt; <span class="number">0</span> <span class="keyword">and</span> nums[mid] == nums[mid - <span class="number">1</span>]:</span><br><span class="line">                    mid -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
            <tag> 插值查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - NC76 用两个栈实现队列</title>
      <link href="/2021/07/07/LeetCode-NC76-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>/2021/07/07/LeetCode-NC76-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=188&amp;&amp;tqId=38552&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-rankingj">https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=188&amp;&amp;tqId=38552&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-rankingj</a></p><span id="more"></span><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-两个栈分别在push和pop之前都会循环"><a href="#1-两个栈分别在push和pop之前都会循环" class="headerlink" title="1. 两个栈分别在push和pop之前都会循环"></a>1. 两个栈分别在push和pop之前都会循环</h3><p>Java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( !stack2.isEmpty() )</span><br><span class="line">        &#123;</span><br><span class="line">            stack1.push(stack2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( !stack1.isEmpty() )</span><br><span class="line">        &#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-对上面代码的一点点优化，将两个循环转变为一个循环"><a href="#2-对上面代码的一点点优化，将两个循环转变为一个循环" class="headerlink" title="2. 对上面代码的一点点优化，将两个循环转变为一个循环"></a>2. 对上面代码的一点点优化，将两个循环转变为一个循环</h3><p>Java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( stack2.isEmpty() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( !stack1.isEmpty() )</span><br><span class="line">            &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java, python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - NC4 判断链表中是否有环</title>
      <link href="/2021/07/06/LeetCode-NC4-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/"/>
      <url>/2021/07/06/LeetCode-NC4-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/650474f313294468a4ded3ce0f7898b9?tpId=188&amp;&amp;tqId=38576&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/650474f313294468a4ded3ce0f7898b9?tpId=188&amp;&amp;tqId=38576&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking</a></p><span id="more"></span><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="1-快慢指针（典型使用）"><a href="#1-快慢指针（典型使用）" class="headerlink" title="1. 快慢指针（典型使用）"></a>1. 快慢指针（典型使用）</h3><p>java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head, fast = head.next;</span><br><span class="line">        <span class="keyword">while</span>( slow != <span class="keyword">null</span> &amp;&amp; fast != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( slow == fast )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( slow.next == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param head ListNode类 </span></span><br><span class="line"><span class="comment"># @return bool布尔型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self , head </span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        slow, fast = head, head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> slow <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> fast <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> slow.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="2-集合判断是否存在"><a href="#2-集合判断是否存在" class="headerlink" title="2. 集合判断是否存在"></a>2. 集合判断是否存在</h3><p>Java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>( head != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( set.contains(head) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self , head </span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> tmp:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            tmp.append(head)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="3-逐个删除"><a href="#3-逐个删除" class="headerlink" title="3. 逐个删除"></a>3. 逐个删除</h3><p>删除，也就是将每个节点指向自己。</p><p>在循环的开始对<code>head</code>和<code>head.next</code>判断是否相等，如果相等，循环，如果不相等，删除后继续循环比较，直到没有节点。</p><p>Java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( head != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( head.next != <span class="keyword">null</span> &amp;&amp; head == head.next )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode t = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">            t.next = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self , head </span>):</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> head == head.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            tmp = head</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">            tmp.<span class="built_in">next</span> = tmp</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java, python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sparksql脚本的编写</title>
      <link href="/2021/07/05/sparksql%E8%84%9A%E6%9C%AC%E7%9A%84%E7%BC%96%E5%86%99/"/>
      <url>/2021/07/05/sparksql%E8%84%9A%E6%9C%AC%E7%9A%84%E7%BC%96%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h3 id="1-写含有sparksql语句的、带参的shell脚本"><a href="#1-写含有sparksql语句的、带参的shell脚本" class="headerlink" title="1. 写含有sparksql语句的、带参的shell脚本"></a>1. 写含有sparksql语句的、带参的shell脚本</h3><span id="more"></span><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># 此文件命名为show.sh</span></span><br><span class="line">SQL=<span class="string">&quot;</span></span><br><span class="line"><span class="string">show create table <span class="variable">$0</span>;</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line">spark-sql --num-executors 100 -e <span class="variable">$SQL</span></span><br></pre></td></tr></table></figure><h3 id="2-写循环数组、可以传参的shell脚本来运行上述脚本"><a href="#2-写循环数组、可以传参的shell脚本来运行上述脚本" class="headerlink" title="2. 写循环数组、可以传参的shell脚本来运行上述脚本"></a>2. 写循环数组、可以传参的shell脚本来运行上述脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> !/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此文件命名为run.sh</span></span><br><span class="line">tables=(&quot;a&quot; &quot;b&quot; &quot;c&quot;)</span><br><span class="line">for t in $&#123;tables[@]&#125;    # 循环</span><br><span class="line">do</span><br><span class="line">    sh show.sh $t    # 传参</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上述循环还有一种写法</span></span><br><span class="line">for((i=1;i&lt;=$&#123;#tables&#125;;i++));</span><br><span class="line">do</span><br><span class="line">    sh show.sh $&#123;tables[$i]&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="3-控制并任务的数量"><a href="#3-控制并任务的数量" class="headerlink" title="3. 控制并任务的数量"></a>3. 控制并任务的数量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while [ `ps -ef |grep show.sh |grep -v grep|wc -l` -gt 2 ]</span><br><span class="line">do...done</span><br></pre></td></tr></table></figure><p>其中，<code>ps -ef</code>查询进程的任务数；</p><p>​           <code>|</code>管道，前面命令的输出是后面命令的输入；</p><p>​           <code>grep bash_file_name</code> 指定进程；</p><p>​           <code>grep -v grep</code>去除grep本身；</p><p>​           <code>wc -l</code>计算数量。</p><p><strong>这个控制并行，当并行任务数大于等于2的时候，执行某一个操作以暂停其他线程的运行。如果让脚本的线程一个一个运行，即不使用&amp;操作，就可以不用（最好别用，容易崩）</strong></p><h3 id="4-如果报错，怎么查"><a href="#4-如果报错，怎么查" class="headerlink" title="4. 如果报错，怎么查"></a>4. 如果报错，怎么查</h3><ol><li>首先查看进程的ID：<code>ps -ef | grep show.sh </code>；</li><li>杀死该进程：将上述得到的<code>sh...</code>的进程ID，即</li></ol><p><strong>上述需要注意的点：</strong></p><ol><li>变量的使用需要<code>$</code>；</li><li>数组的每个元素之间没有逗号；</li><li><code>=</code>两边不能有空格；</li><li>最重要的点：一定要仔细检查循环，查看循环本身是不是死循环，还有循环体中调用的脚本要确定是否正确，如果误写了自己，也会导致死循环！！！死循环很可能会导致系统崩盘！！！&lt; 血的教训！！！ &gt;</li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - NC78 反转链表</title>
      <link href="/2021/07/04/LeetCode-NC78-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
      <url>/2021/07/04/LeetCode-NC78-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=188&amp;&amp;tqId=38547&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=188&amp;&amp;tqId=38547&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking</a></p><span id="more"></span><h2 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h2><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>( head != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode p = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">            p.next = res;</span><br><span class="line">            res = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead <span class="keyword">or</span> <span class="keyword">not</span> pHead.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        res = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> pHead:</span><br><span class="line">            p = pHead</span><br><span class="line">            pHead = pHead.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = res</span><br><span class="line">            res = p</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre = ReverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>python：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre = ReverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对上面代码的理解：</p><ol><li><p>ListNode pre &#x3D; ReverseList(head.next)</p><p>获取当前结点之前反转好的链表，注意，此时head.next是已经反转好的链表的最后一个节点；</p></li><li><p>head.next.next &#x3D; head</p><p>将当前节点接到已经反转好的链表的最后一个节点后面，也就是将当前head放到head.next后面；</p></li><li><p>head.next &#x3D; null</p><p>最后将当前节点的next置空，作为当前已经反转好的链表的最后一个节点。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java, python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sqoop50题</title>
      <link href="/2021/06/27/Sqoop50%E9%A2%98/"/>
      <url>/2021/06/27/Sqoop50%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>Sqoop导出操作</p><p>\1. 准备数据</p><span id="more"></span><p>CREATE TABLE student (</p><p>id int(11) DEFAULT NULL,</p><p>name varchar(100) DEFAULT NULL,</p><p>class varchar(100) DEFAULT NULL,</p><p>age int(11) DEFAULT NULL,</p><p>high varchar(10) DEFAULT NULL</p><p>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;latin1;</p><p>INSERT INTO student VALUES (‘1001’, ‘James’, ‘12’, ‘16’, ‘158’);</p><p>INSERT INTO student VALUES (‘1002’, ‘Mark’, ‘34’, ‘17’, ‘169’);</p><p>INSERT INTO student VALUES (‘1003’, ‘Henry’, ‘13’, ‘18’, ‘178’);</p><p>INSERT INTO student VALUES (‘1004’, ‘Kitte’, ‘24’, ‘17’, ‘175’);</p><p>INSERT INTO student VALUES (‘1005’, ‘Tom’, ‘23’, ‘20’, ‘180’);</p><p>使用sqoop把部分数据导入到HDFS的 &#x2F;MysqlToHDFS3 目录下,要求使用query sql语句查询，导入的字段为id,name,age,查询条件为age&gt;16,两个map，以id字段进行划分。语句是？</p><p>A.  bin&#x2F;sqoop import</p><p>–connect jdbc:mysql:&#x2F;&#x2F;192.168.10.10:3306&#x2F;userdb</p><p>–username root</p><p>–delete-target-dir</p><p>–target-dir &#x2F;MysqlToHDFS3</p><p>–query “select id,name,age from student WHERE age &gt; 16 and $CONDITIONS”</p><p>–split-by id</p><p>–fields-terminated-by ‘\t’</p><p>–num-mappers 2</p><p>B. bin&#x2F;sqoop import</p><p>–connect jdbc:mysql:&#x2F;&#x2F;192.168.10.10:3306&#x2F;userdb</p><p>–username root</p><p>–delete-target-dir</p><p>–target-dir &#x2F;MysqlToHDFS3</p><p>–query ‘select id,name,age from student WHERE age &gt; 16’</p><p>–split-by id</p><p>–fields-terminated-by ‘\t’</p><p>–num-mappers 2</p><p>C. bin&#x2F;sqoop import</p><p>–connect jdbc:mysql:&#x2F;&#x2F;192.168.10.10:3306&#x2F;userdb</p><p>–username root</p><p>–delete-target-dir</p><p>–target-dir &#x2F;MysqlToHDFS3</p><p>–query ‘select id,name,age from student WHERE age &gt; 16 and $CONDITIONS’</p><p>–split-by id</p><p>–fields-terminated-by ‘\t’</p><p>–m 2</p><p>D. bin&#x2F;sqoop import</p><p>–connect jdbc:mysql:&#x2F;&#x2F;192.168.10.10:3306&#x2F;userdb</p><p>–username root</p><p>–delete-target-dir</p><p>–target-dir &#x2F;MysqlToHDFS3</p><p>–query “select id,name,age from student WHERE age &gt; 16 and $CONDITIONS”</p><p>–split-by id</p><p>–fields-terminated-by ‘\t’</p><p>–m 2</p><p>参考答案C</p><p>2.阅读下面两个陈述：</p><p>A. 用Sqoop将关系型数据库中的数据导入Hive，当Hive中没有对应表时，则自动创建。</p><p>B. Sqoop命令create-hive-table可以生成与关系数据库表结构对应的hive表结构。</p><p>A.A 错B 错</p><p>B.A 错 B 对 </p><p>C.A 对 B 对 </p><p>D.A 对 B 错</p><p>参考答案C</p><p>3.______工具将文件从HDFS传输到RDBMS</p><p>A. export</p><p>B. transfer</p><p>C. import</p><p>D. output</p><p>参考答案A</p><p>\4. 关于Sqoop说法正确的是？</p><p>A.可以列出关系型数据库的某个说数据库下的所有表</p><p>B.可以列出关系型数据库的所有数据库</p><p>C.以上都是</p><p>D.可以执行SQL语句</p><p>参考答案C</p><p>\5. 下面哪个场景适合使用Sqoop？</p><p>A.将HDFS数据传输到Oracle数据库中</p><p>B.将服务器日志传输到Kafka消息中间件中</p><p>C.将Kafka主题的消息传输到HDFS</p><p>D.将一个MySQL服务器数据同步到另外一个MySQL服务器中</p><p>参考答案A</p><p>\6. ___ 就是只导入表中新添加的记录的导入方式。</p><p>A减量导入</p><p>B.全量导入</p><p>C.以上都不对</p><p>D.增量导入</p><p>参考答案D</p><p>7.Sqoop导出操作失败的原因可能是？</p><p>A. RAM不足</p><p>B. 磁盘空间不足</p><p>C. 以上都是</p><p>D.使用错误的定界符解析记录</p><p>参考答案C</p><p>\8. Sqoop将导入或导出命令翻译成MapReduce程序，而MapReduce 中主要是对_______和______进行定制</p><p>A.以上都不对</p><p>B. InputText, OutputText</p><p>C. InputFormat, OutputFormat</p><p>D. InputTextFormat, OutputTextFormat</p><p>参考答案C</p><p>9.在使用Sqoop导入数据到hive时，添加那个属性可以去掉数据中的\r\n\013\010这样的字符?</p><p>A. –input-lines-terminated-by</p><p>B. –hive-delims-replacement </p><p>C. –hive-drop-import-delims</p><p>D. –input-lines-terminated-by</p><p>参考答案C</p><p>\10. 导入MySQL数据库dbtest下emp表数据到HDFS语句正确的是？</p><p>A. sqoop-import –connect jdbc:mysql:&#x2F;&#x2F;node01:3306&#x2F;dbtest –password 123456 –username root –schema emp -m 1</p><p>B. sqoop-import –connect jdbc:mysql:&#x2F;&#x2F;node01:3306&#x2F;dbtest –password 123456 –username root –table emp -m 1</p><p>C. sqoop export –connect jdbc:mysql:&#x2F;&#x2F;node01:3306&#x2F;dbtest –password 123456 –username root –table emp -m 1</p><p>D. sqoop export –connect jdbc:mysql:&#x2F;&#x2F;node01:3306&#x2F;dbtest –password 123456 –username root –schema emp -m 1</p><p>参考答案B</p><p>\11. 默认情况下，Sqoop将在导出过程中并行使用____个任务。</p><p>A.4</p><p>B.2</p><p>C.3</p><p>D.1</p><p>参考答案A</p><p>12.A. Sqoop可以保存作业反复执行</p><p>B. sqoop在创建job时，使用–password-file参数，可以避免输入mysql密码, 而是从本地文件系统的指定文件获取密码</p><p>A.A 错 B 错</p><p>B.A 错 B 对 </p><p>C.A 对 B 对 </p><p>D.A 对 B 错</p><p>参考答案D</p><p>13.对于Sqoop导出控制参数，说明正确的是？</p><p>A. –input-null-string 字符串列将被解释为null的字符串表示</p><p>B. –input-null-non-string 非字符串列将被解释为null的字符串</p><p>C. –table 可以不指定</p><p>D. –export-dir 可以不指定</p><p>参考答案C</p><p>\14. Sqoop导出操作失败的原因可能是？</p><p>A.以上都是</p><p>B. Hadoop集群与数据库之间的连接丢失</p><p>C.尝试从HDFS源数据中解析不完整或格式不正确的记录</p><p>D.尝试在关系型数据库中插入违反一致性约束的记录</p><p>参考答案A</p><p>\15. 关于sqoop的导出操作说法错误的是？</p><p>A.默认导出操作是转换为UPDATE语句实现的</p><p>B.可以使用命令 sqoop-export实现导出</p><p>C.导出的目标表必须已经存在于数据库中</p><p>D.可以使用命令 sqoop export实现导出</p><p>参考答案A</p><p>Sqoop介绍和导入操作</p><p>1.Sqoop Import 命令中如果没有制定 -m 或者 –num-mappers 参数，则默认的mapper任务数量为？</p><p>A.4</p><p>B.2</p><p>C.3</p><p>D.1</p><p>参考答案A</p><p>\2. 哪个选项不会是下面这个命令执行失败的原因？</p><p>sqoop import \</p><p>–connect jdbc:mysql:&#x2F;&#x2F;192.168.186.100:3306&#x2F;test \</p><p>–username root \</p><p>–password niit1234 \</p><p>–table message \</p><p>–delete-target-dir \</p><p>–target-dir &#x2F;sqoop&#x2F;result \</p><p>-m 1</p><p>A.导入的目标路径里面已经有文件存在</p><p>B.没有配置环境变量</p><p>C. Hadoop文件系统服务资源不足</p><p>D. MySQL用户root没有配置远程访问</p><p>参考答案A</p><p>3.在sqoop导入命令中，中的有关–split-by参数的用途说法正确的是 ？</p><p>A:如果指定了主键，默认按照主键进行分片</p><p>B:如果没有指定主键，则必须指定–split-by才能实现分片</p><p>A.A对B对</p><p>B.A对B错</p><p>C.B对A错</p><p>D.A错B错</p><p>参考答案A</p><p>\4. 关于Apache Sqoop 的版本说法正确的是 ？</p><p>A.只有 Sqoop 2 可以用于生产环境</p><p>B. Sqoop 1 和 Sqoop 2 都可以用于生产环境</p><p>C. Sqoop 1 和 Sqoop 2 都不可以用于生产环境</p><p>D.只有 Sqoop 1 可以用于生产环境</p><p>参考答案D</p><p>\5. sqoop导入到Hive的数据。默认的行分隔符为？</p><p>A.”\t”</p><p>B.”\001”</p><p>C.”\012”</p><p>D.”,”</p><p>参考答案C</p><p>\6. 使用Sqoop导入到Hive时，如果没有指定Hive表名会怎么样？</p><p>A.默认会在Hive中创建和MySQL同名的数据库和表</p><p>B.以上都不对</p><p>C.默认会在Hive中创建和MySQL同名的表，数据库需要另外指定</p><p>D.报错，必须指定表名</p><p>参考答案C</p><p>7.使用Sqoop工具将MySQL数据传送到HDFS文件系统应该使用什么命令 ？</p><p>A. sqoop export</p><p>B. sqoop transfer</p><p>C. sqoop transport</p><p>D. sqoop import</p><p>参考答案D</p><p>\8. Apache Sqoop 是一款____的工具，主要用于数据的____？</p><p>A.开源、采集</p><p>B.开源、传输</p><p>C.闭源、采集</p><p>D.闭源、传输</p><p>参考答案B</p><p>9.如何使用Sqoop导入关系型数据库中某个表的满足某个条件下的记录中的部分列数据到HDFS中 ？</p><p>A.以上都不对</p><p>B.指定–where</p><p>C.指定–query</p><p>D.指定–columns</p><p>参考答案C</p><p>10.Sqoop导入命令中，如何修改字段分隔符为制表符？</p><p>A. –fields-terminated-by &#x3D; ‘&#x2F;t’</p><p>B. –fields-terminated-by &#x3D; ‘\t’</p><p>C. –fields-terminated-by ‘\t’</p><p>D. –fields-terminated-by ‘&#x2F;t’</p><p>参考答案C</p><p>\11. 使用Sqoop还可以 ____ ?</p><p>A.连接关系型数据库并执行SQL语句</p><p>B.列出关系型数据库的某个数据库下的所有表</p><p>C.以上都是</p><p>D.列出关系型数据库的所有数据库</p><p>参考答案C</p><p>\12. 关于增量导入：</p><p>说法A：只能由一个列作为检查列 –check-column</p><p>说法B：必须指定 –last-value</p><p>A.A对B对</p><p>B.A错B错</p><p>C.A错B对</p><p>D.A对B错</p><p>参考答案C</p><p>\13. sqoop导入到Hive的数据。默认的列分隔符为？</p><p>A.”\t”</p><p>B.”\001”</p><p>C.”\012”</p><p>D.”,”</p><p>参考答案B</p><p>14.在Linux系统中配置Sqoop环境变量的方式正确的是 ？</p><p>A. export $SQOOP_HOME&#x3D;&#x2F;home&#x2F;soft&#x2F;sqoop-1.4.6.bin_hadoop-2.0.4-alpha</p><p>export PATH&#x3D;$PATH:$SQOOP_HOME&#x2F;bin</p><p>B. export SQOOP_HOME&#x3D;&#x2F;home&#x2F;soft&#x2F;sqoop-1.4.6.bin_hadoop-2.0.4-alpha</p><p>export PATH&#x3D;$PATH:$SQOOP_HOME&#x2F;bin</p><p>C. export SQOOP_HOME&#x3D;&#x2F;home&#x2F;soft&#x2F;sqoop-1.4.6.bin_hadoop-2.0.4-alpha</p><p>export $PATH&#x3D;$PATH:$SQOOP_HOME&#x2F;bin</p><p>D. export SQOOP_HOME&#x3D;&#x2F;home&#x2F;soft&#x2F;sqoop-1.4.6.bin_hadoop-2.0.4-alpha</p><p>export PATH&#x3D;PATH:$SQOOP_HOME&#x2F;bin</p><p>参考答案B</p><p>15.下面哪个选项是属于Sqoop import ？</p><p>A.将Oracle数据库中的数据保存到Hive表中</p><p>B.将MongoDB数据库中的数据传输到HDFS文件系统</p><p>C.将HBase数据库中的数据转存到Hive表中</p><p>D.将Storm中拓扑处理的数据持久化到HBase数据库中</p><p>参考答案A</p><p>16.Sqoop导入数据的方式有？</p><p>A.以上都对</p><p>B.部分导入</p><p>C.全量导入</p><p>D.增量导入</p><p>参考答案A</p><p>\17. 如何使用sqoop import 导入部分记录？</p><p>A. –columns</p><p>B. –where</p><p>C以上都是</p><p>D. –query</p><p>参考答案C</p><p>18.sqoop导入到HDFS中的所有记录存储为____格式。</p><p>A.以上都不对</p><p>B.文本格式</p><p>C.二进制</p><p>D.十六进制</p><p>参考答案B</p><p>\1. 根据时间上晚于某列来进行数据增量导入，应使用____类型的增量模式配合_____属性</p><p>A.append –last-value</p><p>B.append –last-time</p><p>C.lastmodified –last-value</p><p>D.lastmodified –last-time</p><p>参考答案C</p><p>2.根据自增数值型主键进行增量导入，应使用____类型的增量模式配合_____属性</p><p>A.append –last-value</p><p>B.append –last-time</p><p>C.lastmodified –last-value</p><p>D.lastmodified –last-time</p><p>参考答案A</p><p>3.增量导入的check-colume参数是指？</p><p>A.设置作为增量导入检查依据的列，只能指定1列</p><p>B.设置作为增量导入检查依据的列，可以指定多列</p><p>C.指定增量导入的实际列，只能指定1列</p><p>D.指定增量导入的实际列，可以指定多列</p><p>参考答案B</p><p>4.Sqoop从MySQL到HDFS传输数据属于___________, 使用Sqoop从HDFS到MySQL传输数据属于________</p><p>A.导入，导出    </p><p>B.导出，导入</p><p>回答正确，得分 2</p><p>参考答案A</p><p>\5. A. Sqoop可以保存作业反复执行</p><p>B. sqoop在创建job时，使用–password-file参数，可以避免输入mysql密码, 而是从本地文件系统的指定文件获取密码</p><p>A.A 对 B 错</p><p>B.A 错 B 对 </p><p>C.A 错 B 错</p><p>D.A 对 B 对 </p><p>参考答案A</p><p>\6. 准备数据</p><p>CREATE TABLE student (</p><p>id int(11) DEFAULT NULL,</p><p>name varchar(100) DEFAULT NULL,</p><p>class varchar(100) DEFAULT NULL,</p><p>age int(11) DEFAULT NULL,</p><p>high varchar(10) DEFAULT NULL</p><p>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;latin1;</p><p>INSERT INTO student VALUES (‘1001’, ‘James’, ‘12’, ‘16’, ‘158’);</p><p>INSERT INTO student VALUES (‘1002’, ‘Mark’, ‘34’, ‘17’, ‘169’);</p><p>INSERT INTO student VALUES (‘1003’, ‘Henry’, ‘13’, ‘18’, ‘178’);</p><p>INSERT INTO student VALUES (‘1004’, ‘Kitte’, ‘24’, ‘17’, ‘175’);</p><p>INSERT INTO student VALUES (‘1005’, ‘Tom’, ‘23’, ‘20’, ‘180’);</p><p>使用sqoop把部分数据导入到HDFS的 &#x2F;MysqlToHDFS3 目录下,要求使用query sql语句查询，导入的字段为id,name,age,查询条件为age&gt;16,两个map，以id字段进行划分。语句是？</p><p>A.bin&#x2F;sqoop import</p><p>–connect jdbc:mysql:&#x2F;&#x2F;192.168.10.10:3306&#x2F;userdb</p><p>–username root</p><p>–delete-target-dir</p><p>–target-dir &#x2F;MysqlToHDFS3</p><p>–query ‘select id,name,age from student WHERE age &gt; 16 and $CONDITIONS’</p><p>–split-by id</p><p>–fields-terminated-by ‘\t’</p><p>–m 2</p><p>B.bin&#x2F;sqoop import</p><p>–connect jdbc:mysql:&#x2F;&#x2F;192.168.10.10:3306&#x2F;userdb</p><p>–username root</p><p>–delete-target-dir</p><p>–target-dir &#x2F;MysqlToHDFS3</p><p>–query “select id,name,age from student WHERE age &gt; 16 and $CONDITIONS”</p><p>–split-by id</p><p>–fields-terminated-by ‘\t’</p><p>–m 2</p><p>C.bin&#x2F;sqoop import</p><p>–connect jdbc:mysql:&#x2F;&#x2F;192.168.10.10:3306&#x2F;userdb</p><p>–username root</p><p>–delete-target-dir</p><p>–target-dir &#x2F;MysqlToHDFS3</p><p>–query “select id,name,age from student WHERE age &gt; 16 and $CONDITIONS”</p><p>–split-by id</p><p>–fields-terminated-by ‘\t’</p><p>–num-mappers 2</p><p>D.bin&#x2F;sqoop import</p><p>–connect jdbc:mysql:&#x2F;&#x2F;192.168.10.10:3306&#x2F;userdb</p><p>–username root</p><p>–delete-target-dir</p><p>–target-dir &#x2F;MysqlToHDFS3</p><p>–query ‘select id,name,age from student WHERE age &gt; 16’</p><p>–split-by id</p><p>–fields-terminated-by ‘\t’</p><p>–num-mappers 2</p><p>参考答案A</p><p>\7. 关于Sqoop说法正确的是？</p><p>A.可以列出关系型数据库的所有数据库</p><p>B.可以列出关系型数据库的某个说数据库下的所有表</p><p>C.可以执行SQL语句</p><p>D.以上都是</p><p>参考答案D</p><p>\8. 阅读下面两个陈述：</p><p>A. 用Sqoop将关系型数据库中的数据导入Hive，当Hive中没有对应表时，则自动创建。</p><p>B. Sqoop命令create-hive-table可以生成与关系数据库表结构对应的hive表结构。</p><p>A.A 对 B 错</p><p>B.A 错 B 对 </p><p>C.A 对 B 对 </p><p>D.A 错B 错</p><p>参考答案C</p><p>\9. 在使用Sqoop导入数据到hive时，添加那个属性可以去掉数据中的\r\n\013\010这样的字符?</p><p>A.–hive-delims-replacement </p><p>B.–hive-drop-import-delims</p><p>C.–input-lines-terminated-by</p><p>D.–input-lines-terminated-by</p><p>参考答案B</p><p>10.导入MySQL数据库dbtest下emp表数据到HDFS语句正确的是？</p><p>A.sqoop export –connect jdbc:mysql:&#x2F;&#x2F;node01:3306&#x2F;dbtest –password 123456 –username root –table emp -m 1</p><p>B.sqoop-import –connect jdbc:mysql:&#x2F;&#x2F;node01:3306&#x2F;dbtest –password 123456 –username root –table emp -m 1</p><p>C.sqoop-import –connect jdbc:mysql:&#x2F;&#x2F;node01:3306&#x2F;dbtest –password 123456 –username root –schema emp -m 1</p><p>D.sqoop export –connect jdbc:mysql:&#x2F;&#x2F;node01:3306&#x2F;dbtest –password 123456 –username root –schema emp -m 1</p><p>参考答案B</p><p>\11. 下面哪个场景适合使用Sqoop？</p><p>A.将服务器日志传输到Kafka消息中间件中</p><p>B.将一个MySQL服务器数据同步到另外一个MySQL服务器中</p><p>C.将HDFS数据传输到Oracle数据库中</p><p>D.将Kafka主题的消息传输到HDFS</p><p>参考答案C</p><p>\12. Sqoop将导入或导出命令翻译成MapReduce程序，而MapReduce 中主要是对_______和______进行定制</p><p>A.InputText, OutputText</p><p>B.InputTextFormat, OutputTextFormat</p><p>C.InputFormat, OutputFormat</p><p>D.以上都不对</p><p>参考答案C</p><p>13.___ 就是只导入表中新添加的记录的导入方式。</p><p>A.全量导入</p><p>B.增量导入</p><p>C.减量导入</p><p>D.以上都不对</p><p>参考答案B</p><p>\14. Sqoop导出操作失败的原因可能是？</p><p>A.Hadoop集群与数据库之间的连接丢失</p><p>B.尝试在关系型数据库中插入违反一致性约束的记录</p><p>C.尝试从HDFS源数据中解析不完整或格式不正确的记录</p><p>D.以上都是</p><p>参考答案D</p><p>\15. 默认情况下，Sqoop将在导出过程中并行使用____个任务。</p><p>A.1</p><p>B.2</p><p>C.3</p><p>D.4</p><p>参考答案D</p><p>\16. 对于Sqoop导出控制参数，说明正确的是？</p><p>A.–input-null-string 非字符串列将被解释为null的字符串</p><p>B.–input-null-non-string 字符串列将被解释为null的字符串表示</p><p>C.–export-dir 可以不指定</p><p>D.–table 可以不指定</p><p>参考答案D</p><p>\17. 关于sqoop的导出操作说法错误的是？</p><p>A.导出的目标表必须已经存在于数据库中</p><p>B.可以使用命令 sqoop export实现导出</p><p>C.可以使用命令 sqoop-export实现导出</p><p>D.默认导出操作是转换为UPDATE语句实现的</p><p>参考答案D</p><p>\18. ______工具将文件从HDFS传输到RDBMS</p><p>A.import</p><p>B.export</p><p>C.output</p><p>D.transfer</p><p>参考答案B</p><p>\19. 关于增量导入：</p><p>说法A：</p><p>只能由一个列作为检查列 –check-column</p><p>说法B：</p><p>必须指定 –last-value</p><p>A.A对B错</p><p>B.A错B对</p><p>C.A对B对</p><p>D.A错B错</p><p>参考答案B</p><p>\20. 如何使用sqoop import 导入部分记录？</p><p>A.–query</p><p>B.–where</p><p>C.–columns</p><p>D.以上都是</p><p>参考答案D</p><p>\21. 哪个选项不会是下面这个命令执行失败的原因？</p><p>sqoop import \</p><p>–connect jdbc:mysql:&#x2F;&#x2F;192.168.186.100:3306&#x2F;test \</p><p>–username root \</p><p>–password niit1234 \</p><p>–table message \</p><p>–delete-target-dir \</p><p>–target-dir &#x2F;sqoop&#x2F;result \</p><p>-m 1</p><p>A.没有配置环境变量</p><p>B.MySQL用户root没有配置远程访问</p><p>C.导入的目标路径里面已经有文件存在</p><p>D.Hadoop文件系统服务资源不足</p><p>参考答案C</p><p>22.如何使用Sqoop导入关系型数据库中某个表的满足某个条件下的记录中的部分列数据到HDFS中 ？</p><p>A.指定–where</p><p>B.指定–query</p><p>C.指定–columns</p><p>D.以上都不对</p><p>参考答案B</p><p>\23. 在sqoop导入命令中，中的有关–split-by参数的用途说法正确的是 ？</p><p>A:如果指定了主键，默认按照主键进行分片</p><p>B:如果没有指定主键，则必须指定–split-by才能实现分片</p><p>A.A对B错</p><p>B.B对A错</p><p>C.A对B对</p><p>D.A错B错</p><p>参考答案C</p><p>\24. 使用Sqoop导入到Hive时，如果没有指定Hive表名会怎么样？</p><p>A.报错，必须指定表名</p><p>B.默认会在Hive中创建和MySQL同名的数据库和表</p><p>C.默认会在Hive中创建和MySQL同名的表，数据库需要另外指定</p><p>D.以上都不对</p><p>参考答案C</p><p>\25. sqoop导入到Hive的数据。默认的行分隔符为？</p><p>A.”,”</p><p>B.”\t”</p><p>C.”\001”</p><p>D.”\012”</p><p>参考答案D</p><p>\26. sqoop导入到Hive的数据。默认的列分隔符为？</p><p>A.”,”</p><p>B.”\t”</p><p>C.”\012”</p><p>D.”\001”</p><p>参考答案D</p><p>\27. Sqoop导入命令中，如何修改字段分隔符为制表符？</p><p>A.–fields-terminated-by &#x3D; ‘\t’</p><p>B.–fields-terminated-by ‘\t’</p><p>C.–fields-terminated-by &#x3D; ‘&#x2F;t’</p><p>D.–fields-terminated-by ‘&#x2F;t’</p><p>参考答案B</p><p>\28. Sqoop导入数据的方式有？</p><p>A.全量导入</p><p>B.增量导入</p><p>C.部分导入</p><p>D.以上都对</p><p>参考答案D</p><p>\29. sqoop导入到HDFS中的所有记录存储为____格式。</p><p>A.二进制</p><p>B.十六进制</p><p>C.文本格式</p><p>D.以上都不对</p><p>参考答案C</p><p>\30. Sqoop Import 命令中如果没有制定 -m 或者 –num-mappers 参数，则默认的mapper任务数量为？</p><p>A.1</p><p>B.2</p><p>C.3</p><p>D.4</p><p>参考答案D</p><p>31.使用Sqoop还可以 ____ ?</p><p>A.列出关系型数据库的所有数据库</p><p>B.列出关系型数据库的某个数据库下的所有表</p><p>C.连接关系型数据库并执行SQL语句</p><p>D.以上都是</p><p>参考答案D</p><p>\32. 在Linux系统中配置Sqoop环境变量的方式正确的是 ？</p><p>A.export SQOOP_HOME&#x3D;&#x2F;home&#x2F;soft&#x2F;sqoop-1.4.6.bin_hadoop-2.0.4-alpha</p><p>export $PATH&#x3D;$PATH:$SQOOP_HOME&#x2F;bin</p><p>B.export $SQOOP_HOME&#x3D;&#x2F;home&#x2F;soft&#x2F;sqoop-1.4.6.bin_hadoop-2.0.4-alpha</p><p>export PATH&#x3D;$PATH:$SQOOP_HOME&#x2F;bin</p><p>C.export SQOOP_HOME&#x3D;&#x2F;home&#x2F;soft&#x2F;sqoop-1.4.6.bin_hadoop-2.0.4-alpha</p><p>export PATH&#x3D;PATH:$SQOOP_HOME&#x2F;bin</p><p>D.export SQOOP_HOME&#x3D;&#x2F;home&#x2F;soft&#x2F;sqoop-1.4.6.bin_hadoop-2.0.4-alpha</p><p>export PATH&#x3D;$PATH:$SQOOP_HOME&#x2F;bin</p><p>回答错误，得分 0</p><p>参考答案D</p><p>\33. 关于Apache Sqoop 的版本说法正确的是 ？</p><p>A.只有 Sqoop 1 可以用于生产环境</p><p>B.只有 Sqoop 2 可以用于生产环境</p><p>C.Sqoop 1 和 Sqoop 2 都可以用于生产环境</p><p>D.Sqoop 1 和 Sqoop 2 都不可以用于生产环境</p><p>参考答案A</p><p>\34. 使用Sqoop工具将MySQL数据传送到HDFS文件系统应该使用什么命令 ？</p><p>A.sqoop import</p><p>B.sqoop export</p><p>C.sqoop transfer</p><p>D.sqoop transport</p><p>参考答案A</p><p>\35. 下面哪个选项是属于Sqoop import ？</p><p>A.将HBase数据库中的数据转存到Hive表中</p><p>B.将Storm中拓扑处理的数据持久化到HBase数据库中</p><p>C.将MongoDB数据库中的数据传输到HDFS文件系统</p><p>D.将Oracle数据库中的数据保存到Hive表中</p><p>参考答案D</p><p>\36. Apache Sqoop 是一款____的工具，主要用于数据的____？</p><p>A.闭源、采集</p><p>B.开源、采集</p><p>C.闭源、传输</p><p>D.开源、传输</p><p>参考答案D</p><p>\37. 选出不属于RDBMS的数据库</p><p>A.MySQL</p><p>B.MongoDB</p><p>C.Redis</p><p>D.HBase</p><p>参考答案BCD</p><p>\38. sqoop import 包括从____到____</p><p>A.HBase -&gt; HDFS</p><p>B.Hive -&gt; HDFS</p><p>C.MySQL -&gt; HIVE</p><p>D.Oracle -&gt; HDFS</p><p>参考答案CD</p><p>\39. Sqoop工具中最核心的是____和_____</p><p>A.import</p><p>B.export</p><p>C.job</p><p>D.help</p><p>参考答案AB</p><p>\40. 增量导入必须指定last-value属性值</p><p>对</p><p>错</p><p>参考答案对</p><p>41.MySQL表用SQOOP传输到HDFS后默认字段分割符号是逗号</p><p>对</p><p>错</p><p>参考答案对</p><p>\42. 导入HDFS操作时，可以同时指定target-dir和warehouse-dir属性。</p><p>对</p><p>错</p><p>参考答案错</p><p>\43. 使用sqoop job工具，命令如下，可以立即执行一个导入操作。</p><p>sqoop job –create sqoopimport1 – import –connect jdbc:mysql:</p><p>对</p><p>错</p><p>参考答案错</p><p>\44. Sqoop工具适用于数据库管理员、数据分析师和数据工程师。</p><p>对</p><p>错</p><p>参考答案对</p><p>\45. Sqoop可以用于关系型数据库之间的数据传输。</p><p>对</p><p>错</p><p>参考答案错</p><p>\46. Sqoop导入命令中使用_______________属性可以修改字段分隔符</p><p>参考答案–fields-terminated-by</p><p>\47. HIVE表的默认字段分隔符是”<em>“，Hive表的默认记录分隔符是”</em>“</p><p>47.1</p><p>参考答案\001;CTRL+A;SOH;^A</p><p>47.2</p><p>参考答案\012;\N;\n</p><p>\48. Sqoop import 工具指定数据传输到HDFS的目标路径用_________属性。</p><p>参考答案–target-dir</p><p>49.SQOOP传输数据到HDFS时，如果需要预先清空目标路径再执行数据传输可以使用__________属性</p><p>参考答案–delete-target-dir</p><p>\50. Apache Sqoop 是一款____的工具，主要用于数据的____</p><p>50.1</p><p>参考答案开源;开放源代码</p><p>50.2</p><p>参考答案传输;导入导出</p>]]></content>
      
      
      
        <tags>
            
            <tag> sqoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flume &amp; Sqoop资源</title>
      <link href="/2021/06/26/Flume-Sqoop%E8%B5%84%E6%BA%90/"/>
      <url>/2021/06/26/Flume-Sqoop%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<p><a href="http://lannaie.top/resources/Flume.pdf">Flume.pdf</a></p><p><a href="http://lannaie.top/resources/Flume%201.9%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C.pdf">Flume 1.9用户手册.pdf</a></p><p><a href="http://lannaie.top/resources/Flume%E9%A2%98%E5%BA%93.pdf">Flume题库.pdf</a></p><p><a href="http://lannaie.top/resources/Sqoop%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97%EF%BC%88v1.4.7%EF%BC%89.pdf">Sqoop用户指南（v1.4.7）.pdf</a></p><p><a href="http://lannaie.top/resources/SQOOP%20%E7%AE%80%E4%BB%8B-%E5%AD%A6%E7%94%9F%E6%8C%87%E5%8D%97.pdf">SQOOP%简介-学生指南.pdf</a></p><p><a href="http://lannaie.top/2021/06/27/Sqoop50%E9%A2%98/">sqoop50题</a></p><p><a href="http://lannaie.top/resources/Flume%E7%AE%80%E4%BB%8B-%E5%AD%A6%E7%94%9F%E6%8C%87%E5%8D%97.pdf">Flume 简介-学生指南.pdf</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spark - SparkSQL</title>
      <link href="/2021/06/24/Spark-SparkSQL/"/>
      <url>/2021/06/24/Spark-SparkSQL/</url>
      
        <content type="html"><![CDATA[<h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><p>SparkSQL是Spark用于结构化数据处理的Spark模块。</p><span id="more"></span><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="1-易整合"><a href="#1-易整合" class="headerlink" title="1. 易整合"></a>1. 易整合</h4><p>无缝地整合了SQL查询和Spark编程。</p><h4 id="2-统一的数据访问"><a href="#2-统一的数据访问" class="headerlink" title="2. 统一的数据访问"></a>2. 统一的数据访问</h4><p>使用相同的方式连接不同的数据源。比如数据库，HBase、Hive、MySQL等都可以使用相同的方式进行连接，即具有了通用性，只需要修改一些参数就可以从不同的数据源中获取数据，非常方便。</p><h4 id="3-兼容hive"><a href="#3-兼容hive" class="headerlink" title="3. 兼容hive"></a>3. 兼容hive</h4><p>在已有的仓库上直接运行SQL或HiveQL。</p><h4 id="4-标准数据连接"><a href="#4-标准数据连接" class="headerlink" title="4. 标准数据连接"></a>4. 标准数据连接</h4><p>通过JDBC或ODBC来连接。</p><h3 id="DataFrame是什么？与RDD的区别"><a href="#DataFrame是什么？与RDD的区别" class="headerlink" title="DataFrame是什么？与RDD的区别"></a>DataFrame是什么？与RDD的区别</h3><p>​        在Spark中，DataFrame是一种以RDD为基础的分布式数据集，类似于传统数据库中的二维表格。</p><p>​        DataFrame与RDD的主要区别在于，前者带有schema元数据信息，即DataFrame锁表示的</p><h2 id="核心编程"><a href="#核心编程" class="headerlink" title="核心编程"></a>核心编程</h2><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>文件可以读取的格式如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csv   format   jdbc   json   load   option   options   orc   parquet   schema   table   text   textFile</span><br></pre></td></tr></table></figure><ol><li>读取类型的例子：</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; spark.read.json(<span class="string">&quot;input/user.json&quot;</span>)</span><br><span class="line">res1: org.apache.spark.sql.<span class="type">DataFrame</span> = [age: string, username: string]</span><br></pre></td></tr></table></figure><ol start="2"><li>读取实际内容的例子：</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> df = spark.read.json(<span class="string">&quot;input/user.json&quot;</span>)</span><br><span class="line">df: org.apache.spark.sql.<span class="type">DataFrame</span> = [age: string, username: string]</span><br><span class="line"></span><br><span class="line">scala&gt; df.show()</span><br><span class="line">+---+--------+</span><br><span class="line">|age|username|</span><br><span class="line">+---+--------+</span><br><span class="line">| <span class="number">30</span>|zhangsan|</span><br><span class="line">| <span class="number">20</span>|    lisi|</span><br><span class="line">| <span class="number">40</span>|  wangwu|</span><br><span class="line">+---+--------+</span><br></pre></td></tr></table></figure><ol start="3"><li>按照条件读取指定内容的例子：</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; df.createTempView(<span class="string">&quot;user&quot;</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; spark.sql(<span class="string">&quot;select username from user&quot;</span>).show</span><br><span class="line">+--------+</span><br><span class="line">|username|</span><br><span class="line">+--------+</span><br><span class="line">|zhangsan|</span><br><span class="line">|    lisi|</span><br><span class="line">|  wangwu|</span><br><span class="line">+--------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">scala&gt; spark.sql(<span class="string">&quot;select avg(age) from user&quot;</span>).show</span><br><span class="line">+------------------------+</span><br><span class="line">|avg(<span class="type">CAST</span>(age <span class="type">AS</span> <span class="type">DOUBLE</span>))|</span><br><span class="line">+------------------------+</span><br><span class="line">|                    <span class="number">30.0</span>|</span><br><span class="line">+------------------------+</span><br></pre></td></tr></table></figure><p>此处<code>createTempView</code>是创建一次临时表，如果多次创建，可能会报错，使用<code>createOrReplaceTempView</code>可以避免这种错误。</p><p><strong>其中，需要知道<code>view</code>即视图，是将查询结果集转换成为一个特定的视图结构，只可以查，不可以改；与表table不同，表可以改。</strong></p><p>注意：普通临时表是Session范围内的，如果在创建一个Session，该Session中的使用不会在新创建的Session中留下痕迹。如果想应用范围内有效，可以使用全局临时表。使用全局临时表需要全路径访问，如<code>global_temp.user</code></p><ol start="4"><li>全局临时表</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; df.createOrReplaceGlobalTempView(<span class="string">&quot;emp&quot;</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; spark.newSession.sql(<span class="string">&quot;select * from global_temp.emp&quot;</span>)</span><br><span class="line">res10: org.apache.spark.sql.<span class="type">DataFrame</span> = [age: string, username: string]</span><br><span class="line"></span><br><span class="line">scala&gt; spark.newSession.sql(<span class="string">&quot;select * from global_temp.emp&quot;</span>).show</span><br><span class="line">+---+--------+</span><br><span class="line">|age|username|</span><br><span class="line">+---+--------+</span><br><span class="line">| <span class="number">30</span>|zhangsan|</span><br><span class="line">| <span class="number">20</span>|    lisi|</span><br><span class="line">| <span class="number">40</span>|  wangwu|</span><br><span class="line">+---+--------+</span><br></pre></td></tr></table></figure><p><code>newSession</code>是重新启动一个Session测试是否多个节点都可以进行测试。</p><h3 id="DSL的简单使用"><a href="#DSL的简单使用" class="headerlink" title="DSL的简单使用"></a>DSL的简单使用</h3><p>是DataFrame提供的，用来管理结构化的数据。使用这个语言不需要去创建视图等，因为它本身九江DataFrame当成数据源。可以在Scala、Java、Python、R中使用DSL。</p><h4 id="1-基本例子："><a href="#1-基本例子：" class="headerlink" title="1. 基本例子："></a>1. 基本例子：</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; df.printSchema</span><br><span class="line">root</span><br><span class="line"> |-- age: string (nullable = <span class="literal">true</span>)</span><br><span class="line"> |-- username: string (nullable = <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">scala&gt; df.select(<span class="string">&quot;age&quot;</span>).show</span><br><span class="line">+---+</span><br><span class="line">|age|</span><br><span class="line">+---+</span><br><span class="line">| <span class="number">30</span>|</span><br><span class="line">| <span class="number">20</span>|</span><br><span class="line">| <span class="number">40</span>|</span><br><span class="line">+---+</span><br></pre></td></tr></table></figure><h4 id="2-查看”username”数据和”age-1”数据"><a href="#2-查看”username”数据和”age-1”数据" class="headerlink" title="2. 查看”username”数据和”age+1”数据"></a>2. 查看”username”数据和”age+1”数据</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; df.select($<span class="string">&quot;age&quot;</span> + <span class="number">1</span>).show</span><br><span class="line">+---------+</span><br><span class="line">|(age + <span class="number">1</span>)|</span><br><span class="line">+---------+</span><br><span class="line">|     <span class="number">31.0</span>|</span><br><span class="line">|     <span class="number">21.0</span>|</span><br><span class="line">|     <span class="number">41.0</span>|</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure><p>使用<code>$</code>符号表示引用这个变量，如果不使用，就表示简单的字符串相加；</p><p>spark提供另一种更简便的方式：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; df.select(<span class="symbol">&#x27;age</span> + <span class="number">1</span>).show</span><br><span class="line">+---------+</span><br><span class="line">|(age + <span class="number">1</span>)|</span><br><span class="line">+---------+</span><br><span class="line">|     <span class="number">31.0</span>|</span><br><span class="line">|     <span class="number">21.0</span>|</span><br><span class="line">|     <span class="number">41.0</span>|</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure><p>其中，<code>$</code>和<code>&#39;</code>只能修饰一个列，有多个列，就有多个符号。</p><h4 id="3-查看age大于30的数据"><a href="#3-查看age大于30的数据" class="headerlink" title="3. 查看age大于30的数据"></a>3. 查看<code>age</code>大于30的数据</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; df.select(<span class="symbol">&#x27;age</span> &gt; <span class="number">30</span>).show</span><br><span class="line">+----------+</span><br><span class="line">|(age &gt; <span class="number">30</span>)|</span><br><span class="line">+----------+</span><br><span class="line">|     <span class="literal">false</span>|</span><br><span class="line">|     <span class="literal">false</span>|</span><br><span class="line">|      <span class="literal">true</span>|</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure><h4 id="4-查看age大于30的数据-过滤"><a href="#4-查看age大于30的数据-过滤" class="headerlink" title="4. 查看age大于30的数据 - 过滤"></a>4. 查看<code>age</code>大于<code>30</code>的数据 - 过滤</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; df.filter($<span class="string">&quot;age&quot;</span> &gt; <span class="number">30</span>).show</span><br><span class="line">+---+--------+</span><br><span class="line">|age|username|</span><br><span class="line">+---+--------+</span><br><span class="line">| <span class="number">40</span>|  wangwu|</span><br><span class="line">+---+--------+</span><br></pre></td></tr></table></figure><h4 id="5-按照age分组，查看数组条数-分组"><a href="#5-按照age分组，查看数组条数-分组" class="headerlink" title="5. 按照age分组，查看数组条数 - 分组"></a>5. 按照<code>age</code>分组，查看数组条数 - 分组</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; df.groupBy(<span class="string">&quot;age&quot;</span>).count.show</span><br><span class="line">+---+-----+</span><br><span class="line">|age|count|</span><br><span class="line">+---+-----+</span><br><span class="line">| <span class="number">30</span>|    <span class="number">1</span>|</span><br><span class="line">| <span class="number">40</span>|    <span class="number">1</span>|</span><br><span class="line">| <span class="number">20</span>|    <span class="number">1</span>|</span><br><span class="line">+---+-----+</span><br></pre></td></tr></table></figure><h3 id="RDD和DataFrame的转换"><a href="#RDD和DataFrame的转换" class="headerlink" title="RDD和DataFrame的转换"></a>RDD和DataFrame的转换</h3><p>RDD转DataFrame：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">15</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> df = rdd.toDF(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">df: org.apache.spark.sql.<span class="type">DataFrame</span> = [id: int]</span><br><span class="line"></span><br><span class="line">scala&gt; df.show</span><br><span class="line">+---+</span><br><span class="line">| id|</span><br><span class="line">+---+</span><br><span class="line">|  <span class="number">1</span>|</span><br><span class="line">|  <span class="number">2</span>|</span><br><span class="line">|  <span class="number">3</span>|</span><br><span class="line">|  <span class="number">4</span>|</span><br><span class="line">+---+</span><br></pre></td></tr></table></figure><p>DataFrame转RDD：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; df.rdd</span><br><span class="line">res4: org.apache.spark.rdd.<span class="type">RDD</span>[org.apache.spark.sql.<span class="type">Row</span>] = <span class="type">MapPartitionsRDD</span>[<span class="number">23</span>] at rdd at &lt;console&gt;:<span class="number">26</span></span><br></pre></td></tr></table></figure><h3 id="DataSet"><a href="#DataSet" class="headerlink" title="DataSet"></a>DataSet</h3><p>dataSet是具有强类型的数据集合，需要提供对应的类型信息。</p><p>DataSet相比于DataFrame、RDD，后二者没有数据类型的概念，而前者有，即前者是包含了DataFrame的结构和RDD的数据。</p><h4 id="1-样例类创建DataSet"><a href="#1-样例类创建DataSet" class="headerlink" title="1. 样例类创建DataSet"></a>1. 样例类创建DataSet</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name:<span class="type">String</span>, age: <span class="type">Long</span></span>)</span></span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> list = <span class="type">List</span>(<span class="type">Person</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">30</span>), <span class="type">Person</span>(<span class="string">&quot;lisi&quot;</span>, <span class="number">40</span>))</span><br><span class="line">list: <span class="type">List</span>[<span class="type">Person</span>] = <span class="type">List</span>(<span class="type">Person</span>(zhangsan,<span class="number">30</span>), <span class="type">Person</span>(lisi,<span class="number">40</span>))</span><br><span class="line"></span><br><span class="line">scala&gt; list.toDS</span><br><span class="line">res5: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">Person</span>] = [name: string, age: bigint]</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> ds = list.toDS</span><br><span class="line">ds: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">Person</span>] = [name: string, age: bigint]</span><br><span class="line"></span><br><span class="line">scala&gt; ds.show</span><br><span class="line">+--------+---+</span><br><span class="line">|    name|age|</span><br><span class="line">+--------+---+</span><br><span class="line">|zhangsan| <span class="number">30</span>|</span><br><span class="line">|    lisi| <span class="number">40</span>|</span><br><span class="line">+--------+---+</span><br></pre></td></tr></table></figure><h4 id="2-和DataFrame的转换"><a href="#2-和DataFrame的转换" class="headerlink" title="2. 和DataFrame的转换"></a>2. 和DataFrame的转换</h4><p>DataFrame转换为DataSet：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ds = df.as[<span class="type">Person</span>]</span><br></pre></td></tr></table></figure><p>DataSet转换为DataFrame：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> df = ds.toDF</span><br></pre></td></tr></table></figure><h3 id="RDD和DataSet的转换"><a href="#RDD和DataSet的转换" class="headerlink" title="RDD和DataSet的转换"></a>RDD和DataSet的转换</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="type">Person</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">30</span>), <span class="type">Person</span>(<span class="string">&quot;lisi&quot;</span>, <span class="number">40</span>)))</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Person</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">29</span>] at makeRDD at &lt;console&gt;:<span class="number">26</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd.toDS</span><br><span class="line">res11: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">Person</span>] = [name: string, age: bigint]</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> ds = rdd.toDS</span><br><span class="line">ds: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">Person</span>] = [name: string, age: bigint]</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> rdd = ds.rdd</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Person</span>] = <span class="type">MapPartitionsRDD</span>[<span class="number">32</span>] at rdd at &lt;console&gt;:<span class="number">25</span></span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="RDD、DataFrame、DataSet的联系"><a href="#RDD、DataFrame、DataSet的联系" class="headerlink" title="RDD、DataFrame、DataSet的联系"></a>RDD、DataFrame、DataSet的联系</h3>]]></content>
      
      
      <categories>
          
          <category> 大数据组件的应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark - 运行环境的安装配置</title>
      <link href="/2021/06/17/Spark-%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/06/17/Spark-%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="一-解压缩文件"><a href="#一-解压缩文件" class="headerlink" title="一. 解压缩文件"></a>一. 解压缩文件</h2><p>在官网下载 <a href="https://www.apache.org/dyn/closer.lua/spark/spark-3.1.2/spark-3.1.2-bin-hadoop3.2.tgz">spark-3.1.2-bin-hadoop3.2.tgz</a> 文件并上传到Linux，然后解压缩到指定位置，重命名为 <code>spark-local</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf spark-3.1.2-bin-hadoop3.2.tgz -C /opt/pkg</span><br><span class="line">mv spark-3.1.2-bin-hadoop3.2 spark-local</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="local环境"><a href="#local环境" class="headerlink" title="local环境"></a>local环境</h3><ol><li><p>进入目录</p><p><code>cd /opt/pkg/spark-local</code></p></li><li><p>启动</p><p><code>bin/spark-shell</code></p><p>正常情况下会进入spark shell客户端，以<code>scala</code>为输入的标记：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">26</span>:<span class="number">15</span> <span class="type">WARN</span> <span class="type">NativeCodeLoader</span>: <span class="type">Unable</span> to load native-hadoop library <span class="keyword">for</span> your platform... using builtin-java classes where applicable</span><br><span class="line"><span class="type">Using</span> <span class="type">Spark</span><span class="symbol">&#x27;s</span> <span class="keyword">default</span> log4j profile: org/apache/spark/log4j-defaults.properties</span><br><span class="line"><span class="type">Setting</span> <span class="keyword">default</span> log level to <span class="string">&quot;WARN&quot;</span>.</span><br><span class="line"><span class="type">To</span> adjust logging level use sc.setLogLevel(newLevel). <span class="type">For</span> <span class="type">SparkR</span>, use setLogLevel(newLevel).</span><br><span class="line"><span class="type">Spark</span> context <span class="type">Web</span> <span class="type">UI</span> available at http:<span class="comment">//hadoop002:4040</span></span><br><span class="line"><span class="type">Spark</span> context available as <span class="symbol">&#x27;s</span>c&#x27; (master = local[*], app id = local<span class="number">-1624029984600</span>).</span><br><span class="line"><span class="type">Spark</span> session available as <span class="symbol">&#x27;spar</span>k&#x27;.</span><br><span class="line"><span class="type">Welcome</span> to</span><br><span class="line">      ____              __</span><br><span class="line">     / __/__  ___ _____/ /__</span><br><span class="line">    _\ \/ _ \/ _ `/ __/  <span class="symbol">&#x27;_</span>/</span><br><span class="line">   /___/ .__/\_,_/_/ /_/\_\   version <span class="number">3.0</span><span class="number">.1</span></span><br><span class="line">      /_/</span><br><span class="line"></span><br><span class="line"><span class="type">Using</span> <span class="type">Scala</span> version <span class="number">2.12</span><span class="number">.10</span> (<span class="type">Java</span> <span class="type">HotSpot</span>(<span class="type">TM</span>) <span class="number">64</span>-<span class="type">Bit</span> <span class="type">Server</span> <span class="type">VM</span>, <span class="type">Java</span> <span class="number">1.8</span><span class="number">.0</span>_281)</span><br><span class="line"><span class="type">Type</span> in expressions to have them evaluated.</span><br><span class="line"><span class="type">Type</span> :help <span class="keyword">for</span> more information.</span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure></li><li><p>可以写一些基本的<code>scala</code>语法，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; var i = 10</span><br><span class="line">i: Int = 10</span><br></pre></td></tr></table></figure></li><li><p>也可以写<code>spark</code>语法，下面给出<code>wordcount</code>的例子</p><p>（1）准备数据</p><p>在目录 <code>/opt/pkg/spark-shell/data</code> 下创建文件 <code>test.txt</code></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello scala</span><br><span class="line">hello spark</span><br></pre></td></tr></table></figure><p>（2）执行命令</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; sc.textFile(<span class="string">&quot;/opt/pkg/spark/data/test.txt&quot;</span>).flatMap(_.split(<span class="string">&quot; &quot;</span>)).map((_,<span class="number">1</span>)).reduceByKey(_+_).collect</span><br><span class="line"></span><br><span class="line">res13: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">Array</span>((scala,<span class="number">1</span>), (spark,<span class="number">1</span>), (hello,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>成功！</p><p>（3）下面简单比较一下 <code>shell</code> 下和 <code>scala代码</code> 中的变化</p><p>其实大致没有变化，只是 <code>sparkContext</code> 不需要进行配置，在进入客户端时就有提示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Spark</span> context available as <span class="symbol">&#x27;s</span>c&#x27; (master = local[*], app id = local<span class="number">-1624029984600</span>).</span><br></pre></td></tr></table></figure><p>所以可以直接使用 <code>sc</code> 来进行操作。</p></li><li><p>查看资源监控页面</p><p>直接复制粘贴进入客户端的提示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Spark</span> context <span class="type">Web</span> <span class="type">UI</span> available at http:<span class="comment">//hadoop002:4040</span></span><br></pre></td></tr></table></figure><p>复制粘贴其中的 <code>http://hadoop002:4040</code> 到网页，就可以打开监控页面了。</p><p>结合本地IDEA的应用：</p><p>运行 <code>spark</code> 中自带的一个jar包例子：</p><p>在 <code>spark-local</code> 的目录下执行：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[hadoop<span class="meta">@hadoop</span>002 spark-local]$ spark-submit \</span><br><span class="line">&gt; --<span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">spark</span>.<span class="title">examples</span>.<span class="title">SparkPi</span> <span class="title">\</span></span></span><br><span class="line">&gt; --master local[<span class="number">2</span>] \</span><br><span class="line">&gt; ./examples/jars/spark-examples_2<span class="number">.12</span><span class="number">-3.0</span><span class="number">.1</span>.jar \</span><br><span class="line">&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure><p>得到结果：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">Pi</span> is roughly <span class="number">3.1422671422671424</span></span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">SparkUI</span>: <span class="type">Stopped</span> <span class="type">Spark</span> web <span class="type">UI</span> at http:<span class="comment">//hadoop002:4040</span></span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">MapOutputTrackerMasterEndpoint</span>: <span class="type">MapOutputTrackerMasterEndpoint</span> stopped!</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">MemoryStore</span>: <span class="type">MemoryStore</span> cleared</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">BlockManager</span>: <span class="type">BlockManager</span> stopped</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">BlockManagerMaster</span>: <span class="type">BlockManagerMaster</span> stopped</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">OutputCommitCoordinator</span>$<span class="type">OutputCommitCoordinatorEndpoint</span>: <span class="type">OutputCommitCoordinator</span> stopped!</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">SparkContext</span>: <span class="type">Successfully</span> stopped <span class="type">SparkContext</span></span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">ShutdownHookManager</span>: <span class="type">Shutdown</span> hook called</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">ShutdownHookManager</span>: <span class="type">Deleting</span> directory /tmp/spark...</span><br></pre></td></tr></table></figure><p>其中，</p><p><code>--master local[2]</code> 设置部署模式，默认本地模式，数字2表示分配的虚拟CPU核数量；</p><p><code>10</code> 表示程序的入口参数，用于设定当前应用的任务数量。</p></li></ol><h3 id="standalone环境"><a href="#standalone环境" class="headerlink" title="standalone环境"></a>standalone环境</h3><ol><li><p>在 <code>local环境</code> 的基础上进行配置</p><p>（1）将 <code>spark-local</code> 重命名为 <code>spark-standalone</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv spark-local spark-standalone</span><br></pre></td></tr></table></figure><p>（2）进入 <code>spark-standalone/conf</code> 目录：</p><p>修改 <code>slaves</code> 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd spark-standalone/conf</span><br><span class="line">mv slaves.template slaves</span><br><span class="line">vim slaves</span><br></pre></td></tr></table></figure><p>然后修改 <code>localhost</code> 为自己的节点名，如果是分布式部署，就写所有节点名称，如：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hadoop001</span><br><span class="line">hadoop002</span><br><span class="line">hadoop003</span><br></pre></td></tr></table></figure><p>如果是伪分布式部署，即只有一个节点，就写一个节点名称：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop001</span><br></pre></td></tr></table></figure><p>修改 <code>spark-env.sh</code> 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd spark-standalone/conf</span><br><span class="line">mv spark-env.sh.template spark-env.sh</span><br><span class="line">vim spark-env.sh</span><br></pre></td></tr></table></figure><p>然后将下述内容贴到文件中：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SPARK_MASTER_HOST=hadoop001       #添加spark master的主机名</span><br><span class="line">SPARK_MASTER_PORT=<span class="number">7077</span>        #添加spark master的端口号</span><br><span class="line">export JAVA_HOME=/<span class="keyword">opt</span>/pkg/java</span><br></pre></td></tr></table></figure><p>其中主要要修改 <code>&#123;JAVA_HOME</code> 的路径。</p><p>如果是分布式部署，需要分发 <code>spark-standalone</code> 目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xsync spark-standalone</span><br></pre></td></tr></table></figure></li><li><p>启动集群</p><p>进入 <code>spark-standalone</code> 目录下执行启动命令，它有一个和 <code>Hadoop</code> 启动一样的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-all.sh</span><br></pre></td></tr></table></figure><p>启动成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop002 spark]$ sbin/start-all.sh</span><br><span class="line">starting org.apache.spark.deploy.master.Master, logging to /opt/pkg/spark/logs/spark-hadoop-org.apache.spark.deploy.master.Master-1-hadoop002.out</span><br><span class="line">hadoop002: starting org.apache.spark.deploy.worker.Worker, logging to /opt/pkg/spark/logs/spark-hadoop-org.apache.spark.deploy.worker.Worker-1-hadoop002.out</span><br></pre></td></tr></table></figure><p>查看资源监控的 <code>Web UI</code> 界面：<a href="http://hadoop002:8080/">http://hadoop002:8080</a></p></li><li><p>结合本地IDEA应用</p><p>运行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@hadoop002 spark]$ spark-submit \</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> --class org.apache.spark.examples.SparkPi \</span></span><br><span class="line"><span class="bash">&gt; --master spark://hadoop002:7077 \</span></span><br><span class="line"><span class="bash">&gt; ./examples/jars/spark-examples_2.12-3.0.1.jar \</span></span><br><span class="line"><span class="bash">&gt; 10</span></span><br></pre></td></tr></table></figure><p>得到结果：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">Pi</span> is roughly <span class="number">3.142367142367142</span></span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">SparkUI</span>: <span class="type">Stopped</span> <span class="type">Spark</span> web <span class="type">UI</span> at http:<span class="comment">//hadoop002:4040</span></span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">StandaloneSchedulerBackend</span>: <span class="type">Shutting</span> down all executors</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">CoarseGrainedSchedulerBackend</span>$<span class="type">DriverEndpoint</span>: <span class="type">Asking</span> each executor to shut down</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">MapOutputTrackerMasterEndpoint</span>: <span class="type">MapOutputTrackerMasterEndpoint</span> stopped!</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">MemoryStore</span>: <span class="type">MemoryStore</span> cleared</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">BlockManager</span>: <span class="type">BlockManager</span> stopped</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">BlockManagerMaster</span>: <span class="type">BlockManagerMaster</span> stopped</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">OutputCommitCoordinator</span>$<span class="type">OutputCommitCoordinatorEndpoint</span>: <span class="type">OutputCommitCoordinator</span> stopped!</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">SparkContext</span>: <span class="type">Successfully</span> stopped <span class="type">SparkContext</span></span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">ShutdownHookManager</span>: <span class="type">Shutdown</span> hook called</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">ShutdownHookManager</span>: <span class="type">Deleting</span> directory /tmp/spa...</span><br></pre></td></tr></table></figure><p>成功！</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据组件的应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划算法</title>
      <link href="/2021/06/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/"/>
      <url>/2021/06/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义：是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。</p><p>​        按照定义，动态规划是将一个大问题拆分为多个小问题来解决。但是最终决定这个问题是否能用动态规划解决的因素是这些小问题是否能被重复调用。</p><p>​        如果能被重复利用，我们需要找出其中的状态转移方程，也就是找到相邻的两个结果之间的转换方程。</p><span id="more"></span><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="题目见下链接"><a href="#题目见下链接" class="headerlink" title="题目见下链接"></a>题目见下链接</h3><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a></p><h3 id="动态规划思想"><a href="#动态规划思想" class="headerlink" title="动态规划思想"></a>动态规划思想</h3><p>因为要求是连续数组的最大值，所以每一次计算的中间结果，也必须是以当前最后一个元素为当亲计算的结尾。</p><p>上述，可以得到状态转移方程：</p><p><code>maxn = max(maxn+num[i], num[i])</code></p><p>但是由于以当前最后一个元素结尾的最大值不一定是整体数组中的最大值，所以需要再使用一个变量来存储整体数组的最大值：</p><p><code>res = max(maxn, res)</code></p><p>经过分析，可以得到具体代码如下：</p><h4 id="java"><a href="#java" class="headerlink" title="java:"></a>java:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int pre = 0, res = nums[0];</span><br><span class="line">        for ( int n : nums )</span><br><span class="line">        &#123;</span><br><span class="line">            pre = Math.max(pre + n, n);</span><br><span class="line">            res = Math.max(pre, res);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="python"><a href="#python" class="headerlink" title="python:"></a>python:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxSubArray(self, nums: List[int]) -&gt; int:</span><br><span class="line">        pre, res = 0, nums[0]</span><br><span class="line">        for n in nums:</span><br><span class="line">            pre = max( pre + n, n )</span><br><span class="line">            res = max( pre, res )</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode - 1.两数之和</title>
      <link href="/2021/06/15/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2021/06/15/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/two-sum/">https://leetcode-cn.com/problems/two-sum/</a></p><span id="more"></span><h2 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h2><h3 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h3><p><strong>这种方法不一定符合要求的时空复杂度，但是在没有任何思路的时候，我觉得暴力解决是最有效的方式。</strong></p><h4 id="1-java"><a href="#1-java" class="headerlink" title="1. java:"></a>1. java:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len; ++ j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( nums[i] + nums[j] == target )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-python"><a href="#2-python" class="headerlink" title="2. python"></a>2. python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( <span class="number">0</span>, length ):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>( i+<span class="number">1</span>, length ):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                    <span class="keyword">return</span> [i, j]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><p>​        其中，为了防止重复遍历和指向同一个元素的情况发生，将 <code>j</code> 指向 <code>i</code> 的下一个，即 <code>j = i + 1</code> ；如果有两个元素满足条件，返回 <code>new int[]&#123;i, j&#125;</code> ，否则就返回不含任何元素的新数组 <code>new int[0]</code> 。</p><h3 id="哈希表求解"><a href="#哈希表求解" class="headerlink" title="哈希表求解"></a>哈希表求解</h3><p>三种方法中的最优解，是处理该类问题的更普遍方法。</p><h4 id="1-java-1"><a href="#1-java-1" class="headerlink" title="1. java"></a>1. java</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( map.containsKey( target - nums[i]) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(target-nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        在表中进行搜索，如果没有 <code>target - nums[i]</code> 的值在表中出现，就将 <code>nums[i]</code> 和对一个下标以键值对的形式存储到表中，然后进行判断，因为题目中假设只有一对元素符合条件，所以只要出现第一个，就可以直接返回，为防万一，在句末添加 <code>return new int[0]</code> 来确保没有结果时不会报错。</p><p>​        这种方法相当于是在暴力求解的基础上，省略了一个循环，将中间结果存入一个表来提高时间复杂度。</p><p>对哈希表了解一点简单的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义声明键值类型均为Integer的HashMap</span></span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"><span class="comment">// 2. 添加元素</span></span><br><span class="line">map.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 3. 删除元素</span></span><br><span class="line">map.remove(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">//删除指定key的键值对，其中value可省</span></span><br><span class="line">map.values().removeIf(value -&gt; !value.contains(<span class="number">1</span>))<span class="comment">//根据Map中的值删除</span></span><br><span class="line">map.keySet().removeIf(key -&gt; !key.contains(<span class="number">1</span>))<span class="comment">//根据Map中的键删除</span></span><br><span class="line">map.entrySet().removeIf(entry -&gt; entry.getKey() != <span class="number">1</span>)<span class="comment">//根据获得的键或值的元素来判断删除</span></span><br><span class="line"><span class="comment">// 4. 获取元素</span></span><br><span class="line">map.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="2-python-1"><a href="#2-python-1" class="headerlink" title="2. python"></a>2. python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( <span class="number">0</span>, length ):</span><br><span class="line">            <span class="keyword">if</span> target - nums[i] <span class="keyword">in</span> dic.keys():</span><br><span class="line">                <span class="keyword">return</span> [dic[target - nums[i]], i]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><p>对字典了解一点简单的操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 1. 定义声明</span><br><span class="line">dic = &#123;&#125;</span><br><span class="line">dic = &#123;1:2, 2:3, &quot;abc&quot;:1&#125;</span><br><span class="line">// 2. 添加元素</span><br><span class="line">dic[&quot;bei&quot;] = 6</span><br><span class="line">dic.update(&#123;9:2&#125;)</span><br><span class="line">// 3. 删除元素</span><br><span class="line">del dic[&quot;bei&quot;]//删除指定键的键值对</span><br><span class="line">dic.clear()//清空字典</span><br><span class="line">del dic//删除字典</span><br><span class="line">// 4. 获取元素</span><br><span class="line">print(dic[&quot;bei&quot;])</span><br><span class="line">// 5. 修改元素</span><br><span class="line">dic[&quot;bei&quot;] = 3</span><br></pre></td></tr></table></figure><h3 id="取下标数组标记"><a href="#取下标数组标记" class="headerlink" title="取下标数组标记"></a>取下标数组标记</h3><p>​        这是最开始的想法：将一维数组变为二维数组，其中，第一列是下标，第二列是元素；然后按照元素列进行升序排序，再定两个点 <code>i = 0, j = nums.length-1</code> ，如果有 <code>nums[i] + nums[j] == target</code> ,就返回元素对应的下标，即第二列元素值对应的第一列的下标值；否则直到 不满足条件 <code>i &lt; j</code> ，退出遍历，返回空数组。    </p><p>​        因为这种方法用Java没有任何优势，所以此处不展示此代码。</p><h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        i , j = <span class="number">0</span>, length - <span class="number">1</span></span><br><span class="line">        tmp = <span class="built_in">enumerate</span>(nums)</span><br><span class="line">        tmp = <span class="built_in">sorted</span>(tmp, key=<span class="keyword">lambda</span> k: k[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">while</span> i &lt; j :</span><br><span class="line">            <span class="keyword">if</span> tmp[i][<span class="number">1</span>] + tmp[j][<span class="number">1</span>] == target:</span><br><span class="line">                <span class="keyword">return</span> [tmp[i][<span class="number">0</span>], tmp[j][<span class="number">0</span>]]</span><br><span class="line">            <span class="keyword">elif</span> tmp[i][<span class="number">1</span>] + tmp[j][<span class="number">1</span>] &gt; target:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><p>简单了解 <code>enumerate()</code> 函数的使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;tmp = [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]</span><br><span class="line">&gt;&gt;&gt; for i, element in enumerate(tmp):</span><br><span class="line">...     print i, element</span><br><span class="line">... </span><br><span class="line">0 one</span><br><span class="line">1 two</span><br><span class="line">2 three</span><br><span class="line">&gt;&gt;&gt;tmp = enumerate(tmp)</span><br><span class="line">&gt;&gt;&gt; print(tmp[0][0])</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spark - 安装 &amp; 简单使用wordcount</title>
      <link href="/2021/06/06/spark-%E5%AE%89%E8%A3%85%20&amp;%20%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8wordcount/"/>
      <url>/2021/06/06/spark-%E5%AE%89%E8%A3%85%20&amp;%20%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8wordcount/</url>
      
        <content type="html"><![CDATA[<h3 id="IDEA创建spark项目"><a href="#IDEA创建spark项目" class="headerlink" title="IDEA创建spark项目"></a>IDEA创建spark项目</h3><span id="more"></span><ol><li><p>创建java环境为JDK1.8的maven项目，项目名为atguigu-classes；</p><p>此步骤省略。</p></li><li><p>添加scala插件</p><p>scala插件是使用spark操作必不可少的工具，默认采用的版本是2.12，而不是最新版本。</p><p>File -&gt; Project Structure -&gt; Global Libraries</p><p>然后点击<code>+</code>号，选择<code>download</code>，找到合适的版本：<code>2.12.11</code>，下载。此过程可能会有点久。</p></li><li><p>检查是否成功添加</p><p>右键项目 -&gt; add frameworks support</p><p>然后寻找是否有scala选项，如果有，则成功添加，此时需要点击打勾，以添加该选项。</p></li><li><p>新建第一个简单的项目，来测试是否成功配置spark环境</p><p>右键<code>new</code>选择<code>Scala Class</code>，然后选择<code>Object</code>，输入名称为<code>test</code>，其中，具体代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">object test &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    println(&quot;Hello Spark&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="WordCount案例"><a href="#WordCount案例" class="headerlink" title="WordCount案例"></a>WordCount案例</h3><ol><li><p>任务需求 - 将下述文件进行<code>wordcount</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello scala</span><br><span class="line">hello spark</span><br></pre></td></tr></table></figure></li><li><p>初始代码如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.core.wc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2021/6/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> 读取数据后，将数据切分并按照相同的单词为一组的思想对数据进行分组，groupBy以后就会得到[word, list[word, word, ...]]，最后输出的是[word, list.size]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark01_WordCount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//Application</span></span><br><span class="line">    <span class="comment">//Spark框架</span></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 建立和spark框架的连接</span></span><br><span class="line">      <span class="comment">//基本配置</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line">    <span class="comment">//创建连接</span></span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 执行业务逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 以行为单位，读取数据</span></span><br><span class="line">    <span class="keyword">val</span> line = sc.textFile(path = <span class="string">&quot;datas&quot;</span>)</span><br><span class="line">    <span class="comment">//2. 将一行数据拆分为一个个单词，即扁平化，flatMap就是扁平映射</span></span><br><span class="line">    <span class="keyword">val</span> words = line.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 以分割后的数据为准，分组累加计算</span></span><br><span class="line">    <span class="comment">//相同的单词进行分组，给我的每个元素是单词，而我按照单词分组</span></span><br><span class="line">    <span class="comment">//此时需要知道，wordGroup的类型是RDD[(String, Iterable[String])]，String是分组的条件，即word，Iterable[String]是结果，即word相同元素的集合</span></span><br><span class="line">    <span class="keyword">val</span> wordGroup = words.groupBy(word =&gt; word)</span><br><span class="line">    <span class="comment">//4. 将分组后的数据进行转换，即多个值 -&gt; 一个值和一个数字（值的数量）</span></span><br><span class="line">    <span class="keyword">val</span> word_count = wordGroup.map&#123;</span><br><span class="line">      <span class="keyword">case</span> (word, list) =&gt;</span><br><span class="line">        (word, list.size)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5. 将结果采集到控制台输出</span></span><br><span class="line">    <span class="keyword">val</span> res = word_count.collect()</span><br><span class="line">    res.foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 关闭连接</span></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用到的部分函数记录</p><blockquote><p>textFile：读取文件，其中, <code>path</code> 可以是一个文件的路径，也可以是多个文件的目录，即可以同时读取多个文件。</p><p>flatMap：对集合中的每个元素进行操作后再扁平化处理；</p><p>​        通常会将map和flatMap进行比较：</p><p>​        二者均会对集合中的每个元素进行操作，不同的是flatMap会将操作后的结果进行扁平化，即合并为一个一维的集合，而map不会；</p><p>groupBy：通过什么规则进行分组；</p><p>​        通常将groupBy和groupByKey进行比较</p><p>【此处我简单搬了该文章：<a href="https://blog.csdn.net/jiangzhali1623/article/details/83717088">文章链接</a>】：</p><p>​        groupByKey希望用户自己实现groupBy的规则，而groupBy被列属性束缚，相较而言，前者更灵活；但groupByKey返回的KeyValueGroupedDataset类提供的操作接口不如groupBy返回的RelationalGroupedDataset类所提供的接口丰富，所以在大多数情况下，更推荐使用groupBy。</p></blockquote></li><li><p>初始代码中进行的所谓聚合，实际上是对函数方法的调用，并不是真正的聚合，以下是对调用部分的更改：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.core.wc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2021/6/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> 核心代码中，将单词划分开后首先均赋1，然后再进行分组，最后累加1值来聚合最终结果。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark02_WordCount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//Application</span></span><br><span class="line">    <span class="comment">//Spark框架</span></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 建立和spark框架的连接</span></span><br><span class="line">      <span class="comment">//基本配置</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line">    <span class="comment">//创建连接</span></span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 执行业务逻辑</span></span><br><span class="line">    <span class="keyword">val</span> line = sc.textFile(path = <span class="string">&quot;datas&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> words = line.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> word2One = words.map(</span><br><span class="line">      word =&gt; (word, <span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里对word2One的(word,1)，以word，即t._1为条件进行分组</span></span><br><span class="line">    <span class="keyword">val</span> wordGroup = word2One.groupBy(</span><br><span class="line">      t =&gt; t._1</span><br><span class="line">    )</span><br><span class="line"><span class="comment">//    wordGroup.foreach(println)</span></span><br><span class="line">    <span class="keyword">val</span> word_count = wordGroup.map&#123;</span><br><span class="line">      <span class="keyword">case</span> (word, list) =&gt; &#123;<span class="comment">// 因为不使用word遍历，所以也可以写为 case (_, list)</span></span><br><span class="line">        list.reduce(</span><br><span class="line">          (t1, t2) =&gt; &#123;</span><br><span class="line">            (t1._1, t1._2+t2._2)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5. 将结果采集到控制台输出</span></span><br><span class="line">    <span class="keyword">val</span> res = word_count.collect()</span><br><span class="line">    res.foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 关闭连接</span></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>更改后的代码的部分函数使用</p><blockquote><ol><li><p>map函数</p><p>​        map，即映射，可以在 <code>()</code> 或 <code>&#123;&#125;</code> 内遍历数据进行操作，<code>()</code> 和 <code>&#123;&#125;</code> 的区别在于，如果遍历的数据只有一列，用前者，此时定义的临时变量不需要 <code>case</code> 关键字；如果是多列，需要使用 <code>case (...)</code>，其中，<code>case</code> 后的括号内必须包含与列数相等的变量，如果不会使用，可以使用 <code>_</code> 占位符省略名称。</p></li><li><p>reduce函数</p><p>​        reduce可以对集合中的元素进行归约操作。</p><p>​        如上述代码，reduce会将每一个分组的元素以某种方式进行合并，即上述的累加1值。</p></li></ol></blockquote></li><li><p>单看前两版的代码，flatMap、reduce、map等函数，Java中也有，Spark好像并没有什么优势。但实际上，<strong>spark框架提供了更多的功能，其中主要代码的分组和聚合，可以用一个方法实现 - reduceByKey - 相同key的数据，可以对value进行reduce聚合</strong>：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.core.wc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2021/6/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> 核心代码中，将单词划分开后首先均赋1，然后再进行分组，最后累加1值来聚合最终结果。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark03_WordCount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 建立和spark框架的连接</span></span><br><span class="line">      <span class="comment">//基本配置</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line">    <span class="comment">//创建连接</span></span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 执行业务逻辑</span></span><br><span class="line">    <span class="keyword">val</span> line = sc.textFile(path = <span class="string">&quot;datas&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> words = line.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> word2One = words.map(</span><br><span class="line">      word =&gt; (word, <span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Spark框架提供更多的功能，可以将分组和聚合使用一个方法实现</span></span><br><span class="line">    <span class="comment">//reduceByKey：相同key的数据，可以对value进行reduce聚合</span></span><br><span class="line">    <span class="keyword">val</span> word_count = word2One.reduceByKey(_+_)</span><br><span class="line">    <span class="comment">//5. 将结果采集到控制台输出</span></span><br><span class="line">    <span class="keyword">val</span> res = word_count.collect()</span><br><span class="line">    res.foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 关闭连接</span></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="log4j编写"><a href="#log4j编写" class="headerlink" title="log4j编写"></a>log4j编写</h3><p>为了省略执行时显示在控制台的执行日志，可以配置 <code>log4j.properties</code> 文件来提高日志输出的权限等。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">log4j.rootCategory</span>=<span class="string">ERROR, console</span></span><br><span class="line"><span class="meta">log4j.appender.console</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.console.target</span>=<span class="string">System.err</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="string">%d&#123;yy/MM/dd HH:mm:ss&#125; %p %c&#123;1&#125;: %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.logger.org.apache.spark.repl.Main</span>=<span class="string">ERROR</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.logger.org.spark_project.jetty</span>=<span class="string">ERROR</span></span><br><span class="line"><span class="meta">log4j.logger.org.spark_project.jetty.util.component.AbstractLifeCycle</span>=<span class="string">ERROR</span></span><br><span class="line"><span class="meta">log4j.logger.org.apache.spark.repl.SparkIMain$exprTyper</span>=<span class="string">ERROR</span></span><br><span class="line"><span class="meta">log4j.logger.org.apache.spark.repl.SparkILoop$SparkILoopInterpreter</span>=<span class="string">ERROR</span></span><br><span class="line"><span class="meta">log4j.logger.org.apache.parquet</span>=<span class="string">ERROR</span></span><br><span class="line"><span class="meta">log4j.logger.parquet</span>=<span class="string">ERROR</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.logger.org.apache.hadoop.hive.metastore.RetryingHMSHandler</span>=<span class="string">FATAL</span></span><br><span class="line"><span class="meta">log4j.logger.org.apache.hadoop.hive.ql.exec.FunctionRegistry</span>=<span class="string">ERROR</span></span><br></pre></td></tr></table></figure><p>日志的级别从高到低为如下：</p><blockquote><p>OFF、FATAL、ERROR、WARN、INFO、DEBUG、TRACE、ALL</p></blockquote><p>log4j建议只使用四个级别：<code>ERROR、WARN、INFO、DEBUG</code>，程序会打印高于或等于所设置级别的日志，设置的日志等级越高，打印出来的日志就越少。如果设置级别为INFO，则优先级高于等于INFO级别（如：INFO、WARN、ERROR）的日志信息将可以被输出,小于该级别的如DEBUG将不会被输出。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据组件的应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqoop - 使用基础</title>
      <link href="/2021/05/31/sqoop-%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"/>
      <url>/2021/05/31/sqoop-%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="使用sqoop将mysql数据导入hive"><a href="#使用sqoop将mysql数据导入hive" class="headerlink" title="使用sqoop将mysql数据导入hive"></a>使用sqoop将mysql数据导入hive</h2><p>执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sqoop import -m 1 \</span><br><span class="line">--connect jdbc:mysql://192.168.186.100:3306/forum \</span><br><span class="line">--username root \</span><br><span class="line">--password niit1234 \</span><br><span class="line">--hive-import \</span><br><span class="line">--create-hive-table \</span><br><span class="line">--hive-database forum \</span><br><span class="line">--delete-target-dir;</span><br></pre></td></tr></table></figure><span id="more"></span><p>其中：</p><blockquote><p>–hive-import ：将表导入到hive中，如果不设置，使用hive的默认界定符，即^A or \001；</p><p>–create-hive-table ：使用mysql的表名和字段类型直接创建；</p><p>–hive-database ：指定将表放到某个数据库；</p><p>–connect、–username、–password ：这些不需要说，肯定知道；</p><p>–delete-target-dir ：删除指定目录；</p></blockquote><p>还有一些其他常用的命令：</p><blockquote><p>–target-dir ：将数据导入指定目录；</p><p>–where ：指定条件导入；</p><p>–fields-terminated-by ：指定分隔符；</p><p>-m ：即–num-mappers，指定map的个数，默认是4个。</p></blockquote><h4 id="split-by和-m的联系"><a href="#split-by和-m的联系" class="headerlink" title="split-by和-m的联系"></a>split-by和-m的联系</h4><p>sqoop从大多数数据库中并行导入数据。</p><p>在执行并行导入的时候，需要一个可用来划分工作负载的标准。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据组件的应用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql - 日志分析项目小记</title>
      <link href="/2021/05/31/mysql-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/"/>
      <url>/2021/05/31/mysql-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="mysql执行本地sql文件"><a href="#mysql执行本地sql文件" class="headerlink" title="mysql执行本地sql文件"></a>mysql执行本地sql文件</h2><p>现在有一个<code>test.sql</code>文件，该文件需要导入到<code>mysql</code>的<code>test</code>数据库中：</p><ol><li><p>登录<code>mysql</code>，创建数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -ppasswd</span><br><span class="line">create database test;</span><br></pre></td></tr></table></figure></li></ol><span id="more"></span><ol><li><p>退出登录，执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">quit;</span><br><span class="line">mysql -uroot -ppasswd -Dtest &lt; test.sql</span><br></pre></td></tr></table></figure><p>此时可能报如下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">ERROR 1273 (HY000) at line 24: Unknown collation: &#x27;utf8mb4_0900_ai_ci&#x27;</span><br></pre></td></tr></table></figure><p>那是因为我的<code>mysql</code>的版本为5.7，<code>sql</code>文件的版本是8.x，高版本不能向下兼容。解决：</p><p>（1）将<code>utf8mb4_0900_ai_ci</code>全部替换为<code>utf8_general_ci</code>；</p><p>（2）将<code>utf8mb4</code>替换为<code>utf8</code>。</p><p>我使用<code>vim</code>工具，执行如下命令一次性将内容全部替换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:%s/utf8mb4_0900_ai_ci/utf8_general_ci/g</span><br><span class="line">:%s/utf8mb4/utf8/g</span><br></pre></td></tr></table></figure><blockquote><p><code>%s/a/b/g</code>的解释：即将文档中所有a内容替换为b内容</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hive - 日志分析项目小记</title>
      <link href="/2021/05/31/hive-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/"/>
      <url>/2021/05/31/hive-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="启动hive"><a href="#启动hive" class="headerlink" title="启动hive"></a>启动hive</h2><ol><li><p>启动hadoop集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start-dfs.sh</span><br><span class="line">start-yarn.sh</span><br></pre></td></tr></table></figure></li></ol><span id="more"></span><ol><li><p>启动zookeeper集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zkServer.sh start zoo1.cfg</span><br><span class="line">zkServer.sh start zoo2.cfg</span><br><span class="line">zkServer.sh start zoo3.cfg</span><br></pre></td></tr></table></figure></li><li><p>启动hive</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hive-services.sh start</span><br><span class="line">hive</span><br></pre></td></tr></table></figure><p>有时候会遇到下述错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hadoop.ipc.RemoteException(org.apache.hadoop.hdfs.server.namenode.SafeModeException): Cannot create directory /tmp/hive/hadoop/3a6e8cb6-9e44-45ce-8fc4-8d79f816f720. Name node is in safe mode.</span><br><span class="line">The reported blocks 609 needs additional 3 blocks to reach the threshold 0.9990 of total blocks 613.</span><br><span class="line">The minimum number of live datanodes is not required. Safe mode will be turned off automatically once the thresholds have been reached. NamenodeHostName:hadoop002</span><br><span class="line">        at org.apache.hadoop.hdfs.server.namenode.FSNamesystem.newSafemodeException(FSNamesystem.java:1498)</span><br><span class="line">        at org.apache.hadoop.hdfs.server.namenode.FSNamesystem.checkNameNodeSafeMode(FSNamesystem.java:1485)</span><br><span class="line">        at org.apache.hadoop.hdfs.server.namenode.FSNamesystem.mkdirs(FSNamesystem.java:3191)</span><br><span class="line">        at org.apache.hadoop.hdfs.server.namenode.NameNodeRpcServer.mkdirs(NameNodeRpcServer.java:1157)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>解决：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop dfsadmin -safemode leave</span><br></pre></td></tr></table></figure></li></ol><h2 id="使用sqoop将mysql数据导入hive"><a href="#使用sqoop将mysql数据导入hive" class="headerlink" title="使用sqoop将mysql数据导入hive"></a>使用sqoop将mysql数据导入hive</h2><p>执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sqoop import -m 1 \</span><br><span class="line">--connect jdbc:mysql://192.168.186.100:3306/forum \</span><br><span class="line">--username root \</span><br><span class="line">--password niit1234 \</span><br><span class="line">--hive-import \</span><br><span class="line">--create-hive-table \</span><br><span class="line">--hive-database forum \</span><br><span class="line">--delete-target-dir;</span><br></pre></td></tr></table></figure><p>其中：</p><blockquote><p>–create-hive-table ：使用mysql的表名和字段类型直接创建；</p><p>–hive-database ：指定将表放到某个数据库</p></blockquote><h2 id="报错：FAILED-ParseException-line-6-0-cannot-recognize-input-near-‘group’-‘by’-‘t’-in-expression-specification"><a href="#报错：FAILED-ParseException-line-6-0-cannot-recognize-input-near-‘group’-‘by’-‘t’-in-expression-specification" class="headerlink" title="报错：FAILED: ParseException line 6:0 cannot recognize input near ‘group’ ‘by’ ‘t’ in expression specification"></a>报错：FAILED: ParseException line 6:0 cannot recognize input near ‘group’ ‘by’ ‘t’ in expression specification</h2><p>我是因为下面这句报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">on tmp.id=t.course_id and t.type_name=”选修课”</span><br></pre></td></tr></table></figure><p>报错点：<code>&quot;&quot;</code>是中文的，我一开始直接在word文档中复制粘贴，但是就算是英文格式，在命令行也是中文的。</p><p>解决方法：</p><p>在命令行中敲出引号，在文档中进行修改，再将整个语句粘贴到命令行运行。</p><p>在创建表的时候，如果定义的字段名称是关键字，也会报这个错。</p>]]></content>
      
      
      <categories>
          
          <category> 项目小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spark - 面试题</title>
      <link href="/2021/05/31/spark-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2021/05/31/spark-%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-spark是什么"><a href="#1-spark是什么" class="headerlink" title="1. spark是什么"></a>1. spark是什么</h3><p>spark是一种与hadoop相似的开源集群计算框架，是基于内存的快速、通用、可扩展的大数据分析计算引擎。</p><p>基于内存：并不是说spark是内存计算，因为它的shuffle过程也是需要硬盘落地的，它的特点是多个任务之间的数据通信是通过内存进行的。</p><span id="more"></span><h3 id="2-spark的hadoop的对比"><a href="#2-spark的hadoop的对比" class="headerlink" title="2. spark的hadoop的对比"></a>2. spark的hadoop的对比</h3><p><strong>MapReduce框架局限性：</strong></p><p>1）仅支持Map和Reduce两种操作；</p><p>2）处理效率低效；</p><p>Map中间结果写磁盘，Reduce写HDFS，多个MR之间通过HDFS交换数据;，任务调度和启动开销大，无法充分利用内存，Map端和Reduce端均需要排序；</p><p>3）不适合迭代计算(如机器学习、图计算等)，交互式处理（数据挖掘)）和流式处理(点击日志分析）。</p><p><strong>Spark相比的优势：</strong><br>1.高性能：Spark采用内存计算引擎，允许用户将数据放到内存中以加快数据读取；同时，Spark提供了更加通用的DAG计算引擎，使得数据可通过本地磁盘或内存流向不同的计算单元。</p><p>2.简单易用：Spark提供了丰富的高层次API，包括sortByKey、groupByKey等操作，并且提供了四种编程语言API：Scala、Python、Java和R，从代码量看，Spark比MapReduce少2~5倍。</p><p>3.与Hadoop完好集成：Spark作为新型框架，可以部署在YARN集群上，读取和存储HDFS&#x2F;HBase中的数据。</p><p>经过上述比较可知，在绝大多数的数据计算场景下，spark比hadoop更具有优势，但是spark是基于内存的，在实际的生产环境中，由于内存的限制，可能会因为内存资源不够而导致job运行失败，此时，hadoop的mapreduce就是一个更好的选择，所以spark并不能完全替代hadoop。</p><h3 id="3-spark核心模块简介"><a href="#3-spark核心模块简介" class="headerlink" title="3. spark核心模块简介"></a>3. spark核心模块简介</h3><p>即spark sql、spark streaming、spark mllib、spark graphx和spark core。</p><p>其中，位于最底层的是spark core，它是整个spark框架的核心，其余的功能模块都是基于core来实现和完善的。</p><p>spark sql：用于操作结构化数据的功能模块，通过spark sql，用户可以使用sql或apache hive版本的sql语言来查询数据；</p><p>spark streaming：用于对流式数据进行处理的功能模块，提供了丰富的处理数据流的API；</p><p>spark mllib：是spark提供的一个机器学习算法库，不仅提供了模型评估、数据导入等额外的功能，还提供了一些更底层的机器学习原语；</p><p>spark graphx：是面向图计算提供的框架和算法库。</p><h3 id="4-RDD、DataFrame和DataSet的区别和联系"><a href="#4-RDD、DataFrame和DataSet的区别和联系" class="headerlink" title="4. RDD、DataFrame和DataSet的区别和联系"></a>4. RDD、DataFrame和DataSet的区别和联系</h3><h4 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h4><p>1、RDD、DataFrame、Dataset全都是spark平台下的分布式弹性数据集，为处理超大型数据提供便利；</p><p>2、三者都有惰性机制，在进行创建、转换，如map方法时，不会立即执行，只有在遇到Action如foreach、count、collect等时，三者才会开始运算，极端情况下，如果代码里面有创建、转换，但是后面没有Action操作，在执行时会被直接跳过；    </p><p>3、三者都会根据spark的内存情况自动缓存运算，这样即使数据量很大，也不用担心会内存溢出；</p><p>4、三者都有partition的概念；</p><p>5、三者有许多共同的函数，如filter，排序等；</p><p>6、对DataFrame和Dataset的许多操作都需要import spark.implicits._进行支持；</p><p>7、DataFrame和Dataset均可使用模式匹配获取各个字段的值和类型；</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol><li><p>RDD</p><p>1、RDD一般和spark mllib同时使用；</p><p>2、RDD不支持sparksql操作；</p></li><li><p>DataFrame</p><p>1、与RDD和Dataset不同，DataFrame每一行的类型固定为Row，只有通过解析才能获取各个字段的值，即每一列的值不能直接访问；</p><p>2、DataFrame与Dataset一般与spark mllib同时使用；</p><p>3、DataFrame与Dataset均支持sparksql的操作，比如select，groupby之类，还能注册临时表&#x2F;视窗，进行sql语句操作；</p><p>4、DataFrame与Dataset支持一些特别方便的保存方式，比如保存成csv，可以带上表头，这样每一列的字段名一目了然，利用这样的保存方式，可以方便的获得字段名和列的对应，而且分隔符（delimiter）可以自由指定；</p></li><li><p>DataSet</p><p> 主要是与DataFrame的比较，因为Dataset和DataFrame拥有完全相同的成员函数，区别只是每一行的数据类型不同；</p><p>DataFrame也可以叫Dataset[Row],每一行的类型是Row，不解析，每一行究竟有哪些字段，各个字段又是什么类型都无从得知，只能用getAS模式匹配取出特定字段；</p><p>而Dataset中，每一行是什么类型是不一定的，在自定义了case class之后可以很自由的获得每一行的信息；</p><p>相较而言，DataSet访问列的某个字段是方便的，然后，如果要写一些适配性比较强的函数，如果使用DataSet，行的类型又不确定，可以使用DataFrame。</p></li></ol><h3 id="5-SparkSession和SparkContext的区别和联系"><a href="#5-SparkSession和SparkContext的区别和联系" class="headerlink" title="5. SparkSession和SparkContext的区别和联系"></a>5. SparkSession和SparkContext的区别和联系</h3><p>SparkSession实质上是SparkContext和HiveContext的组合，所以在SparkContext和HiveContext上可用的API在SparkSession上同样可用。</p><p>SparkSession的内部封装了SparkContext，所以它的计算实际上是由SparkContext完成的。即需要SpakSQL活Hive时使用SparkSession，否则用SparkContext就行。</p><h3 id="6-DataSet、DataFrame常见的Action行动算子"><a href="#6-DataSet、DataFrame常见的Action行动算子" class="headerlink" title="6. DataSet、DataFrame常见的Action行动算子"></a>6. DataSet、DataFrame常见的Action行动算子</h3><blockquote><p>show(n) - 显示n条记录，n省略时显示全部；</p><p>collect - 获取所有数据并返回Array结构；</p><p>collectAsList - 获取所有数据并返回list结构；</p><p>first - 获取第一行数据；</p><p>head - 获取第一行数据 - head(n:int) - 获取前n行数据；</p><p>take(n:int) - 获取前n行数据；</p><p>takeAsList(n:int) - 获取前n行数据并以list形式展示；</p><p>printSchema - 输出数据结构信息；</p><p>explain - 将物理计划打印到控制台以进行调试；</p><p>count - 统计个数；</p><p>reduce - 对数据进行规约操作。</p></blockquote><h3 id="7-DataSet、DataFrame常见的Transformation转换算子"><a href="#7-DataSet、DataFrame常见的Transformation转换算子" class="headerlink" title="7. DataSet、DataFrame常见的Transformation转换算子"></a>7. DataSet、DataFrame常见的Transformation转换算子</h3><blockquote><p>map - 分析表中的数据；</p><p>flatMap - 在map的基础上将String扁平化为字符数组；</p><p>filter - 过滤；</p><p>select和selectExpr - 查询，select写查询语句，selectExpr写要查询的字段；</p><p>drop - 将表从内存删除；</p><p>withColumn - 用于向DataFrame添加列、更新现有列的值、转换列的数据类型以及从现有列派生新列；</p><p>join - 连接；</p><p>where - 指定条件；</p><p>groupBy - 分组；</p><p>agg - 对整个数据集聚合；</p><p>orderBy - 先将数据按照指定字段分区，在进行分区内排序；</p><p>sortBy - 分区内排序；</p><p>union、intersect、except - 并、交、差。</p></blockquote><h3 id="8-Spark有哪几种部署模式，每种模式有哪些特点"><a href="#8-Spark有哪几种部署模式，每种模式有哪些特点" class="headerlink" title="8. Spark有哪几种部署模式，每种模式有哪些特点"></a>8. Spark有哪几种部署模式，每种模式有哪些特点</h3><ol><li>本地模式：该模式被称为local[N]模式，是利用本地的多个线程来模拟spark的分布式计算，便于调试；它有以下分类：local - 只运行一个线程；local[K] - 运行K个executor；local[*] - 运行和cpu数目相同的executor。</li><li>standalone模式：是Spark自身的一个调度系统。 对集群性能要求非常高；分布式部署集群，自带完整的服务，其中资源管理和任务监控都由spark自己监控，该模式是其他模式的基础。</li><li>spark on yarn模式：分布式部署集群，资源和任务监控交给yarn管理，它是粗粒度资源分配方式，包含cluster和client运行模式：cluster 适合生产，driver运行在集群子节点，具有容错功能；client 适合调试，dirver运行在客户端。</li><li>spark on mesos模式：官方推荐这种模式（当然，原因之一是血缘关系）。正是由于Spark开发之初就考虑到支持Mesos，因此，目前而言，Spark运行在Mesos上会比运行在YARN上更加灵活，更加自然。用户可选择两种调度模式之一运行自己的应用程序：<br>  ①粗粒度模式（Coarse-grained Mode）：每个应用程序的运行环境由一个Dirver和若干个Executor组成，其中，每个Executor占用若干资源，内部可运行多个Task（对应多少个“slot”）。应用程序的各个任务正式运行之前，需要将运行环境中的资源全部申请好，且运行过程中要一直占用这些资源，即使不用，最后程序运行结束后，回收这些资源。<br>  ② 细粒度模式（Fine-grained Mode）：鉴于粗粒度模式会造成大量资源浪费，Spark On Mesos还提供了另外一种调度模式：细粒度模式，这种模式类似于现在的云计算，思想是按需分配。</li></ol><p><strong>Spark 客户端直接连接 Mesos；不需要额外构建 Spark 集群。国内应用比较少，更多的是运用 yarn 调度。</strong></p><h3 id="9-Spark的常用端口号"><a href="#9-Spark的常用端口号" class="headerlink" title="9. Spark的常用端口号"></a>9. Spark的常用端口号</h3><p>（1）4040：spark shell任务端口；<br>（2）7077：内部通讯端口，类似于hadoop的8020；<br>（3）8080：查看任务执行情况的端口号，类似hadoop的8088；<br>（4）18080：历史服务器，类似于hadoop的19888。</p><h3 id="10-SparkSQL中的三种join操作"><a href="#10-SparkSQL中的三种join操作" class="headerlink" title="10. SparkSQL中的三种join操作"></a>10. SparkSQL中的三种join操作</h3><p>用于小表join大表的 <code>broadcast join</code> 和 <code>shuffle join</code>，以及用于将两个大表连接的 <code>sort merge join</code>。</p><ol><li>broadcast join：将小表的数据通过广播的数据，分发到各个excutor中，即每个excutor都存储小表的全部数据，然后将大表分区，每个分区都和本地的广播变量进行join操作，这种方式会消耗空间，但会缩短shuffle的时间；</li><li>shuffle join：broadcast join适用于比较小的表，这个小的程度由spark.sql.broadcastTreshold参数来设置，默认是10M。对于表较大的小表，可以对两个表进行shuffle操作，将相同key的数据分到同一个分区，在分区之间进行join操作，这就相当于是将两张表分成若干份，小份和小份之间进行join，充分利用集群资源；</li><li>sort merge join：<code>broadcast join</code> 和 <code>shuffle join</code> 都是采用hash join，即将小表的数据完全加载到内存，然后通过hashcode取join key相等的方式进行连接，如果两个表都是大表就不适用了。此时就需要用到 <code>sort merge join</code>。它将两张表依照join key进行分区，然后对分区中的数据进行排序，排序后在对相应分区的数据遍历，碰到key相同就输出，这种方式大大提高了大数据量下sql join的稳定性。</li></ol><h3 id="11-Spark任务的提交流程-有时间再看看这个"><a href="#11-Spark任务的提交流程-有时间再看看这个" class="headerlink" title="11. Spark任务的提交流程**有时间再看看这个"></a>11. Spark任务的提交流程**有时间再看看这个</h3><p>spark的任务，在生产环境中一般会在yarn上运行，具体流程如下：</p><ol><li>用户通过client将任务提交到RM；</li><li>RM会启动一个AM；</li><li>AM会在内部启动一个driver线程，并向RM申请资源；</li><li>RM会返回一个资源可用列表；</li><li>Driver会在内部初始化SC、进行任务的划分和调度；</li><li>AM通过NM启动Container，并在Container内部启动一个ExcutorBanked进程；</li><li>Excutor反向注册给Driver；</li><li>Excutor启动任务。</li></ol><h3 id="12-如何划分Spark的stage"><a href="#12-如何划分Spark的stage" class="headerlink" title="12. 如何划分Spark的stage"></a>12. 如何划分Spark的stage</h3><p>有两个点，概念和划分的思路。</p><ol><li>窄依赖是父RDD的一个分区最多只能被子RDD的一个分区依赖，常见的有map、flatmap、filter等；</li><li>宽依赖是父RDD的一个分区可以由子RDD的多个分区所依赖，常见的有groupbykey、sortbykey、reducebykey等；</li><li>shuffle的概念是，在spark中，每个任务对应一个分区，通常不会跨区域操作数据，但遇到宽依赖的操作，spark必须从多个分区中读取数据，并查找所有键对应的值，最终汇总在一起以计算每个键最终的结果；</li><li>stage划分的思路：stage是以result和shuffle两种类型来划分task的，对于窄依赖，由于分区依赖关系的确定性，partition转换处理可以在同一个线程完成，这成为resulttask；对于宽依赖，需要等待父RDD的shuffle处理完成，在下一个stage才能开始接下来的计算，这成为shuffletask。</li><li>因此，stage的划分原则为：从后往前推RDD算子，如果遇到宽依赖就断开，划分为一个stage；如果是窄依赖，就将该RDD加入当前的stage中。</li></ol><h3 id="13-spark的懒加载机制"><a href="#13-spark的懒加载机制" class="headerlink" title="13. spark的懒加载机制"></a>13. spark的懒加载机制</h3><p>在spark中，RDD包含两种操作，一种是转换，泛指接收rdd作为输入，并输出一个rdd的函数，划分为窄依赖和宽依赖；另一种是行为，将rdd转换为非rdd的变量的操作，通常用于返回rdd计算的结果。其中转换操作就是懒操作，转换操作是延迟计算的，也就是说一个rdd转换生成另一个rdd的过程不会立即执行，而是等到出现行为操作的时候才会真正触发运算。</p><p>转化操作返回的数据类型是一个rdd类型；行为运算返回的数据类型是其他类型，二者的区别在于spark计算rdd的方式不同。</p><h3 id="14-spark的DAG？"><a href="#14-spark的DAG？" class="headerlink" title="14. spark的DAG？"></a>14. spark的DAG？</h3><p>DAG的中文全称是有向无环图，在spark中，使用DAG来描述我们的计算逻辑。</p><p>DAG简单的说就是一个RDD的执行流程和依赖关系。 有方向无闭环。创建RDD的时候构建DAG图，执行行动算子时一个DAG图形成。一个应用里面有多少个DAG取决于执行了多少次行动算子。</p><h3 id="15-spark的数据倾斜问题"><a href="#15-spark的数据倾斜问题" class="headerlink" title="15. spark的数据倾斜问题"></a>15. spark的数据倾斜问题</h3><p><strong>一. 产生的原因</strong></p><p>spark 中的数据倾斜并不是说原始数据存在倾斜，原始数据都是一个一个的 block，大小都一样，不存在数据倾斜；</p><p>而是指 shuffle 过程中产生的数据倾斜，由于不同的 key 对应的数据量不同导致不同 task 处理的数据量不同。</p><p>这里需要注意一点，数据倾斜和数据过量不同，数据倾斜是某几个task处理的数据量很大，数据过量是所有task的数据量都很大。</p><p><strong>二. 数据倾斜的表现</strong></p><p>大部分 task 都快速执行完毕，少数 task 执行缓慢，甚至报错 OOM，即使最终运行完毕，也叫数据倾斜。</p><p><strong>三. 后果</strong></p><ol><li>程序运行缓慢；</li><li>报错OOM；</li></ol><p><strong>四. 定位问题</strong></p><ol><li>查看代码中的shuffle算子，如reduceByKey、sortByKey、groupByKey、join等，根据代码逻辑推断是否会出现数据倾斜；</li><li>查看spark log文件，log记录错误发生在哪一行，再根据自己的理解定位到哪个shuffle算子；</li><li>使用spark web UI查看。</li></ol><p><strong>五. 解决方案</strong></p><ol><li><p>使用Hive FTL预处理数据</p><p>​        适用于导致数据倾斜的表是hive表。如果该hive表中的数据本身就很不均匀，如某个key对应100万条数据，而其他key才对应10条数据，而且业务场景需要频繁使用spark对hive表执行某个分析操作，就比较适合使用这种技术。</p><p>​        该方法的优点是实现起来简单便捷，效果还非常好，完全规避掉了数据倾斜，Spark作业的性能会大幅度提升。</p><p>​        缺点是治标不治本，Hive ETL中还是会发生数据倾斜。</p></li><li><p>过滤少数会导致倾斜的key</p><p>​        如果我们判断哪少数几个数据量特别多的key，对作业的执行和计算结果不是特别重要的话，那么干脆就直接过滤掉那少数几个key。比如，在Spark SQL中可以使用where子句过滤掉这些key或者在Spark Core中对RDD执行filter算子过滤掉这些key。如果需要每次作业执行时，动态判定哪些key的数据量最多然后再进行过滤，那么可以使用sample算子对RDD进行采样，然后计算出每个key的数量，取数据量最多的key过滤掉即可。</p><p>​        优点是实现简单，而且效果也很好，可以完全规避掉数据倾斜。</p><p>​        缺点是适用场景不多，大多数情况下，导致倾斜的key还是很多的，并不是只有少数几个。</p></li><li><p>提高shuffle操作的并行度</p><p>​        在对RDD执行shuffle算子时，给shuffle算子传入一个参数，比如reduceByKey(1000)，该参数就设置了这个shuffle算子执行时shuffle read task的数量。对于Spark SQL中的shuffle类语句，比如group by、join等，需要设置一个参数，即spark.sql.shuffle.partitions，该参数代表了shuffle read task的并行度，该值默认是200，对于很多场景来说都有点过小。</p><p>​        优点是实现起来比较简单，可以有效缓解和减轻数据倾斜的影响。</p><p>​        缺点是只是缓解了数据倾斜而已，没有彻底根除问题，其效果有限。</p></li><li><p>局部和全局两阶段聚合</p><p>​        对RDD执行reduceByKey等聚合类shuffle算子或者在Spark SQL中使用group by语句进行分组聚合时，比较适用这种方案。</p><p>​        该方法的原理是将原本相同的key通过附加随机前缀的方式，变成多个不同的key，就可以让原本被一个task处理的数据分散到多个task上去做局部聚合，进而解决单个task处理数据量过多的问题。接着去除掉随机前缀，再次进行全局聚合，就可以得到最终的结果。</p><p>​        优点是对于聚合类的shuffle操作导致的数据倾斜，效果是非常不错的。通常都可以解决掉数据倾斜，或者至少是大幅度缓解数据倾斜，将Spark作业的性能提升数倍以上。</p><p>​        缺点是仅仅适用于聚合类的shuffle操作，适用范围相对较窄。如果是join类的shuffle操作，还得用其他的解决方案。</p></li><li><p>将reduce join转为map join</p><p>​        正常情况下，join 会产生 shuffle 过程，而且是 reduce join，即先将相同 key 对应的 value 汇聚到一个 reduce task 中，再进行 join。如果其中有一个 RDD 很小，就可以采用 广播小 RDD + map 大 RDD 实现 join 功能，此时没有 shuffle 操作，自然不会有数据倾斜。</p><p>​        该方法的优点是对join操作导致的数据倾斜，效果非常好，因为根本就不会发生shuffle，也就根本不会发生数据倾斜。</p><p>​        缺点是适用场景较少，因为这个方案只适用于一个大表和一个小表的情况。毕竟我们需要将小表进行广播，此时会比较消耗内存资源，driver和每个Executor内存中都会驻留一份小RDD的全量数据。如果我们广播出去的RDD数据比较大，比如10G以上，那么就可能发生内存溢出了。因此并不适合两个都是大表的情况。</p></li><li><p>采样倾斜key并分拆join操作</p><p>​        适于大表join大表，对于join导致的数据倾斜，如果只是某几个key导致了倾斜，可以将少数几个key分拆成独立RDD，并附加随机前缀打散成n份去进行join，此时这几个key对应的数据就不会集中在少数几个task上，而是分散到多个task进行join了。</p><p>​        优点是对于join导致的数据倾斜，如果只是某几个key导致了倾斜，采用该方式可以用最有效的方式打散key进行join。而且只需要针对少数倾斜key对应的数据进行扩容n倍，不需要对全量数据进行扩容。避免了占用过多内存。</p><p>​        缺点是如果导致倾斜的key特别多的话，比如成千上万个key都导致数据倾斜，那么这种方式也不适合。</p></li><li><p>使用随机前缀和扩容RDD进行join</p><p>​        适用于在进行join操作时，有大量的key导致数据倾斜。</p><p>​        它将原先一样的key通过附加随机前缀变成不一样的key，然后就可以将这些处理后的“不同key”分散到多个task中去处理，而不是让一个task处理大量的相同key。该方案上种方法的不同之处就在于，上一种方法是尽量只对少数倾斜key对应的数据进行特殊处理，由于处理过程需要扩容RDD，因此上一种方案扩容RDD后对内存的占用并不大；而这一种方案是针对有大量倾斜key的情况，没法将部分key拆分出来进行单独处理，因此只能对整个RDD进行数据扩容，对内存资源要求很高。</p><p>​        优点是对join类型的数据倾斜基本都可以处理，而且效果也相对比较显著，性能提升效果非常不错。</p><p>​        缺点是该方法更多的是缓解数据倾斜，而不是彻底避免数据倾斜。而且需要对整个RDD进行扩容，对内存资源要求很高。</p></li><li><p>多种方法组合使用</p><p>​        如果只是处理较为简单的数据倾斜场景，那么使用上述方案中的某一种基本就可以解决。但是如果要处理一个较为复杂的数据倾斜场景，那么可能需要将多种方案组合起来使用。比如说，我们针对出现了多个数据倾斜环节的Spark作业，可以先运用解决方案一和二，预处理一部分数据，并过滤一部分数据来缓解；其次可以对某些shuffle操作提升并行度，优化其性能；最后还可以针对不同的聚合或join操作，选择一种方案来优化其性能。</p></li></ol><h3 id="16-Spark的内存管理机制"><a href="#16-Spark的内存管理机制" class="headerlink" title="16. Spark的内存管理机制"></a>16. Spark的内存管理机制</h3><h4 id="B站摘："><a href="#B站摘：" class="headerlink" title="B站摘："></a>B站摘：</h4><p>​        在一个executor节点上，内存被分为堆内内存和堆外内存，堆外内存由JVM来使用，对spark来说是不可见的，所以更多讨论的是堆内内存的内容。</p><p>​        这一块分为四个部分，首先它会默认保留300M的Reserved保留存储，剩下的for执行、for缓存、和for用户的memory，默认是按照334的比例进行划分。其中for执行指的是在计算过程中，特别是shuffle过程中，所需要使用到的临时的内存，而for缓存是缓存rdd时需要用到的内存。在1.6版本之前，这些配置都是相对静态的，1.6之后spark引入了统一内存管理的特性，极大的简化和优化了这个问题。</p><p>​        在默认情况下，执行和缓存各占一半的内存，而在统一内存管理中，当缓存需要内存多于一半的时候，它可以部分的占用原本属于执行的内存空间，反过来也一样，从而使它们之间有一个buffer的区域，可以互相占用，这种方式可以保证在大多数情况下，内存能有一个很好的利用。</p><h4 id="网上找："><a href="#网上找：" class="headerlink" title="网上找："></a>网上找：</h4><p>在执行 Spark 的应用程序时，Spark 集群会启动 Driver 和 Executor 两种 JVM 进程，前者为主控进程，负责创建 Spark 上下文，提交 Spark 作业（Job），并将作业转化为计算任务（Task），在各个 Executor 进程间协调任务的调度，后者负责在工作节点上执行具体的计算任务，并将结果返回给 Driver，同时为需要持久化的 RDD 提供存储功能。</p><p>1）堆内和堆外内存划分<br>堆内内存受到 JVM 统一管理，堆外内存是直接向操作系统进行内存的申请和释放。<br>1&gt;堆内内存<br>Executor 内运行的并发任务共享 JVM 堆内内存，这些任务在缓存 RDD 数据和广播（Broadcast）数据时占用的内存被规划为存储（Storage）内存 ， 而这些任务在执行 Shuffle 时占用的内存被规划为执行（Execution）内存，剩余的部分不做特殊规划，那些 Spark 内部的对象实例，或者用户定义的 Spark 应用程序中的对象实例，均占用剩余的空间。</p><p>Spark 对堆内内存的管理是一种逻辑上的”规划式”的管理，因为对象实例占用内存的申请和释放都由 JVM 完成，Spark 只能在申请后和释放前记录这些内存，我们来看其具体流程：<br>申请内存流程如下：<br>1.Spark 在代码中 new 一个对象实例；<br>2.JVM 从堆内内存分配空间，创建对象并返回对象引用；<br>3.Spark 保存该对象的引用，记录该对象占用的内存。<br>释放内存流程如下：<br>1.Spark 记录该对象释放的内存，删除该对象的引用；<br>2.等待 JVM 的垃圾回收机制释放该对象占用的堆内内存。<br>java虚拟机管理的内存（堆内内存），若想去控制它，比如说资源的释放是无法做到的，通知释放指令后，什么时候释放是不确定的，只能通知而不能控制，导致不灵活，即被 Spark 标记为释放的对象实例，很有可能在实际上并没有被 JVM 回收，导致实际可用的内存小于 Spark 记录的可用内存，比如想要去加载数据，但是发现内存没释放，导致内存不够用。所以 Spark 并不能准确记录实际可用的堆内内存。<br>2&gt;堆外内存<br>为了进一步优化内存的使用以及提高 Shuffle 时排序的效率，Spark 引入了堆外（Off-heap）内存。堆外内存意味着把内存对象分配在 Java 虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机）。这样做的结果就是能保持一个较小的堆，以减少垃圾收集对应用的影响。<br>堆外内存可以被精确地申请和释放（堆外内存之所以能够被精确的申请和释放，是由于内存的申请和释放不再通过 JVM 机制，而是直接向操作系统申请，JVM 对于内存的清理是无法准确指定时间点的，因此无法实现精确的释放），而且堆外内存序列化的数据占用的空间可以被精确计算，所以相比堆内内存来说降低了管理的难度，也降低了误差。但是相对来说也就不安全。因为它不是自动化的，而是人为控制的，存在人为操作错误的风险。<br>2）内存空间分配<br>和java虚拟机内存结构进行分类管理类似，Spark也将内存进行分类，分为：存储内存、执行内存、其他内存。</p><p>存储内存主要存储RDD缓存数据以及广播变量（广播变量：把task重复的数据独立出来共享到Excuter，所以放在存储内存中）。<br>执行内存存储的是Shuffle过程中的操作。<br>其他内存：系统自带的数据以及RDD元数据的信息。<br>预留内存：固定大小300M。<br>存储内存占除了预留内存其余内存的30%，执行内存占30%，其他内存占40%。</p><p>在 Spark 最初采用的静态内存管理机制下，存储内存、执行内存和其他内存的大小在 Spark 应用程序运行期间均为固定的，Spark 1.6 之后引入的统一内存管理机制，与静态内存管理的区别在于存储内存和执行内存共享同一块空间，可以动态占用对方的空闲区域。</p><p>其中最重要的优化在于动态占用机制，其规则如下：<br>1&gt;设定基本的存储内存和执行内存区域（spark.storage.storageFraction 参数），该设定确定了双方各自拥有的空间的范围；<br>2&gt;双方的空间都不足时，则存储到硬盘；若一方空间不足而对方空余时，可借用对方的空间;（存储空间不足是指不足以放下一个完整的 Block）.<br>3&gt;存储内存不够的时候，向执行内存借的内存需要还回去。可让对方将占用的部分转存到硬盘，然后”归还”借用的空间；<br>4&gt;执行内存不够用向存储内存借的内存不用还，因为如果执行内存还回借用的内存，会造成数据丢失，shuffle在Excuter中执行，意味着需要做统计分析。数据丢失，那么统计的结果将不正确。因此Excuter不能淘汰内存还给存储内存。<br>        存储内存不够的时候，向执行内存借的内存需要还回去，而执行内存不够用向存储内存借的内存不用还。因为存储内存如果丢失了，可以再走一遍，程序不会出现太多问题，只不过性能差一些，延时更长一些。如果执行内存还回借用的内存，会造成数据丢失，shuffle在Excuter中执行，意味着需要做统计分析。数据丢失，那么统计的结果将不正确。因此Excuter不能淘汰内存还给存储内存。</p><h3 id="17-spark中可以引起shuffle的算子"><a href="#17-spark中可以引起shuffle的算子" class="headerlink" title="17. spark中可以引起shuffle的算子"></a>17. spark中可以引起shuffle的算子</h3><ol><li>去重：distinct</li><li>聚合：reduceByKey、groupByKey、aggregateByKey、combineByKey。</li><li>排序：sortByKey、sortBy</li><li>重分区：coalesce、repartition</li><li>集合或表操作：intersection、subtract、subtractByKey、join、leftOuterJoin</li></ol><h3 id="18-Spark中的Shuffle"><a href="#18-Spark中的Shuffle" class="headerlink" title="18. Spark中的Shuffle"></a>18. Spark中的Shuffle</h3><p>​        Shuffle描述着数据从map task输出到reduce task输入的这段过程。shuffle是连接Map和Reduce之间的桥梁，Map的输出要用到Reduce中必须经过shuffle这个环节，shuffle的性能高低直接影响了整个程序的性能和吞吐量。因为在分布式情况下，reduce task需要跨节点去拉取其它节点上的map task结果。这一过程将会产生网络资源消耗和内存，磁盘IO的消耗。通常shuffle分为两部分：Map阶段的数据准备和Reduce阶段的数据拷贝处理。一般将在map端的Shuffle称之为Shuffle Write，在Reduce端的Shuffle称之为Shuffle Read。</p><p>​        在Spark的中，负责shuffle过程的执行、计算和处理的组件主要就是ShuffleManager，也即shuffle管理器。ShuffleManager随着Spark的发展有两种实现的方式，分别为HashShuffleManager和SortShuffleManager，因此spark的Shuffle有Hash Shuffle和Sort Shuffle两种。</p><p>1）Hash shuffle</p><p>这种shuffle类型在2.0之后就不再使用了。优化前的hashshuffle，每个task 会生成reducer类别数的数据文件，然后reducer会将每个task中对应类别的数据收集汇聚，这种方式会得到n个task和m个reducer数量输出的n * m数量的小文件；优化后的hashshuffle会复用buffer，即无论多少个task，都只会将数据存放在m个reducer数量的buffer中。</p><p>2）Sort Shuffle</p><p>​        这种方式以更少的中间磁盘文件产生而远远优于HashShuffle。而它的运行机制主要分为两种。一种为普通机制，另一种为bypass机制。而bypass机制的启动条件为，当shuffle read task的数量小于等于spark.shuffle.sort.bypassMergeThreshold参数的值时（默认为200），就会启用bypass机制。</p><p>（1）普通机制：</p><p>​        在该模式下，数据会先写入一个数据结构，聚合算子写入Map，一边通过Map局部聚合，一遍写入内存。Join算子写入ArrayList直接写入内存中。然后需要判断是否达到阈值，如果达到就会将内存数据结构的数据写入到磁盘，清空内存数据结构。</p><p>​        在溢写磁盘前，先根据key进行排序，排序过后的数据，会分批写入到磁盘文件中。默认批次为10000条，数据会以每批一万条写入到磁盘文件。写入磁盘文件通过缓冲区溢写的方式，每次溢写都会产生一个磁盘文件，也就是说一个task过程会产生多个临时文件。</p><p>​        最后在每个task中，将所有的临时文件合并，这就是merge过程，此过程将所有临时文件读取出来，一次写入到最终文件。意味着一个task的所有数据都在这一个文件中。同时单独写一份索引文件，标识下游各个task的数据在文件中的索引，start offset和end offset。</p><p>​        这样算来如果第一个stage 50个task，每个Executor执行一个task，那么无论下游有几个task，就需要50个磁盘文件。</p><p>（2）bypass机制</p><p>bypass机制运行条件：</p><p>① shuffle map task数量小于spark.shuffle.sort.bypassMergeThreshold参数的值。<br>② 不是聚合类的shuffle算子（比如reduceByKey）。<br>        在这种机制下，当前stage的task会为每个下游的task都创建临时磁盘文件。将数据按照key值进行hash，然后根据hash值，将key写入对应的磁盘文件中（个人觉得这也相当于一次另类的排序，将相同的key放在一起了）。最终，同样会将所有临时文件依次合并成一个磁盘文件，建立索引。</p><p>​        该机制与未优化的hashshuffle相比，没有那么多磁盘文件，下游task的read操作相对性能会更好。</p><p>​        该机制与sortshuffle的普通机制相比，在readtask不多的情况下，首先写的机制是不同，其次不会进行排序。这样就可以节约一部分性能开销。</p><h3 id="19-foreach和foreachPartition的区别"><a href="#19-foreach和foreachPartition的区别" class="headerlink" title="19. foreach和foreachPartition的区别"></a>19. foreach和foreachPartition的区别</h3><h4 id="我自己的理解"><a href="#我自己的理解" class="headerlink" title="我自己的理解"></a>我自己的理解</h4><p>二者都用来迭代rdd，前者一次迭代一个数据，后者一次迭代一批数据。</p><h4 id="找到的答案"><a href="#找到的答案" class="headerlink" title="找到的答案"></a>找到的答案</h4><p>每个partition中iterator时行迭代的处理，通过用户传入的function对iterator进行内容的处理。</p><p>（1）foreach</p><p>​        Foreach中，传入一个function，这个函数的传入参数就是每个partition中，每次的foreach得到的一个rdd的kv实例，也就是具体的内容<br>​        这种处理你并不知道这个iterator的foreach什么时候结果，只能是在foreach过程中，你得到一条数据，就处理一条数据。</p><p>（2）foreachPartition</p><p>​        这个函数也是根据传入的function进行处理，但是不同之处再有这里function传入的参数是一个partition对应数据的iterator，而不是直接使用iterator的foreach。</p><h3 id="20-map和mapPartitions的区别"><a href="#20-map和mapPartitions的区别" class="headerlink" title="20 map和mapPartitions的区别"></a>20 map和mapPartitions的区别</h3><p>（1）主要区别在于：</p><p>1） map ：一次处理一个元素的数据；</p><p>2）mapPartitions：一次处理一批数据。</p><p>（2）mapPartitions的优缺点：</p><p>优点：速度快，一次处理一批数据，即一次接收所有的partition数据，在map过程中需要频繁创建额外的对象(例如将rdd中的数据通过jdbc写入数据库，map需要为每个元素创建一个链接，而mapPartition为每个partition创建一个链接)，则mapPartitions效率比map高的多。</p><p>缺点：容易出现内存溢出，当接收的partition的数据量较大时，例如100万数据， 一次传入一个function以后，那么可能一下子内存不够，但是又没有办法去腾出内存空间来，可能就导致OOM（内存溢出）；而map一般较少出现内存溢出。</p><p>（3）mapPartitions()出现内存溢出时的解决方法：</p><ol><li>将数据切成较多的partition：<br><code>repartition(100).mapPartitions(xx)</code></li><li>设置较大的处理器内存<br><code>--executor-memory 8g</code></li></ol><h3 id="21-Spark-Sql支持的存储文件类型？"><a href="#21-Spark-Sql支持的存储文件类型？" class="headerlink" title="21 Spark Sql支持的存储文件类型？"></a>21 Spark Sql支持的存储文件类型？</h3><p>常见的文件存储类型：Text文件、Json文件、Sequence文件和Object文件。<br>Spark Sql的默认存储格式是Parquet，Parquet是一种列式存储格式。</p><h3 id="22-spark的核心组件"><a href="#22-spark的核心组件" class="headerlink" title="22 spark的核心组件"></a>22 spark的核心组件</h3><ol><li><p>Driver：Spark驱动节点，用于执行Spark任务中的main方法，负责实际代码的执行工作。Driver在Spark作业执行时主要负责：</p><p>1）将用户程序转化为job；</p><p>2）在Executor之间调度Task；</p><p>3）跟踪Executor的执行情况；</p><p>4）通过UI查询展示运行情况；</p></li><li><p>Executor：Executor节点是一个JVM进程，负责运行具体任务，任务之间相互独立。</p><p>Spark应用启动时，Executor节点被同时启动，并且始终伴随着整个Spark应用的生命周期。</p><p>如果有Executor节点发生故障或者崩溃，Spark应用会将出错节点上的任务调度到其他Executor节点上继续运行。</p><p>Executor有两个核心功能：</p><p>1）负责运行组成Spark应用的任务，并将结果返回给驱动器进程；</p><p>2）Executor通过自身的块管理器（Block Manager）为用户程序中要求缓存的RDD提供内存式存储。RDD是直接缓存在Executor进程内的，因此任务可以在运行时充分利用缓存数据加速运算。</p></li></ol><h3 id="23-什么是RDD"><a href="#23-什么是RDD" class="headerlink" title="23 什么是RDD"></a>23 什么是RDD</h3><p>RDD (Resilient Distributed Dataset)叫做弹性分布式数据集，是Spark中最基本的数据处理模型。代码中是一个抽象类，它代表一个弹性的、不可变、可分区、里面的元素可并行计算的集合。</p><p>它有五大特性：</p><ol><li><p><strong>分区列表( a list of partitions)</strong></p><p>Spark RDD是被分区的，每一个分区都会被一个计算任务(Task)处理，分区数决定了并行计算的数量，RDD的并行度默认从父RDD传给子RDD。默认情况下，一个HDFS上的数据分片就是一个 partiton，RDD分片数决定了并行计算的力度，可以在创建RDD时指定RDD分片个数（分区）。</p></li><li><p><strong>每一个分区（分片）都有一个计算函数( a function for computing each split）</strong></p><p>每个分区都会有计算函数， Spark的RDD的计算函数是以分片为基本单位的，每个RDD都会实现 compute函数，对具体的分片进行计算，RDD中的分片是并行的，所以是分布式并行计算。</p></li><li><p><strong>依赖于其他RDD的列表</strong></p><p>RDD会记录它的依赖 ，为了容错，也就是说在内存中的RDD操作时出错或丢失会进行重算。</p></li><li><p><strong>key- value数据类型的RDD分区</strong></p><p>如果RDD里面存的数据是key-value形式，则可以传递一个自定义的Partitioner进行重新分区，例如这里自定义的Partitioner是基于key进行分区，那则会将不同RDD里面的相同key的数据放到同一个partition里面。</p></li><li><p><strong>每个分区都有一个优先位置列表</strong></p><p>优先位置列表会存储每个 Partition的优先位置，对于一个HDFS文件来说，就是每个Partition块的位置。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建立第一个独立博客</title>
      <link href="/2021/05/30/%E5%BB%BA%E7%AB%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/05/30/%E5%BB%BA%E7%AB%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>前人栽树，后人乘凉~</p><p>具体见<a href="https://zhuanlan.zhihu.com/p/102592286?tdsourcetag=s_pctim_aiomsg">https://zhuanlan.zhihu.com/p/102592286?tdsourcetag=s_pctim_aiomsg</a></p><span id="more"></span><p>此处记录日常生成并上传文件的方式。</p><h3 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;文章标题&quot;</span><br></pre></td></tr></table></figure><p>文章标题可以不用双引号括住。</p><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/05/30/hello-world/"/>
      <url>/2021/05/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
