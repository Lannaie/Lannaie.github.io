<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>20210721 - sum函数由于优先级计算错误 项目小记</title>
    <url>/2021/07/21/20210721-sum%E5%87%BD%E6%95%B0%E7%94%B1%E4%BA%8E%E4%BC%98%E5%85%88%E7%BA%A7%E8%AE%A1%E7%AE%97%E9%94%99%E8%AF%AF-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="摘自"><a href="#摘自" class="headerlink" title="摘自"></a>摘自</h2><p><a href="https://blog.csdn.net/a158123/article/details/91051636">传送门</a></p>
<span id="more"></span>



<h2 id="1-具体错误结果"><a href="#1-具体错误结果" class="headerlink" title="1. 具体错误结果"></a>1. 具体错误结果</h2><p>希望能通过 <code>sum</code> 函数累加表中某个字段的第一行 <code>limit 1</code>；</p>
<p>期望结果是：<code>0.0</code>；</p>
<p>得到结果是：<code>22178</code>。</p>
<p> 下面给出错误代码：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="built_in">SUM</span>(`amount`)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    `<span class="keyword">order</span>`</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> `id`</span><br><span class="line">LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure>



<h2 id="2-问题所在"><a href="#2-问题所在" class="headerlink" title="2. 问题所在"></a>2. 问题所在</h2><p>没有意识到这个是优先级别的问题：</p>
<ol>
<li>FROM：FROM子句是最先执行的，确定了查询的是order这张表</li>
<li>SELECT：SELECT子句是第二个执行的子句，同时SUM()函数也在此时执行了。</li>
<li>ORDER BY：ORDER BY子句是第三个执行的子句，其处理的结果只有一个，就是订单总金额</li>
<li>LIMIT：LIMIT子句是最后执行的，此时结果集中只有一个结果（订单总金额）</li>
</ol>
<h2 id="3-具体解决"><a href="#3-具体解决" class="headerlink" title="3. 具体解决"></a>3. 具体解决</h2><p>使用子查询的方式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    <span class="built_in">SUM</span>(o.amount)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (<span class="keyword">SELECT</span> </span><br><span class="line">        `amount`</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        `<span class="keyword">order</span>`</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> `id`</span><br><span class="line">    LIMIT <span class="number">5</span>) <span class="keyword">AS</span> o;</span><br></pre></td></tr></table></figure>



<h2 id="4-select语句的执行顺序"><a href="#4-select语句的执行顺序" class="headerlink" title="4. select语句的执行顺序"></a>4. select语句的执行顺序</h2><blockquote>
<ol>
<li>FROM <left_table></left_table></li>
<li>ON <join_condition></join_condition></li>
<li><join_type> JOIN <right_table></right_table></join_type></li>
<li>WHERE <where_condition></where_condition></li>
<li>GROUP BY <group_by_list></group_by_list></li>
<li>HAVING <having_condition></having_condition></li>
<li>SELECT</li>
<li>DISTINCT <select_list></select_list></li>
<li>ORDER BY <order_by_condition></order_by_condition></li>
<li>LIMIT <limit_number></limit_number></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>项目小记</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP页面中文乱码</title>
    <url>/2022/01/14/JSP%E9%A1%B5%E9%9D%A2%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</url>
    <content><![CDATA[<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>将 <code>&lt;%@ page contentType=&quot;text/html;charset=udf-8&quot; language=&quot;java&quot; %&gt;</code></p>
<p>改为 <code>&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot; language=&quot;java&quot; %&gt;</code></p>
<p>修改地方：<code>udf-8</code> -&gt; <code>gb2312</code></p>
]]></content>
      <categories>
        <category>项目小记</category>
        <category>报错</category>
      </categories>
      <tags>
        <tag>jsp</tag>
      </tags>
  </entry>
  <entry>
    <title>Flume &amp; Sqoop资源</title>
    <url>/2021/06/26/Flume-Sqoop%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<p><a href="http://lannaie.top/resources/Flume.pdf">Flume.pdf</a></p>
<p><a href="http://lannaie.top/resources/Flume%201.9%E7%94%A8%E6%88%B7%E6%89%8B%E5%86%8C.pdf">Flume 1.9用户手册.pdf</a></p>
<p><a href="http://lannaie.top/resources/Flume%E9%A2%98%E5%BA%93.pdf">Flume题库.pdf</a></p>
<p><a href="http://lannaie.top/resources/Sqoop%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97%EF%BC%88v1.4.7%EF%BC%89.pdf">Sqoop用户指南（v1.4.7）.pdf</a></p>
<p><a href="http://lannaie.top/resources/SQOOP%20%E7%AE%80%E4%BB%8B-%E5%AD%A6%E7%94%9F%E6%8C%87%E5%8D%97.pdf">SQOOP%简介-学生指南.pdf</a></p>
<p><a href="http://lannaie.top/2021/06/27/Sqoop50%E9%A2%98/">sqoop50题</a></p>
<p><a href="http://lannaie.top/resources/Flume%E7%AE%80%E4%BB%8B-%E5%AD%A6%E7%94%9F%E6%8C%87%E5%8D%97.pdf">Flume 简介-学生指南.pdf</a></p>
]]></content>
  </entry>
  <entry>
    <title>Java与MySQL读取和获取图片</title>
    <url>/2022/01/15/Java%E4%B8%8EMySQL%E8%AF%BB%E5%8F%96%E5%92%8C%E8%8E%B7%E5%8F%96%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h3 id="数据库的代码"><a href="#数据库的代码" class="headerlink" title="数据库的代码"></a>数据库的代码</h3><span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS goods_settlement.COMMODITY(</span><br><span class="line">imgid int AUTO_INCREMENT PRIMARY KEY NOT NULL COMMENT &#x27;图片ID&#x27;,</span><br><span class="line">name VARCHAR(200) NOT NULL COMMENT &#x27;名称&#x27;,</span><br><span class="line">picture LONGBLOB COMMENT &#x27;图片&#x27;,</span><br><span class="line">cost DECIMAL(10, 2) COMMENT &#x27;价格&#x27;</span><br><span class="line">)</span><br><span class="line">COMMENT &#x27;商品表&#x27;</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>其中，MySQL有四种Blob类型：</p>
<ol>
<li>TinyBlob 最大 255B</li>
<li>Blob 最大 65K</li>
<li>MediumBlob 最大 16M </li>
<li>LongBlob 最大 4G</li>
</ol>
<p>插入图像的时候，注意下图像大小，图像超过该类型所能容纳的最大字节的时候，会报错。</p>
<h3 id="插入图片的二进制文件到mysql"><a href="#插入图片的二进制文件到mysql" class="headerlink" title="插入图片的二进制文件到mysql"></a>插入图片的二进制文件到mysql</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">( String name, String pic_url, <span class="keyword">double</span> cost )</span> </span>&#123;</span><br><span class="line">    String sql = <span class="string">&quot;INSERT INTO COMMODITY(name, picture, cost) values(?, ?, ?)&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span>(Connection conn = getConnection();</span><br><span class="line">        PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line">        FileInputStream input = <span class="keyword">new</span> FileInputStream(pic_url); )</span><br><span class="line">    &#123;</span><br><span class="line">        ps.setString(<span class="number">1</span>, name);</span><br><span class="line">        ps.setBinaryStream(<span class="number">2</span>, input, input.available());</span><br><span class="line">        ps.setBigDecimal(<span class="number">3</span>, BigDecimal.valueOf(cost));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num = ps.executeUpdate();</span><br><span class="line">        <span class="keyword">if</span>( num &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;插入成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;插入失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="获取图片"><a href="#获取图片" class="headerlink" title="获取图片"></a>获取图片</h3><h4 id="获取非图片内容"><a href="#获取非图片内容" class="headerlink" title="获取非图片内容"></a>获取非图片内容</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getGoods</span><span class="params">()</span> <span class="keyword">throws</span> SQLException, ClassNotFoundException </span>&#123;</span><br><span class="line">        String sql = <span class="string">&quot;SELECT * FROM goods_settlement.COMMODITY&quot;</span>;</span><br><span class="line">        List&lt;Good&gt; goods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>(Connection conn = getConnection(); PreparedStatement ps = conn.prepareStatement(sql); ResultSet rs = ps.executeQuery())</span><br><span class="line">        &#123;</span><br><span class="line"><span class="comment">//            System.out.println(rs.getRow());</span></span><br><span class="line">            <span class="keyword">while</span>( rs.next() )</span><br><span class="line">            &#123;</span><br><span class="line">                Good good = <span class="keyword">new</span> Good();</span><br><span class="line">                Blob pic = rs.getBlob(<span class="string">&quot;picture&quot;</span>);</span><br><span class="line">                good.setImgid(rs.getInt(<span class="string">&quot;imgid&quot;</span>));</span><br><span class="line">                good.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                good.setCost(rs.getBigDecimal(<span class="string">&quot;cost&quot;</span>));</span><br><span class="line">                goods.add(good);</span><br><span class="line">            &#125;</span><br><span class="line">            Commodity.setGoods(goods);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取图片-1"><a href="#获取图片-1" class="headerlink" title="获取图片"></a>获取图片</h4><p>使用 <code>OutputStream.flush()</code> 映射上去，不知道怎么在同一页面操作。</p>
<p>通用的操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String imgid = request.getParameter(<span class="string">&quot;imgid&quot;</span>);</span><br><span class="line">String sql = <span class="string">&quot;SELECT picture FROM COMMODITY WHERE imgid = 1&quot;</span>;<span class="comment">// + imgid;</span></span><br><span class="line"><span class="keyword">try</span>(Connection conn = getConnection(); PreparedStatement ps = conn.prepareStatement(sql); ResultSet rs = ps.executeQuery()) &#123;</span><br><span class="line">    <span class="keyword">if</span>( rs.next() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建输入输出流</span></span><br><span class="line">        InputStream inputStream = rs.getBinaryStream(<span class="string">&quot;picture&quot;</span>);</span><br><span class="line">        OutputStream outputStream = response.getOutputStream(); <span class="comment">// 发送给jsp页面</span></span><br><span class="line">        <span class="keyword">int</span> num = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((num = inputStream.read()) != -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            outputStream.write(num);</span><br><span class="line">        &#125;</span><br><span class="line">        outputStream.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭输入输出流</span></span><br><span class="line">        inputStream.close();</span><br><span class="line">        outputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果类型是Blob，可以使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> String imgid = request.getParameter(<span class="string">&quot;imgid&quot;</span>);</span><br><span class="line"> String sql = <span class="string">&quot;SELECT picture FROM COMMODITY WHERE imgid = 1&quot;</span>;<span class="comment">// + imgid;</span></span><br><span class="line"> <span class="keyword">try</span>(Connection conn = getConnection(); PreparedStatement ps = conn.prepareStatement(sql); ResultSet rs = ps.executeQuery()) &#123;</span><br><span class="line">     <span class="keyword">if</span>( rs.next() )</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="comment">// 创建输入输出流</span></span><br><span class="line">         Blob b = rs.getBlob(<span class="string">&quot;photo_image&quot;</span>); </span><br><span class="line"><span class="keyword">long</span> size = b.length(); </span><br><span class="line"><span class="keyword">byte</span>[] bs = b.getBytes(<span class="number">1</span>, (<span class="keyword">int</span>)size); </span><br><span class="line">response.setContentType(<span class="string">&quot;image/jpeg&quot;</span>); </span><br><span class="line">OutputStream outs = response.getOutputStream(); </span><br><span class="line">outs.write(bs); </span><br><span class="line">outs.flush(); </span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 关闭输入输出流</span></span><br><span class="line">         inputStream.close();</span><br><span class="line">         outputStream.close();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="借鉴"><a href="#借鉴" class="headerlink" title="借鉴"></a>借鉴</h3><p><a href="https://www.cnblogs.com/nashiyue/p/4528155.html">Java BLOB 数据的插入与读取 操作</a></p>
<p><a href="https://www.cnblogs.com/jokerjason/p/5747690.html">JSP 实现 之 读取数据库显示图片</a></p>
]]></content>
      <categories>
        <category>项目小记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 11. 盛最多水的容器</title>
    <url>/2022/01/03/LeetCode-11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/container-with-most-water/">https://leetcode-cn.com/problems/container-with-most-water/</a></p>
<span id="more"></span>



<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>双指针是立刻能想到的方向，只是可能无法运用。</p>
<p>可以这样思考：最终需要的结果 <code>容纳最多的水</code> 的计算公式是：<br>$$<br>容纳的水量 &#x3D; min(height[left], height[right]) * (right - left)<br>$$<br>即容纳的水量是由两个端点中的较小值和两个端点的距离决定的，所以要么扩大扩大两个端点的距离，要么增大较小值。</p>
<p>这里可以使用 <code>left = 0, right = height.length - 1</code> 两个指针来指定初始的两个端点，因为在距离稳定减少的情况下，如果我们移动数字较大的那个指针，那么前者「两个指针指向的数字中较小值」不会增加，后者「指针之间的距离」会减小，那么这个乘积会减小。因此，我们移动数字较大的那个指针是不合理的。因此，我们移动 数字较小的那个指针。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxwater = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( left &lt; right )</span><br><span class="line">        &#123;</span><br><span class="line">            maxwater = Math.max(Math.min(height[left], height[right]) * (right - left), maxwater);</span><br><span class="line">            <span class="keyword">if</span>( height[left] &lt; height[right] )</span><br><span class="line">            &#123;</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxwater;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 1.两数之和</title>
    <url>/2021/06/15/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/two-sum/">https://leetcode-cn.com/problems/two-sum/</a></p>
<span id="more"></span>

<h2 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h2><h3 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h3><p><strong>这种方法不一定符合要求的时空复杂度，但是在没有任何思路的时候，我觉得暴力解决是最有效的方式。</strong></p>
<h4 id="1-java"><a href="#1-java" class="headerlink" title="1. java:"></a>1. java:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len; ++ j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( nums[i] + nums[j] == target )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-python"><a href="#2-python" class="headerlink" title="2. python"></a>2. python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( <span class="number">0</span>, length ):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>( i+<span class="number">1</span>, length ):</span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] == target:</span><br><span class="line">                    <span class="keyword">return</span> [i, j]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

<p>​        其中，为了防止重复遍历和指向同一个元素的情况发生，将 <code>j</code> 指向 <code>i</code> 的下一个，即 <code>j = i + 1</code> ；如果有两个元素满足条件，返回 <code>new int[]&#123;i, j&#125;</code> ，否则就返回不含任何元素的新数组 <code>new int[0]</code> 。</p>
<h3 id="哈希表求解"><a href="#哈希表求解" class="headerlink" title="哈希表求解"></a>哈希表求解</h3><p>三种方法中的最优解，是处理该类问题的更普遍方法。</p>
<h4 id="1-java-1"><a href="#1-java-1" class="headerlink" title="1. java"></a>1. java</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( map.containsKey( target - nums[i]) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(target-nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​        在表中进行搜索，如果没有 <code>target - nums[i]</code> 的值在表中出现，就将 <code>nums[i]</code> 和对一个下标以键值对的形式存储到表中，然后进行判断，因为题目中假设只有一对元素符合条件，所以只要出现第一个，就可以直接返回，为防万一，在句末添加 <code>return new int[0]</code> 来确保没有结果时不会报错。</p>
<p>​        这种方法相当于是在暴力求解的基础上，省略了一个循环，将中间结果存入一个表来提高时间复杂度。</p>
<p>对哈希表了解一点简单的操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 定义声明键值类型均为Integer的HashMap</span></span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"><span class="comment">// 2. 添加元素</span></span><br><span class="line">map.put(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 3. 删除元素</span></span><br><span class="line">map.remove(<span class="number">1</span>, <span class="number">2</span>);	<span class="comment">//删除指定key的键值对，其中value可省</span></span><br><span class="line">map.values().removeIf(value -&gt; !value.contains(<span class="number">1</span>))	<span class="comment">//根据Map中的值删除</span></span><br><span class="line">map.keySet().removeIf(key -&gt; !key.contains(<span class="number">1</span>))	<span class="comment">//根据Map中的键删除</span></span><br><span class="line">map.entrySet().removeIf(entry -&gt; entry.getKey() != <span class="number">1</span>)	<span class="comment">//根据获得的键或值的元素来判断删除</span></span><br><span class="line"><span class="comment">// 4. 获取元素</span></span><br><span class="line">map.get(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<h4 id="2-python-1"><a href="#2-python-1" class="headerlink" title="2. python"></a>2. python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        dic = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>( <span class="number">0</span>, length ):</span><br><span class="line">            <span class="keyword">if</span> target - nums[i] <span class="keyword">in</span> dic.keys():</span><br><span class="line">                <span class="keyword">return</span> [dic[target - nums[i]], i]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

<p>对字典了解一点简单的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. 定义声明</span><br><span class="line">dic = &#123;&#125;</span><br><span class="line">dic = &#123;1:2, 2:3, &quot;abc&quot;:1&#125;</span><br><span class="line">// 2. 添加元素</span><br><span class="line">dic[&quot;bei&quot;] = 6</span><br><span class="line">dic.update(&#123;9:2&#125;)</span><br><span class="line">// 3. 删除元素</span><br><span class="line">del dic[&quot;bei&quot;]	//删除指定键的键值对</span><br><span class="line">dic.clear()	//清空字典</span><br><span class="line">del dic	//删除字典</span><br><span class="line">// 4. 获取元素</span><br><span class="line">print(dic[&quot;bei&quot;])</span><br><span class="line">// 5. 修改元素</span><br><span class="line">dic[&quot;bei&quot;] = 3</span><br></pre></td></tr></table></figure>



<h3 id="取下标数组标记"><a href="#取下标数组标记" class="headerlink" title="取下标数组标记"></a>取下标数组标记</h3><p>​        这是最开始的想法：将一维数组变为二维数组，其中，第一列是下标，第二列是元素；然后按照元素列进行升序排序，再定两个点 <code>i = 0, j = nums.length-1</code> ，如果有 <code>nums[i] + nums[j] == target</code> ,就返回元素对应的下标，即第二列元素值对应的第一列的下标值；否则直到 不满足条件 <code>i &lt; j</code> ，退出遍历，返回空数组。    </p>
<p>​        因为这种方法用Java没有任何优势，所以此处不展示此代码。</p>
<h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        length = <span class="built_in">len</span>(nums)</span><br><span class="line">        i , j = <span class="number">0</span>, length - <span class="number">1</span></span><br><span class="line">        tmp = <span class="built_in">enumerate</span>(nums)</span><br><span class="line">        tmp = <span class="built_in">sorted</span>(tmp, key=<span class="keyword">lambda</span> k: k[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">while</span> i &lt; j :</span><br><span class="line">            <span class="keyword">if</span> tmp[i][<span class="number">1</span>] + tmp[j][<span class="number">1</span>] == target:</span><br><span class="line">                <span class="keyword">return</span> [tmp[i][<span class="number">0</span>], tmp[j][<span class="number">0</span>]]</span><br><span class="line">            <span class="keyword">elif</span> tmp[i][<span class="number">1</span>] + tmp[j][<span class="number">1</span>] &gt; target:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

<p>简单了解 <code>enumerate()</code> 函数的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;tmp = [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]</span><br><span class="line">&gt;&gt;&gt; for i, element in enumerate(tmp):</span><br><span class="line">...     print i, element</span><br><span class="line">... </span><br><span class="line">0 one</span><br><span class="line">1 two</span><br><span class="line">2 three</span><br><span class="line">&gt;&gt;&gt;tmp = enumerate(tmp)</span><br><span class="line">&gt;&gt;&gt; print(tmp[0][0])</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 10. 正则表达式匹配</title>
    <url>/2022/03/03/LeetCode-10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/regular-expression-matching/">https://leetcode-cn.com/problems/regular-expression-matching/</a></p>
<span id="more"></span>



<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>动态规划的典型思路：判断s的前缀子串和p的前缀子串究竟符不符合。</p>
<p>这里有一个小点：<strong>s串如果是空串，这个p串应该也需要判断是否能够成立，因此 i &#x3D; 0 的情况也需要遍历。</strong></p>
<p>具体思路如下：</p>
<p>首先肯定的是，分析的重点肯定是在p串上的。对于p上的字符，只有两种：有 <code>*</code> 和 没有 <code>*</code> 。</p>
<ol>
<li>没有 <code>* </code> 的情况：</li>
</ol>
<p>   <code>(p.charAt(j - 1) == &#39;.&#39;) || (s.charAt(i - 1) == p.charAt(j - 1))</code> 的时候才会存在 <code>dp[i][j] = dp[i - 1][j - 1]</code> ，但是不能保证 <code>false</code> 就可以结束循环，因为还有 <code>i = 0</code> 的情况是需要忽略的。</p>
<ol start="2">
<li><p>有 <code>*</code> 的情况：</p>
<p>其实也是只有两种情况：0次和无数次的差别。</p>
<p>（1）默认使用0次，也就是先假设前面的字符不相等的情况；</p>
<p>（2）然后判断 <code>p[j - 2] == s[i - 1]</code> 是否成立，如果成立，就要考虑用1次还是1次以上的问题；</p>
<p>（3）但是这种思路容易想复杂，所以可以换个方式去想，不考虑次数问题，就到当前下标的p的前缀子串，和除了当前下标后的s的前缀子串相比，是否相同。也就是如果当前元素是 <code>s[i - 1]</code> 和 <code>p[j - 1]</code> ，如果 <code>s[0 ... i - 2] == p[0 ... j - 1]</code> 是相等的，那就说明此时一定是需要 <code>*</code> 来多贴一个字符的，即在当 <code>p[j - 2] == s[i - 1]</code> 时，<code>dp[i][j] = dp[i][j - 2] || dp[i - 1][j]</code> 。</p>
<p>综上，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slen = s.length(), plen = p.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[slen + <span class="number">1</span>][plen + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= slen; ++i ) <span class="comment">// i = 0 的情况是为了保证空串是否能被匹配</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= plen; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>]; <span class="comment">// 默认前面的字符不使用的情况</span></span><br><span class="line">                    <span class="keyword">if</span>( match(s, p, i, j - <span class="number">1</span>) )</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = dp[i][j] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>( match(s, p, i, j) )</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[slen][plen];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(String s, String p, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 不直接用 char a,b 是因为 i = 0 的可能</span></span><br><span class="line">        <span class="keyword">if</span>( i == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (p.charAt(j - <span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>) || (s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>这脑回路我是想不到</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-121-买卖股票的最佳时机</title>
    <url>/2021/10/21/LeetCode-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p>
<span id="more"></span>



<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>该题是比较明确的动态规划实例，所以需要考虑如何进行动态规划。</p>
<h3 id="一-传统动态规划形式"><a href="#一-传统动态规划形式" class="headerlink" title="一. 传统动态规划形式"></a>一. 传统动态规划形式</h3><p>创建一个二维数组 <code>dp[len + 1][len + 1]</code> 来存储当前元素 <code>i - 1</code> 和 <code>j - 1</code> 之间的差值（因为多出一行一列用来存储0值，以防止越界，所以当前的两个元素需要 <code>-1</code> 来获取），然后嵌套遍历数组，如果当前差值比 <code>dp[i-1][j]</code> 和 <code>dp[i][j-1]</code> 大，则取当前差值，否则取其余两个值的最大值。最终返回 <code>dp[len - 1][len]</code> 。</p>
<p>具体代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len+<span class="number">1</span>; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = prices[j-<span class="number">1</span>] - prices[i-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>( tmp &gt; dp[i-<span class="number">1</span>] &amp;&amp; tmp &gt; dp[i] )</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = tmp;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i-<span class="number">1</span>], dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len-<span class="number">1</span>][len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="将代码改进为只需要遍历一次即可"><a href="#将代码改进为只需要遍历一次即可" class="headerlink" title="将代码改进为只需要遍历一次即可"></a>将代码改进为只需要遍历一次即可</h3><p>仔细分析上述代码，发现三个值 <code>dp[i][j]</code> 、<code>dp[i-1][j]</code> 和 <code>dp[i][j-1]</code> 之间的关系是最值之间的比较，所以只需要标记两个最值 <code>minprice</code> 和 <code>maxprofit</code> 即可，存储到当前元素为止的最值，如果比最小值小，则替换最小值，否则比较最大值和当前差值的大小，取其中的最大值。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minprice = prices[<span class="number">0</span>], maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( prices[i] &lt; minprice )</span><br><span class="line">            &#123;</span><br><span class="line">                minprice = prices[i];</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                maxprofit = Math.max(maxprofit, (prices[i] - minprice));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 1370. 上升下降字符串</title>
    <url>/2021/11/12/LeetCode-1370-%E4%B8%8A%E5%8D%87%E4%B8%8B%E9%99%8D%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p><a href="https://leetcode-cn.com/problems/increasing-decreasing-string/">https://leetcode-cn.com/problems/increasing-decreasing-string/</a></p>
<span id="more"></span>

<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>因为是 <strong>字符的个数</strong> 计算，可以使用 <strong>固定大小的桶</strong> 来存放累加的个数，即大小为 26 的桶。</p>
<p>然后遍历原字符串，累加相应的字符下标 <code>c - &#39;a&#39;</code> ，之后按照规则，从前往后取，再从后往前取就行。注意，每取一次，减一，直到该元素为0。</p>
<p>具体代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sortString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] chars = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        String res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            ++chars[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(res.length() &lt; s.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(chars[i] &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    --chars[i];</span><br><span class="line">                    res += (<span class="keyword">char</span>)(i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">25</span>; i &gt;= <span class="number">0</span>; --i )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( chars[i] &gt; <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    --chars[i];</span><br><span class="line">                    res += (<span class="keyword">char</span>)(i + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>桶计数</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 142. 环形链表 II</title>
    <url>/2022/01/26/LeetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>使用 <code>HashSet</code> 存已经遍历过的节点，第一个二次遍历的节点就是入口结点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( head != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( !set.add(head) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>这道题的重点是获取入口节点，但是快慢指针重合的第一个节点不一定是这个入口结点。下面进行简单的推导：</p>
<p><img src="/LeetCode-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-II.assets/142_fig1.png" alt="引用官方图"></p>
<p><em><u>[上图引用自官方题解]</u></em></p>
<p>上图假设快慢指针在紫色圆点出重合，此时慢指针走过 <code>a + b</code>，快指针走过 <code>a + n(b + c) + b</code>。<br>$$<br>\begin{cases}<br>fast &#x3D; a + n(b + c) + b\<br>slow &#x3D; a + b\<br>fast &#x3D; 2 * slow<br>\end{cases}<br>$$<br>上述方程组可以推导出：<br>$$<br>\begin{align*}<br>&amp;\qquad a + n(b + c) + b &#x3D; 2(a + b)\<br>&amp;&#x3D;&gt; a + (n + 1)b + nc &#x3D; 2a + 2b\<br>&amp;&#x3D;&gt; a &#x3D; c + (n - 1)(b + c)<br>\end{align*}<br>$$<br>也就是，将指针从 <code>head</code> 开始，<code>head = head.next; slow = slow.next</code> ，这二者第一次重合的节点为入口结点。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( slow == <span class="keyword">null</span> || fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;<span class="keyword">while</span>(slow != fast);</span><br><span class="line">        <span class="keyword">if</span>( slow == fast )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( head != slow )</span><br><span class="line">            &#123;</span><br><span class="line">                head = head.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 139. 单词拆分</title>
    <url>/2022/01/25/LeetCode-139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/word-break/">https://leetcode-cn.com/problems/word-break/</a></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>​        一开始的思路是逐个计算每个 <code>word</code> 出现在字符串的次数，然后加上长度，等于字符串长度就看成是可以拼接。但是这种思路的实现较为复杂，就没有实现。</p>
<p>​        可以换另一种思考方式，不求时间复杂度的优化，使用动态规划进行嵌套查询，遍历字符串的元素，将每个元素作为一个单词的截至字符，从头开始查是否存在到当前元素位置的字符串能够拼接成功。边界条件为：空串默认可以拼接。</p>
<p>具体代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length() + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;   <span class="comment">// 空串为 true</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.length(); ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( dp[j] &amp;&amp; wordDict.contains(s.substring(j, i)) )</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 145. 二叉树的后序遍历</title>
    <url>/2021/11/01/LeetCode-145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/</a></p>
<span id="more"></span>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>涉及到二叉树的遍历问题，自然是考虑 <strong>两种方式，递归和迭代</strong> 。</p>
<h3 id="一-递归"><a href="#一-递归" class="headerlink" title="一. 递归"></a>一. 递归</h3><p>需要知道一点：如果将数组作为参数传递，传递的是引用值，也就是不需要返回，在作为参数的函数中增删了元素，在作为定义该数组的函数中，也会相应的增删元素，也就是 <strong>实时</strong> 。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        getPostTra(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPostTra</span><span class="params">( TreeNode root, List&lt;Integer&gt; res )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getPostTra(root.left, res);</span><br><span class="line">        getPostTra(root.right, res);</span><br><span class="line">        res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二-迭代"><a href="#二-迭代" class="headerlink" title="二. 迭代"></a>二. 迭代</h3><ol>
<li>首先定义一个 <code>ArrayList</code> 存放最终的结果，定义一个 <code>Stack</code> 存放向左遍历时经过的节点，定义一个 <code>pre</code> 节点存放某个已经无法再遍历的节点，建立这个节点的原因是防止重复遍历；</li>
<li>向左遍历，直到出现 <code>null</code> ，然后判断当前节点的右子节点是否为 <code>null</code> 或者是否已经遍历过自己的右子节点，前者是为了确保该节点是这条支线上的最后一个节点，后者是为了保证已经遍历过右子节点，因为在左子节点为 <code>null</code> 的情况下，只要是两个情况出现任意一个，都可以保证当前节点是没有遍历过的最后一个节点；</li>
<li>之后就按照这个规则遍历，直到头节点也存储到数组成功，遍历成功。</li>
</ol>
<p>具体代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( !stack.empty() || root != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( root != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                stack.add(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>( root.right == <span class="keyword">null</span> || root.right == pre )</span><br><span class="line">            &#123;</span><br><span class="line">                res.add(root.val);</span><br><span class="line">                pre = root;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                stack.add(root);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
        <tag>迭代</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 15. 三数之和</title>
    <url>/2022/01/04/LeetCode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/3sum/">https://leetcode-cn.com/problems/3sum/</a></p>
<span id="more"></span>



<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用双指针解决该题，问题是这个双指针该怎么用，因为需要获取所有满足为0的三元数组，所以固定一个元素，取头尾指针的方法行不通，可以考虑固定两个元素，然后动态遍历第三个元素。即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; ++i )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>( i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] )</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n - <span class="number">1</span>; ++j )</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>( j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>] )</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">int</span> k = j + <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">while</span>( k &lt; len )</span><br><span class="line">           &#123;</span><br><span class="line">               ......</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，因为相同元素回得到相同的答案，所以需要对每个固定元素去重，即上述代码中的 <code>if语句</code> 。</p>
<p>但是这种方式还是会超出时间限制，所以需要对循环进行优化。因为前两个固定元素没有优化的空间，所以需要考虑第三个元素的优化。</p>
<p>通过观察可以知道，在非降序数组中，固定了第一个元素，第二个元素越大，所需要的第三个元素理应更小，且会比上一个确定的第三个元素更小，所以可以优化第三个元素在遍历一次 <code>i</code> 的时候，<code>k</code> 也只遍历一次。即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; ++i )</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>( i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] )</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 将 k 提出来，在本次j遍历完，k也只遍历一次</span></span><br><span class="line">       <span class="keyword">int</span> k = n - <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n - <span class="number">1</span>; ++j )</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>( j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>] )</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">while</span>( j &lt; k )</span><br><span class="line">           &#123;</span><br><span class="line">               ......</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>( len &lt; <span class="number">3</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> k = len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len - <span class="number">1</span>; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>] )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>( j &lt; k &amp;&amp; nums[i] + nums[j] + nums[k] &gt; <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    --k;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( j &gt;= k )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( nums[i] + nums[j] + nums[k] == <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(nums[i], nums[j], nums[k])));</span><br><span class="line">                    <span class="comment">// break;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 152. 乘积最大子数组</title>
    <url>/2022/01/26/LeetCode-152-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">https://leetcode-cn.com/problems/maximum-product-subarray/</a></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目本身实现动态规划是大致思路，主要看怎么实现 O(n) 时间复杂度的动态规划。</p>
<h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><p>以每个元素为连续子数组的第一个元素，遍历相乘取最大值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( nums.length == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxpro = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> curpro = nums[i];</span><br><span class="line">            maxpro = Math.max(maxpro, curpro);</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                curpro *= nums[j];</span><br><span class="line">                maxpro = Math.max(maxpro, curpro);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxpro;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="一次循环"><a href="#一次循环" class="headerlink" title="一次循环"></a>一次循环</h3><p>相乘的连续子数组与一般的连续子数组的区别在于：一般连续子数组取的每个小部分都是最大值；但是相乘的连续子数组可能小部分是最小值，也可能是最大值。所以我们需要同时获取以当前元素为连续子数组的最后一个元素的最大积和最小积。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( nums.length == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> curmax = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> curmin = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxpro = curmax;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmpmax = curmax, tmpmin = curmin;</span><br><span class="line">            curmax = Math.max(Math.max(nums[i], tmpmax * nums[i]), tmpmin * nums[i]);</span><br><span class="line">            curmin = Math.min(Math.min(nums[i], tmpmax * nums[i]), tmpmin * nums[i]);</span><br><span class="line">            maxpro = Math.max(maxpro, curmax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxpro;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 206. 反转链表</title>
    <url>/2021/10/29/LeetCode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/reverse-linked-list/">https://leetcode-cn.com/problems/reverse-linked-list/</a></p>
<span id="more"></span>



<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="一-链表"><a href="#一-链表" class="headerlink" title="一. 链表"></a>一. 链表</h3><p>这是一种常规方法：</p>
<ol>
<li>创建两个指针 <code>pre</code> 和 <code>next</code> 表示当前头节点翻转过来后的前一个节点和后一个节点，即 <strong>pre &#x3D; NULL</strong> ，<strong>next &#x3D; head.next</strong> ，这样也就要求了，如果 <code>head == null || head.next == null</code>，可以直接 <code>return head</code>；</li>
<li>将当前节点的前后节点互换后，往下逐一遍历；</li>
<li>直到 <code>pre == null</code> ，也就是没有需要往前的节点，这时候，退出循环，将当前节点的 <code>next</code> 连接上后，完成反转。</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode next = <span class="keyword">null</span>, pre = head.next;</span><br><span class="line">        <span class="keyword">while</span>( pre != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            head.next = next;</span><br><span class="line">            next = head;</span><br><span class="line">            head = pre;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二-递归"><a href="#二-递归" class="headerlink" title="二. 递归"></a>二. 递归</h3><p>这种方法只需要注意一个问题，就变得非常简单：<strong>就算递归将 node.next 的位置转换了，node.next 也不会有变化。</strong></p>
<p>理解如下：有一个链表如下：<code>a -&gt; b -&gt; c -&gt; NULL</code> ，当前节点为 <code>a</code> ，自然， <code>a.next == b</code> 成立，此时有一个递归如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">( ListNode head )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode node = test(head.next);</span><br><span class="line">    node.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果仅让这个函数递归到 <code>b</code> 节点久结束，此时，<code>a</code> 节点的 <code>next</code> 依然指向 <code>b</code> ，而非 <code>c</code> 。</p>
<p>如上所述，得到的递归方法如下：</p>
<ol>
<li>这种方式要求 <code>head != null &amp;&amp; head.next != null</code>， 否则直接 <code>return head</code>；</li>
<li>按上述的例子假设，<code>b</code> 节点开头的后续节点已经排好序，此时 <code>b</code> 节点应该是最后一个非空节点，而 <code>b</code> 又是当前节点 <code>a</code> 的下一个节点，所以只需要让当前节点的下一个节点的下一个节点等于自己即可：<code>a.next.next = a</code> &#x3D;&#x3D;&#x3D; <code>b.next = a</code>。</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode node = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 160. 相交链表</title>
    <url>/2022/01/28/LeetCode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表的思想很明显，先遍历一个链表，存储其中的节点，再遍历另一个链表，第一个在表中查到的节点就是相交的起始节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( headA != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            set.add(headA);</span><br><span class="line">            headA = headA.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( headB != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( set.contains(headB) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> headB;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                headB = headB.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nul</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>整个结构简单来看就是三个部分：链表A不重合的部分节点数为a，链表B不重合的部分节点数为b，重合的部分节点数为c。可以得到下述等式：<br>$$<br>a + c + b &#x3D;&#x3D; b + c + a<br>$$<br>也就是设置两个指针 <code>pa = headA</code> 和 <code>pb = headB</code> 开始遍历，如果 <code>a == b</code> ，那么同时遍历完两侧指针没有重合，就说明 <code>c == 0</code> ，即无重合；如果 <code>a != b</code> ，同时遍历，当 <code>pa</code> 遍历 <code>a + c + b</code> 时，<code>pb</code> 一定也遍历了 <code>b + c + a</code> ，此时两个指针不是同时为 <code>null</code> ，必定重合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( headA == headB )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> headA;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pa = headA, pb = headB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( pa != <span class="keyword">null</span> || pb != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( pa != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                pa = pa.next;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pa = headB;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( pb != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                pb = pb.next;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pb = headA;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( pa == pb )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> pa;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 207. 课程表</title>
    <url>/2022/02/01/LeetCode-207-%E8%AF%BE%E7%A8%8B%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/course-schedule/">https://leetcode-cn.com/problems/course-schedule/</a></p>
<span id="more"></span>



<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>**借鉴：<a href="https://www.cnblogs.com/bigsai/p/11489260.html">拓扑排序详解与实现</a>**，这个文章已经解释的很详细，下面简单总结一下自己的理解。</p>
<p><img src="/LeetCode-207-%E8%AF%BE%E7%A8%8B%E8%A1%A8.assets/20190904123849168.png" alt="侵删"></p>
<p>​        首先存储所有节点以及该节点指向的所有节点，可以使用 <code>ArrayList</code> 存储所有被指向的节点。</p>
<p>​        其次遍历获取没有被指向的节点，也就是图中的 1、2，将这些节点存入队列或栈。可以使用数组来存放每个节点被指向的次数，如果指向它的前驱节点被删除，就将次数减一，当次数为0就存入队列或栈。</p>
<p>​        重复上述过程，直到最后一个节点被删除，表示这个图遍历完成，或者不存在环。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>遍历所有节点，以 <code>Map(int curnode, List&lt;Integer&gt; prenode)</code> 形式存储；</li>
<li>然后创建一个 <code>prenodessize</code> 数组来存储每个节点被指向的次数；</li>
<li>创建一个队列，存储被指向次数为0的节点；</li>
<li>每次出一个节点，将这个节点指向的所有节点的被指向次数减一，如果这个被指向的节点的次数为0，存入队列；</li>
<li>上述以此类推，当队列为空，退出循环；</li>
<li>最后判断最先创建的 <code>map.size()</code> 是否为0，如果不为0，表示存在类似 <code>[[1,0],[0,1]]</code> 的环；否则不存在环。</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( numCourses == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] precoursesize = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        Map&lt;Integer, List&lt;Integer&gt;&gt; courses = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; curcourses = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 map 和 precoursesize</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( courses.containsKey(prerequisites[i][<span class="number">1</span>]) )</span><br><span class="line">            &#123;</span><br><span class="line">                courses.get(prerequisites[i][<span class="number">1</span>]).add(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                courses.put(prerequisites[i][<span class="number">1</span>], <span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(prerequisites[i][<span class="number">0</span>])));</span><br><span class="line">            &#125;</span><br><span class="line">            ++precoursesize[prerequisites[i][<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化 curcourses</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( precoursesize[i] == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                curcourses.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( !curcourses.isEmpty() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> curcourse = curcourses.poll();</span><br><span class="line">            <span class="keyword">if</span>( !courses.containsKey(curcourse) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;Integer&gt; course = courses.get(curcourse);</span><br><span class="line">            courses.remove(curcourse);</span><br><span class="line">            <span class="comment">// 对当前被连接的课程减1</span></span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> c : course )</span><br><span class="line">            &#123;</span><br><span class="line">                --precoursesize[c];</span><br><span class="line">                <span class="keyword">if</span>( precoursesize[c] == <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    curcourses.offer(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( courses.size() != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 208. 实现 Trie (前缀树)</title>
    <url>/2022/02/08/LeetCode-208-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">https://leetcode-cn.com/problems/implement-trie-prefix-tree/</a></p>
<span id="more"></span>



<h2 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h2><p>首先需要了解多叉树的结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    VALUE_TYPE value; <span class="comment">// 节点值</span></span><br><span class="line">    TreeNode[] children; <span class="comment">// 所有孩子节点</span></span><br><span class="line">    <span class="comment">// 创建一个它的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(VALUE_TYPE value, <span class="keyword">int</span> children_size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        children = <span class="keyword">new</span> TreeNode[children_size];</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么可以推出字典树的结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isEnd; <span class="comment">// 当前节点是否为一个字符串的结尾</span></span><br><span class="line">    Trie[] children; <span class="comment">// 当前节点的孩子节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        children = <span class="keyword">new</span> Trie[<span class="number">26</span>]; <span class="comment">// 默认每个节点的孩子节点都包含26个字母</span></span><br><span class="line">        isEnd = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体的解题思路"><a href="#具体的解题思路" class="headerlink" title="具体的解题思路"></a>具体的解题思路</h3><p>上述推出字典树的结构，接着实现其中的方法：Insert、search、startWith。其实就是两个方法：插入、查找前缀，其中如果前缀的最后一个字母的 isEnd 值为 true，就表示存在这个字符串，否则仅存在前缀。</p>
<ol>
<li>插入字符串：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    Trie node = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>( node.children[index] == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            node.children[index] = <span class="keyword">new</span> Trie();</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    node.isEnd = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Trie node = this</code> ，获取以当前对象为头节点的引用。开始遍历字符串。代码中可以明显看出，判断一个节点是否存在某个孩子节点只需要判断这个孩子节点是否被实例化。同理，如果想要扩展一个孩子节点，也只需要将这个孩子节点实例化即可。最终对这个字符串的最后一个字符对应的 isEnd 变量赋值为 true ，这个字符串插入成功。</p>
<ol start="2">
<li>查找前缀：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Trie <span class="title">isPrefix</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">    Trie node = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>( node.children[index] == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.children[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回值设置为 <code>Trie</code> 类型返回这个前缀最后一个字符对应的节点，是为了判断这个节点是否是这个字符串的结尾。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    Trie[] children;</span><br><span class="line">    <span class="keyword">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        children = <span class="keyword">new</span> Trie[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>( node.children[index] == <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie node = isPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="keyword">null</span> &amp;&amp; node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isPrefix(prefix) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Trie <span class="title">isPrefix</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        Trie node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>( node.children[index] == <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Trie obj = new Trie();</span></span><br><span class="line"><span class="comment"> * obj.insert(word);</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.search(word);</span></span><br><span class="line"><span class="comment"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 221. 最大正方形</title>
    <url>/2021/12/24/LeetCode-221-%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximal-square/">https://leetcode-cn.com/problems/maximal-square/</a></p>
<span id="more"></span>



<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>不能放图，可以简单的想象，一个右下角为 <code>(i, j)</code> 边长为3的正方形，有三个边长为2的正方形组成，其右下角坐标是：<code>(i - 1, j)、(i, j - 1)、(i - 1, j - 1)</code> ，如果其中一个子正方形的面积为0，都不能构成以当前 <code>(i, j)</code> 为右下角的正方形。如果构成当前右下角的正方形，则子边长加一，所以综上，可以得出转移方程：<br>$$<br>dp[i][j] &#x3D; Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1<br>$$<br>已知当 <code>i == 0 || j == 0</code> 最多只会有边长为1的正方形，当 <code>matrix[i][j] == 0</code> 的时候，不会构成正方形：<code>dp[i][j] = 0</code> ，可以得到如下最终结论：<br>$$<br>dp[i][j] &#x3D; \begin{cases}<br>matrix[i][j] - ‘0’ &amp;\text{i &#x3D;&#x3D; 0 || j &#x3D;&#x3D; 0}\<br>0 &amp;\text{matrix[i][j] &#x3D;&#x3D; ‘0’}\<br>Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 &amp;\text{除了上述条件}\<br>\end{cases}<br>$$<br>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalSquare</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( i == <span class="number">0</span> || j == <span class="number">0</span> || matrix[i][j] == <span class="string">&#x27;0&#x27;</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = matrix[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], Math.min(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                maxlen = Math.max(maxlen, dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen * maxlen;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>这脑回路我是想不到</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 234. 回文链表</title>
    <url>/2022/02/09/LeetCode-234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">https://leetcode-cn.com/problems/palindrome-linked-list/</a></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="遍历存储，暴力解法"><a href="#遍历存储，暴力解法" class="headerlink" title="遍历存储，暴力解法"></a>遍历存储，暴力解法</h3><p>遍历链表，将节点值存储到可变数组ArrayList中，在数组中判断。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head.next == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; val = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( head != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            val.add(head.val);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = val.size() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( i &lt; j )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( val.get(i) != val.get(j) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="部分递归"><a href="#部分递归" class="headerlink" title="部分递归"></a>部分递归</h3><p>递归的回溯部分可以看成是逆序遍历链表，所以可以先遍历到链表的最后一个节点，然后存储一个不在递归内的头节点，每次回退都比较当前回退的节点值和从头结点开始往下遍历的节点值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> ListNode front;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        front = head;</span><br><span class="line">        <span class="keyword">return</span> reverseListNode(head);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">reverseListNode</span><span class="params">(ListNode head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( !reverseListNode(head.next) || head.val != front.val )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            front = front.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="快慢指针-反转链表"><a href="#快慢指针-反转链表" class="headerlink" title="快慢指针 + 反转链表"></a>快慢指针 + 反转链表</h3><p>回文链表可以看程前半部分和后半部分。通过快慢指针获取前半部分的最后一个节点，然后反转后半部分的链表，最后获取两个部分的头节点依次比较。</p>
<p>有一个小点：奇数节点的中间节点算哪边？都可以，只要判断短的一边是否为null就可以。</p>
<p>注意：因为这种操作会修改链表，所以在并发操作需要锁。一般情况下，不是程序要求，最好不要修改链表结构，如果修改了，最后需要将其恢复原样。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode frontEnd = endOfFrontHelf(head);</span><br><span class="line">        ListNode secondStart = reverseList(frontEnd.next); </span><br><span class="line">        ListNode front = head, second = secondStart;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( secondStart != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( front.val != secondStart.val )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            front = front.next;</span><br><span class="line">            secondStart = secondStart.next;</span><br><span class="line">        &#125;</span><br><span class="line">        reverseList(second);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取前半部分的最后一个节点，如果是奇数个节点，中间节点应该属于前半部分</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">endOfFrontHelf</span><span class="params">( ListNode head )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span>( fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>, next = head.next;</span><br><span class="line">        <span class="keyword">while</span>( head != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">            <span class="keyword">if</span>( next != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                next = next.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 236. 二叉树的最近公共祖先</title>
    <url>/2022/02/11/LeetCode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a></p>
<span id="more"></span>



<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先分析两个节点出现的可能性：</p>
<ol>
<li>其中一个为祖先节点；</li>
<li>都为祖先节点的子孙节点。</li>
</ol>
<p>可以递归当前节点的左右节点：</p>
<ol>
<li>如果左右节点中不包含指定节点，判断当前节点是否是其中一个指定节点，是就返回该节点，否则就返回空；</li>
<li>如果左右节点中其中一个包含指定节点，返回这个节点，这里不能返回当前节点，因为有可能这个其中一个包含的是所有指定的节点，返回的这个子节点可能是最近的公共祖先；</li>
<li>如果左右子节点都包含指定节点，就说明当前节点为最近公共祖先，返回当前节点。</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (root == p || root == q) ? root : <span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( left == <span class="keyword">null</span> || right == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( root == p || root == q )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 239. 滑动窗口最大值</title>
    <url>/2022/02/15/LeetCode-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">https://leetcode-cn.com/problems/sliding-window-maximum/</a></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><p>优先队列其实就是堆，这里维护的是大顶堆，而堆的底层实现的是 <code>PriorityQueue</code> 。</p>
<p>由此，可以实现一个 <code>PriorityQueue</code>，因为其中涉及比较的内容包括下标和值，所以需要存两个元素，或者将其列为一个数组 <code>new int[]&#123;nums[i], i&#125;</code>，所以需要自定义一个 <code>Comparator</code> 排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> p1[], <span class="keyword">int</span> p2[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1[<span class="number">0</span>] != p2[<span class="number">0</span>] ? p2[<span class="number">0</span>] - p1[<span class="number">0</span>] : p2[<span class="number">1</span>] - p1[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>之后每遍历到一个元素就存进去，取出来的时候要取出下标在 <code>k</code> 区间内的最大值，也就是说如果当前最大值，也就是 <code>queue.peek()[1] &lt;= i - k</code> 时，可以永久删除了。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> p1[], <span class="keyword">int</span> p2[])</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> p1[<span class="number">0</span>] != p2[<span class="number">0</span>] ? p2[<span class="number">0</span>] - p1[<span class="number">0</span>] : p2[<span class="number">1</span>] - p1[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>( ; i &lt; k; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        res[r++] = queue.peek()[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>( ; i &lt; nums.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;nums[i], i&#125;);</span><br><span class="line">            <span class="keyword">while</span>( queue.peek()[<span class="number">1</span>] &lt;= i - k )</span><br><span class="line">            &#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            res[r++] = queue.peek()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>对第一个解法优化：单调队列一般指的是满足单调性递增或递减的双端队列。仅存储元素的下标，需要保证其中包含的下标对应的元素值是单调递减的，也就是遇上 <code>nums[deque.peek()] &lt;= nums[i]</code> 则会弹出。</p>
<ol>
<li><code>deque.size() &lt;= k</code> 是为了维护 <code>k</code> 区间，可以保证单调队列中的所有元素都不超出范围。</li>
<li>当 <code>deque.size() &gt;= k</code> 需要弹出头元素，因为后续需要加入一个元素，所以其实应该是在 <code>deque.size() == k</code> 的时候弹出头元素，保证一次遍历结束时 <code>deque.size() + 1 == k</code> 。</li>
<li>因为是单调递减的，所以从尾部插入的时候，需要保证插入的是最小值，否则就弹出之前的值，这里能够确定不会误删之后的最大值。</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSlidingWindow(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len - k + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>( ; i &lt; k; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( !deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt;= nums[i] )</span><br><span class="line">            &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 赋值</span></span><br><span class="line">        res[r++] = nums[deque.peekFirst()];</span><br><span class="line">        <span class="keyword">for</span>( ; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从头删除不满足k区间的节点</span></span><br><span class="line">            <span class="keyword">while</span>( !deque.isEmpty() &amp;&amp; deque.peekFirst() &lt;= i - k )</span><br><span class="line">            &#123;</span><br><span class="line">                deque.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从尾增加当前节点，保证是递减的</span></span><br><span class="line">            <span class="keyword">while</span>( !deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt;= nums[i] )</span><br><span class="line">            &#123;</span><br><span class="line">                deque.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerLast(i);</span><br><span class="line">            res[r++] = nums[deque.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>PriorityQueue</tag>
        <tag>Deque</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 279. 完全平方数</title>
    <url>/2022/02/14/LeetCode-279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/perfect-squares/">https://leetcode-cn.com/problems/perfect-squares/</a></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用动态规划遍历到当前 i 之内（包括当前 i ）的所有可能的内容。使用嵌套循环，因为从 1 到 n 的每一个元素都会被重复使用，所以无法省略数组为单一的值。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">1</span>; j * j &lt;= i; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                min = Math.min(min, dp[i - j * j]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = min + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dp[i] = min + 1</code> 中的 <code>+1</code> 的操作是因为 <code>j * j</code> 为一个完全平方的整数。</p>
]]></content>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 283. 移动零</title>
    <url>/2022/02/15/LeetCode-283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/move-zeroes/">https://leetcode-cn.com/problems/move-zeroes/</a></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用两个指针，都从头出发，<code>right</code> 指向第一个非零元素的时候换。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( right &lt; len )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[right] != <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                swap(nums, left, right);</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 322. 零钱兑换</title>
    <url>/2021/12/21/LeetCode-322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="记忆化搜索算法"><a href="#记忆化搜索算法" class="headerlink" title="记忆化搜索算法"></a>记忆化搜索算法</h2><p>是一种自顶而下的方法，解题思路类似树状图的结构。</p>
<span id="more"></span>

<p>记忆化搜索实际上是递归实现的，但是递归的过程中有许多结果是被反复计算的，这样会大大降低运算的效率。而记忆化搜索是在递归过程中，将已经计算出的结果保存起来，当之后的运算用到的时候直接取出结果，避免重复运算，因此极大的提高了运算效率。</p>
<p>以如下题为例。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/coin-change/">https://leetcode-cn.com/problems/coin-change/</a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h3><p>这种方法算是暴力解题了，很容易超出时间限制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( coins.length == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        findWay(coins, amount, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res == Integer.MAX_VALUE ? -<span class="number">1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findWay</span><span class="params">( <span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount, <span class="keyword">int</span> count )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( amount &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( amount == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            res = Math.min(res, count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            findWay(coins, amount - coins[i], count + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-记忆化搜索"><a href="#2-记忆化搜索" class="headerlink" title="2. 记忆化搜索"></a>2. 记忆化搜索</h3><p>​        上述递归的过程中，重复性的操作是在 <code>findWay</code> 方法中的 <code>for循环</code> 会产生重复内容，进行重复计算，可以将这些重复的数值存进数组  <code>count</code> 中，这样一旦当前操作被记录过，就不需要再次记录了。比如上述 <code>amount</code> 可能会有多种情况相减到相同的结果，这时候后续的遍历操作就是重复性操作了。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( coins.length == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> findWay(coins, amount, <span class="keyword">new</span> <span class="keyword">int</span>[amount]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findWay</span><span class="params">( <span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount, <span class="keyword">int</span>[] count )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( amount &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( amount == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( count[amount - <span class="number">1</span>] != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> count[amount - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res = findWay(coins, amount - coins[i], count);</span><br><span class="line">            <span class="keyword">if</span>( res &gt;= <span class="number">0</span> &amp;&amp; res &lt; min )</span><br><span class="line">            &#123;</span><br><span class="line">                min = res + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count[amount - <span class="number">1</span>] = min;</span><br><span class="line">        <span class="keyword">return</span> count[amount - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-动态规划"><a href="#3-动态规划" class="headerlink" title="3. 动态规划"></a>3. 动态规划</h3><p>本题的状态转移方程很好得出：<br>$$<br>F(i) &#x3D; min_{j&#x3D;0…n−1}<br>F(i−c_j)+1<br>$$<br>可以借鉴背包问题解决。</p>
<p>基本思路是：</p>
<ol>
<li>首先定义一个容量长的数组 <code>dp[amount + 1]</code> ，并对其中的元素全部赋最大值 <code>MAX_VALUE = amount + 1</code> ，类似于 <code>Integer.MAX_VALUE</code>；</li>
<li>由于 <code>amount == 0</code> 时 <code>count == 0</code> ，所以 <code>dp[0] = 0</code> ；</li>
<li>后续只需要对容量 <code>1 ... amount</code> 取最小数量的硬币即可；</li>
<li>最后判断 <code>dp[amount]</code> 是否被赋值，没有被赋值，就说明硬币组合不可能有该数字，返回 <code>-1</code> ，否则返回 <code>dp[amount]</code> 。</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 347. 前K个高频元素</title>
    <url>/2022/02/19/LeetCode-347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">https://leetcode-cn.com/problems/top-k-frequent-elements/</a></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>​        涉及到计算元素个数，并且元素值没有固定范围，使用 <code>HashMap</code> 存储。已知时间复杂度为 <code>O(nlogn)</code> 的算法有归并排序和堆排序，相比于堆排序这种必须全部排序的算法，堆排序这种可以仅排序指定大小为 <code>k</code> 的算法更适合在此处，时间复杂度会从 <code>O(nlogn)</code> 优化为 <code>O(nlogk)</code> 。</p>
<p>​        具体的操作就是构建小顶堆，已知 <code>PriorityQueue</code> 的底层就是堆排序，所有可以直接使用它。先初始化堆，当 <code>size() == k</code> 时判断队首元素的个数是否小于当前元素的个数，如果小于，就说明此时队首元素不再属于k个元素，将其删掉，插入当前元素。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">// HashMap存储个数</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> num : nums )</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// PriorityQueue建小顶堆</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">1</span>] - o2[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>( Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( queue.size() == k )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( queue.peek()[<span class="number">1</span>] &lt; entry.getValue() )</span><br><span class="line">                &#123;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;entry.getKey(), entry.getValue()&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存储前k个元素</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            res[i] = queue.poll()[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 377. 组合总和 Ⅳ</title>
    <url>/2021/12/29/LeetCode-377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A3/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/combination-sum-iv/">https://leetcode-cn.com/problems/combination-sum-iv/</a></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>首先需要知道边界条件：<code>target = 0</code> 时只有一种情况，就是不使用数组元素的时候，这种情况返回1；<code>target &lt; 0</code> 时返回0，即不会有这种情况，因为数组元素均 <code>&gt;= 1</code> ，所以就算不使用数组元素，最小也是0，不可能会存在使得 <code>target &lt; 0</code> 的排列方法；</li>
<li>计算区间 <code>[1, target]</code> 内的所有整数，遍历所有数组元素满足当前tar的排列。</li>
</ol>
<h3 id="1-记忆化搜索"><a href="#1-记忆化搜索" class="headerlink" title="1. 记忆化搜索"></a>1. 记忆化搜索</h3><p>记忆化搜索可以说是递归调用的优化版本，即使用一个数组来存储已经遍历过的元素，此处将 <code>target</code> 看作数组 <code>tar = &#123;1, ... , target&#125;</code> ，记录每个 <code>tar[i]</code> 的结果，已经遍历过的元素不需要重复遍历，只需要对没有遍历过的 <code>tar[i]</code> 遍历计算 <code>nums</code> 数组的元素即可，最终将最终结果 <code>tar[target]</code> 返回，即第一轮遍历的结果。</p>
<p>这里创建一个 <code>count</code> 数组存放每一个 <code>tar[i]</code> 遍历的结果，默认值为-1，因为有可能 <code>tar[i]</code> 遍历的结果就算0，如果默认 <code>count[i]</code> 为0，还是会导致很多重复计算，最终超时。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        count[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            count[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getCombination(count, nums, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCombination</span><span class="params">( <span class="keyword">int</span>[] count, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> target )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( target &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( count[target] != -<span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> count[target];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            cnt += getCombination(count, nums, target - nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        count[target] = cnt;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2. 动态规划"></a>2. 动态规划</h3><p>该方法其实就是记忆化搜索的迭代版本，使用嵌套循环模仿递归执行，其中 <code>i</code> 即 <code>tar[i]</code> ，j遍历 <code>nums</code> ，由此得出每一个 <code>i</code> 的排列结果。</p>
<p>此处 有一个 <code>dp[i] += dp[i - nums[j]]</code> ，因为 <code>tar[i]</code> 的排列结果是建立在 <code>tar[0] ~ tar[i - 1]</code> 上的，比如 <code>tar[2] = 2</code> ，前面的值为 <code>dp[0] = 1; dp[1] = 1</code> ，确定一个元素 <code>i - 1 == 1</code> ，然后这个元素可以放在 <code>tar[1]</code> 元素的排列结果后，<code>dp[1]</code> 的排列记过是：<code>&#123;1&#125;</code> 构成针对于 <code>tar[2]</code> 的结果集：<code>&#123;1,1&#125;</code> ，以此类推，就可以理解为什么只需要加上 <code>dp[i - nums[j]]</code> 就可以。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( i - nums[j] &gt;= <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] += dp[i - nums[j]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>记忆化搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 36. 有效的数独</title>
    <url>/2021/10/26/LeetCode-36-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/valid-sudoku/">https://leetcode-cn.com/problems/valid-sudoku/</a></p>
<span id="more"></span>



<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="一-哈希表"><a href="#一-哈希表" class="headerlink" title="一. 哈希表"></a>一. 哈希表</h3><p>提到哈希表，我首先想到的是 <code>Map</code> 操作：</p>
<ol>
<li><p>创建 <code>HashMap&lt;Integer, ArrayList&lt;Integer&gt;&gt;</code> 对象存储，使用 <code>ArrayList</code> 是为了方便查重：</p>
<p>下标 <code>0</code> 存储每行的元素，下标 <code>1</code> 存储每列元素，<code>i</code> 值既为遍历一行的 <code>行</code> ，也是遍历一列的 <code>列</code> ，最外层指针每次往下移动一行，行列下标对应的数组均清空重建。</p>
</li>
<li><p>依次遍历每个元素：</p>
<p>下标 <code>2 - 10</code> 存储9个 <code>3x3</code> 的子宫格。使用 <code>i / 3 * 3 + j / 3 + 2</code> 的下标来定位是哪一个子宫格。</p>
<p>注意：由于子宫格不会清空，所以需要保证不会重复存储相同下标的值，则遍历行时需要保证行列交叉之前不使用：<code>if j &lt; i then continue;</code> ，遍历列时保证行列交叉及之前不使用：<code>if k &lt;= i then continue;</code></p>
</li>
<li><p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, ArrayList&lt;Integer&gt;&gt; list = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">11</span>; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            list.put(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            list.put(<span class="number">0</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( board[i][j] == <span class="string">&#x27;.&#x27;</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> tmp = board[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">int</span> level = (i / <span class="number">3</span>) * <span class="number">3</span> + j / <span class="number">3</span> + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>( list.get(<span class="number">0</span>).contains(tmp) )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    list.get(<span class="number">0</span>).add(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( j &lt; i )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( list.get(level).contains(tmp) )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    list.get(level).add(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            list.put(<span class="number">1</span>, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">9</span>; ++k )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( board[k][i] == <span class="string">&#x27;.&#x27;</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> tmp = board[k][i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">int</span> level = (k / <span class="number">3</span>) * <span class="number">3</span> + i / <span class="number">3</span> + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>( list.get(<span class="number">1</span>).contains(tmp) )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    list.get(<span class="number">1</span>).add(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( k &lt;= i )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( list.get(level).contains(tmp) )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    list.get(level).add(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="二-矩阵"><a href="#二-矩阵" class="headerlink" title="二. 矩阵"></a>二. 矩阵</h3><p>因为 <code>9x9</code> 宫格的行列数已经确定，所以使用数组的形式存储三种条件的数据不会出现很大的资源浪费的情况。</p>
<ol>
<li><p>准备三个数组存储三种条件：<code>rows[9][9]</code>、<code>cols[9][9]</code>、<code>subs[3][3][9]</code>；</p>
</li>
<li><p>一次遍历数组中的所有元素：<code>board[i][j]</code> ，从而得到一个合法元素的下标值 <code>index = board[i][j] - &#39;0&#39; - 1</code>，<code>-1</code> 是因为下标从 <code>0</code> 开始；</p>
</li>
<li><p>遍历一个元素，则所有数组相应增加；</p>
</li>
<li><p>最后每次遍历都判断一次是否相应数组元素相加后是否 <code>&gt; 1</code>，只要有一个满足条件，则 <code>false</code>。</p>
</li>
<li><p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] rows = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">int</span>[][] cols = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">        <span class="keyword">int</span>[][][] subs = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> c = board[i][j];</span><br><span class="line">                <span class="keyword">if</span>( c != <span class="string">&#x27;.&#x27;</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> index = c - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;</span><br><span class="line">                    ++rows[i][index];</span><br><span class="line">                    ++cols[index][j];</span><br><span class="line">                    ++subs[i / <span class="number">3</span>][j / <span class="number">3</span>][index];</span><br><span class="line">                    <span class="keyword">if</span>( rows[i][index] &gt; <span class="number">1</span> || cols[index][j] &gt; <span class="number">1</span> || subs[i / <span class="number">3</span>][j / <span class="number">3</span>][index] &gt; <span class="number">1</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>刷题</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 39. 组合总和</title>
    <url>/2022/01/08/LeetCode-39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/combination-sum/">https://leetcode-cn.com/problems/combination-sum/</a></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这里简单的区分一下递归和回溯：递归就是直接或间接的调用自己，回溯相较于递归的区别，就是它有剪枝的功能，知道这条路走不通，会换另一条路走。</p>
<p>我一开始使用递归的思路解决：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        getCombination(candidates, target, res, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCombination</span><span class="params">( <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tmp )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( target &lt;= <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( target == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmp));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> can : candidates )</span><br><span class="line">        &#123;</span><br><span class="line">            tmp.add(can);</span><br><span class="line">            getCombination(candidates, target - can, res, tmp);</span><br><span class="line">            tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这种方法的结果是错的，相当于将结果内部全排序了。所以必须用到<strong>剪枝的思想</strong>。</p>
<p>应该对 <code>candidates</code> 数组升序排序，然后为了防止全排序，又因为元素可以重复，所以应该从当前下标开始遍历。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        getCombination(candidates, target, res, <span class="keyword">new</span> ArrayList&lt;&gt;(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCombination</span><span class="params">( <span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tmp, <span class="keyword">int</span> idx )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( target == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmp));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( ; idx &lt; candidates.length; ++idx )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( target - candidates[idx] &lt; <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmp.add(candidates[idx]);</span><br><span class="line">            getCombination(candidates, target - candidates[idx], res, tmp, idx);</span><br><span class="line">            tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 416. 分割等和子集</title>
    <url>/2021/11/05/LeetCode-416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">https://leetcode-cn.com/problems/partition-equal-subset-sum/</a></p>
<span id="more"></span>



<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这与0-1背包问题大同小异，所以应该先了解0-1背包问题的原理。</p>
<h3 id="一-0-1背包问题"><a href="#一-0-1背包问题" class="headerlink" title="一. 0-1背包问题"></a>一. 0-1背包问题</h3><p>0-1背包问题是典型的动态规划问题。问题如下：</p>
<blockquote>
<p>有n件物品，每件物品的重量为w[i]，价值为c[i]。现有一个容量为V的背包，问如何选取物品放入背包，使得背包内物品的总价值最大。其中每种物品都只有一件。</p>
<table>
<thead>
<tr>
<th align="center">编号i</th>
<th align="center">重量w[i]</th>
<th align="center">价格v[i]</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">4</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">9</td>
<td align="center">10</td>
</tr>
</tbody></table>
<p>背包容量 V &#x3D; 20。</p>
</blockquote>
<p>可以得到的过程表格如下：</p>
<table>
<thead>
<tr>
<th align="center">capacity &#x3D;&gt;</th>
<th>0</th>
<th align="center">1</th>
<th>2</th>
<th>3</th>
<th align="center">4</th>
<th align="center">5</th>
<th>6</th>
<th>7</th>
<th align="center">8</th>
<th align="center">9</th>
<th align="center">10</th>
<th align="center">11</th>
<th align="center">12</th>
<th align="center">13</th>
<th align="center">14</th>
<th align="center">15</th>
<th align="center">16</th>
<th align="center">17</th>
<th align="center">18</th>
<th align="center">19</th>
<th align="center">20</th>
</tr>
</thead>
<tbody><tr>
<td align="center">no items</td>
<td>0</td>
<td align="center">0</td>
<td>0</td>
<td>0</td>
<td align="center">0</td>
<td align="center">0</td>
<td>0</td>
<td>0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">w&#x3D;2,v&#x3D;3</td>
<td>0</td>
<td align="center">0</td>
<td>3</td>
<td>3</td>
<td align="center">3</td>
<td align="center">3</td>
<td>3</td>
<td>3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">w&#x3D;3,v&#x3D;4</td>
<td>0</td>
<td align="center">0</td>
<td>3</td>
<td>4</td>
<td align="center">4</td>
<td align="center">7</td>
<td>7</td>
<td>7</td>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">7</td>
</tr>
<tr>
<td align="center">w&#x3D;4,v&#x3D;5</td>
<td>0</td>
<td align="center">0</td>
<td>3</td>
<td>4</td>
<td align="center">5</td>
<td align="center">7</td>
<td>8</td>
<td>9</td>
<td align="center">9</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">12</td>
<td align="center">12</td>
</tr>
<tr>
<td align="center">w&#x3D;5,v&#x3D;8</td>
<td>0</td>
<td align="center">0</td>
<td>3</td>
<td>4</td>
<td align="center">5</td>
<td align="center">8</td>
<td>8</td>
<td>11</td>
<td align="center">12</td>
<td align="center">13</td>
<td align="center">15</td>
<td align="center">16</td>
<td align="center">17</td>
<td align="center">17</td>
<td align="center">20</td>
<td align="center">20</td>
<td align="center">20</td>
<td align="center">20</td>
<td align="center">20</td>
<td align="center">20</td>
<td align="center">20</td>
</tr>
<tr>
<td align="center">w&#x3D;9,v&#x3D;10</td>
<td>0</td>
<td align="center">0</td>
<td>3</td>
<td>4</td>
<td align="center">5</td>
<td align="center">8</td>
<td>8</td>
<td>11</td>
<td align="center">12</td>
<td align="center">13</td>
<td align="center">15</td>
<td align="center">16</td>
<td align="center">17</td>
<td align="center">17</td>
<td align="center">20</td>
<td align="center">20</td>
<td align="center">21</td>
<td align="center">22</td>
<td align="center">23</td>
<td align="center">25</td>
<td align="center">26</td>
</tr>
</tbody></table>
<p>表格说明如下：</p>
<ol>
<li>行表示前n个商品，列表示在容量为0~20的背包中是否放下；</li>
<li>第一行 <code>no items</code>，前0件商品在所有容量的背包中占0重量，价值为0，所以第一行为0；</li>
<li>接下来，假设当前商品重量为 <code>w[i]</code>，价值为 <code>v[i]</code> 。正常来说，商品重量大于容量时，即 <code>w[i] &gt; j</code> ，该商品放不进去，只能沿用之前的结果，即 <code>dp[i][j] = dp[i-1][j]</code> ；商品能放进的时候，即 <code>w[i] &lt;= j</code> ，有两种情况，当前商品如果放进去，就需要减去目前容量相应重量的体积，如果不放进去，则取前 <code>i-1</code> 个商品的结果，取二者的较大值，即 <code>dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])</code> ；</li>
<li>之后只需要遍历求解，得到的答案为最后的结果 <code>dp[n][m]</code>。</li>
<li>优化：可以将 <code>dp</code> 数组变为一维数组。</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getValue1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sum[]= <span class="keyword">new</span> <span class="keyword">int</span>[W];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=W-<span class="number">1</span>;j&gt;=<span class="number">1</span>;j--) &#123;</span><br><span class="line">			<span class="keyword">if</span>(weight[i]&lt;=j) &#123;</span><br><span class="line">				sum[j]=Math.max(sum[j], sum[j-weight[i]]+value[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	System.out.println(sum[<span class="number">20</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二-本题思路"><a href="#二-本题思路" class="headerlink" title="二. 本题思路"></a>二. 本题思路</h3><p>分析题目：如果一个数组的元素可以分成两个子集，使得两个子集的元素和相等，那么就是说，数组中存在若干个元素，它们的和等于数组总和的一半，那么使用01背包的思想获取即可。</p>
<p>因为此题中只有一个一维数组表示元素的值，可以考虑使用函数返回值，即 <code>boolean</code> 类型作为递推数组的值。</p>
<ol>
<li>首先考虑排除的数据，可以知道，当元素总和是奇数的时候是不可能等分的，可以排除这部分的数据；</li>
<li>接着，以元素个数为行，总和的一半为列，构建递推数组，也可以使用一维数组来展示，那么省略行。先考虑初始值 <code>dp[0]</code> ，表示前0个元素，肯定包含，即 <code>dp[0] = true</code> ；</li>
<li>递推公式为 <strong>dp[j] &#x3D; dp[j] | dp[j - nums[i]]</strong> ：与01背包的解答相似，当前元素 <code>nums[i]</code> 如果选择使用，那么取 <code>dp[j - nums[i]]</code> 的结果，如果不选择使用，那么取 <code>dp[j]</code> ，即前 <code>i-1</code> 个元素的结果；只要两种选择有一个为 <code>true</code> ，那么当前这个元素就是 <code>true</code> 。</li>
</ol>
<p>具体代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> n : nums )</span><br><span class="line">        &#123;</span><br><span class="line">            sum += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( sum % <span class="number">2</span> == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[sum + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = sum; j &gt;= nums[i]; --j )</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = dp[j] | dp[j - nums[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="文章引用"><a href="#文章引用" class="headerlink" title="文章引用"></a>文章引用</h2><p><a href="https://blog.csdn.net/achesong/article/details/88428895">01背包问题</a></p>
]]></content>
      <categories>
        <category>刷题</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 42. 接雨水</title>
    <url>/2022/01/09/LeetCode-42-%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/">https://leetcode-cn.com/problems/trapping-rain-water/</a></p>
<span id="more"></span>



<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>​        已知一个常识，如果想要存水，我们至少需要一个凹面。即左右下标的高度要高于中间下标的高度才能成功存水。那应该怎么计算存水量呢：<br>$$<br>存水量 &#x3D; min(height_{left}, height_{right}) * (right - left - 1)<br>$$<br>​        但是这里面又有一个问题，就是当多个凹面嵌套时，可能会导致重复计算。此处再分析导致重复计算的原因：内层的凹面比外层的凹面小，所以会导致计算外层凹面时将内层凹面也计算进去，那就是说，在距离无法更改的情况下，应该是 <code>min(left_height, right_height)</code> 取的较小值，外层比内层大导致的。</p>
<p>​        基于上述思考，我们可以得到一个方法：使用两个数组：<code>leftmax</code> 和 <code>rightmax</code> ，将从左到右和从右到左的最大高度记录下来，这样，定位每一个下标的时候，就可以取对当前下标来说的两个最大高度的较小值作为它的高度，由于当前定位下标计算，所以距离始终为 <code>1</code> ，只要减去当前下标占据的高度，就可以得到当前下标对应的存水量。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = height.length;</span><br><span class="line">        <span class="keyword">int</span>[] left_max = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] right_max = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        left_max[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            left_max[i] = Math.max(height[i], left_max[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        right_max[len - <span class="number">1</span>] = height[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i )</span><br><span class="line">        &#123;</span><br><span class="line">            right_max[i] = Math.max(height[i], right_max[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            res += Math.min(left_max[i], right_max[i]) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>基于动态规划的思路，可以进行优化：将两个数组转换为两个指针 <code>left = 0</code> 和 <code>right = len - 1</code> ， 使用两个元素存储当前左右两边的最大高度：<code>leftmax</code> 和 <code>rightmax</code> 。</p>
<p>注意的是思路会有所不同：</p>
<ol>
<li>先分别获取当前左右下标的最大高度；</li>
<li>然后取左右最大高度的较小值；</li>
<li>我们应该能有一个理解：比如当 <code>leftmax &lt; rightmax</code> 时，这个 <code>&lt;</code> 的意思是，左侧的 <code>left</code> 指针，它的左右两边的较小高度是 <code>leftmax</code> ，因为比较的不是当前这个凹面的左右，而是当前这个下标所在的最大凹面的左右，而对于当前这个 <code>left</code> 下标来说，右侧的 <code>rightmax</code> 对它不一定是更小的右侧，但是 <code>leftmax</code> 一定是最大的左侧。当右侧有比 <code>rightmax</code> 小的，一定会有 <code>rightmax</code> 这个比它大的外层；当右侧有比 <code>rightmax</code> 大的，左侧小于 <code>rightmax</code> 一定会小于比它大的。所以综上，当 <code>leftmax &lt; rightmax</code> 时，<code>leftmax</code> 一定是当前下标左右两侧最大高度的较小值。</li>
<li>后续计算与动态规划一致。</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> leftmax = <span class="number">0</span>, rightmax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( left &lt;= right )</span><br><span class="line">        &#123;</span><br><span class="line">            leftmax = Math.max(leftmax, height[left]);</span><br><span class="line">            rightmax = Math.max(rightmax, height[right]);</span><br><span class="line">            <span class="keyword">if</span>( leftmax &lt; rightmax )</span><br><span class="line">            &#123;</span><br><span class="line">                res += leftmax - height[left];</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                res += rightmax - height[right];</span><br><span class="line">                --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>和上述的思想其实很近：</p>
<ol>
<li>当 <code>height[i] &lt;= height[i - 1]</code> 时，会形成左边的凹面，这时候无法计算，将 <code>i、i - 1</code> 即左侧和中间下标存储到栈中，继续遍历；</li>
<li>当 <code>height[i] &lt; height[i + 1]</code> 时，可能会形成完整的凹面，此时将栈顶的中间下标取出，但是左侧下标不取出，因为可能存在嵌套凹面，此时的左侧可能会成为外层凹面的中间；</li>
<li>之后只要计算出凹面的较小高度和距离就可以计算当前这个凹面的存水量了。</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( !stack.empty() &amp;&amp; height[i] &gt; height[stack.peek()] )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> top = stack.pop();</span><br><span class="line">                <span class="keyword">if</span>( stack.empty() )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> left = stack.peek();</span><br><span class="line">                <span class="keyword">int</span> curheight = Math.min(height[i], height[left]) - height[top];</span><br><span class="line">                <span class="keyword">int</span> curwide = i - left - <span class="number">1</span>;</span><br><span class="line">                res += curwide * curheight;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>动态规划</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 5. 最长回文子串</title>
    <url>/2021/12/25/LeetCode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-中心扩散法"><a href="#1-中心扩散法" class="headerlink" title="1. 中心扩散法"></a>1. 中心扩散法</h3><p>这种方法应该是最容易想到的思路，唯一的问题是需要判断从当前位置为 <code>left</code> 出发，<code>right</code> 究竟是 <code>i</code> 还是 <code>i + 1</code> 长度更大。具体的思路如下：</p>
<ol>
<li>单独提一个函数 <code>centralExtension( String s, int left, int right )</code> 来计算从当前 <code>left</code> 和 <code>right</code> 出发的最长子串长度；</li>
<li>在主函数中遍历字符串的时候，比较以<code>left = i</code> 的时候，<code>right = i</code> 和 <code>right = i + 1</code> 的情况，哪个长度更大，取最大长度，然后与当前 <code>maxlen = end - start</code> 最大长度比较，如果比它大，就替换；</li>
<li>此处有一个小问题，为什么 <code>start = i - (len - 1) / 2</code> ，因为我们直接获得了两种 <code>right</code> 情况的最大值，以最小的例子来看，<code>left == right == 1</code> 的时候，<code>left = i - 1 / 2 = i</code> 成立，<code>left == i, j == i + 1</code> 的时候，<code>left = i - 2 / 2 = i - 1</code> 不成立，可以推出，<code>left = i - (1 - 1) / 2 == i - (2 - 1) / 2 == i</code> 成立。</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( s == <span class="keyword">null</span> || s.length() == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> len = Math.max(centralExtension(s, i, i), centralExtension(s, i, i + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>( len &gt; (end - start) )</span><br><span class="line">            &#123;</span><br><span class="line">                start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                end = i + len / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">centralExtension</span><span class="params">( String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right) )</span><br><span class="line">        &#123;</span><br><span class="line">            --left;</span><br><span class="line">            ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2. 动态规划"></a>2. 动态规划</h3><p>以 <code>babad</code> 为例，有如下步骤：</p>
<ol>
<li><p>首先我们应该知道简单的状态转移方程：当 <code>s.charAt(i) == s.charAt(j)</code> 且 <code>s.substring(i + 1, j)</code> 即区间 <code>[i+1, j-1]</code> 的子串也是回文串，则当前区间 <code>[i, j]</code> 的字符串为回文串；</p>
</li>
<li><p>已知的边界条件：当 <code>s.length == 1</code> 的时候，肯定是回文串，如 <code>a</code> 、<code>b</code> 等，所以应该创建一个 <code>dp</code> 的二维数组，来存放当前字符串是否为回文串，初始化每个字符都是回文串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> L = <span class="number">0</span>; L &lt; n; ++L )</span><br><span class="line">&#123;</span><br><span class="line">    dp[L][L] = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>并记录一个 <code>maxlen = 1</code> 和 <code>start = 0</code> ；</p>
</li>
<li><p>接着逐步遍历长度为 <code>2 ~ n</code> 的子串，看是否有长度比 <code>maxlen</code> 更大的回文子串；</p>
</li>
<li><p>这里需要注意一点，当确定 <code>s.charAt(i) == s.charAt(j)</code> 时，有两种情况，第一种是 <code>L &lt;= 3</code> ，即 <code>j - i &lt; 3</code> ，这时当前 <code>i, j</code> 之间最多只有一个元素，而单个元素肯定是回文串，所以直接赋值 <code>true</code> ，如果 <code>L &gt; 3</code> ，则需要判断 <code>[i + 1, j - 1]</code> 这个区间内的子串是否是回文串，如果是，则当前 <code>[i, j]</code> 肯定是回文串。</p>
</li>
</ol>
<p>依照上述思路，我们应该得到的dp表格，类型为boolean：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">b</th>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">a</th>
<th align="center">d</th>
</tr>
</thead>
<tbody><tr>
<td align="center">b</td>
<td align="center">T</td>
<td align="center">F</td>
<td align="center">T</td>
<td align="center">F</td>
<td align="center">F</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center"></td>
<td align="center">T</td>
<td align="center">F</td>
<td align="center">T</td>
<td align="center">F</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">T</td>
<td align="center">F</td>
<td align="center">F</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">T</td>
<td align="center">F</td>
</tr>
<tr>
<td align="center">d</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">T</td>
</tr>
</tbody></table>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">1</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> L = <span class="number">0</span>; L &lt; n; ++L )</span><br><span class="line">        &#123;</span><br><span class="line">            dp[L][L] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> L = <span class="number">2</span>; L &lt;= n; ++L )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + L - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>( j &gt;= n )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( s.charAt(i) == s.charAt(j) )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>( j - i &lt; <span class="number">3</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxlen )</span><br><span class="line">                &#123;</span><br><span class="line">                    maxlen = j - i + <span class="number">1</span>;</span><br><span class="line">                    start = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + maxlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>最长回文子串</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵快速幂</title>
    <url>/2021/12/09/LeetCode-509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</url>
    <content><![CDATA[<h2 id="一-引入整数快速幂"><a href="#一-引入整数快速幂" class="headerlink" title="一. 引入整数快速幂"></a>一. 引入整数快速幂</h2><span id="more"></span>

<p>比如计算 **X <sup>19</sup>**。</p>
<p>可以使用二进制运算：<code>19 = 1 0 0 1 1</code> ，可以得出：<strong>X <sup>19</sup> &#x3D; X <sup>16 + 2 + 1</sup> &#x3D; X <sup>16</sup> * X <sup>2</sup> * X <sup>1</sup></strong> 。</p>
<p>这种计算方法可以减少循环的次数。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">QuickPow</span><span class="params">( <span class="keyword">int</span> x, <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = x;</span><br><span class="line">    <span class="keyword">while</span>( N &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( (N &amp; <span class="number">1</span>) == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            res = res * x;</span><br><span class="line">        &#125;</span><br><span class="line">        x *= x;</span><br><span class="line">        N &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="矩阵快速幂"><a href="#矩阵快速幂" class="headerlink" title="矩阵快速幂"></a>矩阵快速幂</h2><p>和上面的思想是一样的，只是整数的次幂变成了矩阵的次幂。</p>
<p>回顾一下矩阵乘法的思想：</p>
<p><img src="/LeetCode-509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0.assets/1149206-20170603085219993-768167045.png" alt="矩阵乘法"></p>
<p>下面使用具体的情景。</p>
<h3 id="具体实例分析-斐波那契数列"><a href="#具体实例分析-斐波那契数列" class="headerlink" title="具体实例分析 - 斐波那契数列"></a>具体实例分析 - 斐波那契数列</h3><p>已知递推序列：<code>F(n) = F(n-1) + F(n-2)</code> ，可以知道 <code>F(n-1) = F(n-1)</code> ，或者可以换算成：</p>
<p><code>F(n) = 1 * F(n-1) + 1 * F(n-2)</code> ，</p>
<p><code>F(n-1) = 1 * F(n-1) + 0 * F(n-2)</code> ，</p>
<p>则可以逆推出矩阵序列：<br>$$<br>\left(<br>\matrix{<br>F(n)\<br>F(n-1)<br>}<br>\right)<br>&#x3D;<br>\left(<br>\matrix{<br>  1 &amp; 1\<br>  1 &amp; 0<br>}<br>\right)<br>*<br>\left(<br>\matrix{<br>F(n)\<br>F(n-1)<br>}<br>\right)<br>$$<br>根据上述矩阵公式，得到斐波那契数列的一般式：<br>$$<br>\left(<br>\matrix{<br>F(n)\<br>F(n-1)<br>}<br>\right)<br>&#x3D;<br>\left(<br>\matrix{<br>1 &amp; 1\<br>1 &amp; 0<br>}<br>\right) ^ {n-1}<br>*<br>\left(<br>\matrix{<br>F(1) &#x3D; 1\<br>F(0) &#x3D; 0<br>}<br>\right)<br>$$<br>得到具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] mat = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] res = &#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        n -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( n != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( (n &amp; <span class="number">1</span>) == <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                matrixSquare(mat, res);</span><br><span class="line">            &#125;</span><br><span class="line">            matrixSquare(mat, mat);</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">matrixSquare</span><span class="params">(<span class="keyword">int</span>[][] mat1, <span class="keyword">int</span>[][] mat2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = mat2.length, m = mat2[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] new_mat = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++k )</span><br><span class="line">                &#123;</span><br><span class="line">                    new_mat[i][j] += mat1[i][k] * mat2[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                mat2[i][j] = new_mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/cmmdc/p/6936196.html">矩阵快速幂基础讲解</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 560. 和为 K 的子数组</title>
    <url>/2022/02/23/LeetCode-560-%E5%92%8C%E4%B8%BA-K-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/">https://leetcode-cn.com/problems/subarray-sum-equals-k/</a></p>
<span id="more"></span>



<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="枚举（暴力）"><a href="#枚举（暴力）" class="headerlink" title="枚举（暴力）"></a>枚举（暴力）</h3><p>遍历每个元素，以当前元素为最后一个必取的元素，往前计算，如果结果与 <code>k</code> 相等则 <code>count++</code> 。</p>
<p>具体代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = i; j &gt;= <span class="number">0</span>; --j )</span><br><span class="line">            &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                <span class="keyword">if</span>( sum == k )</span><br><span class="line">                &#123;</span><br><span class="line">                    ++res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="前缀和-哈希表"><a href="#前缀和-哈希表" class="headerlink" title="前缀和 - 哈希表"></a>前缀和 - 哈希表</h3><p>使用前缀和的思想，可以得到如下式子：<br>$$<br>preSum[i] - preSum[j] &#x3D;&#x3D; k \<br>&#x3D;&gt;\<br>preSum[i] - k &#x3D;&#x3D; preSum[j]\<br>$$<br>式子中，preSum存储 <code>从 0 到 i </code> 的累加，<code>i &lt;= j</code> 。</p>
<p>那么我们可以在哈希表中存储 <code>preSum[j]</code> 的值和出现的次数，这样能够保证一个前缀值出现多次的情况下能够一次获取所有的个数。需要默认，表中存在 <code>(0, 1)</code> ，因为其他的 <code>preSum[i] - k</code> 需要对应的 <code>preSum[j]</code> ，但是 <code>preSum[i] - k == 0</code> 的情况是肯定不用的。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> num : nums )</span><br><span class="line">        &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            <span class="keyword">if</span>( map.containsKey(sum - k) )</span><br><span class="line">            &#123;</span><br><span class="line">                count += map.get(sum - k);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>前缀和</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 581. 最短无序连续子数组</title>
    <url>/2022/02/22/LeetCode-581-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/">https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/</a></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据题目，可以将数组分为三段：<code>numsA, numsB, numsC</code> ，其中 <code>numsA、numsC</code> 均为升序数组，计算最短子数组，即计算最短的 <code>numsB</code> 。</p>
<h3 id="数组克隆"><a href="#数组克隆" class="headerlink" title="数组克隆"></a>数组克隆</h3><p>将原始数组克隆一份到新数组，对新数组排序，然后找出两个数组的最长前缀 <code>numsA</code> 和最长后缀 <code>numsC</code> ，数组的总个数减去头尾就是中间 <code>numsB</code> 的个数。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] sort_nums = nums.clone();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(sort_nums);</span><br><span class="line">        <span class="keyword">while</span>( i &lt; nums.length &amp;&amp; nums[i] == sort_nums[i] )</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( j &gt;= i &amp;&amp; nums[j] == sort_nums[j] )</span><br><span class="line">        &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j - i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h3><p>以 <code>numsA</code> 数组来看，其中的元素 <code>i</code> 应该都满足：<br>$$<br>nums[i] &lt;&#x3D; min(nums[j]), nums[j]∈numsB + numsC<br>$$<br>​        那么此时应该要获取 <code>numsA</code> 数组中最大的元素所在的下标为 <code>left</code>；可以很容易的发现，在 <code>numsA</code> 中的元素都是升序排列的，也就是如果存在一个元素i，使得当前最小的元素j比这个元素大（i &lt; j），那么当前元素肯定存在 <code>numsB + numsC</code> 数组中，此时需要置 <code>left = i</code>。</p>
<p>​        相似的，可以得到 <code>numsC</code> 中的最小值。 </p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> max = nums[len - <span class="number">1</span>], left = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> min = nums[<span class="number">0</span>], right = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( max &gt;= nums[len - i - <span class="number">1</span>] )</span><br><span class="line">            &#123;</span><br><span class="line">                max = nums[len - i - <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left = len - i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( min &lt;= nums[i] )</span><br><span class="line">            &#123;</span><br><span class="line">                min = nums[i];</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left + right &lt; <span class="number">0</span> ? <span class="number">0</span> : right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>一次遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 55. 跳跃游戏</title>
    <url>/2022/01/13/LeetCode-55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/jump-game/">https://leetcode-cn.com/problems/jump-game/</a></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="HashSet去重-队列"><a href="#HashSet去重-队列" class="headerlink" title="HashSet去重 + 队列"></a>HashSet去重 + 队列</h3><p>使用队列按照插入顺序获取下标，插入前在 <code>HashSet</code> 中查找是否已经存在过此下标，直到队列中没有可以到达的下标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Integer&gt; unq_idxs = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        Queue&lt;Integer&gt; idxs = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        idxs.offer(<span class="number">0</span>);</span><br><span class="line">        unq_idxs.add(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>( !idxs.isEmpty() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = idxs.poll();</span><br><span class="line">            <span class="keyword">if</span>( nums[idx] + idx &gt;= nums.length - <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( nums[idx] == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>( <span class="keyword">int</span> i = idx + <span class="number">1</span>; i &lt;= idx + nums[idx]; ++i )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>( unq_idxs.add(i) )</span><br><span class="line">                    &#123;</span><br><span class="line">                        idxs.offer(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><p>记录每次能够到达的最远的下标位置，在这个 <code>maxlen</code> 的最远下标之前的所有下标都可以到达。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxlen = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( i &lt;= maxlen )</span><br><span class="line">            &#123;</span><br><span class="line">                maxlen = Math.max(maxlen, i + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( maxlen &gt;= len - <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( maxlen &gt;= nums.length - <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>队列</tag>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 621. 任务调度器</title>
    <url>/2022/02/22/LeetCode-621-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/task-scheduler/">https://leetcode-cn.com/problems/task-scheduler/</a></p>
<span id="more"></span>



<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>已知 <code>tasks</code> 元素的范围是26个大写字母，可以给定26个桶计算元素的个数。</li>
<li>然后按照个数倒序排列，因为仅需要得到时间，所以可以使用一维数组计算，但是此处使用 <code>Comparator</code> 进行倒序排序，不能传入基本数据类型，所以多了一列空列来占位。</li>
<li>排序后使用两个指针 <code>i</code> 和 <code>j</code> 指向实际的范围。</li>
<li>在实际遍历之前，需要知道，一个周期的长度是 <code>n + 1</code> ，也就是 <code>res % (n + 1) == 0</code> 才是一个周期。</li>
<li>先从个数最多的元素 <code>i</code> 开始遍历，当遍历到 <code>count[i][1] == 1</code> 的时候，为了确保个数是从 <code>j</code> 到 <code>i</code> 逐步为0的，这个时候切换到 <code>count[j]</code> 开始计算，当 <code>count[j] == 0</code>，<code>--j</code> 。</li>
<li>此处有一个是否待命的判断：当 <code>i &gt;= j</code> 也就是里面不为0的元素都遍历了一遍，一个周期还没有结束，这个时候 <code>i</code> 和 <code>j</code> 都不动，仅 <code>++res</code> 直到这个周期结束。</li>
<li>执行下一个周期，则 <code>i = 0</code>。</li>
</ol>
<p>具体代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">char</span> c : tasks )</span><br><span class="line">        &#123;</span><br><span class="line">            ++count[c - <span class="string">&#x27;A&#x27;</span>][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(count, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2[<span class="number">1</span>] - o1[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">while</span>( j &lt; <span class="number">26</span> &amp;&amp; count[j][<span class="number">1</span>] != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        j -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( i &lt; <span class="number">26</span> &amp;&amp; j &gt;= <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( count[i][<span class="number">1</span>] &gt; <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                ++res;</span><br><span class="line">                --count[i++][<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( i &lt;= j &amp;&amp; count[j][<span class="number">1</span>] != <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                ++res;</span><br><span class="line">                --count[j][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>( count[j][<span class="number">1</span>] == <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    --j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ++res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( res % (n + <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 84. 柱状图中最大的矩形</title>
    <url>/2022/01/18/LeetCode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">https://leetcode-cn.com/problems/largest-rectangle-in-histogram/</a></p>
<span id="more"></span>



<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>大致的解题方向：以当前元素为高，向左向右找到第一个小于这个高的边界 <code>left</code> 和 <code>right</code> ，<code>left + 1</code> 到 <code>right - 1</code> 为宽。</p>
<h3 id="1-暴力方式"><a href="#1-暴力方式" class="headerlink" title="1. 暴力方式"></a>1. 暴力方式</h3><p>遍历每个元素，为每个元素找到 <code>left</code> 和 <code>right</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = heights.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> left = i, right = i;</span><br><span class="line">            <span class="keyword">while</span>( left &gt;= <span class="number">0</span> &amp;&amp; heights[left] &gt;= heights[i] )</span><br><span class="line">            &#123;</span><br><span class="line">                --left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>( right &lt; n &amp;&amp; heights[right] &gt;= heights[i] )</span><br><span class="line">            &#123;</span><br><span class="line">                ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max( res, (right - left - <span class="number">1</span>) * heights[i] );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为 <code>O(n2)</code> ，会超出时间限制。</p>
<h3 id="2-单调栈"><a href="#2-单调栈" class="headerlink" title="2. 单调栈"></a>2. 单调栈</h3><p>使用单调栈来存储元素，当栈顶元素比当前元素大，就出栈，直到找到第一个小于它的元素下标，因为要计算宽，所以栈中存放的是下标。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = heights.length;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Stack&lt;Integer&gt; sta = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( !sta.empty() &amp;&amp; heights[sta.peek()] &gt;= heights[i] )</span><br><span class="line">            &#123;</span><br><span class="line">                sta.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( sta.empty() )</span><br><span class="line">            &#123;</span><br><span class="line">                left[i] = -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left[i] = sta.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            sta.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        sta.clear();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( !sta.empty() &amp;&amp; heights[sta.peek()] &gt;= heights[i] )</span><br><span class="line">            &#123;</span><br><span class="line">                sta.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( sta.empty() )</span><br><span class="line">            &#123;</span><br><span class="line">                right[i] = n;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                right[i] = sta.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            sta.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        heights[<span class="number">0</span>] = (right[<span class="number">0</span>] - left[<span class="number">0</span>] - <span class="number">1</span>) * heights[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            heights[i] = Math.max(heights[i - <span class="number">1</span>], (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heights[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 85. 最大矩形</title>
    <url>/2022/01/21/LeetCode-85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximal-rectangle/">https://leetcode-cn.com/problems/maximal-rectangle/</a></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>大致思路：求每一个元素在每一行作为宽的和：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( j == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            mat[i][j] = matrix[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( matrix[i][j] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                mat[i][j] = mat[i][j - <span class="number">1</span>] + matrix[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着求每一个元素在每一列作为宽的最大和。下面两种方式都是在对这个步骤使用不同角度求解。</p>
<h3 id="暴力求解"><a href="#暴力求解" class="headerlink" title="暴力求解"></a>暴力求解</h3><p>在上述的计算之后，每一列的每个值都是所在行的以当前元素为右下角的高为1的矩形，现在遍历每个元素，从当前元素开始在列上往前遍历最小的和作为 <code>width</code> ，计算 <code>area = (i - k + 1) * width</code> 为当前最小 <code>width</code> 的对应面积，取最大面积。</p>
<p>具体代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] mat = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> maxarea = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( j == <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    mat[i][j] = matrix[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>( matrix[i][j] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        mat[i][j] = mat[i][j - <span class="number">1</span>] + matrix[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( i == <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    maxarea = Math.max(maxarea, mat[i][j]);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( mat[i][j] != <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> width = mat[i][j];</span><br><span class="line">                    <span class="keyword">for</span>( <span class="keyword">int</span> k = i; k &gt;= <span class="number">0</span> &amp;&amp; mat[k][j] != <span class="number">0</span>; --k )</span><br><span class="line">                    &#123;</span><br><span class="line">                        width = Math.min(width, mat[k][j]);</span><br><span class="line">                        maxarea = Math.max(maxarea, (i - k + <span class="number">1</span>) * width);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxarea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>可以先看这个题解的思路去思考：<a href="%5Bhttp://lannaie.top/2022/01/18/LeetCode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/#more%5D(http://lannaie.top/2022/01/18/LeetCode-84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/#more)">LeetCode - 84. 柱状图中最大的矩形</a>，思路是一样的。</p>
<p>我们将每一列横向看，作为一个柱状图，就可以套上面题解中单调栈的解法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(<span class="keyword">char</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] mat = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> maxarea = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( j == <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    mat[i][j] = matrix[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>( matrix[i][j] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        mat[i][j] = mat[i][j - <span class="number">1</span>] + matrix[i][j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>( !ind.empty() &amp;&amp; mat[ind.peek()][i] &gt;= mat[j][i] )</span><br><span class="line">                &#123;</span><br><span class="line">                    ind.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                left[j] = ind.empty() ? -<span class="number">1</span> : ind.peek();</span><br><span class="line">                ind.push(j);</span><br><span class="line">            &#125;</span><br><span class="line">            ind.clear();</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>( !ind.empty() &amp;&amp; mat[ind.peek()][i] &gt;= mat[j][i] )</span><br><span class="line">                &#123;</span><br><span class="line">                    ind.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                right[j] = ind.empty() ? m : ind.peek();</span><br><span class="line">                ind.push(j);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                maxarea = Math.max(maxarea, (right[j] - left[j] - <span class="number">1</span>) * mat[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxarea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 918. 环形子数组的最大和</title>
    <url>/2021/12/13/LeetCode-918-%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/">https://leetcode-cn.com/problems/maximum-sum-circular-subarray/</a></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>对于环形数组，一般解的思路是将数组分成三个部分：[max1,min,max2]。有以下的推导关系：</p>
<blockquote>
<p>max(前缀数组 + 后缀数组)<br>&#x3D; max(数组总和 - 中间数组)<br>&#x3D; 数组总和 + max(- 中间数组)<br>&#x3D; 数组总和 - min(中间数组)</p>
</blockquote>
<p>上述的 <code>min(中间数组)</code> 即取数组的最小值。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubarraySumCircular</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxsum = nums[<span class="number">0</span>], curmax = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minsum = nums[<span class="number">0</span>], curmin = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> num : nums )</span><br><span class="line">        &#123;</span><br><span class="line">            curmax = Math.max(curmax + num, num);</span><br><span class="line">            maxsum = Math.max(curmax, maxsum);</span><br><span class="line">            curmin = Math.min(curmin + num, num);</span><br><span class="line">            minsum = Math.min(curmin, minsum);</span><br><span class="line">            tot += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxsum &gt; <span class="number">0</span> ? Math.max(maxsum, tot - minsum) : maxsum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>这脑回路我是想不到</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - JZ48 最长不含重复字符的子字符串</title>
    <url>/2021/11/30/LeetCode-JZ48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.nowcoder.com/practice/48d2ff79b8564c40a50fa79f9d5fa9c7?tpId=13&amp;tqId=2276769&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/48d2ff79b8564c40a50fa79f9d5fa9c7?tpId=13&amp;tqId=2276769&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>动态规划问题肯定需要一个 <code>dp</code> 或 <code>dp[i]</code> ，本题仅涉及 <code>dp[i-1]</code> ，所以使用 <code>dp</code> 计算就可以了。</p>
<p>涉及到重复字符的问题，需要存储上个相同字符的位置，使用 <code>HashMap</code> 更加便捷。</p>
<p>获得最大值结果，使用 <code>max_length</code> 来存储。</p>
<p>如此其实可以推出了代码的大致方向，这里面最需要思考的问题是 <code>dp</code> 的赋值问题。</p>
<ol>
<li>如果没有重复字符最简单，直接 <code>dp += 1</code> 就可以得到当前不重复长度；</li>
<li>如果有重复字符，一开始的想法是 <code>dp = i - map.get(s.charAt(i))</code> ，但是这种方式的一个误区在于：如果重复元素嵌套，比如 <code>abba</code> ，结果会出错，需要重新理清思路：当前的最长字符串，不是由上个重复元素的位置决定，是由 <strong>上一个最长字符串</strong> 决定的，也就是 <code>第二个a</code> 的最长字符串长度不是由 <code>第一个a</code> 决定，而是由 <code>第二个b</code> 决定，当两个重复元素中间没有嵌套重复元素，比如 <code>abca</code> ，当前的长度才会由上一个重复元素决定，也就是说，应该取二者中更短的一边：<strong>dp &#x3D; Math.min(dp + 1, i - map.get(s.charAt(i)))</strong> 。</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( s == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( s.length() == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line"><span class="comment">//         int[] dp = new int[chars.length];</span></span><br><span class="line">        <span class="keyword">int</span> dp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max_length = <span class="number">1</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//         dp[0] = 1;</span></span><br><span class="line">        map.put(chars[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; chars.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( !map.containsKey(chars[i]) )</span><br><span class="line">            &#123;</span><br><span class="line">                dp += <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp = Math.min(dp + <span class="number">1</span>, i - map.get(chars[i]));</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(chars[i], i);</span><br><span class="line">            max_length = Math.max(max_length, dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - JZ46 把数字翻译成字符串</title>
    <url>/2021/11/30/LeetCode-JZ46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.nowcoder.com/practice/046a55e6cd274cffb88fc32dba695668?tpId=13&amp;tqId=1024831&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/046a55e6cd274cffb88fc32dba695668?tpId=13&amp;tqId=1024831&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>数字转变为字母的可能是一位数和两位数，可以联想到 <a href="%5Bhttp://lannaie.top/2021/07/09/LeetCode-NC68-%E8%B7%B3%E5%8F%B0%E9%98%B6/%5D(http://lannaie.top/2021/07/09/LeetCode-NC68-%E8%B7%B3%E5%8F%B0%E9%98%B6/)">爬楼梯相关题目</a> ，只是多了一些筛选条件，接下来，按照这个思路解决该题。</p>
<p>已知爬楼梯的递归条件是 <code>f[n] = f[n-1] + f[n-2]</code> ，此处也同样适用，前提条件是当前数值是合法的两位数才能这样计算，如果不合法，只能取 <code>f[n] = f[n-1]</code> 的结果。</p>
<p>除此之外，本题的难点在于对 <code>0</code> 的处理：</p>
<ol>
<li>涉及到 <code>0</code> 的数值仅有 <code>10</code> 和 <code>20</code> ，如果存在诸如 <code>002 </code>、<code>200</code> 、<code>603</code> 等都是不合法的数值，返回 <code>0</code> ；</li>
<li>不过在循环中不需要考虑为0的情况，只需要考虑 <strong>当前元素是否在一位数区间</strong> 和 <strong>与前一元素构成的两位数是否在两位数的区间内</strong> 的情况，其余情况都是不合法的情况，为 <code>0</code> 即可；</li>
<li>在两位数的区间判断中，还有一个小的判断，如果当前元素下标为 <code>1</code> ，没有 <code>f[n-2]</code> ，只需要在原来的 <code>f[n] = f[n-1]</code> 上 <code>+1</code> 即可，否则 <code>f[n] = f[n-1] + f[n-2]</code> 。</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums string字符串 数字串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(String nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( nums == <span class="keyword">null</span> || nums.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//         char[] num = nums.toCharArray();</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length()];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length(); ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( nums.charAt(i) != <span class="string">&#x27;0&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> tmp_num = (nums.charAt(i - <span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (nums.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>( tmp_num &gt;= <span class="number">10</span> &amp;&amp; tmp_num &lt;= <span class="number">26</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( i == <span class="number">1</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] += <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>爬楼梯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - JZ51 数组中的逆序对</title>
    <url>/2021/12/01/LeetCode-JZ51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&amp;tqId=23260&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=13&amp;tqId=23260&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-暴力解法"><a href="#1-暴力解法" class="headerlink" title="1. 暴力解法"></a>1. 暴力解法</h3><p>就是嵌套循环，遍历每个元素的时候，都嵌套一个往回循环到开头，然后计算逆序值。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> P = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>( j &gt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( array[j] &gt; array[i] )</span><br><span class="line">                &#123;</span><br><span class="line">                    ++P;</span><br><span class="line">                &#125;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(P % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2. 归并排序"></a>2. 归并排序</h3><p><strong>当提示 <code>空间复杂度 O(n)，时间复杂度 O(nlogn)</code> 就可以尝试思考是否可以套归并排序的解法了</strong>。</p>
<ol>
<li>已知归并排序分为两个部分，分治和合并，在分治阶段一般不会有什么其他操作，可以考虑在合并阶段对数据进行操作；</li>
<li>因为是两个部分进行合并，首先可以知道的就是 <code>left</code> 的部分肯定在 <code>right</code> 前面，所以逆序的两个数字可以分别从两个部分选择来比较；</li>
<li>如果确定了逆序的两个数字，可以知道 <code>left</code> 部分从当前元素 <code>i</code> 开始到该部分的结束 <code>mid</code> 对于 <code>right</code> 部分的当前元素 <code>j</code> 都是逆序的，因为此时的两个部分肯定分别是升序排序排列，都是从一个开始排起的。</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> P = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        devide(array, <span class="number">0</span>, len - <span class="number">1</span>, tmp);</span><br><span class="line">        <span class="keyword">return</span> P;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">devide</span><span class="params">( <span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span>[] tmp )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( l &gt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        devide(arr, l, mid, tmp);</span><br><span class="line">        devide(arr, mid + <span class="number">1</span>, r, tmp);</span><br><span class="line">        merge(arr, l, r, mid, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">( <span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> mid, <span class="keyword">int</span>[] tmp )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( mid &gt; r || mid &lt; <span class="number">0</span> || l &gt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( i &lt;= mid &amp;&amp; j &lt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( arr[i] &lt;= arr[j] )</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[t++] = arr[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                P += mid + <span class="number">1</span> - i;</span><br><span class="line">                P %= <span class="number">1000000007</span>;</span><br><span class="line">                tmp[t++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( i &lt;= mid )</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[t++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( j &lt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[t++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( l &lt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            arr[l++] = tmp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - JZ20 表示数值的字符串</title>
    <url>/2021/12/04/LeetCode-JZ20-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.nowcoder.com/practice/e69148f8528c4039ad89bb2546fd4ff8?tpId=13&amp;tqId=1375424&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/e69148f8528c4039ad89bb2546fd4ff8?tpId=13&amp;tqId=1375424&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<span id="more"></span>



<h2 id="有限状态自动机-知识简单介绍"><a href="#有限状态自动机-知识简单介绍" class="headerlink" title="有限状态自动机 - 知识简单介绍"></a>有限状态自动机 - 知识简单介绍</h2><p>一般用于字符串匹配问题。（应该）</p>
<p>有限状态自动机分为确定有限（DFA）和不确定有限（NFA）。</p>
<ol>
<li><p>确定有限状态自动机DFA</p>
<p><img src="/LeetCode-JZ20-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.assets/1423760-20180929170016855-451855187.jpg"></p>
<p>设初始态为 <code>0</code> ，终止态为 <code>2</code> ，当进行一系列操作，使得状态机的状态不断变化，只要最后一个输入使得状态机处于终止态，就表明当前输入可以被状态机接收。</p>
<p>比如，<code>abab</code> 的状态变化是 <code>&#123;0,1,2,2&#125;</code> ，由于最后一个状态是终止态 <code>2</code> ，所以该字符串可以被接收；如果字符串为 <code>bbab</code> ，状态变化是 <code>&#123;0,1,0,1&#125;</code> ，最后一个状态为 <code>1</code> ，不符合终止态，不会被接收。</p>
</li>
<li><p>不确定有限状态自动机NFA</p>
<p><img src="/LeetCode-JZ20-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.assets/1423760-20180929171549048-2112081040.png"></p>
<p>在上面这个状态转换形式中，从 <code>0</code> 开始，读取 <code>a</code> ，可以原地，也可以到 <code>1</code> ，状态不唯一，但都合法，这种状态就是不确定的。这种状态下的路径不会只有一个，只要其中一个能走到终止态，就算成功，所以会涉及到回溯内容。</p>
</li>
</ol>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-整合字符串的部分"><a href="#1-整合字符串的部分" class="headerlink" title="1. 整合字符串的部分"></a>1. 整合字符串的部分</h3><ol>
<li>前导空格；</li>
<li>正负号；</li>
<li>整数；</li>
<li>小数点；</li>
<li>小数点后的数字；</li>
<li><code>e</code> 或 <code>E</code> ；</li>
<li>正负号；</li>
<li>整数；</li>
<li>后导空格。</li>
</ol>
<p><strong>总结上述部分，分为以下几种：</strong></p>
<ol>
<li>空格：<code>&#39; &#39;</code> ；</li>
<li>正负号：<code>&#39;s&#39;</code> ；</li>
<li>整数：<code>&#39;d&#39;</code> ；</li>
<li>小数点：<code>&#39;.&#39;</code> ；</li>
<li><code>e</code> 或 <code>E</code> ：<code>&#39;e&#39;</code> 。</li>
</ol>
<h3 id="2-对这些部分总结规律"><a href="#2-对这些部分总结规律" class="headerlink" title="2. 对这些部分总结规律"></a>2. 对这些部分总结规律</h3><ol>
<li><p>如果有前导空格需要原地遍历完，之后才是真正的开头；</p>
</li>
<li><p>开头有3种：正负号、整数、小数点；</p>
<p>2.1 如果是正负号，后面可以跟：整数、小数点；</p>
<p>2.2 如果是整数，后面可以跟：没遍历完的整数、小数点、e|E、后导空格；</p>
<p>2.3 如果是小数点，后面必须跟整数；</p>
</li>
<li><p>延续 <code>2.1</code> 的思路，<code>正负号 + 整数</code> 后面可以跟：没遍历完的整数、小数点、e|E、后导空格；<code>正负号 + 小数点</code> 后面必须跟整数，与 <code>2.3</code>  具有同样的规则；</p>
</li>
<li><p>延续 <code>2.2</code> 的思路，遍历完整数后，<code>整数 + 小数点</code> 后面可以跟：小数点后的整数、e|E、后导空格；<code>整数 + e|E</code> 后面可以跟：正负号、整数；</p>
</li>
<li><p>延续 <code>2.3</code> 的思路，<code>小数点 + 整数</code> 后面可以跟：e|E、没遍历完的整数、后导空格；</p>
</li>
<li><p>延续 <code>3</code> 的思路，遍历完整数后，<code>正负号 + 整数 + 小数点</code> 、<code>正负号 + 小数点 + 整数</code> 后续的思路与 <code>5</code> 一致，<code>正负号 + 整数 + e|E</code> 与 <code>4</code> 的 <code>整数 + e|E</code> 的思路一致，存在后导空格结束；</p>
</li>
<li><p>延续 <code>4</code> 的思路，<code>整数 + 小数点 + 小数点后的整数</code> 与 <code>5</code> 的思路一致，<code>整数 + 小数点 + e|E</code> 与后面的 <code>整数 + e|E</code> 一致，存在后导空格结束；<code>整数 + e|E + 正负号</code> 后必须跟整数，<code>整数 + e|E + 整数</code> 后可以跟：没遍历完的整数、后导空格；</p>
</li>
<li><p>延续 <code>5</code> 的思路，遍历完整数后，<code>小数点 + 整数 + e|E</code> ，后面可以跟： 正负号、整数，存在后导空格结束；</p>
</li>
<li><p>之后把没遍历完的整数遍历完后，遇到后导空格结束。</p>
</li>
</ol>
<p>按照上述分析，可以有以下 7 步：</p>
<p>① 前导空格、正负号、整数、小数点；</p>
<p>② 整数、小数点；</p>
<p>③ 整数、小数点、e|E、后导空格；</p>
<p>④ 整数；</p>
<p>⑤ 整数、e|E、后导空格；</p>
<p>⑥ 正负号、整数；</p>
<p>⑦ 整数、后导空格。</p>
<h3 id="总结步骤表"><a href="#总结步骤表" class="headerlink" title="总结步骤表"></a>总结步骤表</h3><p>按照上述结论，得出步骤表：</p>
<p>① 前导空格：①、正负号：②、整数：③、小数点：④；</p>
<p>② 整数：③、小数点：④；</p>
<p>③ 整数：③、小数点：⑤、e|E：⑥、后导空格：⑧；</p>
<p>④ 整数：⑤；</p>
<p>⑤ 整数：⑤、e|E：⑥、后导空格：⑧；</p>
<p>⑥ 整数：⑧、正负号：⑦；</p>
<p>⑦ 整数：⑧；</p>
<p>⑧ 整数：⑧、后导空格：⑧。</p>
<p>**注意：上面的步骤多了一个 ⑦ 的步骤，这是因为此处必须出现的整数与 ④ 的整数不同，前一个是小数点后，后一个是e|E以及正负号后。 **</p>
<p>将所有的 <code>str</code> 字符串都添加一个后导空格，最后只需要判断最终的 <code>end</code> 是否是 ⑧ 结尾就可以了。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool布尔型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span> <span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        Map[] maps = </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() &#123;&#123;put(<span class="string">&#x27; &#x27;</span>, <span class="number">0</span>); put(<span class="string">&#x27;s&#x27;</span>, <span class="number">1</span>); put(<span class="string">&#x27;d&#x27;</span>, <span class="number">4</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">2</span>);&#125;&#125;,</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() &#123;&#123;put(<span class="string">&#x27;d&#x27;</span>, <span class="number">4</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">2</span>);&#125;&#125;,</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() &#123;&#123;put(<span class="string">&#x27;d&#x27;</span>, <span class="number">3</span>);&#125;&#125;,</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() &#123;&#123;put(<span class="string">&#x27;d&#x27;</span>, <span class="number">3</span>); put(<span class="string">&#x27;e&#x27;</span>, <span class="number">5</span>); put(<span class="string">&#x27; &#x27;</span>, <span class="number">7</span>);&#125;&#125;,</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() &#123;&#123;put(<span class="string">&#x27;d&#x27;</span>, <span class="number">4</span>); put(<span class="string">&#x27;.&#x27;</span>, <span class="number">3</span>); put(<span class="string">&#x27;e&#x27;</span>, <span class="number">5</span>); put(<span class="string">&#x27; &#x27;</span>, <span class="number">7</span>);&#125;&#125;,</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() &#123;&#123;put(<span class="string">&#x27;s&#x27;</span>, <span class="number">6</span>); put(<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>);&#125;&#125;,</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() &#123;&#123;put(<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>);&#125;&#125;,</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;() &#123;&#123;put(<span class="string">&#x27;d&#x27;</span>, <span class="number">7</span>); put(<span class="string">&#x27; &#x27;</span>, <span class="number">7</span>);&#125;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        str += <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>( c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                c = <span class="string">&#x27;s&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                c = <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( c == <span class="string">&#x27;e&#x27;</span> || c == <span class="string">&#x27;E&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                c = <span class="string">&#x27;e&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( !maps[end].containsKey(c) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            end = (<span class="keyword">int</span>)maps[end].get(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> end == <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有限状态自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC137 表达式求值</title>
    <url>/2021/07/22/LeetCode-NC137-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/c215ba61c8b1443b996351df929dc4d4?tpId=188&amp;&amp;tqId=38548&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/c215ba61c8b1443b996351df929dc4d4?tpId=188&amp;&amp;tqId=38548&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking</a></p>
<span id="more"></span>



<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="1-设测试用例"><a href="#1-设测试用例" class="headerlink" title="1. 设测试用例"></a>1. 设测试用例</h3><p>通过题目可以知道，该题解决的是简易计算器问题。</p>
<p>结合题目和用例，可以得出5个测试维度：<code>+ 、- 、 * 、 ( 、)</code></p>
<p>分析几个维度之间的联系：</p>
<ol>
<li>使用 <code>-</code> ，则后面一个计算符号为 <code>-</code> 或 <code>+</code> 会变号；</li>
<li>使用 <code>*</code> ，该符号的优先级应高于 <code>+</code> 和 <code>-</code> ；</li>
<li>使用 <code>(</code> ，该符号的优先级应该最高，不对数据做任何改变；</li>
<li>使用 <code>)</code> ，此时应该优先将 <code>()</code> 中的算式进行计算。</li>
</ol>
<p>通过上述描述，得到如下测试用例：</p>
<blockquote>
<ol>
<li><p>全是 +<br>“1+2”</p>
</li>
<li><p>全是 -<br>“1-2-2”</p>
</li>
<li><p>加减乘</p>
<p>“1-2 * 3 * 4+2”</p>
</li>
<li><p>加减在括号里面 </p>
<p>“2*(1+2)”</p>
</li>
<li><p>混合</p>
<p>“2 * (1+2*4)+1”</p>
</li>
<li><p>负数计算</p>
<p>“-2+1”</p>
</li>
</ol>
</blockquote>
<h3 id="2-代码思路"><a href="#2-代码思路" class="headerlink" title="2. 代码思路"></a>2. 代码思路</h3><ol>
<li><p>存储：应该使用两个容器分别将数字和运算符号存储起来，因为并不一定是在当前获取的时候进行运算。此处使用两个栈进行存储：</p>
</li>
<li><p>遍历字符串：</p>
<p><strong>2.1</strong> 先判断是数字还是字符串，如果是数字，要注意，数字不一定只有一位，需要使用一个变量来获取完整的数字；</p>
<p><strong>2.2</strong> 如果是运算符，则先判断 <code>+</code> 或 <code>-</code> 的情况，它们只有一种需要验证的可能，即优先级。比二者大的只有 <code>*</code> 和 <code>(</code> ，因为 <code>(</code> 不做处理，所以只判断是否存在 <code>*</code> ，如果存在，取出来运算。</p>
<p><strong>2.3</strong> 然后判断 <code>)</code> 的情况，不需要验证，直接取运算符进行计算，直到遇到 <code>(</code> ；</p>
<p><strong>2.4</strong> 最后如果是 <code>*</code> 和 <code>(</code> ，直接进行存储。</p>
</li>
<li><p>最后查看两个栈中是否还存在元素，如果存在：</p>
<p><strong>2.1</strong> 如果是 <code>+</code> 或 <code>-</code> ：判断前一个运算符是否是 <code>-</code> ，是则变号，不是不变号；</p>
<p><strong>2.2</strong> 如果是 <code>*</code> ，直接运算；</p>
<p><strong>2.3</strong> 这里不会存在 <code>()</code> ，因为在遍历时已经清除了 -  <code>)</code> 不进栈。</p>
</li>
<li><p>最终输出位于 <code>num</code> 数字元素栈的最后一个元素，即最终结果。</p>
</li>
</ol>
<h3 id="3-具体代码"><a href="#3-具体代码" class="headerlink" title="3. 具体代码"></a>3. 具体代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     * 返回表达式的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s string字符串 待计算的表达式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solve</span> <span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; num = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;Character&gt; ope = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; ++ i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>( i &lt; str.length &amp;&amp; str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                n = n * <span class="number">10</span> + str[i] - <span class="number">48</span>;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//             System.out.println(n);</span></span><br><span class="line">            <span class="keyword">if</span>( n!=<span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                num.push(n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( i &gt;= str.length )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( str[i] == <span class="string">&#x27;+&#x27;</span> || str[i] == <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( !ope.isEmpty() &amp;&amp; ope.peek() == <span class="string">&#x27;*&#x27;</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span>( !ope.isEmpty() &amp;&amp;  ope.peek() == <span class="string">&#x27;*&#x27;</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> a = num.pop();</span><br><span class="line">                        <span class="keyword">int</span> b = num.pop();</span><br><span class="line">                        ope.pop();</span><br><span class="line">                        num.push(a * b);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ope.push(str[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>( str[i] == <span class="string">&#x27;*&#x27;</span> || str[i] == <span class="string">&#x27;(&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                ope.push(str[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>( ope.peek() != <span class="string">&#x27;(&#x27;</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>( !num.isEmpty() )</span><br><span class="line">                    &#123;</span><br><span class="line">                        b = num.pop();</span><br><span class="line">                    &#125;<span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>( !num.isEmpty())</span><br><span class="line">                    &#123;</span><br><span class="line">                        a = num.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">char</span> c = ope.pop();</span><br><span class="line">                    <span class="keyword">if</span>( c == <span class="string">&#x27;+&#x27;</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        num.push(a + b);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>( c == <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        num.push(a - b);</span><br><span class="line">                    &#125;<span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        num.push(a * b);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ope.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( !ope.isEmpty() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>( !num.isEmpty() )</span><br><span class="line">            &#123;</span><br><span class="line">                b = num.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( !num.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                a = num.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> c = ope.pop();</span><br><span class="line"><span class="comment">//             System.out.println(a+&quot; &quot;+b+&quot; &quot;+c);</span></span><br><span class="line">            <span class="keyword">if</span>( c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>( !ope.isEmpty() &amp;&amp; ope.peek() == <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>( c == <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">					&#123;</span><br><span class="line">						num.push(a + b);</span><br><span class="line">					&#125;<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						num.push(a - b);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>( c == <span class="string">&#x27;+&#x27;</span> )</span><br><span class="line">					&#123;</span><br><span class="line">						num.push(a + b);</span><br><span class="line">					&#125;<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						num.push(a - b);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				num.push(a * b);</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC102 在二叉树中找到两个节点的最近公共祖先</title>
    <url>/2021/07/10/LeetCode-NC102-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/e0cc33a83afe4530bcec46eba3325116?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/e0cc33a83afe4530bcec46eba3325116?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>可以有两种思路：</p>
<h3 id="1-从局部看：看两个值和公共节点的关系"><a href="#1-从局部看：看两个值和公共节点的关系" class="headerlink" title="1. 从局部看：看两个值和公共节点的关系"></a>1. 从局部看：看两个值和公共节点的关系</h3><p>有三种关系：</p>
<ol>
<li>o1和o2在公共节点的两边；</li>
<li>o1是公共节点；</li>
<li>o2是公共节点。</li>
</ol>
<p>对于第一个关系，就说明该节点的左右子节点都不可能为<code>NULL</code>，则可以得到下述：</p>
<p>java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( root.left != <span class="keyword">null</span> &amp;&amp; root.right!=<span class="keyword">null</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于第二和三的关系，假设当前节点就是公共节点，可以返回该节点。然后由上面一个节点判断此时本节点是公共节点还是一个节点的长辈节点：</p>
<p>java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>( root == <span class="keyword">null</span> || root.val == o1 || root.val == o2 )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了防止有节点只有左节点和右节点中的一个：</p>
<p>java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br></pre></td></tr></table></figure>

<p>总体代码如下：</p>
<p>java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o1 int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o2 int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="keyword">int</span> o1, <span class="keyword">int</span> o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CommonAncestor(root, o1, o2).val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">CommonAncestor</span><span class="params">(TreeNode root, <span class="keyword">int</span> o1, <span class="keyword">int</span> o2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span> || root.val == o1 || root.val == o2 )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode left = CommonAncestor(root.left, o1, o2);</span><br><span class="line">        TreeNode right = CommonAncestor(root.right, o1, o2);</span><br><span class="line">        <span class="keyword">if</span>( left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param root TreeNode类 </span></span><br><span class="line"><span class="comment"># @param o1 int整型 </span></span><br><span class="line"><span class="comment"># @param o2 int整型 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self , root , o1 , o2 </span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">CommonAncestor</span>(<span class="params">root, o1, o2</span>):</span></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> root.val <span class="keyword">in</span> [o1, o2]:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            left = CommonAncestor(root.left, o1, o2)</span><br><span class="line">            right = CommonAncestor(root.right, o1, o2)</span><br><span class="line">            <span class="keyword">if</span> left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">return</span> left <span class="keyword">if</span> left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> right</span><br><span class="line">        <span class="keyword">return</span> CommonAncestor(root, o1, o2).val</span><br></pre></td></tr></table></figure>

<h3 id="2-从整体看：看每个值之间的区别"><a href="#2-从整体看：看每个值之间的区别" class="headerlink" title="2. 从整体看：看每个值之间的区别"></a>2. 从整体看：看每个值之间的区别</h3><p>可以记录从顶点到每个值的路径，然后比较两个路径是从哪个顶点开始聚合或分道扬镳的，该节点就算最近公共节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o1 int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o2 int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lowestCommonAncestor</span> <span class="params">(TreeNode root, <span class="keyword">int</span> o1, <span class="keyword">int</span> o2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; s2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        getPath(root, o1, s1);</span><br><span class="line">        getPath(root, o2, s2);</span><br><span class="line">        <span class="keyword">int</span> res = root.val;</span><br><span class="line">        <span class="keyword">while</span>( !(s1.isEmpty() || s2.isEmpty()) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> f1 = s1.pop(), f2 = s2.pop();</span><br><span class="line">            System.out.println(f1+<span class="string">&quot; &quot;</span>+f2);</span><br><span class="line">            <span class="keyword">if</span>( f1 != f2 )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            res = f1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">getPath</span><span class="params">(TreeNode root, <span class="keyword">int</span> o, Stack&lt;Integer&gt; stack)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( root.val == o || getPath(root.left, o, stack) || getPath(root.right, o, stack) )</span><br><span class="line">        &#123;</span><br><span class="line">            stack.push(root.val);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择元素不相等时退出是因为<code>getPath</code>函数是从下往上<code>push</code>元素的。</p>
<p>python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param root TreeNode类 </span></span><br><span class="line"><span class="comment"># @param o1 int整型 </span></span><br><span class="line"><span class="comment"># @param o2 int整型 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self , root , o1 , o2 </span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getPath</span>(<span class="params">root, o, s</span>):</span></span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> root.val == o <span class="keyword">or</span> getPath(root.left, o, s) <span class="keyword">or</span> getPath(root.right, o, s):</span><br><span class="line">                s.append(root.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        s1, s2 = [], []</span><br><span class="line">        res = root.val</span><br><span class="line">        getPath(root, o1, s1)</span><br><span class="line">        getPath(root, o2, s2)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(s1) != <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(s2) != <span class="number">0</span>:</span><br><span class="line">            f1, f2 = s1.pop(), s2.pop()</span><br><span class="line">            <span class="keyword">if</span> f1 != f2:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            res = f1</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>java, python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - JZ56 数组中只出现一次的两个数字</title>
    <url>/2021/11/30/LeetCode-JZ56-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://www.nowcoder.com/practice/389fc1c3d3be4479a154f63f495abff8?tpId=13&amp;tqId=1375231&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking">https://www.nowcoder.com/practice/389fc1c3d3be4479a154f63f495abff8?tpId=13&amp;tqId=1375231&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<span id="more"></span>



<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1. 哈希表"></a>1. 哈希表</h3><p>这个方法不再赘述，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] FindNumsAppearOnce (<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        HashSet&lt; Integer &gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( set.contains(array[i]) )</span><br><span class="line">            &#123;</span><br><span class="line">                set.remove(array[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                set.add(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( Integer s : set )</span><br><span class="line">        &#123;</span><br><span class="line">            res[r++] = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-位运算"><a href="#2-位运算" class="headerlink" title="2. 位运算"></a>2. 位运算</h3><p>可以先思考该题目的简易版：只出现一次的数字只有一个。这里就用到了异或运算。</p>
<p>已知一个元素和自己异或为0：<code>2 ^ 2 == 0</code> ，和0异或是其本身：<code>2 ^ 0 == 2</code> 。因为重复元素只出现两次，可以自然而然得到下列代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] singleNumber(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        x ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题需要得到两个出现一次的数字，可以将数组分成两个部分，类似奇偶分组，但是取这样的规律进行分组：</p>
<p>我们需要把两个元素区分开，已知异或运算的结果是同0异1，可以取两个元素异或结果的最低位的1作为区分的关键。首先获取两个唯一元素异或的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> arr : array )</span><br><span class="line">&#123;</span><br><span class="line">    tmp ^= arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着获取最低位的1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mark = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>( tmp != <span class="number">0</span> &amp;&amp; (tmp &amp; mark) == <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">    mark &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后依据这个 <code>1</code> 来分别计算两个组的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">int</span> arr : array )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( (arr &amp; mark) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        a ^= arr;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        b ^= arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码整合如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型一维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] FindNumsAppearOnce (<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> arr : array )</span><br><span class="line">        &#123;</span><br><span class="line">            tmp ^= arr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mark = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>( tmp != <span class="number">0</span> &amp;&amp; (tmp &amp; mark) == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            mark &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> arr : array )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( (arr &amp; mark) == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                a ^= arr;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                b ^= arr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( a &gt; b )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c = a;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a, b&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC15 求二叉树的层序遍历</title>
    <url>/2021/07/08/LeetCode-NC15-%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3?tpId=188&amp;&amp;tqId=38595&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/04a5560e43e24e9db4595865dc9c63a3?tpId=188&amp;&amp;tqId=38595&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking</a></p>
<span id="more"></span>



<h2 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h2><p>使用迭代和递归的方式进行处理。</p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder (TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        tmp.add(root);</span><br><span class="line">        <span class="keyword">while</span>( tmp.size() &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; r = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> t_size = tmp.size();</span><br><span class="line">            <span class="keyword">while</span>( t_size -- &gt; <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode t = tmp.remove(<span class="number">0</span>);</span><br><span class="line">                r.add(t.val);</span><br><span class="line">                <span class="keyword">if</span>( t.left != <span class="keyword">null</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp.add(t.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>( t.right != <span class="keyword">null</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp.add(t.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一个常见的小坑：<code>if( root == null )</code>的处理 - </p>
<p>不能直接返回<code>null</code>，而是要返回一个空的结果：<code>new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;()</code></p>
<p>否则会报错。</p>
<p>python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param root TreeNode类 </span></span><br><span class="line"><span class="comment"># @return int整型二维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self , root </span>):</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        tmp = [root]</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(tmp) != <span class="number">0</span>:</span><br><span class="line">            r = []</span><br><span class="line">            size = <span class="built_in">len</span>(tmp)</span><br><span class="line">            <span class="keyword">while</span> size &gt; <span class="number">0</span>:</span><br><span class="line">                t = tmp.pop(<span class="number">0</span>)</span><br><span class="line">                r.append(t.val)</span><br><span class="line">                <span class="keyword">if</span> t.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    tmp.append(t.left)</span><br><span class="line">                <span class="keyword">if</span> t.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    tmp.append(t.right)</span><br><span class="line">                size -= <span class="number">1</span></span><br><span class="line">            res.append(r)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型ArrayList&lt;ArrayList&lt;&gt;&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder (TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.add(root);</span><br><span class="line">        <span class="keyword">return</span> getList(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; getList(ArrayList&lt;TreeNode&gt; tmp)&#123;</span><br><span class="line">        <span class="keyword">if</span>( tmp.size() == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; r = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> size = tmp.size();</span><br><span class="line">        <span class="keyword">while</span>( size -- &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode t = tmp.remove(<span class="number">0</span>);</span><br><span class="line">            r.add(t.val);</span><br><span class="line">            <span class="keyword">if</span>( t.left != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.add(t.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( t.right != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.add(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(r);</span><br><span class="line">        <span class="keyword">return</span> getList(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param root TreeNode类 </span></span><br><span class="line"><span class="comment"># @return int整型二维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">self , root</span>):</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">getList</span>(<span class="params">tmp</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(tmp) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            r = []</span><br><span class="line">            size = <span class="built_in">len</span>(tmp)</span><br><span class="line">            <span class="keyword">while</span> size &gt; <span class="number">0</span>:</span><br><span class="line">                t = tmp.pop(<span class="number">0</span>)</span><br><span class="line">                r.append(t.val)</span><br><span class="line">                <span class="keyword">if</span> t.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    tmp.append(t.left)</span><br><span class="line">                <span class="keyword">if</span> t.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    tmp.append(t.right)</span><br><span class="line">                size -= <span class="number">1</span></span><br><span class="line">            res.append(r)</span><br><span class="line">            <span class="keyword">return</span> getList(tmp)</span><br><span class="line">        tmp = [root]</span><br><span class="line">        <span class="keyword">return</span> getList(tmp)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>java, python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC156 数组中只出现一次的数（其它数出现k次）</title>
    <url>/2021/07/29/LeetCode-NC156-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%EF%BC%88%E5%85%B6%E5%AE%83%E6%95%B0%E5%87%BA%E7%8E%B0k%E6%AC%A1%EF%BC%89/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/5d3d74c3bf7f4e368e03096bb8857871?tpId=188&amp;&amp;tqId=38592&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/5d3d74c3bf7f4e368e03096bb8857871?tpId=188&amp;&amp;tqId=38592&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking</a></p>
<span id="more"></span>



<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-使用map计数"><a href="#1-使用map计数" class="headerlink" title="1. 使用map计数"></a>1. 使用map计数</h3><p>该方法没有使用到变量 <code>k </code>，它将数组中的每个元素进行计数，并将数值以&lt;元素,count&gt;的形式存储到map中，遍历完数组后，返回map的值为1的键。</p>
<p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">foundOnceNumber</span> <span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(arr[i], map.getOrDefault(arr[i], <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( Map.Entry m : map.entrySet() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( m.getValue().equals(<span class="number">1</span>) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="keyword">int</span>)m.getKey();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><p>代码中提到的map的一点基本操作：</p>
<p>1） map默认赋值：getOrDefault(a, b)</p>
<p>map使用 <code>get</code> 方法获取key对应的值，如果没有，会返回 <code>null</code>；可以使用 <code>getOrDefault</code> 方法，如果没有key <code>a</code>，会返回一个默认值 <code>b </code>。</p>
<p>2）Entry迭代</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Map.Entry m: map.entrySet())</span><br><span class="line">&#123;</span><br><span class="line">	System.out.println(m.getKey()+<span class="string">&quot; &quot;</span>+m.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中， <code>m.getKey()</code> 的数据类型为 <code>Object</code> ，指定类型需要进行转换。</p>
<h3 id="2-排序比较"><a href="#2-排序比较" class="headerlink" title="2. 排序比较"></a>2. 排序比较</h3><p>先对数组进行排序，然后比较 <code>n-1</code> 个元素：</p>
<p>当前元素下标为 <code>i</code> ，如果 <code>arr[i] == arr[i+1]</code> ，则说明当前元素是重复的，因为从下标为0开始比较，如果重复肯定往后k个元素都是一样的，所以直接往后跳k步，再进行比较；</p>
<p>为了防止 <code>i+1</code> 的操作越界，需要设定 <code>i &lt; len(arr) - 1</code>，则可以知道，最后一个元素是肯定不会作为 <code>i</code> 进行比较的，所以如果前面所有元素都是重复的，就可以肯定，最后一个元素的个数一定为1。</p>
<p>python:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param arr int一维数组 </span></span><br><span class="line"><span class="comment"># @param k int </span></span><br><span class="line"><span class="comment"># @return int</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foundOnceNumber</span>(<span class="params">self , arr , k </span>):</span></span><br><span class="line">        arr.sort()</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(arr) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> arr[i] == arr[i+<span class="number">1</span>]:</span><br><span class="line">                i += k</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> arr[i]</span><br><span class="line">        <span class="keyword">return</span> arr[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>



<h3 id="3-位运算"><a href="#3-位运算" class="headerlink" title="3. 位运算"></a>3. 位运算</h3><p>因为 <code>k</code> 不一定是偶数，所以不能使用异或运算。可以计算每一位上的1的个数，相同元素肯定会在同一位存在 <code>k</code> 的倍数个 <code>1</code> 。因为 <code>int</code> 的二进制是32位，所以创建长度为32的数组来存储每一位的 <code>1</code> 的个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k int </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">foundOnceNumber</span> <span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] binary_sum = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> n : arr )</span><br><span class="line">            &#123;</span><br><span class="line">                sum += (n &gt;&gt; i &amp; <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            binary_sum[i] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( binary_sum[i] % k != <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                res += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>java, python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC19 子数组的最大累加和问题</title>
    <url>/2021/07/15/LeetCode-NC19-%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E7%B4%AF%E5%8A%A0%E5%92%8C%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/554aa508dd5d4fefbf0f86e5fe953abd?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/554aa508dd5d4fefbf0f86e5fe953abd?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<span id="more"></span>



<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="1-理解"><a href="#1-理解" class="headerlink" title="1. 理解"></a>1. 理解</h3><p>我之前一直想的方法：获取每个子数组的最大连续累加和。</p>
<p>但是这种方法并不适用于这里，因为这种方式求的是并不能连续的最大和。</p>
<p>正确的方法：将之前累加的值永远与当前的值进行比较，将比当前值小的累加抛弃，最小的和是0，即所有值都不取。</p>
<h3 id="2-具体代码"><a href="#2-具体代码" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * max sum of the subarray</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr int整型一维数组 the array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxsumofSubarray</span> <span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Math.max(<span class="number">0</span>, arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = Math.max(arr[i], arr[i-<span class="number">1</span>]+arr[i]);</span><br><span class="line">            max = Math.max(max, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC4 判断链表中是否有环</title>
    <url>/2021/07/06/LeetCode-NC4-%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/650474f313294468a4ded3ce0f7898b9?tpId=188&amp;&amp;tqId=38576&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/650474f313294468a4ded3ce0f7898b9?tpId=188&amp;&amp;tqId=38576&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking</a></p>
<span id="more"></span>

<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="1-快慢指针（典型使用）"><a href="#1-快慢指针（典型使用）" class="headerlink" title="1. 快慢指针（典型使用）"></a>1. 快慢指针（典型使用）</h3><p>java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head, fast = head.next;</span><br><span class="line">        <span class="keyword">while</span>( slow != <span class="keyword">null</span> &amp;&amp; fast != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( slow == fast )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( slow.next == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span> || fast.next.next == <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param head ListNode类 </span></span><br><span class="line"><span class="comment"># @return bool布尔型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self , head </span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        slow, fast = head, head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> slow <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> fast <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> slow.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> fast.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="2-集合判断是否存在"><a href="#2-集合判断是否存在" class="headerlink" title="2. 集合判断是否存在"></a>2. 集合判断是否存在</h3><p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>( head != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( set.contains(head) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self , head </span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> tmp:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            tmp.append(head)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="3-逐个删除"><a href="#3-逐个删除" class="headerlink" title="3. 逐个删除"></a>3. 逐个删除</h3><p>删除，也就是将每个节点指向自己。</p>
<p>在循环的开始对<code>head</code>和<code>head.next</code>判断是否相等，如果相等，循环，如果不相等，删除后继续循环比较，直到没有节点。</p>
<p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( head != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( head.next != <span class="keyword">null</span> &amp;&amp; head == head.next )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode t = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">            t.next = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self , head </span>):</span></span><br><span class="line">        <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> head == head.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            tmp = head</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">            tmp.<span class="built_in">next</span> = tmp</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>java, python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC22 合并两个有序的数组</title>
    <url>/2021/07/14/LeetCode-NC22-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/89865d4375634fc484f3a24b7fe65665?tpId=188&amp;&amp;tqId=38585&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/89865d4375634fc484f3a24b7fe65665?tpId=188&amp;&amp;tqId=38585&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking</a></p>
<span id="more"></span>



<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-从前往后遍历"><a href="#1-从前往后遍历" class="headerlink" title="1. 从前往后遍历"></a>1. 从前往后遍历</h3><p>将两个数组从前往后遍历，如果遇到A数组有值比B当前元素大，则插入；在比较极端的情况下，B数组可能在A数组的两端。</p>
<p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( i &lt; m &amp;&amp; j &lt; n )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( A[i] &lt;= B[j] )</span><br><span class="line">            &#123;</span><br><span class="line">                ++ i;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                move(A, m - <span class="number">1</span>, i);</span><br><span class="line">                A[i] = B[j];</span><br><span class="line">                ++ m;</span><br><span class="line">                ++ j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( i &lt; A.length )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( j &lt; n )</span><br><span class="line">            &#123;</span><br><span class="line">                A[i++] = B[j];</span><br><span class="line">                ++ j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> m, <span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( m + <span class="number">1</span> &gt;= A.length )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=m; i&gt;=s; --i )</span><br><span class="line">        &#123;</span><br><span class="line">            A[i+<span class="number">1</span>] = A[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param A int整型一维数组 </span></span><br><span class="line"><span class="comment"># @param B int整型一维数组 </span></span><br><span class="line"><span class="comment"># @return void</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self , A, m, B, n</span>):</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> j &lt; n:</span><br><span class="line">            <span class="keyword">if</span> A[i] &lt;= B[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.move(A, m - <span class="number">1</span>, i)</span><br><span class="line">                A[i] = B[j]</span><br><span class="line">                m += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(A):</span><br><span class="line">            <span class="keyword">while</span> j &lt; n:</span><br><span class="line">                A[i] = B[j]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span>(<span class="params">self, A, m, s</span>):</span></span><br><span class="line">        <span class="keyword">if</span> m &gt;= <span class="built_in">len</span>(A):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m, s-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            A[i + <span class="number">1</span>] = A[i]</span><br></pre></td></tr></table></figure>



<p>###2. 从后往前遍历</p>
<p>将两张表的当前最后一个元素进行比较，将大的值放到A数组的最后一个空间，循环直到某个表遍历完，如果是B表遍历完结束，A表遍历完就意味着可能B表还有元素没有插入，但是此时A表已经全部存在数据，就意味着A表的前n个数据在后面已经存在，只需要将这些位置的数据替换成B表相应位置的数据就行。</p>
<p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( m &gt; <span class="number">0</span> &amp;&amp; n &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( A[m - <span class="number">1</span>] &gt;= B[n - <span class="number">1</span>] )</span><br><span class="line">            &#123;</span><br><span class="line">                A[m + n - <span class="number">1</span>] = A[m - <span class="number">1</span>];</span><br><span class="line">                m -= <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                A[m + n - <span class="number">1</span>] = B[n - <span class="number">1</span>];</span><br><span class="line">                n -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( n &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i )</span><br><span class="line">            &#123;</span><br><span class="line">                A[i] = B[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param A int整型一维数组 </span></span><br><span class="line"><span class="comment"># @param B int整型一维数组 </span></span><br><span class="line"><span class="comment"># @return void</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self , A, m, B, n</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> A: <span class="keyword">return</span> B</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> B: <span class="keyword">return</span> A</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> A <span class="keyword">and</span> <span class="keyword">not</span> B: <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">while</span> m &gt; <span class="number">0</span> <span class="keyword">and</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> A[m - <span class="number">1</span>] &lt; B[n - <span class="number">1</span>]:</span><br><span class="line">                A[m + n - <span class="number">1</span>] = B[n - <span class="number">1</span>]</span><br><span class="line">                n -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                A[m + n - <span class="number">1</span>] = A[m - <span class="number">1</span>]</span><br><span class="line">                m -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            A[:n] = B[:n]</span><br><span class="line">        <span class="keyword">return</span> A</span><br></pre></td></tr></table></figure>



<p><strong>上述两种方法并没有实质上的区别</strong></p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>java, python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC40 两个链表生成相加链表</title>
    <url>/2021/07/24/LeetCode-NC40-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%94%9F%E6%88%90%E7%9B%B8%E5%8A%A0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/c56f6c70fb3f4849bc56e33ff2a50b6b?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/c56f6c70fb3f4849bc56e33ff2a50b6b?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<span id="more"></span>



<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="1-思路"><a href="#1-思路" class="headerlink" title="1. 思路"></a>1. 思路</h3><p>一开始的思路是将链表转换为具体的值，计算后再转换为最终的链表，但是行不通，因为很有可能会溢出。所以应该要使用类似于数组的结构，可以使用栈Stack来灵活的存取链表的值；也可以更简单粗暴一点，反转链表进行操作。</p>
<h3 id="2-使用栈解决"><a href="#2-使用栈解决" class="headerlink" title="2. 使用栈解决"></a>2. 使用栈解决</h3><p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head1 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head2 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addInList</span> <span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; h1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; h2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        ListNode res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>( head1 != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            h1.push(head1.val);</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( head2 != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            h2.push(head2.val);</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>( !h1.isEmpty() || !h2.isEmpty() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( !h1.isEmpty() )</span><br><span class="line">            &#123;</span><br><span class="line">                sum += h1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( !h2.isEmpty() )</span><br><span class="line">            &#123;</span><br><span class="line">                sum += h2.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ListNode tmp = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            tmp.next = res;</span><br><span class="line">            res = tmp;</span><br><span class="line">            </span><br><span class="line">            sum = sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( sum != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode tmp = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            tmp.next = res;</span><br><span class="line">            res = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param head1 ListNode类 </span></span><br><span class="line"><span class="comment"># @param head2 ListNode类 </span></span><br><span class="line"><span class="comment"># @return ListNode类</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addInList</span>(<span class="params">self , head1 , head2 </span>):</span></span><br><span class="line">        h1, h2, res = [], [], <span class="literal">None</span></span><br><span class="line">        sum_ = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> head1:</span><br><span class="line">            h1.append(head1.val)</span><br><span class="line">            head1 = head1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> head2:</span><br><span class="line">            h2.append(head2.val)</span><br><span class="line">            head2 = head2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> h1 <span class="keyword">or</span> h2:</span><br><span class="line">            <span class="keyword">if</span> h1:</span><br><span class="line">                sum_ = sum_ + h1.pop(-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> h2:</span><br><span class="line">                sum_ = sum_ + h2.pop(-<span class="number">1</span>)</span><br><span class="line">            tmp = ListNode(sum_ % <span class="number">10</span>)</span><br><span class="line">            tmp.<span class="built_in">next</span> = res</span><br><span class="line">            res = tmp</span><br><span class="line">            sum_ = sum_ // <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> sum_ &gt; <span class="number">0</span>:</span><br><span class="line">            tmp = ListNode(sum_)</span><br><span class="line">            tmp.<span class="built_in">next</span> = res</span><br><span class="line">            res = tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h3 id="2-反转链表"><a href="#2-反转链表" class="headerlink" title="2. 反转链表"></a>2. 反转链表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head1 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head2 ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addInList</span> <span class="params">(ListNode head1, ListNode head2)</span> </span>&#123;</span><br><span class="line">        ListNode res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        head1 = reverse(head1);</span><br><span class="line">        head2 = reverse(head2);</span><br><span class="line">        <span class="keyword">while</span>( head1 != <span class="keyword">null</span> || head2 != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( head1 != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                sum += head1.val;</span><br><span class="line">                head1 = head1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( head2 != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                sum += head2.val;</span><br><span class="line">                head2 = head2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode tmp = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            sum /= <span class="number">10</span>;</span><br><span class="line">            tmp.next = res;</span><br><span class="line">            res = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( sum != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode tmp = <span class="keyword">new</span> ListNode(sum);</span><br><span class="line">            tmp.next = res;</span><br><span class="line">            res = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode chan = root.next, pre = root;</span><br><span class="line">        <span class="keyword">while</span>( root != <span class="keyword">null</span> &amp;&amp; chan != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            root.next = chan.next;</span><br><span class="line">            chan.next = pre;</span><br><span class="line">            pre = chan;</span><br><span class="line">            <span class="keyword">if</span>( root != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                chan = root.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>java, python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC3 链表中环的入口结点</title>
    <url>/2021/07/28/LeetCode-NC3-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=188&amp;&amp;tqId=38577&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=188&amp;&amp;tqId=38577&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking</a></p>
<span id="more"></span>



<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><h3 id="1-使用栈留存比较"><a href="#1-使用栈留存比较" class="headerlink" title="1. 使用栈留存比较"></a>1. 使用栈留存比较</h3><p>pHead一次走一步，先与栈中元素进行比较，如果存在当前节点，说明该链表存在环，如果不存在，将当前节点存入，继续进行比较。第一个在栈中出现的节点为入口结点。</p>
<p>Java:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( pHead == <span class="keyword">null</span> )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        Stack&lt;ListNode&gt; list = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>( pHead != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( list.contains(pHead) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> pHead;</span><br><span class="line">            &#125;</span><br><span class="line">            list.push(pHead);</span><br><span class="line">            pHead = pHead.next;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Python:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        arr = []</span><br><span class="line">        <span class="keyword">while</span> pHead:</span><br><span class="line">            <span class="keyword">if</span> pHead <span class="keyword">in</span> arr:</span><br><span class="line">                <span class="keyword">return</span> pHead</span><br><span class="line">            arr.append(pHead)</span><br><span class="line">            pHead = pHead.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>



<h3 id="2-使用快慢指针"><a href="#2-使用快慢指针" class="headerlink" title="2. 使用快慢指针"></a>2. 使用快慢指针</h3><p>一开始想到的就是这种方法，但是陷入一个<strong>误区</strong>：快慢指针相等时的节点为入口结点。这个错误的认知就是无知无畏……</p>
<p>忽略掉的核心步骤：</p>
<p>快慢指针会进行两次 - </p>
<p>（1）找到第一个相同的节点，将该节点置为此链表的最后一个节点，此时slow节点至少会遍历完所有的节点一次；</p>
<p>（2）第二次将fast和slow节点放在头和最后一个节点，每次各走一步：fast走两格、slow走一格；二者第一次相遇的节点即为入口结点。</p>
<blockquote>
<p>比如 {1,2},{3,4,5}，其中前面括号是环外的节点，后面是环中的节点。</p>
<p>第一次遍历：fast - 1 3 5 4；slow - 1 2 3 4 -&gt; 同为4，将链表变为 {1,2},{3,4}；</p>
<p>第二次便利，fast - 1 3 4；slow - 4 3 -&gt; 同为3，可知入环节点为3.</p>
</blockquote>
<p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( pHead == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast = pHead, slow = pHead;</span><br><span class="line">        Stack&lt;ListNode&gt; slow_list = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>( fast != <span class="keyword">null</span> &amp;&amp; slow != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( fast.next != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            slow_list.push(slow);</span><br><span class="line">            <span class="keyword">if</span>( fast == slow )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( fast == <span class="keyword">null</span> || slow == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span>( fast != slow_list.peek() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( fast.next != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            slow_list.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow_list.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">EntryNodeOfLoop</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        fast, slow = pHead, pHead</span><br><span class="line">        slow_list = []</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> slow:</span><br><span class="line">            <span class="keyword">if</span> fast.<span class="built_in">next</span>:</span><br><span class="line">                fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            slow_list.append(slow)</span><br><span class="line">            <span class="keyword">if</span> fast == slow:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> slow:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        fast = pHead</span><br><span class="line">        <span class="keyword">while</span> fast != slow_list[-<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">if</span> fast.<span class="built_in">next</span>:</span><br><span class="line">                fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow_list.pop()</span><br><span class="line">        <span class="keyword">return</span> fast</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>java, python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC45 实现二叉树先序，中序和后序遍历</title>
    <url>/2021/07/14/LeetCode-NC45-%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E5%85%88%E5%BA%8F%EF%BC%8C%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/a9fec6c46a684ad5a3abd4e365a9d362?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/a9fec6c46a684ad5a3abd4e365a9d362?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<span id="more"></span>



<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-常见思路-递归遍历"><a href="#1-常见思路-递归遍历" class="headerlink" title="1. 常见思路 - 递归遍历"></a>1. 常见思路 - 递归遍历</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param root TreeNode类 the root of binary tree</span></span><br><span class="line"><span class="comment"># @return int整型二维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeOrders</span>(<span class="params">self , root </span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 先序遍历</span></span><br><span class="line">        pre = []</span><br><span class="line">        self.preOrder(root, pre)</span><br><span class="line">        <span class="comment"># 中序遍历</span></span><br><span class="line">        mid = []</span><br><span class="line">        self.midOrder(root, mid)</span><br><span class="line">        <span class="comment"># 后序遍历</span></span><br><span class="line">        post = []</span><br><span class="line">        self.postOrder(root, post)</span><br><span class="line">        <span class="keyword">return</span> [pre, mid, post]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preOrder</span>(<span class="params">self, root, arr</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        arr.append(root.val)</span><br><span class="line">        self.preOrder(root.left, arr)</span><br><span class="line">        self.preOrder(root.right, arr)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">midOrder</span>(<span class="params">self, root, arr</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.midOrder(root.left, arr)</span><br><span class="line">        arr.append(root.val)</span><br><span class="line">        self.midOrder(root.right, arr)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postOrder</span>(<span class="params">self, root, arr</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.postOrder(root.left, arr)</span><br><span class="line">        self.postOrder(root.right, arr)</span><br><span class="line">        arr.append(root.val)</span><br></pre></td></tr></table></figure>



<h3 id="2-对第一个代码进行一点改进"><a href="#2-对第一个代码进行一点改进" class="headerlink" title="2. 对第一个代码进行一点改进"></a>2. 对第一个代码进行一点改进</h3><p>将上面代码的三个排序函数合并为一个。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @param root TreeNode类 the root of binary tree</span></span><br><span class="line"><span class="comment"># @return int整型二维数组</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeOrders</span>(<span class="params">self , root </span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="comment"># 先序遍历</span></span><br><span class="line">        pre, mid, post = [], [], []</span><br><span class="line">        self.order(root, pre, mid, post)</span><br><span class="line">        <span class="keyword">return</span> [pre, mid, post]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">order</span>(<span class="params">self, root, pre, mid, post</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        pre.append(root.val)</span><br><span class="line">        self.order(root.left, pre, mid, post)</span><br><span class="line">        mid.append(root.val)</span><br><span class="line">        self.order(root.right, pre, mid, post)</span><br><span class="line">        post.append(root.val)</span><br></pre></td></tr></table></figure>



<h3 id="3-迭代查询"><a href="#3-迭代查询" class="headerlink" title="3. 迭代查询"></a>3. 迭代查询</h3><p>迭代这种就容易想复杂。。。特别是后序遍历！！</p>
<p>以下描述基础思想：</p>
<ol>
<li><p>先序遍历：跟左右</p>
<p>（1）头节点先入栈，然后进入循环；</p>
<p>（2）先出跟，获取其值，然后将右左节点入栈 - 因为栈是先进后出，所以放入应该是先右后左；</p>
<p>（3）然后遍历获取就行了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preOrder</span>(<span class="params">self, root, arr</span>):</span></span><br><span class="line">        stack = [root]</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(stack) != <span class="number">0</span>:</span><br><span class="line">            tmp = stack.pop()</span><br><span class="line">            arr.append(tmp.val)</span><br><span class="line">            <span class="keyword">if</span> tmp.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(tmp.right)</span><br><span class="line">            <span class="keyword">if</span> tmp.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                stack.append(tmp.left)</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历：左跟右</p>
<p>那么存放仅栈的顺序就应该是右跟左，但是不可能从右子树开始遍历，那么就只能存根，遍历左子树，等到没有左子树了，再开始遍历右子树并存值，即出此时没有左子树的跟，取跟值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">midOrder</span>(<span class="params">self, root, arr</span>):</span></span><br><span class="line">    stack = []</span><br><span class="line">    cur = root</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(stack) != <span class="number">0</span> <span class="keyword">or</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> cur.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            stack.append(cur.left)</span><br><span class="line">            cur = cur.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            arr.append(cur.val)</span><br><span class="line">            cur = cur.right</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序遍历（就先序遍历反操作就是了）</p>
<p>也就是先序遍历的反操作，逆序取跟左右，最终输出左右跟。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postOrder</span>(<span class="params">self, root, arr</span>):</span></span><br><span class="line">    stack = [root]</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(stack) != <span class="number">0</span>:</span><br><span class="line">        tmp = stack.pop()</span><br><span class="line">        arr.append(tmp.val)</span><br><span class="line">        <span class="keyword">if</span> tmp.left <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            stack.append(tmp.left)</span><br><span class="line">        <span class="keyword">if</span> tmp.right <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            stack.append(tmp.right)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC76 用两个栈实现队列</title>
    <url>/2021/07/07/LeetCode-NC76-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=188&amp;&amp;tqId=38552&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-rankingj">https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=188&amp;&amp;tqId=38552&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-rankingj</a></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="1-两个栈分别在push和pop之前都会循环"><a href="#1-两个栈分别在push和pop之前都会循环" class="headerlink" title="1. 两个栈分别在push和pop之前都会循环"></a>1. 两个栈分别在push和pop之前都会循环</h3><p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( !stack2.isEmpty() )</span><br><span class="line">        &#123;</span><br><span class="line">            stack1.push(stack2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>( !stack1.isEmpty() )</span><br><span class="line">        &#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-对上面代码的一点点优化，将两个循环转变为一个循环"><a href="#2-对上面代码的一点点优化，将两个循环转变为一个循环" class="headerlink" title="2. 对上面代码的一点点优化，将两个循环转变为一个循环"></a>2. 对上面代码的一点点优化，将两个循环转变为一个循环</h3><p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( stack2.isEmpty() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( !stack1.isEmpty() )</span><br><span class="line">            &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>java, python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC78 反转链表</title>
    <url>/2021/07/04/LeetCode-NC78-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=188&amp;&amp;tqId=38547&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=188&amp;&amp;tqId=38547&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking</a></p>
<span id="more"></span>



<h2 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h2><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>( head != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode p = head;</span><br><span class="line">            head = head.next;</span><br><span class="line">            p.next = res;</span><br><span class="line">            res = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回ListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReverseList</span>(<span class="params">self, pHead</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pHead <span class="keyword">or</span> <span class="keyword">not</span> pHead.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead</span><br><span class="line">        res = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> pHead:</span><br><span class="line">            p = pHead</span><br><span class="line">            pHead = pHead.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = res</span><br><span class="line">            res = p</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre = ReverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode pre = ReverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对上面代码的理解：</p>
<ol>
<li><p>ListNode pre &#x3D; ReverseList(head.next)</p>
<p>获取当前结点之前反转好的链表，注意，此时head.next是已经反转好的链表的最后一个节点；</p>
</li>
<li><p>head.next.next &#x3D; head</p>
<p>将当前节点接到已经反转好的链表的最后一个节点后面，也就是将当前head放到head.next后面；</p>
</li>
<li><p>head.next &#x3D; null</p>
<p>最后将当前节点的next置空，作为当前已经反转好的链表的最后一个节点。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>java, python</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - NC68 跳台阶</title>
    <url>/2021/07/09/LeetCode-NC68-%E8%B7%B3%E5%8F%B0%E9%98%B6/</url>
    <content><![CDATA[<h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=188&amp;&amp;tqId=38622&amp;rp=1&amp;ru=/ta/job-code-high-week&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=188&amp;&amp;tqId=38622&amp;rp=1&amp;ru=/ta/job-code-high-week&amp;qru=/ta/job-code-high-week/question-ranking</a></p>
<span id="more"></span>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>在中间的某个台阶<code>f[n]</code>，走到这个台阶有两种可能，走一步或走两步，得到公式：<code>f[n] = f[n-1] + f[n-2]</code>，根据常识可以知道，<code>n为1或0时</code>，即<code>f[1] = f[0] = 1</code>，默认排除n小于0的可能性，可以计算结果。</p>
<h3 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( target &lt;= <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jumpFloor(target-<span class="number">1</span>) + jumpFloor(target-<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法在python中运算时间过长。</p>
<h3 id="2-动态规划"><a href="#2-动态规划" class="headerlink" title="2. 动态规划"></a>2. 动态规划</h3><p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=target; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对上述代码进行改动，简化了数组的使用。python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        a, b, c = <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, number+<span class="number">1</span>):</span><br><span class="line">            c = a + b</span><br><span class="line">            a = b</span><br><span class="line">            b = c</span><br><span class="line">        <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>爬楼梯</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode - 剑指 Offer 44. 数字序列中某一位的数字</title>
    <url>/2021/11/18/LeetCode-%E5%89%91%E6%8C%87-Offer-44-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/</a></p>
<span id="more"></span>



<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>插值查找是二分查找的变种。</p>
<p>二分查找是：有三个变量，<code>low = 0， high = num.length, mid = (low + high)/2</code>，这三个变量是固定的，插值查找的这三个变量是可变。</p>
<p>将 <code>low</code> 和 <code>high</code> 当成是上限和下限， <code>mid</code> 是一个灵活的具有规律的指定元素，可以分析该题：</p>
<ol>
<li>字符串可以分为多个区间：<code>0-9、10-99、100-999......</code> ；</li>
<li>因为 <code>0-9</code> 返回本身，所以直接返回可以省去一次运算；</li>
<li>接下来降维计算。<strong>像这种求区间中的具体值的，可以考虑这种方法</strong>；</li>
<li>因为是一维一维降的，所以不符合if条件的肯定会降下第一维：<code>n -= 9</code> ；</li>
<li>之后从第二维开始：<code>start = 10, end = 99, digit = 2</code> ；</li>
<li>开始一维一维的减，直到<code>n</code> 在某一维区间内，退出循环；</li>
<li>计算该区间的该 <code>n</code> 对应的实际数字：<code>(start + (n - 1) / digit)</code> ，该区间从 <code>start</code> 开始，<code>n - 1</code> 是因为每次以 <code>0</code> 为首个下标，所以需要 <code> - 1</code> ，为了方便取数，<code>+&quot;&quot;</code> 变成字符串；</li>
<li>之后 <code>(n - 1) % digit</code> 取哪一位上的数。</li>
</ol>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNthDigit</span> <span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> start = <span class="number">10</span>, end = <span class="number">99</span>;</span><br><span class="line">        <span class="keyword">long</span> digit = <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        n -= <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span>( n &gt; end )</span><br><span class="line">        &#123;</span><br><span class="line">            n -= end;</span><br><span class="line">            start *= <span class="number">10</span>;</span><br><span class="line">            digit += <span class="number">1</span>;</span><br><span class="line">            end = start * <span class="number">9</span> * digit;</span><br><span class="line">        &#125;</span><br><span class="line">        String num = (start + (n - <span class="number">1</span>) / digit) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> idx = (<span class="keyword">int</span>)((n - <span class="number">1</span>) % digit);</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(num.charAt(idx)+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>刷题</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>插值查找</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux - 学习笔记</title>
    <url>/2022/02/13/Linux-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="ps-ef-和-ps-aux"><a href="#ps-ef-和-ps-aux" class="headerlink" title="ps -ef 和 ps aux"></a>ps -ef 和 ps aux</h3><p>都用来显示全部进程，<code>-ef</code> 显示标准格式，<code>aux</code> 显示BSD格式。</p>
<span id="more"></span>

<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>查找输入的内容中符合指定内容的字符串。</p>
<p><strong>grep [指定内容] [输入内容，一般此处放文件]</strong></p>
<h4 id="ps-ef-grep-指定内容"><a href="#ps-ef-grep-指定内容" class="headerlink" title="ps -ef | grep [指定内容]"></a>ps -ef | grep [指定内容]</h4><p>显示所有进程中与指定内容相同的进程。</p>
<h4 id="grep-v"><a href="#grep-v" class="headerlink" title="grep -v"></a>grep -v</h4><p><code>grep -v grep</code>：取出不包含grep的进程行。</p>
<p><code>grep -v &quot;name&quot;</code>：取出不包含字符串 name 的行。</p>
<h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h3><p>计算字数。</p>
<h4 id="wc-l"><a href="#wc-l" class="headerlink" title="wc -l"></a>wc -l</h4><p>显示行数</p>
<h4 id="wc-L"><a href="#wc-L" class="headerlink" title="wc -L"></a>wc -L</h4><p>显示当前行的长度。</p>
<h3 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h3><p>不挂断的执行命令。</p>
<h4 id="nohup-amp"><a href="#nohup-amp" class="headerlink" title="nohup &amp;"></a>nohup &amp;</h4><p>在后台执行。会返回一个进程号用于查该进程。</p>
<h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>查看网络相关的信息。</p>
<h4 id="netstat-ap-grep-端口号"><a href="#netstat-ap-grep-端口号" class="headerlink" title="netstat -ap | grep [端口号]"></a>netstat -ap | grep [端口号]</h4><p>查看指定端口有哪些进程。</p>
<h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>删除执行中的程序或工作。</p>
<h4 id="kill-9"><a href="#kill-9" class="headerlink" title="kill -9"></a>kill -9</h4><p>强制杀死进程。</p>
<h3 id="统计文件行数"><a href="#统计文件行数" class="headerlink" title="统计文件行数"></a>统计文件行数</h3><p>两种方式：</p>
<p><strong>1. wc -l test.txt | awk ‘{print $1}’</strong></p>
<p><code>wc -l test.txt</code> 显示行数和 ‘test.txt’ 两列。</p>
<p><code>awk &#39;&#123;print $1&#125;&#39;</code> 显示管道前输出的第一列。</p>
<p><strong>2. awk ‘{print NR}’ test.txt | tail -n1</strong></p>
<p><code>awk &#39;&#123;print NR&#125;&#39; test.txt</code> 显示 <code>test.txt</code> 文件的行号，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>tail -n 1</code> 最后一行。</p>
<p><strong>3. awk ‘END{print NR}’ test.txt</strong></p>
<p><code>END</code> 必须大写。</p>
<p><strong>4. grep -c “” test.txt</strong></p>
<p><code>grep -c</code> 输出文件 <code>test.txt</code> 中匹配字符串 <code>&quot;&quot;</code> 的行。</p>
<p><strong>5. grep -n “” test.txt | awk -F “:” ‘{print $1}’</strong></p>
<p><code>grep -n &quot;&quot; test.txt</code> 输出文件 <code>test.txt</code> 中匹配字符串 <code>&quot;&quot;</code> 的行号及行，格式为：<code>行号:行内容</code> ；</p>
<p><code>awk -F &quot;:&quot; &#39;&#123;print $1&#125;&#39;</code> 将输入依照 <code>:</code> 分隔符切分，并输出第一列。</p>
<h2 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h2><p>如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!bin/bash</span></span><br><span class="line">num=0</span><br><span class="line"><span class="keyword">while</span> (( num &lt;= 500 ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> (( num % 7 == 0 ))</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$num</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">    ((num++))</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>



<h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> &#123;0..500..7&#125;; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$num</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>&#123;0..500..7&#125;</code> 的含义是输出 0 - 500 中 7 的倍数。</p>
<h2 id="头n行和后n行"><a href="#头n行和后n行" class="headerlink" title="头n行和后n行"></a>头n行和后n行</h2><p>头n行：<code>head -n n</code></p>
<p>后n行：<code>tail -n n</code></p>
<h3 id="实现打印第五行"><a href="#实现打印第五行" class="headerlink" title="实现打印第五行"></a>实现打印第五行</h3><p><strong>1. head -n 5 test.txt | tail -n 1</strong></p>
<p><strong>2. sed -n 5p</strong></p>
<h2 id="SHELL5打印空行的行号"><a href="#SHELL5打印空行的行号" class="headerlink" title="SHELL5打印空行的行号"></a>SHELL5打印空行的行号</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;if(NF == 0) print NR&#125;&#x27;</span> nowcoder.txt</span><br></pre></td></tr></table></figure>

<h3 id="awk内建变量"><a href="#awk内建变量" class="headerlink" title="awk内建变量"></a>awk内建变量</h3><p><code>NF</code> 和 <code>NR</code> 是内建变量，<code>NF</code> 计算一行内单词的总数，默认以空格为分隔符计算，<code>NR</code> 显示当前行数。</p>
<p><code>RS</code> 指定行分隔符，使用 <code>awk &#39;BEGIN&#123;RS=&quot;|&quot;&#125;&#123;print $0&#125;&#39;</code> ，将一行按照分隔符 <code>|</code> 分割为多列并显示。</p>
<h3 id="awk流程控制语句"><a href="#awk流程控制语句" class="headerlink" title="awk流程控制语句"></a>awk流程控制语句</h3><p>if语句：以奇偶数为例。</p>
<p>判断偶数：<code>awk &#39;BEGIN &#123;num = 10; if (num % 2 == 0) printf &quot;%d 是偶数\n&quot;, num&#125;&#39;</code></p>
<p>判断奇偶数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN &#123;</span></span><br><span class="line"><span class="string">num = 11;</span></span><br><span class="line"><span class="string">if (num % 2 == 0) printf &quot;%d 是偶数\n&quot;, num;</span></span><br><span class="line"><span class="string">else printf &quot;%d 是奇数\n&quot;, num</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>for语句：以打印字母数小于8的单词为例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># nowcoder.txt</span><br><span class="line">how they are implemented and applied in computer </span><br></pre></td></tr></table></figure>

<p>解决：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;for(i=0;i&lt;NF;++i) if(length($i) &lt; 8) print $i&#125;&#x27;</span> nowcoder.txt</span><br></pre></td></tr></table></figure>



<h3 id="去掉空行"><a href="#去掉空行" class="headerlink" title="去掉空行"></a>去掉空行</h3><p>已知 <code>$0</code> 表示输出整行，可以这样写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;if(NF != 0) print $0&#125;&#x27;</span> nowcoder.txt</span><br></pre></td></tr></table></figure>

<p>也可以这样写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat nowcoder.txt | awk NF</span><br></pre></td></tr></table></figure>



<h2 id="计算文件中所有行的第六列"><a href="#计算文件中所有行的第六列" class="headerlink" title="计算文件中所有行的第六列"></a>计算文件中所有行的第六列</h2><p><a href="https://www.nowcoder.com/practice/fb24140bac154e5b99e44e0cee45dcaf?tpId=195&tqId=36218&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=/exam/oj?tab=SHELL%25E7%25AF%2587&topicId=195&difficulty=undefined&judgeStatus=undefined&tags=&title="><strong>SHELL8</strong> <strong>统计所有进程占用内存大小的和</strong></a></p>
<p>整行获取：</p>
<ol>
<li>read p &lt; file</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> p</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">		...</span><br><span class="line">	<span class="keyword">done</span> &lt; nowcode.txt</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>awk ‘{print $0}’</li>
</ol>
<p>累加第六列：</p>
<ol>
<li>awk的三种方式：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line">sum=0</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `awk <span class="string">&#x27;&#123;print $6&#125;&#x27;</span> nowcode.txt`</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    	((sum+=<span class="variable">$i</span>))</span><br><span class="line">    <span class="keyword">done</span>    </span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">awk <span class="string">&#x27;&#123;sum+=$6&#125;END&#123;print sum&#125;&#x27;</span> nowcode.txt</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;sum=0&#125;&#123;sum+=$6&#125;END&#123;print sum&#125;&#x27;</span> nowcode.txt</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>read p的两种方式，第二种性能最好：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1</span></span><br><span class="line">sum=0</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> p</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">		((sum+=$(<span class="built_in">echo</span> <span class="variable">$p</span>|awk <span class="string">&#x27;print $6&#x27;</span>)))</span><br><span class="line">	<span class="keyword">done</span> &lt; nowcode.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$sum</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">sum=0</span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> p:</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">		arr=(<span class="variable">$p</span>)</span><br><span class="line">		((sum+=arr[5]))</span><br><span class="line">	<span class="keyword">done</span> &lt; nowcode.txt</span><br><span class="line"><span class="built_in">echo</span></span><br></pre></td></tr></table></figure>

<p>没有使用 <code>awk</code> ，而是使用定义数组接收，性能最好。</p>
<h2 id="SHELL9-统计每个单词出现的个数"><a href="#SHELL9-统计每个单词出现的个数" class="headerlink" title="SHELL9 统计每个单词出现的个数"></a><strong>SHELL9</strong> <strong>统计每个单词出现的个数</strong></h2><p>已知 <code>NF</code> 指的是一行中单词的总数，<code>$i</code> 指的是对应的字段。</p>
<p>如果使用 <code>for(i in list) print i, list[i]</code> 表示遍历数组 <code>list</code> ，取出对应的下标 <code>i</code> 和 下标中的值。这里的下标 <code>i</code> 往往指的是实际的字段。</p>
<p>具体代码是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;for(i=1;i&lt;=NF;i++) list[$i]+=1&#125;END&#123;for(i in list) print i, list[i]&#125;&#x27;</span> nowcoder.txt</span><br></pre></td></tr></table></figure>



<h2 id="SHELL11-转置文件的内容（for语句和内建变量的详细理解）"><a href="#SHELL11-转置文件的内容（for语句和内建变量的详细理解）" class="headerlink" title="SHELL11 转置文件的内容（for语句和内建变量的详细理解）"></a><strong>SHELL11</strong> <strong>转置文件的内容</strong>（for语句和内建变量的详细理解）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">for(i=1;i&lt;=NF;i++)&#123;</span></span><br><span class="line"><span class="string">    if(NR==1)&#123;</span></span><br><span class="line"><span class="string">        row[i]=$i</span></span><br><span class="line"><span class="string">    &#125;else</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        row[i]=row[i]&quot; &quot;$i</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;END&#123;</span></span><br><span class="line"><span class="string">    for(i=1;i&lt;=NF;i++)&#123;</span></span><br><span class="line"><span class="string">        print row[i]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> nowcoder.txt</span><br></pre></td></tr></table></figure>

<p>已知文件内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注释：nowcoder.txt</span></span><br><span class="line">job salary</span><br><span class="line">c++ 13</span><br><span class="line">java 14</span><br><span class="line">php 12</span><br></pre></td></tr></table></figure>

<p>先看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print NF&#125;&#x27;</span> nowcode.txt</span><br></pre></td></tr></table></figure>

<p>得到结果：</p>
<blockquote>
<p>2<br>2<br>2<br>2</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span> nowcode.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>salary<br>13<br>14<br>12</p>
</blockquote>
<p><strong>得到结论：内建变量NF本身用于计算一行的单词个数，使用 $ 符号后与 $2 得到的结果一致，都用于取文件中第二列的内容，所以 $ 符号可以用于取某一列的数据。</strong></p>
<p>可以推出如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;for(i=1;i&lt;=NF;++i) print i,$i&#125;&#x27;</span> nowcode.txt</span><br></pre></td></tr></table></figure>

<p>得到结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 job</span><br><span class="line">2 salary</span><br><span class="line">1 c++</span><br><span class="line">2 13</span><br><span class="line">1 java</span><br><span class="line">2 14</span><br><span class="line">1 php</span><br><span class="line">2 12</span><br></pre></td></tr></table></figure>

<p>其中 <code>for(i=1;i&lt;=NF;++i)</code> 用于遍历每一行单词的个数，然后 <code>print i,$i</code> 用于取出每一行的列号及该列对应的单词。</p>
<p>看第一个 <code>&#123;&#125;</code> 内的具体内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=1;i&lt;=NF;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(NR==1)&#123;</span><br><span class="line">        row[i]=<span class="variable">$i</span></span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        row[i]=row[i]<span class="string">&quot; &quot;</span><span class="variable">$i</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外层的 <code>for循环</code> 用于遍历每一行的单词数目，也就是 <code>i∈[1, NF]</code> ，如果该行是第一行 <code>NR==1</code> ，第一行的该列转置为第一列的改行。也就是将</p>
<blockquote>
<p>job salary</p>
</blockquote>
<p>转置为</p>
<blockquote>
<p>job</p>
<p>salary</p>
</blockquote>
<p>使用一维数组 <code>row</code> 来保存，<code>row[1]</code> 表示第一行，<code>row[2]</code> 表示第二行。</p>
<p>然后使用 <code>row[i]=row[i]&quot; &quot;$i</code> 拼接一列数据。</p>
<p>最后在如下代码中将每一行输出即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=1;i&lt;=NF;i++)&#123;</span><br><span class="line">    <span class="built_in">print</span> row[i]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="SHELL12-打印每一行出现的数字个数"><a href="#SHELL12-打印每一行出现的数字个数" class="headerlink" title="SHELL12 打印每一行出现的数字个数"></a><strong>SHELL12</strong> <strong>打印每一行出现的数字个数</strong></h2><p>具体代码如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">linecount=1</span><br><span class="line">sum=0</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">read</span> line;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    count=0</span><br><span class="line">    <span class="keyword">for</span> (( i=0; i&lt;<span class="variable">$&#123;#line&#125;</span>; ++i ))</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> [[ <span class="variable">$&#123;line:$i:1&#125;</span> =~ [1-5] ]]</span><br><span class="line">        <span class="keyword">then</span></span><br><span class="line">            ((++count))</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;line<span class="variable">$linecount</span> number:<span class="variable">$count</span>&quot;</span></span><br><span class="line">    sum=$((<span class="variable">$sum</span> + <span class="variable">$count</span>))</span><br><span class="line">    ((++linecount))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;sum is <span class="variable">$sum</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>诸如 <code>linecount=1</code> 这种都是对变量的定义。这里对空格有严格的规定：</p>
<p><strong>赋值语句等号两边不能有空格，而字符串比较，等号两边必须有空格</strong></p>
<p><code>if</code> 语句和 <code>for</code> 语句的 <code>[[ ]]</code> 和 <code>(( ))</code> 左右和中间都需要空格隔开，否则会报错。</p>
<p><code>while</code> 语句中的 <code>line</code> 会显示一行的数据，<code>$&#123;#line&#125;</code> 会显示一行的字符个数，<code>$&#123;line:$i:1&#125;</code> 显示一行字符从 <code>$i</code> 开始取一个字符。</p>
<p><code>=~</code> 左侧的内容是否包含右侧<strong>正则匹配</strong>内容的模式。</p>
<p><code>$(($sum + $count))</code> 两个变量相加，<code>((++linecount))</code> 变量自增。</p>
<h2 id="SHELL14-求平均值（保留三位小数）"><a href="#SHELL14-求平均值（保留三位小数）" class="headerlink" title="SHELL14 求平均值（保留三位小数）"></a><strong>SHELL14</strong> <strong>求平均值</strong>（保留三位小数）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    if(NR == 1)</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        count=$1</span></span><br><span class="line"><span class="string">    &#125;else</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        sum+=$1</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;END&#123;</span></span><br><span class="line"><span class="string">    printf(&quot;%.3f&quot;, sum / count)</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> nowcoder.txt</span><br></pre></td></tr></table></figure>



<h2 id="SHELL16-判断输入的是否为IP地址（指定分隔符，or）"><a href="#SHELL16-判断输入的是否为IP地址（指定分隔符，or）" class="headerlink" title="SHELL16 判断输入的是否为IP地址（指定分隔符，or）"></a><strong>SHELL16</strong> <strong>判断输入的是否为IP地址</strong>（指定分隔符，or）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F <span class="string">&#x27;.&#x27;</span> <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    if(NF==4)</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        for(i=1;i&lt;=NF;++i)</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            if($i &lt; 0 || $i &gt; 255)</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                print(&quot;no&quot;)</span></span><br><span class="line"><span class="string">                break</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        if(i == 5)</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">        print(&quot;yes&quot;)</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;else</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        print(&quot;error&quot;)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> nowcoder.txt</span><br></pre></td></tr></table></figure>

<p><code>awk -F &#39;.&#39;</code> 对一行数据指定 <code>.</code> 为分隔符，<code>awk</code> 中使用 <code>print</code> 相关作为输出，<code>echo</code> 不行。</p>
<h2 id="数组计数并sort-r-排序"><a href="#数组计数并sort-r-排序" class="headerlink" title="数组计数并sort -r 排序"></a>数组计数并sort -r 排序</h2><p><a href="https://www.nowcoder.com/practice/f076c0a3c1274cbe9d615e0f3fd965f1?tpId=195&tags=&title=&difficulty=0&judgeStatus=0&rp=1"><strong>SHELL18</strong> <strong>域名进行计数排序处理</strong></a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F <span class="string">&quot;/&quot;</span> <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    arr[$3] = arr[$3] + 1</span></span><br><span class="line"><span class="string">&#125;END&#123;for(a in arr)&#123;print(arr[a], a)&#125;&#125;&#x27;</span> | sort -r</span><br></pre></td></tr></table></figure>



<h2 id="echo、print和printf"><a href="#echo、print和printf" class="headerlink" title="echo、print和printf"></a>echo、print和printf</h2><p><a href="https://www.nowcoder.com/practice/d91a06bfaff443928065e611b14a0e95?tpId=195&tqId=39430&rp=1&ru=/exam/oj&qru=/exam/oj&sourceUrl=/exam/oj?tab=SHELL%25E7%25AF%2587&topicId=195&difficulty=undefined&judgeStatus=undefined&tags=&title="><strong>SHELL21</strong> <strong>格式化输出</strong></a></p>
<p><a href="https://www.cnblogs.com/f-ck-need-u/p/5915076.html">借鉴1</a></p>
<p><a href="https://www.runoob.com/linux/linux-shell-printf.html">借鉴2</a></p>
<h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>主要注意点在于单双引号的特殊情况。</p>
<ol>
<li><p><code>!</code> 的使用：</p>
<p>可以直接打印，也可以单引号打印。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello world!</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello world!&#x27;</span></span><br></pre></td></tr></table></figure>

<p>但是不能使用双引号打印：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello world!&quot;</span> <span class="comment"># 会报错：-bash: !&quot;: event not found</span></span><br><span class="line"><span class="comment"># 如果一定要双引号，可以把 ! 单独拎出来单引</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span><span class="string">&#x27;!&#x27;</span></span><br></pre></td></tr></table></figure>

<p>当后面还要输出内容，必须使用单引号括住，或者放到最后输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> hello world!; <span class="built_in">echo</span> <span class="string">&#x27;hello world!&#x27;</span> <span class="comment"># 会报错：-bash: !: event not found</span></span><br><span class="line"><span class="comment"># 应该这么写</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;hello world!&#x27;</span>; <span class="built_in">echo</span> hello world!</span><br></pre></td></tr></table></figure>
</li>
<li><p>转义字符的识别：</p>
<p>需要加 <code>-e</code> 来识别。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;Hello World!\n&#x27;</span>;<span class="built_in">echo</span> <span class="string">&quot;Hello World&quot;</span>!  </span><br></pre></td></tr></table></figure>

<blockquote>
<p>会输出：</p>
<p>Hello World!\n</p>
<p>Hello World!</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&#x27;hello world!\n&#x27;</span>; <span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span>!</span><br></pre></td></tr></table></figure>

<blockquote>
<p>会输出：</p>
<p>hello world!</p>
<p>#换行</p>
<p>hello world!</p>
</blockquote>
</li>
<li><p>写入文件的分行处理：</p>
<p>默认每次写入会分行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World&quot;</span>! &gt; a.sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World&quot;</span>! &gt;&gt; a.sh <span class="comment"># &gt; 覆盖，&gt;&gt; 追加</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>#a.sh</p>
<p>Hello World!</p>
<p>Hello World!</p>
</blockquote>
<p>使用 <code>-n</code> 取消分行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;Hello World&quot;</span>! &gt; a.sh</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello World&quot;</span>! &gt;&gt; a.sh</span><br></pre></td></tr></table></figure>

<blockquote>
<p>#a.sh</p>
<p>Hello World!Hello World!</p>
</blockquote>
</li>
<li><p>颜色输出：</p>
<p>（1）常见的字体颜色：重置&#x3D;0，黑色&#x3D;30，红色&#x3D;31，绿色&#x3D;32，黄色&#x3D;33，蓝色&#x3D;34，紫色&#x3D;35，天蓝色&#x3D;36，白色&#x3D;37。</p>
<p>（2）常见的背景颜色：重置&#x3D;0，黑色&#x3D;40，红色&#x3D;41，绿色&#x3D;42，黄色&#x3D;43，蓝色&#x3D;44，紫色&#x3D;45，天蓝色&#x3D;46，白色&#x3D;47。</p>
<p>（3）字体控制选项：1表示高亮，4表示下划线，5表示闪烁等。</p>
<p><strong>因为需要使用特殊符号，所以需要配合-e选项来识别特殊符号。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;\e[1;41m Red Bcakground \e[0m&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>\e[字体色;背景色m ... \e[字体色:背景色m</code> 的格式定义开始的颜色和结束的颜色。<code>[0m</code> 是重置为默认色。</p>
</li>
</ol>
<h3 id="print"><a href="#print" class="headerlink" title="print"></a>print</h3><p>是ksh的内置命令，不能使用 <code>%s、%d、%c</code> 等占位符，会自动换行。</p>
<h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><p>是bash的内置命令，支持使用占位符，不会自动换行，所以要换行的时候需要使用 <code>\n</code> 。</p>
<p>常见的：**%s %c %d %f** 都是格式替代符，<strong>％s</strong> 输出一个字符串，<strong>％d</strong> 整型输出，<strong>％c</strong> 输出一个字符，<strong>％f</strong> 输出实数，以小数形式输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%-5s %-5s&quot;</span>, hello world) <span class="comment"># -表示左对齐，默认是右对齐，5表示占5个位</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记</title>
    <url>/2022/01/28/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​        Redis是一款基于键值对的NoSQL数据库，它的值支持多种数据结构：字符串(strings)、哈希(hashes)、列表(lists)、集合(sets)、有序集合(sorted sets)等。</p>
<span id="more"></span>

<p>​        Redis将所有的数据都存放在内存中，所以它的读写性能十分惊人。同时，Redis还可以将内存中的数据以快照或日志的形式保存到硬盘上，以保证数据的安全性。</p>
<p>​        其中快照的形式，也叫RDB的形式，这种形式就是将内存中的数据原原本本存到硬盘上，这种形式的优点是数据体积小，如果想从硬盘恢复数据到内存里，速度会很快；而缺点是，因为是一次性将数据存到硬盘，这个过程会比较耗时，而且在存储的时候会产生阻塞，如果这个时候还在处理其他业务，会对其他业务有影响。所以快照的形式不适合实时的场景，而是适用于隔一段时间做一次备份的场景。</p>
<p>​        以日志的形式存数据到硬盘，这种形式叫AOF。每执行一次redis命令，就会以日志的形式把这个命令存下来。因为一个命令通俗来看就是一句话的记录，所以会比较快，适用于实时的场景。AOF以追加的形式存储，数据的体积会比较大，比较占磁盘空间；另外，如果想从磁盘把数据恢复到内存，就需要将记录的命令从头到尾再跑一遍，所以恢复的速度会比较慢。</p>
<p>​        Redis典型的应用场景包括:缓存、排行榜、计数器、社交网络、消息队列等。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h4 id="windows下安装："><a href="#windows下安装：" class="headerlink" title="windows下安装："></a>windows下安装：</h4><p>网址：<a href="https://github.com/microsoftarchive/redis/releases">https://github.com/microsoftarchive/redis/releases</a></p>
<p>选择最新版本安装：<code>Redis-x64-3.0.504.msi</code></p>
<p>然后一路 <code>next</code> 默认安装。</p>
<h4 id="linux下安装"><a href="#linux下安装" class="headerlink" title="linux下安装"></a>linux下安装</h4><p><a href="https://blog.csdn.net/qq_39135287/article/details/83474865">https://blog.csdn.net/qq_39135287/article/details/83474865</a></p>
<h3 id="测试是否安装成功（出现的报错）"><a href="#测试是否安装成功（出现的报错）" class="headerlink" title="测试是否安装成功（出现的报错）"></a>测试是否安装成功（出现的报错）</h3><blockquote>
<p>Could not connect to Redis at 127.0.0.1:6379: 由于目标计算机积极拒绝，无法连接。</p>
</blockquote>
<p>问题：没有启动 redis-server.exe</p>
<p>解决：</p>
<ol>
<li>使用两个cmd命令行，第一个输入 <code>redis-server redis.windows.conf</code>；</li>
<li>第二个cmd输入 <code>redis-cli</code></li>
</ol>
<blockquote>
<p> Can’t handle RDB format version 7</p>
</blockquote>
<p>问题：版本无法兼容。</p>
<p>解决：删除redis文件夹下的 <code>dump.rdb</code> 文件。</p>
<h3 id="maven项目-Java连接redis"><a href="#maven项目-Java连接redis" class="headerlink" title="maven项目 Java连接redis"></a>maven项目 Java连接redis</h3><ol>
<li><p>粘贴 <code>dependency</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如下代码完成基本测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;192.168.121.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">jedis.auth(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;服务正在运行：&quot;</span> + jedis.ping());</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="redis数据库"><a href="#redis数据库" class="headerlink" title="redis数据库"></a>redis数据库</h3><p>默认有16个内置的库，这些库没有名字，使用 <code>0 ~ databases.size() - 1</code> 的序列号来区分，客户端与redis建立连接后默认选择0号数据库。</p>
<ol>
<li>可以通过 <code>select num</code> 来更换库，其中 <code>num</code> 为库的序列号。</li>
<li>如果想删除一个库中的数据，在该库下执行 <code>flushdb</code> 命令；</li>
</ol>
<h3 id="操作String类型数据"><a href="#操作String类型数据" class="headerlink" title="操作String类型数据"></a>操作String类型数据</h3><p>存：<code>set key value </code></p>
<p>取：<code>get key</code></p>
<p>其中，对于 key，如果是多个单词组成，使用 <code>:</code> 连接。对于 key 和 value，类型都是 String。</p>
<p>让 value 自增1：<code>incr test:count</code>，会自动将 value 转换为 Integer 类型并加一。</p>
<p>让 value 自减1：<code>decr test:count</code>，自动将value减一。</p>
<h3 id="操作哈希类型的数据"><a href="#操作哈希类型的数据" class="headerlink" title="操作哈希类型的数据"></a>操作哈希类型的数据</h3><p>存：<code>hset key field value</code>，此处可以将 key 看成哈希表名称，将 field看成是 key。</p>
<p>取：<code>hget key field</code>。</p>
<p>具体实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hset test:user <span class="built_in">id</span> <span class="number">1</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hset test:user name zhangsan</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hget test:user <span class="built_in">id</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; hget test:user name</span><br><span class="line"><span class="string">&quot;zhangsan&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="操作列表类型的数据"><a href="#操作列表类型的数据" class="headerlink" title="操作列表类型的数据"></a>操作列表类型的数据</h3><p>按照插入顺序排序，可以从两侧侧插入取出。所以可以实现队列和栈。</p>
<ol>
<li>左侧进：<code>lpush test:ids 101 102 103</code></li>
<li>查看长度：<code>llen test:ids</code></li>
<li>查看某一个索引对应的元素：<code>lindex test:ids 0</code></li>
<li>查看子列表：<code>lrange test:ids 0 2</code></li>
<li>右侧出：<code>rpop test:ids</code></li>
</ol>
<p>具体实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lpush test:ids <span class="number">101</span> <span class="number">102</span> <span class="number">103</span></span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; llen test:ids</span><br><span class="line">(integer) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lindex test:ids <span class="number">0</span></span><br><span class="line"><span class="string">&quot;103&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange test:ids <span class="number">0</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;103&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;102&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;101&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; rpop test:ids</span><br><span class="line"><span class="string">&quot;101&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="操作集合类型的数据"><a href="#操作集合类型的数据" class="headerlink" title="操作集合类型的数据"></a>操作集合类型的数据</h3><p>集合中的数据是无序的，不能存在重复数据。</p>
<ol>
<li>增数据：<code>sadd test:teachers aaa bbb ccc ddd</code></li>
<li>查看个数：<code>scard test:teachers</code></li>
<li>从集合随机删除一个元素：<code>spop test:teachers</code>，这个方式可以用于实现抽奖场景</li>
<li>查看集合中具体有哪些元素：<code>smembers test:teachers</code></li>
</ol>
<p>具体实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; sadd test:teachers aaa bbb ccc ddd</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; scard test:teachers</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; spop test:teachers</span><br><span class="line"><span class="string">&quot;aaa&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; smembers test:teachers</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;ddd&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;bbb&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;ccc&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="操作有序集合类型的数据"><a href="#操作有序集合类型的数据" class="headerlink" title="操作有序集合类型的数据"></a>操作有序集合类型的数据</h3><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。</p>
<p>不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。分数可以重复。</p>
<ol>
<li>增数据：<code>zadd test:students 10 aaa 20 bbb 1 ccc 30 ddd</code></li>
<li>查看个数：<code>zcard test:students</code></li>
<li>查看某个元素的分数：<code>zscore test:students ccc</code></li>
<li>查看某个元素的排名，默认从小到大，从0开始：<code>zrank test:students ccc</code></li>
<li>取某个范围内的数据：<code>zrange test:students 0 3</code></li>
</ol>
<p>具体实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zadd test:students <span class="number">10</span> aaa <span class="number">20</span> bbb <span class="number">1</span> ccc <span class="number">30</span> ddd</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zcard test:students</span><br><span class="line">(integer) <span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zscore test:students ccc</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrank test:students ccc</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; zrange test:students <span class="number">0</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;ccc&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;aaa&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;bbb&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;ddd&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="操作全局，对所有数据都有效"><a href="#操作全局，对所有数据都有效" class="headerlink" title="操作全局，对所有数据都有效"></a>操作全局，对所有数据都有效</h3><ol>
<li>查看库中目前有多少个key：<code>keys *</code></li>
<li>查看库中目前以 test 开头的key有多少个：<code>keys test*</code></li>
<li>查看key对应的值的类型：<code>type test:user</code></li>
<li>查看某个key是否存在：<code>exists test:User</code></li>
<li>删除某个key：<code>del test:user</code></li>
<li>设置key的过期时间，key 过期后将不再可用。单位以秒计：<code>expire test:teachers 5</code></li>
</ol>
<p>具体实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;test:count&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;test:user&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;test:students&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;test:list&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;test:ids&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;test:teachers&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys test*</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;test:count&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;test:user&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;test:students&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;test:list&quot;</span></span><br><span class="line"><span class="number">5</span>) <span class="string">&quot;test:ids&quot;</span></span><br><span class="line"><span class="number">6</span>) <span class="string">&quot;test:teachers&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="built_in">type</span> test:user</span><br><span class="line"><span class="built_in">hash</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; exists test:User</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; exists test:user</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; <span class="keyword">del</span> test:user</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; exists test:user</span><br><span class="line">(integer) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; expire test:students <span class="number">2</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;test:count&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;test:list&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;test:ids&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;test:teachers&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; expire test:teachers <span class="number">5</span></span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;test:count&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;test:list&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;test:ids&quot;</span></span><br><span class="line"><span class="number">4</span>) <span class="string">&quot;test:teachers&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;test:count&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;test:list&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;test:ids&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="借鉴"><a href="#借鉴" class="headerlink" title="借鉴"></a>借鉴</h2><p><a href="https://www.nowcoder.com/study/live/246/4/1">https://www.nowcoder.com/study/live/246/4/1</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL - 报错</title>
    <url>/2021/07/29/SQL-%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p><strong>1. SQL_ERROR_INFO: ‘Operand should contain 1 column(s)’</strong></p>
<span id="more"></span>



<p>报错语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(salary) <span class="keyword">as</span> avg_salary</span><br><span class="line">  <span class="keyword">from</span> salaries</span><br><span class="line"> <span class="keyword">where</span> salary </span><br><span class="line"><span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(salary)</span><br><span class="line">       ,<span class="built_in">max</span>(salary) </span><br><span class="line">  <span class="keyword">from</span> salaries</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>解决：</p>
<p><code>in</code> 关键字只能对应一列数据。</p>
<p><strong>2.FAILED: SemanticException [Error 10044]: Line 1:12 Cannot insert into target table because column number&#x2F;types are different ‘’813’’: Table insclause-0 has 7 columns, but query has 8 columns.</strong></p>
<p>。。。仔细看 <code>values</code> 里面的内容，应该有多了。</p>
<p><strong>3. Data source rejected establishment of connection, message from server: “Too</strong></p>
<p><a href="https://blog.csdn.net/ljphhj/article/details/23804057">借鉴</a></p>
<p><strong>4. SELECT list is not in GROUP BY clause and contains nonaggregated column ‘practice_record.submit_time’ which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode&#x3D;only_full_group_by”</strong></p>
<p>这好像是mysql5.7以上版本默认 ONLY_FULL_GROUP_BY 模式的原因。<a href="https://www.cnblogs.com/chancy/p/10026097.html">解决</a></p>
<p><strong>5. BIGINT UNSIGNED value is out of range in ‘(<code>A</code>.<code>rank2</code> - <code>A</code>.<code>rank1</code>)</strong></p>
<p>问题出在两个 <code>bigint unsigned</code> 类型的元素相减必须是<strong>非负数</strong>，否则会报这个错。<code>rank()</code> 这种排名函数的结果就是 <code>bigint unsigned</code> 类型。</p>
<p>解决：类型转换，<code>cast(rank1 as signed)</code></p>
]]></content>
      <categories>
        <category>报错</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark - 运行环境的安装配置</title>
    <url>/2021/06/17/Spark-%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="一-解压缩文件"><a href="#一-解压缩文件" class="headerlink" title="一. 解压缩文件"></a>一. 解压缩文件</h2><p>在官网下载 <a href="https://www.apache.org/dyn/closer.lua/spark/spark-3.1.2/spark-3.1.2-bin-hadoop3.2.tgz">spark-3.1.2-bin-hadoop3.2.tgz</a> 文件并上传到Linux，然后解压缩到指定位置，重命名为 <code>spark-local</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -zxvf spark-3.1.2-bin-hadoop3.2.tgz -C /opt/pkg</span><br><span class="line">mv spark-3.1.2-bin-hadoop3.2 spark-local</span><br></pre></td></tr></table></figure>



<span id="more"></span>



<h3 id="local环境"><a href="#local环境" class="headerlink" title="local环境"></a>local环境</h3><ol>
<li><p>进入目录</p>
<p><code>cd /opt/pkg/spark-local</code></p>
</li>
<li><p>启动</p>
<p><code>bin/spark-shell</code></p>
<p>正常情况下会进入spark shell客户端，以<code>scala</code>为输入的标记：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">26</span>:<span class="number">15</span> <span class="type">WARN</span> <span class="type">NativeCodeLoader</span>: <span class="type">Unable</span> to load native-hadoop library <span class="keyword">for</span> your platform... using builtin-java classes where applicable</span><br><span class="line"><span class="type">Using</span> <span class="type">Spark</span><span class="symbol">&#x27;s</span> <span class="keyword">default</span> log4j profile: org/apache/spark/log4j-defaults.properties</span><br><span class="line"><span class="type">Setting</span> <span class="keyword">default</span> log level to <span class="string">&quot;WARN&quot;</span>.</span><br><span class="line"><span class="type">To</span> adjust logging level use sc.setLogLevel(newLevel). <span class="type">For</span> <span class="type">SparkR</span>, use setLogLevel(newLevel).</span><br><span class="line"><span class="type">Spark</span> context <span class="type">Web</span> <span class="type">UI</span> available at http:<span class="comment">//hadoop002:4040</span></span><br><span class="line"><span class="type">Spark</span> context available as <span class="symbol">&#x27;s</span>c&#x27; (master = local[*], app id = local<span class="number">-1624029984600</span>).</span><br><span class="line"><span class="type">Spark</span> session available as <span class="symbol">&#x27;spar</span>k&#x27;.</span><br><span class="line"><span class="type">Welcome</span> to</span><br><span class="line">      ____              __</span><br><span class="line">     / __/__  ___ _____/ /__</span><br><span class="line">    _\ \/ _ \/ _ `/ __/  <span class="symbol">&#x27;_</span>/</span><br><span class="line">   /___/ .__/\_,_/_/ /_/\_\   version <span class="number">3.0</span><span class="number">.1</span></span><br><span class="line">      /_/</span><br><span class="line"></span><br><span class="line"><span class="type">Using</span> <span class="type">Scala</span> version <span class="number">2.12</span><span class="number">.10</span> (<span class="type">Java</span> <span class="type">HotSpot</span>(<span class="type">TM</span>) <span class="number">64</span>-<span class="type">Bit</span> <span class="type">Server</span> <span class="type">VM</span>, <span class="type">Java</span> <span class="number">1.8</span><span class="number">.0</span>_281)</span><br><span class="line"><span class="type">Type</span> in expressions to have them evaluated.</span><br><span class="line"><span class="type">Type</span> :help <span class="keyword">for</span> more information.</span><br><span class="line"></span><br><span class="line">scala&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以写一些基本的<code>scala</code>语法，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scala&gt; var i = 10</span><br><span class="line">i: Int = 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以写<code>spark</code>语法，下面给出<code>wordcount</code>的例子</p>
<p>（1）准备数据</p>
<p>在目录 <code>/opt/pkg/spark-shell/data</code> 下创建文件 <code>test.txt</code></p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">hello scala</span><br><span class="line">hello spark</span><br></pre></td></tr></table></figure>

<p>（2）执行命令</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; sc.textFile(<span class="string">&quot;/opt/pkg/spark/data/test.txt&quot;</span>).flatMap(_.split(<span class="string">&quot; &quot;</span>)).map((_,<span class="number">1</span>)).reduceByKey(_+_).collect</span><br><span class="line"></span><br><span class="line">res13: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">Array</span>((scala,<span class="number">1</span>), (spark,<span class="number">1</span>), (hello,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>成功！</p>
<p>（3）下面简单比较一下 <code>shell</code> 下和 <code>scala代码</code> 中的变化</p>
<p>其实大致没有变化，只是 <code>sparkContext</code> 不需要进行配置，在进入客户端时就有提示：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">Spark</span> context available as <span class="symbol">&#x27;s</span>c&#x27; (master = local[*], app id = local<span class="number">-1624029984600</span>).</span><br></pre></td></tr></table></figure>

<p>所以可以直接使用 <code>sc</code> 来进行操作。</p>
</li>
<li><p>查看资源监控页面</p>
<p>直接复制粘贴进入客户端的提示：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">Spark</span> context <span class="type">Web</span> <span class="type">UI</span> available at http:<span class="comment">//hadoop002:4040</span></span><br></pre></td></tr></table></figure>

<p>复制粘贴其中的 <code>http://hadoop002:4040</code> 到网页，就可以打开监控页面了。</p>
<p>结合本地IDEA的应用：</p>
<p>运行 <code>spark</code> 中自带的一个jar包例子：</p>
<p>在 <code>spark-local</code> 的目录下执行：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">[hadoop<span class="meta">@hadoop</span>002 spark-local]$ spark-submit \</span><br><span class="line">&gt; --<span class="class"><span class="keyword">class</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">spark</span>.<span class="title">examples</span>.<span class="title">SparkPi</span> <span class="title">\</span></span></span><br><span class="line">&gt; --master local[<span class="number">2</span>] \</span><br><span class="line">&gt; ./examples/jars/spark-examples_2<span class="number">.12</span><span class="number">-3.0</span><span class="number">.1</span>.jar \</span><br><span class="line">&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>得到结果：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">Pi</span> is roughly <span class="number">3.1422671422671424</span></span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">SparkUI</span>: <span class="type">Stopped</span> <span class="type">Spark</span> web <span class="type">UI</span> at http:<span class="comment">//hadoop002:4040</span></span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">MapOutputTrackerMasterEndpoint</span>: <span class="type">MapOutputTrackerMasterEndpoint</span> stopped!</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">MemoryStore</span>: <span class="type">MemoryStore</span> cleared</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">BlockManager</span>: <span class="type">BlockManager</span> stopped</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">BlockManagerMaster</span>: <span class="type">BlockManagerMaster</span> stopped</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">OutputCommitCoordinator</span>$<span class="type">OutputCommitCoordinatorEndpoint</span>: <span class="type">OutputCommitCoordinator</span> stopped!</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">SparkContext</span>: <span class="type">Successfully</span> stopped <span class="type">SparkContext</span></span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">ShutdownHookManager</span>: <span class="type">Shutdown</span> hook called</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">18</span> <span class="number">23</span>:<span class="number">47</span>:<span class="number">00</span> <span class="type">INFO</span> <span class="type">ShutdownHookManager</span>: <span class="type">Deleting</span> directory /tmp/spark...</span><br></pre></td></tr></table></figure>

<p>其中，</p>
<p><code>--master local[2]</code> 设置部署模式，默认本地模式，数字2表示分配的虚拟CPU核数量；</p>
<p><code>10</code> 表示程序的入口参数，用于设定当前应用的任务数量。</p>
</li>
</ol>
<h3 id="standalone环境"><a href="#standalone环境" class="headerlink" title="standalone环境"></a>standalone环境</h3><ol>
<li><p>在 <code>local环境</code> 的基础上进行配置</p>
<p>（1）将 <code>spark-local</code> 重命名为 <code>spark-standalone</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv spark-local spark-standalone</span><br></pre></td></tr></table></figure>

<p>（2）进入 <code>spark-standalone/conf</code> 目录：</p>
<p>修改 <code>slaves</code> 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd spark-standalone/conf</span><br><span class="line">mv slaves.template slaves</span><br><span class="line">vim slaves</span><br></pre></td></tr></table></figure>

<p>然后修改 <code>localhost</code> 为自己的节点名，如果是分布式部署，就写所有节点名称，如：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">hadoop001</span><br><span class="line">hadoop002</span><br><span class="line">hadoop003</span><br></pre></td></tr></table></figure>

<p>如果是伪分布式部署，即只有一个节点，就写一个节点名称：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">hadoop001</span><br></pre></td></tr></table></figure>

<p>修改 <code>spark-env.sh</code> 文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd spark-standalone/conf</span><br><span class="line">mv spark-env.sh.template spark-env.sh</span><br><span class="line">vim spark-env.sh</span><br></pre></td></tr></table></figure>

<p>然后将下述内容贴到文件中：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">SPARK_MASTER_HOST=hadoop001       #添加spark master的主机名</span><br><span class="line">SPARK_MASTER_PORT=<span class="number">7077</span>        #添加spark master的端口号</span><br><span class="line">export JAVA_HOME=/<span class="keyword">opt</span>/pkg/java</span><br></pre></td></tr></table></figure>

<p>其中主要要修改 <code>&#123;JAVA_HOME</code> 的路径。</p>
<p>如果是分布式部署，需要分发 <code>spark-standalone</code> 目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xsync spark-standalone</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动集群</p>
<p>进入 <code>spark-standalone</code> 目录下执行启动命令，它有一个和 <code>Hadoop</code> 启动一样的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sbin/start-all.sh</span><br></pre></td></tr></table></figure>

<p>启动成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hadoop@hadoop002 spark]$ sbin/start-all.sh</span><br><span class="line">starting org.apache.spark.deploy.master.Master, logging to /opt/pkg/spark/logs/spark-hadoop-org.apache.spark.deploy.master.Master-1-hadoop002.out</span><br><span class="line">hadoop002: starting org.apache.spark.deploy.worker.Worker, logging to /opt/pkg/spark/logs/spark-hadoop-org.apache.spark.deploy.worker.Worker-1-hadoop002.out</span><br></pre></td></tr></table></figure>

<p>查看资源监控的 <code>Web UI</code> 界面：<a href="http://hadoop002:8080/">http://hadoop002:8080</a></p>
</li>
<li><p>结合本地IDEA应用</p>
<p>运行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[hadoop@hadoop002 spark]$ spark-submit \</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> --class org.apache.spark.examples.SparkPi \</span></span><br><span class="line"><span class="bash">&gt; --master spark://hadoop002:7077 \</span></span><br><span class="line"><span class="bash">&gt; ./examples/jars/spark-examples_2.12-3.0.1.jar \</span></span><br><span class="line"><span class="bash">&gt; 10</span></span><br></pre></td></tr></table></figure>

<p>得到结果：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">Pi</span> is roughly <span class="number">3.142367142367142</span></span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">SparkUI</span>: <span class="type">Stopped</span> <span class="type">Spark</span> web <span class="type">UI</span> at http:<span class="comment">//hadoop002:4040</span></span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">StandaloneSchedulerBackend</span>: <span class="type">Shutting</span> down all executors</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">CoarseGrainedSchedulerBackend</span>$<span class="type">DriverEndpoint</span>: <span class="type">Asking</span> each executor to shut down</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">MapOutputTrackerMasterEndpoint</span>: <span class="type">MapOutputTrackerMasterEndpoint</span> stopped!</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">MemoryStore</span>: <span class="type">MemoryStore</span> cleared</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">BlockManager</span>: <span class="type">BlockManager</span> stopped</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">BlockManagerMaster</span>: <span class="type">BlockManagerMaster</span> stopped</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">OutputCommitCoordinator</span>$<span class="type">OutputCommitCoordinatorEndpoint</span>: <span class="type">OutputCommitCoordinator</span> stopped!</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">SparkContext</span>: <span class="type">Successfully</span> stopped <span class="type">SparkContext</span></span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">ShutdownHookManager</span>: <span class="type">Shutdown</span> hook called</span><br><span class="line"><span class="number">21</span>/<span class="number">06</span>/<span class="number">19</span> <span class="number">00</span>:<span class="number">47</span>:<span class="number">13</span> <span class="type">INFO</span> <span class="type">ShutdownHookManager</span>: <span class="type">Deleting</span> directory /tmp/spa...</span><br></pre></td></tr></table></figure>

<p>成功！</p>
</li>
</ol>
]]></content>
      <categories>
        <category>大数据组件的应用</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>com.mysql.jdbc.MysqlDataTruncation: Data truncation: Data too long for column &#39;picture&#39; at row 1</title>
    <url>/2022/01/14/com-mysql-jdbc-MysqlDataTruncation-Data-truncation-Data-too-long-for-column-picture-at-row-1/</url>
    <content><![CDATA[<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>表字段设置长度不够。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>修改表字段长度设置。</p>
<p>本项目使用 <code>blob</code> 存储图片的二进制数报错，应改成 <code>longblob</code> 。</p>
]]></content>
      <categories>
        <category>报错</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark - SparkSQL</title>
    <url>/2021/06/24/Spark-SparkSQL/</url>
    <content><![CDATA[<h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><p>SparkSQL是Spark用于结构化数据处理的Spark模块。</p>
<span id="more"></span>

<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="1-易整合"><a href="#1-易整合" class="headerlink" title="1. 易整合"></a>1. 易整合</h4><p>无缝地整合了SQL查询和Spark编程。</p>
<h4 id="2-统一的数据访问"><a href="#2-统一的数据访问" class="headerlink" title="2. 统一的数据访问"></a>2. 统一的数据访问</h4><p>使用相同的方式连接不同的数据源。比如数据库，HBase、Hive、MySQL等都可以使用相同的方式进行连接，即具有了通用性，只需要修改一些参数就可以从不同的数据源中获取数据，非常方便。</p>
<h4 id="3-兼容hive"><a href="#3-兼容hive" class="headerlink" title="3. 兼容hive"></a>3. 兼容hive</h4><p>在已有的仓库上直接运行SQL或HiveQL。</p>
<h4 id="4-标准数据连接"><a href="#4-标准数据连接" class="headerlink" title="4. 标准数据连接"></a>4. 标准数据连接</h4><p>通过JDBC或ODBC来连接。</p>
<h3 id="DataFrame是什么？与RDD的区别"><a href="#DataFrame是什么？与RDD的区别" class="headerlink" title="DataFrame是什么？与RDD的区别"></a>DataFrame是什么？与RDD的区别</h3><p>​        在Spark中，DataFrame是一种以RDD为基础的分布式数据集，类似于传统数据库中的二维表格。</p>
<p>​        DataFrame与RDD的主要区别在于，前者带有schema元数据信息，即DataFrame锁表示的</p>
<h2 id="核心编程"><a href="#核心编程" class="headerlink" title="核心编程"></a>核心编程</h2><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>文件可以读取的格式如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">csv   format   jdbc   json   load   option   options   orc   parquet   schema   table   text   textFile</span><br></pre></td></tr></table></figure>

<ol>
<li>读取类型的例子：</li>
</ol>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; spark.read.json(<span class="string">&quot;input/user.json&quot;</span>)</span><br><span class="line">res1: org.apache.spark.sql.<span class="type">DataFrame</span> = [age: string, username: string]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>读取实际内容的例子：</li>
</ol>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> df = spark.read.json(<span class="string">&quot;input/user.json&quot;</span>)</span><br><span class="line">df: org.apache.spark.sql.<span class="type">DataFrame</span> = [age: string, username: string]</span><br><span class="line"></span><br><span class="line">scala&gt; df.show()</span><br><span class="line">+---+--------+</span><br><span class="line">|age|username|</span><br><span class="line">+---+--------+</span><br><span class="line">| <span class="number">30</span>|zhangsan|</span><br><span class="line">| <span class="number">20</span>|    lisi|</span><br><span class="line">| <span class="number">40</span>|  wangwu|</span><br><span class="line">+---+--------+</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>按照条件读取指定内容的例子：</li>
</ol>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; df.createTempView(<span class="string">&quot;user&quot;</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; spark.sql(<span class="string">&quot;select username from user&quot;</span>).show</span><br><span class="line">+--------+</span><br><span class="line">|username|</span><br><span class="line">+--------+</span><br><span class="line">|zhangsan|</span><br><span class="line">|    lisi|</span><br><span class="line">|  wangwu|</span><br><span class="line">+--------+</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">scala&gt; spark.sql(<span class="string">&quot;select avg(age) from user&quot;</span>).show</span><br><span class="line">+------------------------+</span><br><span class="line">|avg(<span class="type">CAST</span>(age <span class="type">AS</span> <span class="type">DOUBLE</span>))|</span><br><span class="line">+------------------------+</span><br><span class="line">|                    <span class="number">30.0</span>|</span><br><span class="line">+------------------------+</span><br></pre></td></tr></table></figure>

<p>此处<code>createTempView</code>是创建一次临时表，如果多次创建，可能会报错，使用<code>createOrReplaceTempView</code>可以避免这种错误。</p>
<p><strong>其中，需要知道<code>view</code>即视图，是将查询结果集转换成为一个特定的视图结构，只可以查，不可以改；与表table不同，表可以改。</strong></p>
<p>注意：普通临时表是Session范围内的，如果在创建一个Session，该Session中的使用不会在新创建的Session中留下痕迹。如果想应用范围内有效，可以使用全局临时表。使用全局临时表需要全路径访问，如<code>global_temp.user</code></p>
<ol start="4">
<li>全局临时表</li>
</ol>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; df.createOrReplaceGlobalTempView(<span class="string">&quot;emp&quot;</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; spark.newSession.sql(<span class="string">&quot;select * from global_temp.emp&quot;</span>)</span><br><span class="line">res10: org.apache.spark.sql.<span class="type">DataFrame</span> = [age: string, username: string]</span><br><span class="line"></span><br><span class="line">scala&gt; spark.newSession.sql(<span class="string">&quot;select * from global_temp.emp&quot;</span>).show</span><br><span class="line">+---+--------+</span><br><span class="line">|age|username|</span><br><span class="line">+---+--------+</span><br><span class="line">| <span class="number">30</span>|zhangsan|</span><br><span class="line">| <span class="number">20</span>|    lisi|</span><br><span class="line">| <span class="number">40</span>|  wangwu|</span><br><span class="line">+---+--------+</span><br></pre></td></tr></table></figure>

<p><code>newSession</code>是重新启动一个Session测试是否多个节点都可以进行测试。</p>
<h3 id="DSL的简单使用"><a href="#DSL的简单使用" class="headerlink" title="DSL的简单使用"></a>DSL的简单使用</h3><p>是DataFrame提供的，用来管理结构化的数据。使用这个语言不需要去创建视图等，因为它本身九江DataFrame当成数据源。可以在Scala、Java、Python、R中使用DSL。</p>
<h4 id="1-基本例子："><a href="#1-基本例子：" class="headerlink" title="1. 基本例子："></a>1. 基本例子：</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; df.printSchema</span><br><span class="line">root</span><br><span class="line"> |-- age: string (nullable = <span class="literal">true</span>)</span><br><span class="line"> |-- username: string (nullable = <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">scala&gt; df.select(<span class="string">&quot;age&quot;</span>).show</span><br><span class="line">+---+</span><br><span class="line">|age|</span><br><span class="line">+---+</span><br><span class="line">| <span class="number">30</span>|</span><br><span class="line">| <span class="number">20</span>|</span><br><span class="line">| <span class="number">40</span>|</span><br><span class="line">+---+</span><br></pre></td></tr></table></figure>

<h4 id="2-查看”username”数据和”age-1”数据"><a href="#2-查看”username”数据和”age-1”数据" class="headerlink" title="2. 查看”username”数据和”age+1”数据"></a>2. 查看”username”数据和”age+1”数据</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; df.select($<span class="string">&quot;age&quot;</span> + <span class="number">1</span>).show</span><br><span class="line">+---------+</span><br><span class="line">|(age + <span class="number">1</span>)|</span><br><span class="line">+---------+</span><br><span class="line">|     <span class="number">31.0</span>|</span><br><span class="line">|     <span class="number">21.0</span>|</span><br><span class="line">|     <span class="number">41.0</span>|</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure>

<p>使用<code>$</code>符号表示引用这个变量，如果不使用，就表示简单的字符串相加；</p>
<p>spark提供另一种更简便的方式：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; df.select(<span class="symbol">&#x27;age</span> + <span class="number">1</span>).show</span><br><span class="line">+---------+</span><br><span class="line">|(age + <span class="number">1</span>)|</span><br><span class="line">+---------+</span><br><span class="line">|     <span class="number">31.0</span>|</span><br><span class="line">|     <span class="number">21.0</span>|</span><br><span class="line">|     <span class="number">41.0</span>|</span><br><span class="line">+---------+</span><br></pre></td></tr></table></figure>

<p>其中，<code>$</code>和<code>&#39;</code>只能修饰一个列，有多个列，就有多个符号。</p>
<h4 id="3-查看age大于30的数据"><a href="#3-查看age大于30的数据" class="headerlink" title="3. 查看age大于30的数据"></a>3. 查看<code>age</code>大于30的数据</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; df.select(<span class="symbol">&#x27;age</span> &gt; <span class="number">30</span>).show</span><br><span class="line">+----------+</span><br><span class="line">|(age &gt; <span class="number">30</span>)|</span><br><span class="line">+----------+</span><br><span class="line">|     <span class="literal">false</span>|</span><br><span class="line">|     <span class="literal">false</span>|</span><br><span class="line">|      <span class="literal">true</span>|</span><br><span class="line">+----------+</span><br></pre></td></tr></table></figure>

<h4 id="4-查看age大于30的数据-过滤"><a href="#4-查看age大于30的数据-过滤" class="headerlink" title="4. 查看age大于30的数据 - 过滤"></a>4. 查看<code>age</code>大于<code>30</code>的数据 - 过滤</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; df.filter($<span class="string">&quot;age&quot;</span> &gt; <span class="number">30</span>).show</span><br><span class="line">+---+--------+</span><br><span class="line">|age|username|</span><br><span class="line">+---+--------+</span><br><span class="line">| <span class="number">40</span>|  wangwu|</span><br><span class="line">+---+--------+</span><br></pre></td></tr></table></figure>

<h4 id="5-按照age分组，查看数组条数-分组"><a href="#5-按照age分组，查看数组条数-分组" class="headerlink" title="5. 按照age分组，查看数组条数 - 分组"></a>5. 按照<code>age</code>分组，查看数组条数 - 分组</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; df.groupBy(<span class="string">&quot;age&quot;</span>).count.show</span><br><span class="line">+---+-----+</span><br><span class="line">|age|count|</span><br><span class="line">+---+-----+</span><br><span class="line">| <span class="number">30</span>|    <span class="number">1</span>|</span><br><span class="line">| <span class="number">40</span>|    <span class="number">1</span>|</span><br><span class="line">| <span class="number">20</span>|    <span class="number">1</span>|</span><br><span class="line">+---+-----+</span><br></pre></td></tr></table></figure>



<h3 id="RDD和DataFrame的转换"><a href="#RDD和DataFrame的转换" class="headerlink" title="RDD和DataFrame的转换"></a>RDD和DataFrame的转换</h3><p>RDD转DataFrame：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">15</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> df = rdd.toDF(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">df: org.apache.spark.sql.<span class="type">DataFrame</span> = [id: int]</span><br><span class="line"></span><br><span class="line">scala&gt; df.show</span><br><span class="line">+---+</span><br><span class="line">| id|</span><br><span class="line">+---+</span><br><span class="line">|  <span class="number">1</span>|</span><br><span class="line">|  <span class="number">2</span>|</span><br><span class="line">|  <span class="number">3</span>|</span><br><span class="line">|  <span class="number">4</span>|</span><br><span class="line">+---+</span><br></pre></td></tr></table></figure>

<p>DataFrame转RDD：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; df.rdd</span><br><span class="line">res4: org.apache.spark.rdd.<span class="type">RDD</span>[org.apache.spark.sql.<span class="type">Row</span>] = <span class="type">MapPartitionsRDD</span>[<span class="number">23</span>] at rdd at &lt;console&gt;:<span class="number">26</span></span><br></pre></td></tr></table></figure>



<h3 id="DataSet"><a href="#DataSet" class="headerlink" title="DataSet"></a>DataSet</h3><p>dataSet是具有强类型的数据集合，需要提供对应的类型信息。</p>
<p>DataSet相比于DataFrame、RDD，后二者没有数据类型的概念，而前者有，即前者是包含了DataFrame的结构和RDD的数据。</p>
<h4 id="1-样例类创建DataSet"><a href="#1-样例类创建DataSet" class="headerlink" title="1. 样例类创建DataSet"></a>1. 样例类创建DataSet</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name:<span class="type">String</span>, age: <span class="type">Long</span></span>)</span></span><br><span class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> list = <span class="type">List</span>(<span class="type">Person</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">30</span>), <span class="type">Person</span>(<span class="string">&quot;lisi&quot;</span>, <span class="number">40</span>))</span><br><span class="line">list: <span class="type">List</span>[<span class="type">Person</span>] = <span class="type">List</span>(<span class="type">Person</span>(zhangsan,<span class="number">30</span>), <span class="type">Person</span>(lisi,<span class="number">40</span>))</span><br><span class="line"></span><br><span class="line">scala&gt; list.toDS</span><br><span class="line">res5: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">Person</span>] = [name: string, age: bigint]</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> ds = list.toDS</span><br><span class="line">ds: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">Person</span>] = [name: string, age: bigint]</span><br><span class="line"></span><br><span class="line">scala&gt; ds.show</span><br><span class="line">+--------+---+</span><br><span class="line">|    name|age|</span><br><span class="line">+--------+---+</span><br><span class="line">|zhangsan| <span class="number">30</span>|</span><br><span class="line">|    lisi| <span class="number">40</span>|</span><br><span class="line">+--------+---+</span><br></pre></td></tr></table></figure>

<h4 id="2-和DataFrame的转换"><a href="#2-和DataFrame的转换" class="headerlink" title="2. 和DataFrame的转换"></a>2. 和DataFrame的转换</h4><p>DataFrame转换为DataSet：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> ds = df.as[<span class="type">Person</span>]</span><br></pre></td></tr></table></figure>

<p>DataSet转换为DataFrame：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> df = ds.toDF</span><br></pre></td></tr></table></figure>

<h3 id="RDD和DataSet的转换"><a href="#RDD和DataSet的转换" class="headerlink" title="RDD和DataSet的转换"></a>RDD和DataSet的转换</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="type">Person</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">30</span>), <span class="type">Person</span>(<span class="string">&quot;lisi&quot;</span>, <span class="number">40</span>)))</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Person</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">29</span>] at makeRDD at &lt;console&gt;:<span class="number">26</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd.toDS</span><br><span class="line">res11: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">Person</span>] = [name: string, age: bigint]</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> ds = rdd.toDS</span><br><span class="line">ds: org.apache.spark.sql.<span class="type">Dataset</span>[<span class="type">Person</span>] = [name: string, age: bigint]</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> rdd = ds.rdd</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Person</span>] = <span class="type">MapPartitionsRDD</span>[<span class="number">32</span>] at rdd at &lt;console&gt;:<span class="number">25</span></span><br></pre></td></tr></table></figure>

<h4 id><a href="#" class="headerlink" title></a></h4><h3 id="RDD、DataFrame、DataSet的联系"><a href="#RDD、DataFrame、DataSet的联系" class="headerlink" title="RDD、DataFrame、DataSet的联系"></a>RDD、DataFrame、DataSet的联系</h3>]]></content>
      <categories>
        <category>大数据组件的应用</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>flume面试题</title>
    <url>/2022/03/03/flume%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="flume架构"><a href="#flume架构" class="headerlink" title="flume架构"></a>flume架构</h3><ol>
<li><p>Agent：</p>
<p>是一个JVM进程，它以事件Event的形式将数据从源头发送到目的地。Agent主要由三个部分组成：Source、Channel、Sink。</p>
</li>
<li><p>Event：是flume传输数据的基本单元，</p>
</li>
</ol>
<span id="more"></span>

<ol start="3">
<li><p>Source：</p>
<p>负责接受各种类型的数据到Agent，并将数据推送到Channel。常见的类型包括：avro、exec、spooling directory、netcat、taildir等。</p>
</li>
<li><p>Sink：</p>
<p>不断拉取Channel中的事件且批量的移除它们，并将这些事件批量写入目的地，常见的包括：hdfs、hbase、logger、avro或下一个flume的Agent等。</p>
</li>
<li><p>Channel：</p>
<p>是运行在Source和Sink之间的缓冲区，因此它允许Source和Sink运作在不同的速率上。Channel是线程安全的，可以同时处理几个Source的写入和几个Sink的读取。</p>
<p>flume自带两种Channel：memory channel和file channel。memory channel因为存在内存，所以速度肯定快，但是一旦出现故障数据就会丢失；file channel因为写在磁盘，所以安全性好，但是速度慢。</p>
</li>
<li><p>Event：</p>
<p>是Flume传输数据的单元，分为两部分：header和body，body部分使用字节数组存储实际传输的数据，header存储一些event的属性，比如说想要将不同类型的输入数据传到不同的channel中处理，可以让source通过header来区分并发送到不同的channel。</p>
</li>
</ol>
<h3 id="Flume-事务"><a href="#Flume-事务" class="headerlink" title="Flume 事务"></a>Flume 事务</h3><p>在从Source推送数据到Channel的过程和Sink从Channel拉取数据的过程可以看成是两个事务。</p>
<h4 id="Put事务过程"><a href="#Put事务过程" class="headerlink" title="Put事务过程"></a>Put事务过程</h4><p>​        在Source端开始发送数据前会启动一个Put事务。首先 doPut 将数据先写入临时缓冲区 putlist ，然后 doCommit 回去检查channel中是否有足够的空间，如果够就真正提交写入；否则 doRollback 回滚，将数据放回Source。</p>
<h4 id="Take事务"><a href="#Take事务" class="headerlink" title="Take事务"></a>Take事务</h4><p>​        在Sink端开始拉取数据前会启动一个Take事务。首先 doTake 将数据取到临时缓冲区 takelist ，并尝试往目的地写出，doCommit 检查如果数据发送成功，就情况 takelist，否则 doRollback 将临时缓冲区的数据归还给Channel，此时不会情况缓冲区。</p>
<h3 id="Agent内部原理（详细架构）"><a href="#Agent内部原理（详细架构）" class="headerlink" title="Agent内部原理（详细架构）"></a>Agent内部原理（详细架构）</h3><ol>
<li><p>数据输入首先传递给Source。</p>
</li>
<li><p>Source将数据作为事件传递给 Channel处理器，这个处理器会将事件传递给拦截器链，也就是一至多个拦截器，拦截器会将数据拦截下来去做一些额外的处理，处理完后再传回给处理器。</p>
</li>
<li><p>接着处理器会将事件传给Channel选择器，由这个选择器选择将事件发给哪个Channel。</p>
<p>选择器有两种类型：Replicating副本选择器，是默认的，假设给一个source绑定了两个channel，并且没有配任何选择器的内容，那么source会将这个事件发送给两个相同的channel；Multiplexing多路复用，这个选择器会有选择的将事件发给不同的channel，但是需要结合拦截器使用，因为这个选择器是根据header的内容来处理的。处理完后选择器又会将事件发回给channel处理器。</p>
</li>
<li><p>然后处理器会根据选择器的选择结果将事件发给对应的channel中。</p>
</li>
<li><p>接着Channel要发送到哪个Sink又需要做选择，这里就涉及到Sink组的问题，所以出现了SInkProcessor。</p>
<p>SinkProcessor有三种类型：DefaultSinkProcessor默认的SinkProcessor、LoadBalancingSinkProcessor是负载均衡和FailoverSinkProcessor故障转移。默认SinkProcessor只有一个Sink，所以其实不算在Sink组的类型。</p>
<p>对于负载均衡，假设一个channel绑定了三个sink，这三个Sink会依次拉取Channel的数据，实现负载均衡。</p>
<p>对于故障转移，是对sink组里的sink配置优先级，优先级最高的先去拉取数据，当这个sink出现故障，再由下一个优先级最高的继续拉取。</p>
</li>
</ol>
<h3 id="Flume拓扑结构"><a href="#Flume拓扑结构" class="headerlink" title="Flume拓扑结构"></a>Flume拓扑结构</h3><p>​        也就是多个Agent串联的结构。</p>
<p><a href="https://www.cnblogs.com/jhxxb/p/11578150.html">图片借鉴</a></p>
<h4 id="简单串联"><a href="#简单串联" class="headerlink" title="简单串联"></a>简单串联</h4><p><img src="/flume%E9%9D%A2%E8%AF%95%E9%A2%98.assets/1595409-20190924142339540-581718439.png"></p>
<p>​        将多个Agent顺序串联为一条线路，这种模式不建议桥接过多的agent，因为数量过多不仅会影响传输的效率，而且一旦传输过程中某个flume宕机，会影响整个传输系统。</p>
<p>​        此外，从Sink输出到另一个Source输入的过程，它们的数据类型要求是avro。avro是一个轻量级的通信框架，通过一个接口来实现接收数据和发送数据。</p>
<h4 id="复制和多路复用"><a href="#复制和多路复用" class="headerlink" title="复制和多路复用"></a>复制和多路复用</h4><p><img src="/flume%E9%9D%A2%E8%AF%95%E9%A2%98.assets/1595409-20190924143041975-1644651799.png"></p>
<p>​        将Flume中的事件发送到多个目的地，也就是使用多个Channel，然后每个channel可以将相同的数据发送到不同的目的地，来实现备份的效果。</p>
<h4 id="负载均衡和故障转移"><a href="#负载均衡和故障转移" class="headerlink" title="负载均衡和故障转移"></a>负载均衡和故障转移</h4><p><img src="/flume%E9%9D%A2%E8%AF%95%E9%A2%98.assets/1595409-20190924145106004-1719791353.png"></p>
<p>​        使用Sink组来实现，这个agent中只有一个channel，然后连接一个sink组，选择使用负载均衡或者故障转移的处理器来输出到对应的多个agent中，这些agent用于将分散的数据写入目的地，这种方式虽然没有降低要写入的数据量，但是增加了channel的个数，提高了缓冲的效率。比如要写入hdfs，但是写入磁盘的速度会比较慢，就可以使用负载均衡的策略将事件分别发送给多个sink传输，然后这些sink分别连接对应的agent去写入hdfs。</p>
<h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><p><img src="/flume%E9%9D%A2%E8%AF%95%E9%A2%98.assets/1595409-20190924142628732-1732447063.png"></p>
<p>​        将多个agent的输出数据都发送到一个agent中合并为一条线路，发送到目的地。比如京东或者淘宝用于访问的服务器肯定不止一台，在不同服务器上访问的本地日志肯定是存在本地服务器的，可以在每台服务器启动一个agent把数据都传输到一个总的agent中，让这个总的agent将所有数据写入hdfs。</p>
<h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>​        用于过滤脏数据、不合法的数据等，或者和channel的多路复用选择器结合，将不同的事件传给不同的channel。</p>
<h4 id="实现的步骤"><a href="#实现的步骤" class="headerlink" title="实现的步骤"></a>实现的步骤</h4><ol>
<li>创建实现类并实现 Intercept 接口；</li>
<li>内部需要重写 initialize初始化、处理单个event的 intercept 方法、批处理event的intercept方法以及close方法；</li>
<li>一般会在处理单个 event 的intercept方法中给事件的header添加选择的属性，然后在批处理intercept方法中调用处理；</li>
<li>最后要定义一个静态内部类实现 Intercept.Builder 接口来调用外部这个实现类。</li>
</ol>
<h3 id="taildir"><a href="#taildir" class="headerlink" title="taildir"></a>taildir</h3><p>​        用于实时监控一批文件，并记录每个文件最新消费的位置，这样当agent宕机重启时就不会存在重复消费的问题。</p>
<h3 id="Kafka-Channel"><a href="#Kafka-Channel" class="headerlink" title="Kafka Channel"></a>Kafka Channel</h3><p>​        除了Flume自带的两种channel，还有kafka channel。Source端将数据推送到kafka channel中，kafka channel会直接将数据传输到kafka集群等待进一步的消费，这个过程可以省略sink的使用，与memory channel相比能够避免数据的丢失，与file channel相比也提高了传输的速度，但是kafka中的消息是没有头信息的，所以传入kafka channel时事件的header会丢失。</p>
<h3 id="怎么实现Flume数据传输的监控"><a href="#怎么实现Flume数据传输的监控" class="headerlink" title="怎么实现Flume数据传输的监控"></a>怎么实现Flume数据传输的监控</h3><p>​        具体没有实现，但是直到有这个懂。使用第三方框架Ganglia实时监控flume。里面有五个比较重要的图是：source尝试写入channel的event量、source成功写入的event、sink尝试拉取的event量、sink成功拉取的event量以及channel的容量。当尝试写入或拉取的量一直是远大于成功写入或拉取的量，就说明内存资源可能不够，需要增加agent的内存资源，在conf&#x2F;flume-env.sh里面有一个 java_opts 的变量，这个变量规定了-Xms是最小内存量，-Xmx是最大内存量，可以修改最大内存量来增加内存。</p>
<h3 id="使用的Source、Channel、Sink是什么类型？为什么这么用？"><a href="#使用的Source、Channel、Sink是什么类型？为什么这么用？" class="headerlink" title="使用的Source、Channel、Sink是什么类型？为什么这么用？"></a>使用的Source、Channel、Sink是什么类型？为什么这么用？</h3><h3 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h3><p>​        在source中，有一个batchsize参数决定source一次批量运输到channel的event条数，可以适当的调大这个参数来提高搬运的效率。增大source的数量也可以提高source的读取能力。</p>
<p>​        在channel中，使用memory channel的时候，会调整transectioncapacity，这个参数控制一个事务中，source最多推送的event数和sink最多拉取的event数，这个参数需要大于source和sink的batchsize。</p>
<p>​        在sink中，也有一个batchsize参数决定sink拉取一次的event数，可以适当调大这个参数提高sink从channel拉取的效率。同时，增大sink的个数也可以增加sink消费event的能力，比如sink组的负载均衡和故障转移，但是也不是越多越好的，过多的sink会占用系统的资源，造成系统资源不必要的浪费。</p>
<h3 id="Flume采集数据会丢失吗"><a href="#Flume采集数据会丢失吗" class="headerlink" title="Flume采集数据会丢失吗"></a>Flume采集数据会丢失吗</h3><p>​        由于Source到Channel的过程和Channel到Sink的过程都采取了事务机制，所以这两个阶段是不可能出现数据丢失的，唯一可能出现的地方在于使用memory channel的时候，一旦agent宕机或者channel存满了，导致source无法写入，这些未写入的数据也会丢失。</p>
<p>​        Flume不会丢数据，但是有可能造成重复数据，例如数据已经从sink写出了，但是没有接收到应答，sink就会再次发送数据，此时有可能导致数据的重复。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>flume</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/05/30/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>



<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>hbase面试题</title>
    <url>/2022/03/03/hbase%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>​        HBase是一种分布式、可扩展、支持海量数据存储的NoSQL数据库，能够在HDFS上实现数据的增删改查。它在运行过程中需要不断切分和聚合，消耗的资源量让其在小数据集上不具有优势，但是对于大数据集能够做到亿万数据的秒级查询。并且Hbase是基于HDFS的，所以可以实现对hdfs存储数据做随机写操作。</p>
<p>​        HDFS是不支持随机写的，如果要对里面的数据进行修改，需要先下载下来，改完以后再删掉原来的数据重新提交，这种方式非常不灵活。</p>
<span id="more"></span>

<h3 id="HBase-数据模型（重点应该是架构，这个可以先不看）"><a href="#HBase-数据模型（重点应该是架构，这个可以先不看）" class="headerlink" title="HBase 数据模型（重点应该是架构，这个可以先不看）"></a>HBase 数据模型（重点应该是架构，这个可以先不看）</h3><p>​        从逻辑上看，HBase的数据模型和关系型数据库很相似，都是存在一张表上，有行有列。但是HBase的底层是以键值对的形式存储的。模型中包括：</p>
<ol>
<li>namespace命名空间：类似于mysql的database的概念，hbase中有两个默认的命名空间，hbase存内置的表，default是用户默认使用的库；</li>
<li>region：类似于mysql的表的概念，不同的是，HBase只需要声明到列族即可，因为列是可以动态、按需指定的，所以和mysql相比，HBase能够轻松应对列变更的场景，HBase最开始是只有一个region的，等到存储了一定的数据量后才会进行切分，也可以手动切分；</li>
<li>row：每一行数据都包含一个rowkey和多个列，数据按照rowkey的字典序排序，查询时也只能根据rowkey进行检索，所以rowkey的设计非常重要；</li>
<li>column：HBase中实际插入一列的时候，需要使用 <code>列族:列限定符</code> 来限定是在哪个列族插入的数据，其中列限定符可以看成是该列的列名；</li>
<li>timestamp：用于标识数据的不同版本，每条数据写入时，如果不指定时间戳，系统会自动填入插入该条数据的时间；</li>
<li>cell：是最小的单元，由 {行键, 列族:列名, 时间戳} 唯一确定，cell中存储的数据在底层都是以字节码的形式保存的，所以存放的数据实际上是没有类型的。</li>
</ol>
<h3 id="HBase架构"><a href="#HBase架构" class="headerlink" title="HBase架构"></a>HBase架构</h3><p>​        首先，HBase的底层存储依赖于hdfs，且使用Zookeeper分担了HMaster的和客户端交互的工作，所以在启动HBase的时候，这两个是必须要先启动的。然后，对于HBase来说，需要启动的有两大组件：HMaster和HRegionServer。</p>
<p>​        HMaster负责命名空间的增删和表的增删改查，以及分配HRegion到某个RS下，并监控每个RS的状态。</p>
<p>​        HRegionServer负责实际数据增删改查，以及HRegion的切分和聚合。</p>
<p>​        在HRegionServer内，存在一个HLog，也就是预写入日志，和hdfs的edits文件的作用的一样的。因为HBase中的数据也会先存在内存，然后等到一定的条件再刷写到磁盘，所以避免刷写之前数据丢失，使用hlog存储数据的操作。之后，HRegionServer中还会存储一至多个HRegion。HRegion中包含了多个列族，这里称为store，一个store对应一个文件夹。</p>
<p>​        store内部开始存储实际的数据，其中包括了 mem store 就是在内存的存储，和storeFile 磁盘的存储。因为每刷写一次会产生一个新文件，所以Store中也会存在很多的storefile，如果这些storefile的容量不大，也就是这些storefile会存在一些小文件，hbase会自动将同store的小文件合并；等到聚合到一定的大小，又会进行切分，这就是hregion的切分和聚合。storefile内有一个hfile是文件存储格式，指定了storefile中的实际数据应该以kv形式存储。</p>
<p>​        最后会使用hdfs客户端将hlog和storefile的数据发送到datanode下存储。</p>
<p><strong>Zookeeper在HBase中的作用：</strong></p>
<p>HBase启动成功后，会在Zookeeper中注册：当前活动的HMaster信息、热备的HMaster信息和每个HRegionServer的信息。活动的HMaster会注册监听存储HRegionServer信息的znode，这样一旦某个HRegionServer出现问题，HMaster就能第一时间发现；同时，所有热备的HMaster也都会监听活动HMaster的状态，一旦出现故障，热备的HMaster会立刻开始抢Zookeeper中的资源，谁抢到谁就当Leader。</p>
<h3 id="HBase写数据流程"><a href="#HBase写数据流程" class="headerlink" title="HBase写数据流程"></a>HBase写数据流程</h3><ol>
<li>客户端想要put一条数据，首先会向Zookeeper请求meta表所在的regionserver。meta表是hbase命名空间内默认存储的表，里面保存了集群中所有region的位置信息，zookeeper中存储了这个meta表的位置。</li>
<li>zookeeper会向客户端返回meta表所在的regionserver；</li>
<li>客户端读取这个meta中的数据，并根据命名空间、表名、列族等返回对应的regionserver；</li>
<li>客户端向这个regionserver发送put请求，会先写hlog，然后再写到memstore，到这里，对客户端来说，写的过程就结束了，这个regionserver会返回给客户端ack应答。</li>
</ol>
<h3 id="HBase-flush过程"><a href="#HBase-flush过程" class="headerlink" title="HBase flush过程"></a>HBase flush过程</h3><p>​        刷写的过程其实很简单，到达某个条件就会触发flush过程。重要的是什么时候会触发刷写。有三个方面：regionserver、region和hlog。</p>
<p>​        regionserver方面：</p>
<ol>
<li>默认regionserver中所有memstore的总大小超过堆内存的40%，会触发刷写；</li>
<li>为了防止刷写过程中，写的速度比刷写的速度快，导致memstore的大小一直大于规定的值，所以在总大小超过 堆大小 * 0.4 * 0.95 的时候会阻塞客户端的读写操作，直到memstore的大小降到这个安全值内；</li>
<li>为了防止数据由于长时间不写入而一直留在内存中，规定当最后一条数据写入后一小时内不再有新数据写入就会触发刷写；</li>
</ol>
<p>​        region方面：</p>
<ol>
<li>当region中数据量默认达到128M会触发刷写；</li>
</ol>
<p>​        hlog方面：</p>
<ol>
<li>默认当单个hlog大小达到hdfs的block大小时会写新的hlog，当hlog的数量达到32的时候会触发刷写。</li>
</ol>
<h3 id="HBase读数据流程"><a href="#HBase读数据流程" class="headerlink" title="HBase读数据流程"></a>HBase读数据流程</h3><ol>
<li>客户端向zookeeper请求meta表所在的regionserver；</li>
<li>zookeeper返回后，客户端向对应的regionserver请求meta读取数据，这个regionserver返回查询的结果；</li>
<li>客户端会向存储实际数据的regionserver发送get请求；</li>
<li>这个regionserver会同时在memstore和storefile中查找数据，然后对查找到的数据进行一个合并，找到其中时间戳最大的结果返回。为了提高磁盘读的效率，在regionserver中会额外圈出一块内存来存放磁盘中读出来的数据，让regionserver在找磁盘前先查一下读缓存，但是读缓存中存的只是之前已经扫描过的文件的结果，所以如果读缓存中能找到数据，就不会在磁盘再扫描这个storefile，但是会在磁盘中扫描其他新刷写的文件，然后会对这三个找到的内容进行一个合并，返回时间戳最大的结果。所以无论如何读操作都是会经过磁盘的，所以HBase的读操作肯定会比写操作要慢。</li>
</ol>
<p>​        注：因为读缓存的容量肯定是远小于这个磁盘的，所以在存储到达上限就需要删掉一些数据，使用LRU算法，也就是将最近最久未使用的数据删掉。（一般没问也可以不用说，也没背其他的算法）</p>
<h3 id="HBase-Compact过程（合并小文件）"><a href="#HBase-Compact过程（合并小文件）" class="headerlink" title="HBase Compact过程（合并小文件）"></a>HBase Compact过程（合并小文件）</h3><p>​        分为两种：minor compaction和 major compaction。minor compaction会将临近的若干个较小的hfile合并，但是不会清理过期和删除的数据；major compaction是将整个store的所有hfile进行合并，会清理掉过期和删除的数据。</p>
<p>​        相关的参数有：</p>
<ol>
<li>hbase.hregion.majorcompaction：默认是7天合并一次，这个过程因为比较消耗资源，所以减一生产关闭，在应用空闲时手动触发。</li>
<li>hbase.hstore.compactionThreshold：默认当store中的hfile个数超过3个，会合并重写为一个新文件，设置个数越大能够减少合并的次数，但是每次合并的事件也会相对延长。当然这里合并之后考虑到数据一致性的问题，不会立刻删除旧文件，而是等一会才删掉。</li>
</ol>
<h3 id="HBase-真正删除数据的时间"><a href="#HBase-真正删除数据的时间" class="headerlink" title="HBase 真正删除数据的时间"></a>HBase 真正删除数据的时间</h3><p>​        首先，HBase会在flush和major compaction阶段触发删除数据。</p>
<p>​        对于flush阶段，如果数据存在同一个内存，就能知道这个数据是否过期，或者这个数据是否已经标记了delete，然后会删掉过期或被删除的数据，但是不会删除这个delete标记。</p>
<p>​        对于major compaction，由于是整个store的文件合并，在重写到新文件时，就可以看到这个数据是否是过期的，或者是否已经被删除，然后就会删掉这部分数据，并且会删除delete标记。</p>
<p>​        这个delete标记之所以在flush阶段不删掉，是因为flush阶段看到的只是这块内存中的内容，但是不确定之前刷写到磁盘的数据中是否有这个数据的其他版本，如果在flush阶段就删掉这个标记，那么系统中其他版本的数据还能够被查到；在major compaction阶段会删除这个标记是因为进行大合并的时候就会删掉这个表中所有的不合法的数据，那么这个delete标记的其他版本的数据也会被删掉。</p>
<h3 id="HBase切分region"><a href="#HBase切分region" class="headerlink" title="HBase切分region"></a>HBase切分region</h3><p>​        HBase在最开始的时候只会有一个Region，等到数据量到达某个阈值才会切分这个region。这个阈值在0.94版本，指的是某个storefile的大小超过10G，它所在的region就会进行切分。在0.94版本后，除了这个值以外，还有一个将数据从内存刷写到磁盘的临界值，默认是hdfs一个块的大小，会将这个临界值乘以这个regionserver中属于这个表的region的个数，然后将这个乘积和10G的参数比较取较小值，这个较小值就是0.94版本之后触发切分的阈值。这样的操作越到后面region就会越大，很容易引起数据倾斜（热点）问题。</p>
<h3 id="HBase优化"><a href="#HBase优化" class="headerlink" title="HBase优化"></a>HBase优化</h3><h4 id="预分区"><a href="#预分区" class="headerlink" title="预分区"></a>预分区</h4><p>​        为了解决自动切分导致的数据倾斜问题，引入了预分区。预分区就是，每个region会维护一个StartRow和EndRow，如果加入的数据的rowkey在这个region维护的范围内，就将这个数据交给这个region。依照这个原则，可以将数据需要投放的分区大致规划好，以提高hbase的性能。</p>
<p>分区的代码：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建表 test，并为该表设置四个分区 [-∞, 1000], [1000, 2000], [2000, 3000], [3000, +∞]</span></span><br><span class="line"><span class="keyword">create</span> <span class="string">&#x27;test1&#x27;</span>, <span class="string">&#x27;info&#x27;</span>, <span class="string">&#x27;partition1&#x27;</span>, &#123;SPLITS <span class="operator">=</span><span class="operator">&gt;</span> [<span class="string">&#x27;1000&#x27;</span>, <span class="string">&#x27;2000&#x27;</span>, <span class="string">&#x27;3000&#x27;</span>]&#125;</span><br><span class="line"><span class="comment">-- 通过文件来指定分区，相对路径是将文件建在 hbase/ 目录下</span></span><br><span class="line"><span class="keyword">create</span> <span class="string">&#x27;test2&#x27;</span>, <span class="string">&#x27;info&#x27;</span>, <span class="string">&#x27;partition1&#x27;</span>, SPLITS_FILE <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;splits.txt&#x27;</span></span><br></pre></td></tr></table></figure>



<h4 id="RowKey设计"><a href="#RowKey设计" class="headerlink" title="RowKey设计"></a>RowKey设计</h4><p>RowKey的设计有三个原则：</p>
<ol>
<li>散列原则：让RowKey能够尽量均匀的分配到不同的分区中，不应该将时间戳</li>
<li>唯一原则：HBase通过这个RowKey唯一的判断一条数据；</li>
<li>长度原则：正常来说应该是在70~100个字节之间，因为要保证唯一，长度太短比较难实现，如果太长，假设是500字节，如果此时存储了1000万的数据，那么仅rowkey就占了差不多1G的容量，极大的影响了存储的效率。</li>
</ol>
<p>​        在生产环境中，rowkey的唯一性和长度是一定要保证的，那么具体的优化内容其实就是围绕散列原则进行的。但是一个好的rowkey不应该只考虑散列性，还需要依据业务逻辑考虑rowkey的集中性，也就是应该将经常一起访问的内容放在一起，这样才能使用一个 (startrow, endrow] 也就是查找尽量少的分区将它们一起拿出来。</p>
<p>​        <strong>rowkey的设计在面试中常会结合具体示例来考：</strong></p>
<p>示例：电信业务的某一个项目中，会实时产生这样的数据：</p>
<blockquote>
<p>12345678910 -&gt; 13926635209 2022-05-05 15:15:15 568</p>
</blockquote>
<p>注：上述这个例子的解读为，在 2022-05-05 15:15:15 这个时间，电话号为 12345678910 的机主给电话号为 13926635209 的记住打了电话，通话时长为 568s 。</p>
<p><strong>题：</strong>想要查询电话号为 12345678910 的通话详情。假设需要创建300个分区，如何设计rowkey和分区键？</p>
<p><strong>答：</strong> </p>
<p>因为rowkey需要均匀分布在不同的分区内，所以首先要考虑分区键的创建：</p>
<p>​        因为要创建300个分区，那么可以考虑分区键的位数是3，然后通过取模的方式获取具体分区，那么具体的分区键为：</p>
<blockquote>
<p>000|</p>
<p>001|</p>
<p>…</p>
<p>298|</p>
</blockquote>
<p>​        因为是300个分区，那么分区键的取值范围应该是 1<del>299 或 0</del>298 ，考虑到取模数值肯定存在0，设置 0 ~ 298 ，然后让一个值对299取模，就可以得到该分区的前三位。需要注意，第四位是 <code>|</code> ，因为这个符号在 ascii 码中是比较大的值，又因为hbase中数值是按照字典序比较的，使用 <code>|</code> 可以保证rowkey中前三位数的前缀相等的内容会写到一个分区。</p>
<p>确定了分区后，接着看rowkey：</p>
<p>​        RowKey为了保证写操作可以将相同手机号的数据写入一个分区，前缀会对手机号取299的模，然后拼接字符 <code>_</code> 。之所以使用 <code>_</code> 是为了因为 <code>_</code> 的ascii比 <code>|</code> 小，这样就能保证相同前三位数的rowkey能够进入一个分区。</p>
<p>​        但是不同手机号的通话详情的数据肯定是不一致的，有些很多，有些很少，这种情况单用一个手机号也容易产生数据倾斜，而这种详情基本是按年、月、日来取的，可以加上日期，来让这个值更加散列。如果加上的日期是日或者更小，数据就太散了，如果想要取一年的数据会很复杂；如果使用年份数据依然会比较集中，所以取<strong>年月加上电话号的组合再取299的模</strong>最好。那么具体的rowkey前缀是：</p>
<blockquote>
<p>xxx_</p>
</blockquote>
<p>​        之所以说是前缀，是为了在保证散列性的前提下，能够让一个手机号的数据存放在一起，这样就能方便取出，那么可以在这个前缀后拼接手机号，因为是按位排序的，相同手机号的数据肯定会放在一起。接着，一般这种详情都是会按年、月、日来读，那么后面拼接具体的日期就可以让一个手机号同一年月的数据更加集中。那么具体的rowkey应该是如下形式：</p>
<blockquote>
<p>xxx_12345678910_2022-05-05 15:15:15</p>
</blockquote>
<p>那么想要查 <strong>手机号为 12345678910 的机主在 2022年5月的通话详情</strong> ，应该怎么设置 startrow 和 endrow ：</p>
<p>​        首先取rowkey前缀：<code>(12345678910 + 202205) % 299</code> ，这个值应该是 startrow 和 endrow 的共同前缀，接着因为手机号和年月相同，所以应该拼接手机号和年月，最后，endrow 的结尾应该会比 startrow多一位 <code>|</code> 来表示结束。具体如下：</p>
<blockquote>
<p>xxx &#x3D; (12345678910 + 202205) % 299</p>
<p>startrow &#x3D; xxx_12345678910_202205</p>
<p>endrow &#x3D; xxx_12345678910_202205|</p>
<p> 或者</p>
<p>endrow &#x3D; xxx_12345678910_202206</p>
</blockquote>
<p>因为是按位比较，那么 startrow 的值肯定是最小的，endrow 因为有 <code>|</code> 仅小于 <code>&#125;</code> 和 <code>~</code> 的值，所以可以说是 <code>xxx_12345678910_202205</code> 前缀中最大的值了，另一个 <code>6</code> 结尾的 endrow 是因为 5 的字典序肯定比6小，所以这样设计也是5月份中最大的值。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>hive - 报错</title>
    <url>/2021/08/06/hive-%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h3 id="hive-ql-io-orc-OrcSerde-OrcSerdeRow-cannot-be-cast-to-org-apache-hadoop-io-BytesWritable"><a href="#hive-ql-io-orc-OrcSerde-OrcSerdeRow-cannot-be-cast-to-org-apache-hadoop-io-BytesWritable" class="headerlink" title="hive.ql.io.orc.OrcSerde$OrcSerdeRow cannot be cast to org.apache.hadoop.io.BytesWritable"></a>hive.ql.io.orc.OrcSerde$OrcSerdeRow cannot be cast to org.apache.hadoop.io.BytesWritable</h3><span id="more"></span>

<p>具体报错内容如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">&quot;area_flag&quot;:&quot;3&quot;,&quot;kpi_value&quot;:<span class="number">72980.5886</span>&#125;</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.mr.ExecMapper.map(ExecMapper.java:<span class="number">179</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.mapred.MapRunner.run(MapRunner.java:<span class="number">54</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.mapred.MapTask.runOldMapper(MapTask.java:<span class="number">459</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.mapred.MapTask.run(MapTask.java:<span class="number">343</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.mapred.YarnChild$<span class="number">2.</span>run(YarnChild.java:<span class="number">164</span>)</span><br><span class="line">        <span class="keyword">at</span> java.security.AccessController.doPrivileged(Native <span class="keyword">Method</span>)</span><br><span class="line">        <span class="keyword">at</span> javax.security.auth.Subject.doAs(Subject.java:<span class="number">415</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.security.UserGroupInformation.doAs(UserGroupInformation.java:<span class="number">1917</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.mapred.YarnChild.main(YarnChild.java:<span class="number">158</span>)</span><br><span class="line">Caused <span class="keyword">by</span>: org.apache.hadoop.hive.ql.metadata.HiveException: Hive Runtime Error while processing <span class="type">row</span> &#123;&quot;kpi_code&quot;:&quot;FFJFCW121&quot;,&quot;area_code&quot;:&quot;811&quot;,&quot;area_name&quot;:&quot;北京&quot;,&quot;area_flag&quot;:&quot;3&quot;,&quot;kpi_value&quot;:<span class="number">72980.5886</span>&#125;</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.MapOperator.process(MapOperator.java:<span class="number">507</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.mr.ExecMapper.map(ExecMapper.java:<span class="number">170</span>)</span><br><span class="line">        ... <span class="number">8</span> more</span><br><span class="line">Caused <span class="keyword">by</span>: org.apache.hadoop.hive.ql.metadata.HiveException: Unexpected exception: Unexpected exception: org.apache.hadoop.hive.ql.io.orc.OrcSerde$OrcSerdeRow cannot be cast <span class="keyword">to</span> org.apache.hadoop.io.BytesWritable</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.MapJoinOperator.processOp(MapJoinOperator.java:<span class="number">318</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.Operator.forward(Operator.java:<span class="number">815</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.TableScanOperator.processOp(TableScanOperator.java:<span class="number">98</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.MapOperator$MapOpCtx.forward(MapOperator.java:<span class="number">157</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.MapOperator.process(MapOperator.java:<span class="number">497</span>)</span><br><span class="line">        ... <span class="number">9</span> more</span><br><span class="line">Caused <span class="keyword">by</span>: org.apache.hadoop.hive.ql.metadata.HiveException: Unexpected exception: org.apache.hadoop.hive.ql.io.orc.OrcSerde$OrcSerdeRow cannot be cast <span class="keyword">to</span> org.apache.hadoop.io.BytesWritable</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.MapJoinOperator.processOp(MapJoinOperator.java:<span class="number">318</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.Operator.forward(Operator.java:<span class="number">815</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.internalForward(CommonJoinOperator.java:<span class="number">638</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.genAllOneUniqueJoinObject(CommonJoinOperator.java:<span class="number">670</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.checkAndGenObject(CommonJoinOperator.java:<span class="number">748</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.MapJoinOperator.processOp(MapJoinOperator.java:<span class="number">306</span>)</span><br><span class="line">        ... <span class="number">13</span> more</span><br><span class="line">Caused <span class="keyword">by</span>: java.lang.ClassCastException: org.apache.hadoop.hive.ql.io.orc.OrcSerde$OrcSerdeRow cannot be cast <span class="keyword">to</span> org.apache.hadoop.io.BytesWritable</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat$<span class="number">1.</span>write(HiveIgnoreKeyTextOutputFormat.java:<span class="number">91</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.FileSinkOperator.processOp(FileSinkOperator.java:<span class="number">717</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.Operator.forward(Operator.java:<span class="number">815</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.SelectOperator.processOp(SelectOperator.java:<span class="number">84</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.Operator.forward(Operator.java:<span class="number">815</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.internalForward(CommonJoinOperator.java:<span class="number">638</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.createForwardJoinObject(CommonJoinOperator.java:<span class="number">433</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.genObject(CommonJoinOperator.java:<span class="number">525</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.genObject(CommonJoinOperator.java:<span class="number">522</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.genObject(CommonJoinOperator.java:<span class="number">522</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.genJoinObject(CommonJoinOperator.java:<span class="number">451</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.CommonJoinOperator.checkAndGenObject(CommonJoinOperator.java:<span class="number">752</span>)</span><br><span class="line">        <span class="keyword">at</span> org.apache.hadoop.hive.ql.exec.MapJoinOperator.processOp(MapJoinOperator.java:<span class="number">306</span>)</span><br><span class="line">        ... <span class="number">18</span> more</span><br></pre></td></tr></table></figure>



<p>解决：</p>
<ol>
<li><p>查看表结构</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&gt;</span> <span class="keyword">desc</span> formatted table_name;</span><br><span class="line">...                 </span><br><span class="line"># Storage Information            </span><br><span class="line">SerDe Library:          org.apache.hadoop.hive.ql.io.orc.OrcSerde        </span><br><span class="line">InputFormat:            org.apache.hadoop.mapred.TextInputFormat         </span><br><span class="line">OutputFormat:           org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>SerDe Library</code> 的格式为 <code>OrcSerde</code> 。</p>
<p>有两种可能性：</p>
<p>（1）可能是复制其他表的结构创建该表，没有复制完，有部分配置不对，这时候需要对比两个表的结构分析；</p>
<p>（2）创建表结构指定的格式不对。</p>
</li>
<li><p>查看表结构</p>
<p>如果是复制表结构创建的表，可以使用如下命令比对两个表创建时候的结构：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> table_name;</span><br></pre></td></tr></table></figure>

<p>本次错误是因为没有复制完，漏掉了如下设置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="type">ROW</span> FORMAT SERDE </span><br><span class="line">  <span class="string">&#x27;org.apache.hadoop.hive.ql.io.orc.OrcSerde&#x27;</span> </span><br><span class="line"><span class="keyword">WITH</span> SERDEPROPERTIES ( </span><br><span class="line">  <span class="string">&#x27;field.delim&#x27;</span><span class="operator">=</span><span class="string">&#x27;\u0005&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;serialization.format&#x27;</span><span class="operator">=</span><span class="string">&#x27;\u0005&#x27;</span>) </span><br><span class="line">STORED <span class="keyword">AS</span> INPUTFORMAT </span><br><span class="line">  <span class="string">&#x27;org.apache.hadoop.hive.ql.io.orc.OrcInputFormat&#x27;</span> </span><br><span class="line">OUTPUTFORMAT </span><br><span class="line">  <span class="string">&#x27;org.apache.hadoop.hive.ql.io.orc.OrcOutputFormat&#x27;</span></span><br><span class="line">LOCATION</span><br><span class="line">  <span class="string">&#x27;hdfs://ns/domain/ns/sc_share/dm_db/tmp_td_month&#x27;</span></span><br><span class="line">TBLPROPERTIES (</span><br><span class="line">  <span class="string">&#x27;orcfile.compress&#x27;</span><span class="operator">=</span><span class="string">&#x27;Snappy&#x27;</span>, </span><br><span class="line">  <span class="string">&#x27;transient_lastDdlTime&#x27;</span><span class="operator">=</span><span class="string">&#x27;1587809055&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>解决方式：</p>
<p>将当前出错的表删掉：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">table</span> table_name;</span><br></pre></td></tr></table></figure>

<p>然后将原表的结构复制，可能需要修改存储位置<code>LOCATION</code> ；</p>
<p>最后使用该创建语句再次创建表，成功解决。</p>
</li>
<li><p>修改表的格式</p>
<p>本内容摘自：<a href="https://blog.csdn.net/wawa8899/article/details/81674817">Hive表的file_format参数</a></p>
<p>有如下这些格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">file_format:</span><br><span class="line">  : SEQUENCEFILE</span><br><span class="line">  <span class="operator">|</span> TEXTFILE    <span class="comment">-- (Default, depending on hive.default.fileformat configuration)  # 默认存储文本格式，不能区分数据类型</span></span><br><span class="line">  <span class="operator">|</span> RCFILE      <span class="comment">-- (<span class="doctag">Note:</span> Available in Hive 0.6.0 and later)</span></span><br><span class="line">  <span class="operator">|</span> ORC         <span class="comment">-- (<span class="doctag">Note:</span> Available in Hive 0.11.0 and later)</span></span><br><span class="line">  <span class="operator">|</span> PARQUET     <span class="comment">-- (<span class="doctag">Note:</span> Available in Hive 0.13.0 and later)</span></span><br><span class="line">  <span class="operator">|</span> AVRO        <span class="comment">-- (<span class="doctag">Note:</span> Available in Hive 0.14.0 and later)</span></span><br><span class="line">  <span class="operator">|</span> JSONFILE    <span class="comment">-- (<span class="doctag">Note:</span> Available in Hive 4.0.0 and later)</span></span><br><span class="line">  <span class="operator">|</span> INPUTFORMAT input_format_classname OUTPUTFORMAT output_format_classname</span><br></pre></td></tr></table></figure>

<p>TEXTFILE：文本格式，为hive默认的存储格式，这种格式不能区分数据类型（Int类型的数据也只能当作文本来处理）。TEXTFILE在使用时只需要指定两个东西：列与列之间的分隔符；行与行之间的分隔符。<br>SEQUENCEFILE：二进制的，它存在一些问题，这种存储格式存储的数据size比原始数据还要大，现在基本不用。<br>RCFILE：它是一个混合的行列编成的，它保证所有行的一个列都在一个节点（block）之上，缺点是row group太小（4M）了，实际的好处只是空间节省只提升了大约10%，工作中不会大面积使用，所以现在基本也不使用了。<br>ORC：优化过后的RC（行列存储），它提供了更高效的存储方式。一个strip（250M）包含了索引文件，索引范围1~10W。查询时只会查询index范围内的strip，提高查询效率。默认每10000行为一个单位。orc默认采用zlib压缩方式。详见官网说明。<br>PARQUET：源于dremel（三秒钟完成一个T的数据处理），效率很高。<br>AVRO：不常用。<br>JSONFILE：不常用。</p>
<p>可以使用如下命令修改表的格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">set</span> fileformat file_format;</span><br></pre></td></tr></table></figure>

<p>一般情况下用来转换为 <code>ORC</code> 格式。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>报错</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>jsp引用外部css文件失效</title>
    <url>/2021/12/27/jsp%E5%BC%95%E7%94%A8%E5%A4%96%E9%83%A8css%E6%96%87%E4%BB%B6%E5%A4%B1%E6%95%88/</url>
    <content><![CDATA[<h3 id="失效的内容"><a href="#失效的内容" class="headerlink" title="失效的内容"></a>失效的内容</h3><p>css：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.goodpage</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: white;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">3px</span> <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>jsp:</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;css/style.css&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;goodpage&quot;</span>&gt;</span><br><span class="line">        asdf</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>结果css样式没有起到作用，jsp的内容在左上角顶格出现。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>我的代码出现这个bug的原因：因为客户端缓存了修改之前的css文件，在下次再加载的时候，客户端不会加载之前缓存的同名文件。</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>修改css文件的名称，或者给文件名称添加一个版本号，此处使用系统时间戳作为版本号：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;stylesheet&quot;</span> href=<span class="string">&quot;css/style.css?v=&lt;%= System.currentTimeMillis()%&gt;&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>不用在实际文件中添加，这种 <code>?v | ?version</code> 只是给这个链接添加一个版本号的参数，目的是让客户端区分文件。</p>
]]></content>
      <categories>
        <category>项目小记</category>
        <category>报错</category>
      </categories>
      <tags>
        <tag>jsp</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>java - 内存模型的理解</title>
    <url>/2021/07/13/java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="Java中的变量"><a href="#Java中的变量" class="headerlink" title="Java中的变量"></a>Java中的变量</h3><p>有三种：</p>
<span id="more"></span>



<p>成员变量（实例变量、属性）、本地变量（局部变量）、类变量（静态属性）。</p>
<ol>
<li>成员变量在类中定义，在类的内部的任何区域都可以访问的变量。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name,</span><br><span class="line">    <span class="keyword">int</span> age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>本地变量在方法中定义，在方法体的任何区域都可以访问的变量。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类变量是被<code>static</code>关键字修饰的属性，它的作用范围在定义之后，只能在类中修饰。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sex;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="成员变量和类变量的区别"><a href="#成员变量和类变量的区别" class="headerlink" title="成员变量和类变量的区别"></a>成员变量和类变量的区别</h4><p>类变量的实质是全局变量，如果某个变量是被所有对象共享，那么这个变量可以被设置成类变量，用<code>static</code>修饰；没有被 <code>static</code> 修饰的变量属于对象的特殊描述。</p>
<p>不同的对象的成员变量会被分配不同的内存空间，如果是类变量，那么所有对象的这个类变量会被分配到同一个内存，改变其中一个对象的类变量就会改变所有对象的这个类变量，即所有对象共享该变量。</p>
<p><strong>对象是类的实例。</strong></p>
<h3 id="摘自"><a href="#摘自" class="headerlink" title="摘自"></a>摘自</h3><p><a href="https://blog.csdn.net/smile_from_2015/article/details/50189797">Java中的变量</a></p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>hive - 日志分析项目小记</title>
    <url>/2021/05/31/hive-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="启动hive"><a href="#启动hive" class="headerlink" title="启动hive"></a>启动hive</h2><ol>
<li><p>启动hadoop集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">start-dfs.sh</span><br><span class="line">start-yarn.sh</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>



<ol>
<li><p>启动zookeeper集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">zkServer.sh start zoo1.cfg</span><br><span class="line">zkServer.sh start zoo2.cfg</span><br><span class="line">zkServer.sh start zoo3.cfg</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动hive</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hive-services.sh start</span><br><span class="line">hive</span><br></pre></td></tr></table></figure>

<p>有时候会遇到下述错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hadoop.ipc.RemoteException(org.apache.hadoop.hdfs.server.namenode.SafeModeException): Cannot create directory /tmp/hive/hadoop/3a6e8cb6-9e44-45ce-8fc4-8d79f816f720. Name node is in safe mode.</span><br><span class="line">The reported blocks 609 needs additional 3 blocks to reach the threshold 0.9990 of total blocks 613.</span><br><span class="line">The minimum number of live datanodes is not required. Safe mode will be turned off automatically once the thresholds have been reached. NamenodeHostName:hadoop002</span><br><span class="line">        at org.apache.hadoop.hdfs.server.namenode.FSNamesystem.newSafemodeException(FSNamesystem.java:1498)</span><br><span class="line">        at org.apache.hadoop.hdfs.server.namenode.FSNamesystem.checkNameNodeSafeMode(FSNamesystem.java:1485)</span><br><span class="line">        at org.apache.hadoop.hdfs.server.namenode.FSNamesystem.mkdirs(FSNamesystem.java:3191)</span><br><span class="line">        at org.apache.hadoop.hdfs.server.namenode.NameNodeRpcServer.mkdirs(NameNodeRpcServer.java:1157)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>解决：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hadoop dfsadmin -safemode leave</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="使用sqoop将mysql数据导入hive"><a href="#使用sqoop将mysql数据导入hive" class="headerlink" title="使用sqoop将mysql数据导入hive"></a>使用sqoop将mysql数据导入hive</h2><p>执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqoop import -m 1 \</span><br><span class="line">--connect jdbc:mysql://192.168.186.100:3306/forum \</span><br><span class="line">--username root \</span><br><span class="line">--password niit1234 \</span><br><span class="line">--hive-import \</span><br><span class="line">--create-hive-table \</span><br><span class="line">--hive-database forum \</span><br><span class="line">--delete-target-dir;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<blockquote>
<p>–create-hive-table ：使用mysql的表名和字段类型直接创建；</p>
<p>–hive-database ：指定将表放到某个数据库</p>
</blockquote>
<h2 id="报错：FAILED-ParseException-line-6-0-cannot-recognize-input-near-‘group’-‘by’-‘t’-in-expression-specification"><a href="#报错：FAILED-ParseException-line-6-0-cannot-recognize-input-near-‘group’-‘by’-‘t’-in-expression-specification" class="headerlink" title="报错：FAILED: ParseException line 6:0 cannot recognize input near ‘group’ ‘by’ ‘t’ in expression specification"></a>报错：FAILED: ParseException line 6:0 cannot recognize input near ‘group’ ‘by’ ‘t’ in expression specification</h2><p>我是因为下面这句报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">on tmp.id=t.course_id and t.type_name=”选修课”</span><br></pre></td></tr></table></figure>

<p>报错点：<code>&quot;&quot;</code>是中文的，我一开始直接在word文档中复制粘贴，但是就算是英文格式，在命令行也是中文的。</p>
<p>解决方法：</p>
<p>在命令行中敲出引号，在文档中进行修改，再将整个语句粘贴到命令行运行。</p>
<p>在创建表的时候，如果定义的字段名称是关键字，也会报这个错。</p>
]]></content>
      <categories>
        <category>项目小记</category>
      </categories>
      <tags>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql - 日志分析项目小记</title>
    <url>/2021/05/31/mysql-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="mysql执行本地sql文件"><a href="#mysql执行本地sql文件" class="headerlink" title="mysql执行本地sql文件"></a>mysql执行本地sql文件</h2><p>现在有一个<code>test.sql</code>文件，该文件需要导入到<code>mysql</code>的<code>test</code>数据库中：</p>
<ol>
<li><p>登录<code>mysql</code>，创建数据库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -uroot -ppasswd</span><br><span class="line">create database test;</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>



<ol>
<li><p>退出登录，执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">quit;</span><br><span class="line">mysql -uroot -ppasswd -Dtest &lt; test.sql</span><br></pre></td></tr></table></figure>

<p>此时可能报如下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">ERROR 1273 (HY000) at line 24: Unknown collation: &#x27;utf8mb4_0900_ai_ci&#x27;</span><br></pre></td></tr></table></figure>

<p>那是因为我的<code>mysql</code>的版本为5.7，<code>sql</code>文件的版本是8.x，高版本不能向下兼容。解决：</p>
<p>（1）将<code>utf8mb4_0900_ai_ci</code>全部替换为<code>utf8_general_ci</code>；</p>
<p>（2）将<code>utf8mb4</code>替换为<code>utf8</code>。</p>
<p>我使用<code>vim</code>工具，执行如下命令一次性将内容全部替换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:%s/utf8mb4_0900_ai_ci/utf8_general_ci/g</span><br><span class="line">:%s/utf8mb4/utf8/g</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>%s/a/b/g</code>的解释：即将文档中所有a内容替换为b内容</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>项目小记</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql - 面试题</title>
    <url>/2021/07/13/mysql-%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1-on和where的区别"><a href="#1-on和where的区别" class="headerlink" title="1. on和where的区别"></a>1. on和where的区别</h2><span id="more"></span>

<p>二者都是对临时表进行筛选，不同的是，on是在临时表创建的时候进行筛选，where是在临时表创建完以后进行的筛选。</p>
<p>比如在一个 <code>on a.id=b.id</code> 的连接后面添加条件 <code>b.id = 20</code> ，添加后面的条件之前，可以知道a表的连接条件是<code> = b.id</code> ，b表的连接条件是 <code> = a.id</code>，如果 <code>b.id = 20</code> 的操作是在 <code>on</code> 中，那么a表的筛选是<code> = b.id</code> ，b表的筛选条件是<code> = a.id</code> 和<code>id = 20</code>；</p>
<p>如果该条件在 <code>where</code> 中，操作就变成了首先将ab表通过前面的连接条件连接起来之后，对此临时表进行 <code>b.id = 20</code> 的筛选。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>spark - 报错</title>
    <url>/2021/08/13/spark-%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h3 id="Error-in-query-Detected-cartesian-product-for-INNER-join-between-logical-plans"><a href="#Error-in-query-Detected-cartesian-product-for-INNER-join-between-logical-plans" class="headerlink" title="Error in query: Detected cartesian product for INNER join between logical plans"></a>Error in query: Detected cartesian product for INNER join between logical plans</h3><p>默认sparksql版本2.x不支持笛卡尔积操作，需要手动开启支持权限：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> spark.sql.crossJoin.enabled<span class="operator">=</span><span class="literal">true</span>;</span><br></pre></td></tr></table></figure>



<span id="more"></span>



<h3 id="Caused-by-org-apache-spark-SparkException-Job-aborted-due-to-stage-failure-ResultStage-98-sql-at-0-M-has-failed-the-maximum-allowable-number-of-M-times-4-M-Most-recent-failure-reason-org-apache-spark-shuffle-MetadataFetchFailedException-Missing-an-output-location-for-shuffle-33"><a href="#Caused-by-org-apache-spark-SparkException-Job-aborted-due-to-stage-failure-ResultStage-98-sql-at-0-M-has-failed-the-maximum-allowable-number-of-M-times-4-M-Most-recent-failure-reason-org-apache-spark-shuffle-MetadataFetchFailedException-Missing-an-output-location-for-shuffle-33" class="headerlink" title="Caused by: org.apache.spark.SparkException: Job aborted due to stage failure: ResultStage 98 (sql at :0)^M has failed the maximum allowable number of^M times: 4.^M Most recent failure reason: org.apache.spark.shuffle.MetadataFetchFailedException: Missing an output location for shuffle 33"></a>Caused by: org.apache.spark.SparkException: Job aborted due to stage failure: ResultStage 98 (sql at <unknown>:0)^M has failed the maximum allowable number of^M times: 4.^M Most recent failure reason: org.apache.spark.shuffle.MetadataFetchFailedException: Missing an output location for shuffle 33</unknown></h3><p>不知道具体什么原因（热烈欢迎大佬教我如何深入查找具体原因），只能通过代码大致判断可能数据量太大造成内存溢出。</p>
<p>解决方法：</p>
<p>使用 <code>mapjoin </code> 将小表放到内存，减少reduce端的压力。</p>
<ol>
<li><p>设置参数：<code>set hive.ignore.mapjoin.hint=true;</code></p>
<p>true 注释方式不生效，false 注释方式生效 - 用于强行指定需要加入内存走mapjoin的表。</p>
</li>
<li><p>将小表进行 <code>mapjoin</code> 操作。</p>
<p>具体代码为 <code>/*+ mapjoin(table_name)*/</code></p>
</li>
</ol>
<p>具体代码：</p>
<p>前：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table_a <span class="keyword">join</span> table_b;</span><br></pre></td></tr></table></figure>

<p>其中 <code>table_b</code> 为小表。</p>
<p>后：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="comment">/*+ mapjoin(table_b)*/</span> <span class="operator">*</span> <span class="keyword">from</span> table_a <span class="keyword">join</span> table_b;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>报错</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>spark - 安装 &amp; 简单使用wordcount</title>
    <url>/2021/06/06/spark-%E5%AE%89%E8%A3%85%20&amp;%20%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8wordcount/</url>
    <content><![CDATA[<h3 id="IDEA创建spark项目"><a href="#IDEA创建spark项目" class="headerlink" title="IDEA创建spark项目"></a>IDEA创建spark项目</h3><span id="more"></span>

<ol>
<li><p>创建java环境为JDK1.8的maven项目，项目名为atguigu-classes；</p>
<p>此步骤省略。</p>
</li>
<li><p>添加scala插件</p>
<p>scala插件是使用spark操作必不可少的工具，默认采用的版本是2.12，而不是最新版本。</p>
<p>File -&gt; Project Structure -&gt; Global Libraries</p>
<p>然后点击<code>+</code>号，选择<code>download</code>，找到合适的版本：<code>2.12.11</code>，下载。此过程可能会有点久。</p>
</li>
<li><p>检查是否成功添加</p>
<p>右键项目 -&gt; add frameworks support</p>
<p>然后寻找是否有scala选项，如果有，则成功添加，此时需要点击打勾，以添加该选项。</p>
</li>
<li><p>新建第一个简单的项目，来测试是否成功配置spark环境</p>
<p>右键<code>new</code>选择<code>Scala Class</code>，然后选择<code>Object</code>，输入名称为<code>test</code>，其中，具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object test &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    println(&quot;Hello Spark&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="WordCount案例"><a href="#WordCount案例" class="headerlink" title="WordCount案例"></a>WordCount案例</h3><ol>
<li><p>任务需求 - 将下述文件进行<code>wordcount</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello scala</span><br><span class="line">hello spark</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始代码如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.core.wc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2021/6/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> 读取数据后，将数据切分并按照相同的单词为一组的思想对数据进行分组，groupBy以后就会得到[word, list[word, word, ...]]，最后输出的是[word, list.size]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark01_WordCount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//Application</span></span><br><span class="line">    <span class="comment">//Spark框架</span></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 建立和spark框架的连接</span></span><br><span class="line">      <span class="comment">//基本配置</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line">    <span class="comment">//创建连接</span></span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 执行业务逻辑</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 以行为单位，读取数据</span></span><br><span class="line">    <span class="keyword">val</span> line = sc.textFile(path = <span class="string">&quot;datas&quot;</span>)</span><br><span class="line">    <span class="comment">//2. 将一行数据拆分为一个个单词，即扁平化，flatMap就是扁平映射</span></span><br><span class="line">    <span class="keyword">val</span> words = line.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 以分割后的数据为准，分组累加计算</span></span><br><span class="line">    <span class="comment">//相同的单词进行分组，给我的每个元素是单词，而我按照单词分组</span></span><br><span class="line">    <span class="comment">//此时需要知道，wordGroup的类型是RDD[(String, Iterable[String])]，String是分组的条件，即word，Iterable[String]是结果，即word相同元素的集合</span></span><br><span class="line">    <span class="keyword">val</span> wordGroup = words.groupBy(word =&gt; word)</span><br><span class="line">    <span class="comment">//4. 将分组后的数据进行转换，即多个值 -&gt; 一个值和一个数字（值的数量）</span></span><br><span class="line">    <span class="keyword">val</span> word_count = wordGroup.map&#123;</span><br><span class="line">      <span class="keyword">case</span> (word, list) =&gt;</span><br><span class="line">        (word, list.size)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5. 将结果采集到控制台输出</span></span><br><span class="line">    <span class="keyword">val</span> res = word_count.collect()</span><br><span class="line">    res.foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 关闭连接</span></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用到的部分函数记录</p>
<blockquote>
<p>textFile：读取文件，其中, <code>path</code> 可以是一个文件的路径，也可以是多个文件的目录，即可以同时读取多个文件。</p>
<p>flatMap：对集合中的每个元素进行操作后再扁平化处理；</p>
<p>​        通常会将map和flatMap进行比较：</p>
<p>​        二者均会对集合中的每个元素进行操作，不同的是flatMap会将操作后的结果进行扁平化，即合并为一个一维的集合，而map不会；</p>
<p>groupBy：通过什么规则进行分组；</p>
<p>​        通常将groupBy和groupByKey进行比较</p>
<p>【此处我简单搬了该文章：<a href="https://blog.csdn.net/jiangzhali1623/article/details/83717088">文章链接</a>】：</p>
<p>​        groupByKey希望用户自己实现groupBy的规则，而groupBy被列属性束缚，相较而言，前者更灵活；但groupByKey返回的KeyValueGroupedDataset类提供的操作接口不如groupBy返回的RelationalGroupedDataset类所提供的接口丰富，所以在大多数情况下，更推荐使用groupBy。</p>
</blockquote>
</li>
<li><p>初始代码中进行的所谓聚合，实际上是对函数方法的调用，并不是真正的聚合，以下是对调用部分的更改：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.core.wc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2021/6/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> 核心代码中，将单词划分开后首先均赋1，然后再进行分组，最后累加1值来聚合最终结果。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark02_WordCount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//Application</span></span><br><span class="line">    <span class="comment">//Spark框架</span></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 建立和spark框架的连接</span></span><br><span class="line">      <span class="comment">//基本配置</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line">    <span class="comment">//创建连接</span></span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 执行业务逻辑</span></span><br><span class="line">    <span class="keyword">val</span> line = sc.textFile(path = <span class="string">&quot;datas&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> words = line.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> word2One = words.map(</span><br><span class="line">      word =&gt; (word, <span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里对word2One的(word,1)，以word，即t._1为条件进行分组</span></span><br><span class="line">    <span class="keyword">val</span> wordGroup = word2One.groupBy(</span><br><span class="line">      t =&gt; t._1</span><br><span class="line">    )</span><br><span class="line"><span class="comment">//    wordGroup.foreach(println)</span></span><br><span class="line">    <span class="keyword">val</span> word_count = wordGroup.map&#123;</span><br><span class="line">      <span class="keyword">case</span> (word, list) =&gt; &#123;	<span class="comment">// 因为不使用word遍历，所以也可以写为 case (_, list)</span></span><br><span class="line">        list.reduce(</span><br><span class="line">          (t1, t2) =&gt; &#123;</span><br><span class="line">            (t1._1, t1._2+t2._2)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5. 将结果采集到控制台输出</span></span><br><span class="line">    <span class="keyword">val</span> res = word_count.collect()</span><br><span class="line">    res.foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 关闭连接</span></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更改后的代码的部分函数使用</p>
<blockquote>
<ol>
<li><p>map函数</p>
<p>​        map，即映射，可以在 <code>()</code> 或 <code>&#123;&#125;</code> 内遍历数据进行操作，<code>()</code> 和 <code>&#123;&#125;</code> 的区别在于，如果遍历的数据只有一列，用前者，此时定义的临时变量不需要 <code>case</code> 关键字；如果是多列，需要使用 <code>case (...)</code>，其中，<code>case</code> 后的括号内必须包含与列数相等的变量，如果不会使用，可以使用 <code>_</code> 占位符省略名称。</p>
</li>
<li><p>reduce函数</p>
<p>​        reduce可以对集合中的元素进行归约操作。</p>
<p>​        如上述代码，reduce会将每一个分组的元素以某种方式进行合并，即上述的累加1值。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>单看前两版的代码，flatMap、reduce、map等函数，Java中也有，Spark好像并没有什么优势。但实际上，<strong>spark框架提供了更多的功能，其中主要代码的分组和聚合，可以用一个方法实现 - reduceByKey - 相同key的数据，可以对value进行reduce聚合</strong>：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bigdata.spark.core.wc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2021/6/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> 核心代码中，将单词划分开后首先均赋1，然后再进行分组，最后累加1值来聚合最终结果。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark03_WordCount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 建立和spark框架的连接</span></span><br><span class="line">      <span class="comment">//基本配置</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local&quot;</span>).setAppName(<span class="string">&quot;WordCount&quot;</span>)</span><br><span class="line">    <span class="comment">//创建连接</span></span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 执行业务逻辑</span></span><br><span class="line">    <span class="keyword">val</span> line = sc.textFile(path = <span class="string">&quot;datas&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> words = line.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    <span class="keyword">val</span> word2One = words.map(</span><br><span class="line">      word =&gt; (word, <span class="number">1</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Spark框架提供更多的功能，可以将分组和聚合使用一个方法实现</span></span><br><span class="line">    <span class="comment">//reduceByKey：相同key的数据，可以对value进行reduce聚合</span></span><br><span class="line">    <span class="keyword">val</span> word_count = word2One.reduceByKey(_+_)</span><br><span class="line">    <span class="comment">//5. 将结果采集到控制台输出</span></span><br><span class="line">    <span class="keyword">val</span> res = word_count.collect()</span><br><span class="line">    res.foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span> 关闭连接</span></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="log4j编写"><a href="#log4j编写" class="headerlink" title="log4j编写"></a>log4j编写</h3><p>为了省略执行时显示在控制台的执行日志，可以配置 <code>log4j.properties</code> 文件来提高日志输出的权限等。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">log4j.rootCategory</span>=<span class="string">ERROR, console</span></span><br><span class="line"><span class="meta">log4j.appender.console</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.console.target</span>=<span class="string">System.err</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="string">%d&#123;yy/MM/dd HH:mm:ss&#125; %p %c&#123;1&#125;: %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.logger.org.apache.spark.repl.Main</span>=<span class="string">ERROR</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.logger.org.spark_project.jetty</span>=<span class="string">ERROR</span></span><br><span class="line"><span class="meta">log4j.logger.org.spark_project.jetty.util.component.AbstractLifeCycle</span>=<span class="string">ERROR</span></span><br><span class="line"><span class="meta">log4j.logger.org.apache.spark.repl.SparkIMain$exprTyper</span>=<span class="string">ERROR</span></span><br><span class="line"><span class="meta">log4j.logger.org.apache.spark.repl.SparkILoop$SparkILoopInterpreter</span>=<span class="string">ERROR</span></span><br><span class="line"><span class="meta">log4j.logger.org.apache.parquet</span>=<span class="string">ERROR</span></span><br><span class="line"><span class="meta">log4j.logger.parquet</span>=<span class="string">ERROR</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.logger.org.apache.hadoop.hive.metastore.RetryingHMSHandler</span>=<span class="string">FATAL</span></span><br><span class="line"><span class="meta">log4j.logger.org.apache.hadoop.hive.ql.exec.FunctionRegistry</span>=<span class="string">ERROR</span></span><br></pre></td></tr></table></figure>

<p>日志的级别从高到低为如下：</p>
<blockquote>
<p>OFF、FATAL、ERROR、WARN、INFO、DEBUG、TRACE、ALL</p>
</blockquote>
<p>log4j建议只使用四个级别：<code>ERROR、WARN、INFO、DEBUG</code>，程序会打印高于或等于所设置级别的日志，设置的日志等级越高，打印出来的日志就越少。如果设置级别为INFO，则优先级高于等于INFO级别（如：INFO、WARN、ERROR）的日志信息将可以被输出,小于该级别的如DEBUG将不会被输出。</p>
]]></content>
      <categories>
        <category>大数据组件的应用</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>sparksql脚本的编写</title>
    <url>/2021/07/05/sparksql%E8%84%9A%E6%9C%AC%E7%9A%84%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<h3 id="1-写含有sparksql语句的、带参的shell脚本"><a href="#1-写含有sparksql语句的、带参的shell脚本" class="headerlink" title="1. 写含有sparksql语句的、带参的shell脚本"></a>1. 写含有sparksql语句的、带参的shell脚本</h3><span id="more"></span>

<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># !/bin/bash</span></span><br><span class="line"><span class="comment"># 此文件命名为show.sh</span></span><br><span class="line">SQL=<span class="string">&quot;</span></span><br><span class="line"><span class="string">show create table <span class="variable">$0</span>;</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line">spark-sql --num-executors 100 -e <span class="variable">$SQL</span></span><br></pre></td></tr></table></figure>

<h3 id="2-写循环数组、可以传参的shell脚本来运行上述脚本"><a href="#2-写循环数组、可以传参的shell脚本来运行上述脚本" class="headerlink" title="2. 写循环数组、可以传参的shell脚本来运行上述脚本"></a>2. 写循环数组、可以传参的shell脚本来运行上述脚本</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> !/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 此文件命名为run.sh</span></span><br><span class="line">tables=(&quot;a&quot; &quot;b&quot; &quot;c&quot;)</span><br><span class="line">for t in $&#123;tables[@]&#125;    # 循环</span><br><span class="line">do</span><br><span class="line">    sh show.sh $t    # 传参</span><br><span class="line">done</span><br><span class="line"><span class="meta">#</span><span class="bash"> 上述循环还有一种写法</span></span><br><span class="line">for((i=1;i&lt;=$&#123;#tables&#125;;i++));</span><br><span class="line">do</span><br><span class="line">    sh show.sh $&#123;tables[$i]&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h3 id="3-控制并任务的数量"><a href="#3-控制并任务的数量" class="headerlink" title="3. 控制并任务的数量"></a>3. 控制并任务的数量</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while [ `ps -ef |grep show.sh |grep -v grep|wc -l` -gt 2 ]</span><br><span class="line">do...done</span><br></pre></td></tr></table></figure>

<p>其中，<code>ps -ef</code>查询进程的任务数；</p>
<p>​           <code>|</code>管道，前面命令的输出是后面命令的输入；</p>
<p>​           <code>grep bash_file_name</code> 指定进程；</p>
<p>​           <code>grep -v grep</code>去除grep本身；</p>
<p>​           <code>wc -l</code>计算数量。</p>
<p><strong>这个控制并行，当并行任务数大于等于2的时候，执行某一个操作以暂停其他线程的运行。如果让脚本的线程一个一个运行，即不使用&amp;操作，就可以不用（最好别用，容易崩）</strong></p>
<h3 id="4-如果报错，怎么查"><a href="#4-如果报错，怎么查" class="headerlink" title="4. 如果报错，怎么查"></a>4. 如果报错，怎么查</h3><ol>
<li>首先查看进程的ID：<code>ps -ef | grep show.sh </code>；</li>
<li>杀死该进程：将上述得到的<code>sh...</code>的进程ID，即</li>
</ol>
<p><strong>上述需要注意的点：</strong></p>
<ol>
<li>变量的使用需要<code>$</code>；</li>
<li>数组的每个元素之间没有逗号；</li>
<li><code>=</code>两边不能有空格；</li>
<li>最重要的点：一定要仔细检查循环，查看循环本身是不是死循环，还有循环体中调用的脚本要确定是否正确，如果误写了自己，也会导致死循环！！！死循环很可能会导致系统崩盘！！！&lt; 血的教训！！！ &gt;</li>
</ol>
]]></content>
      <categories>
        <category>项目小记</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>sqoop - 使用基础</title>
    <url>/2021/05/31/sqoop-%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="使用sqoop将mysql数据导入hive"><a href="#使用sqoop将mysql数据导入hive" class="headerlink" title="使用sqoop将mysql数据导入hive"></a>使用sqoop将mysql数据导入hive</h2><p>执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqoop import -m 1 \</span><br><span class="line">--connect jdbc:mysql://192.168.186.100:3306/forum \</span><br><span class="line">--username root \</span><br><span class="line">--password niit1234 \</span><br><span class="line">--hive-import \</span><br><span class="line">--create-hive-table \</span><br><span class="line">--hive-database forum \</span><br><span class="line">--delete-target-dir;</span><br></pre></td></tr></table></figure>



<span id="more"></span>



<p>其中：</p>
<blockquote>
<p>–hive-import ：将表导入到hive中，如果不设置，使用hive的默认界定符，即^A or \001；</p>
<p>–create-hive-table ：使用mysql的表名和字段类型直接创建；</p>
<p>–hive-database ：指定将表放到某个数据库；</p>
<p>–connect、–username、–password ：这些不需要说，肯定知道；</p>
<p>–delete-target-dir ：删除指定目录；</p>
</blockquote>
<p>还有一些其他常用的命令：</p>
<blockquote>
<p>–target-dir ：将数据导入指定目录；</p>
<p>–where ：指定条件导入；</p>
<p>–fields-terminated-by ：指定分隔符；</p>
<p>-m ：即–num-mappers，指定map的个数，默认是4个。</p>
</blockquote>
<h4 id="split-by和-m的联系"><a href="#split-by和-m的联系" class="headerlink" title="split-by和-m的联系"></a>split-by和-m的联系</h4><p>sqoop从大多数数据库中并行导入数据。</p>
<p>在执行并行导入的时候，需要一个可用来划分工作负载的标准。</p>
]]></content>
      <categories>
        <category>大数据组件的应用</category>
      </categories>
      <tags>
        <tag>sqoop</tag>
      </tags>
  </entry>
  <entry>
    <title>storm面试题</title>
    <url>/2022/03/03/storm%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>zookeeper面试题</title>
    <url>/2022/03/01/zookeeper%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="Zookeeper-是做什么的（工作机制）"><a href="#Zookeeper-是做什么的（工作机制）" class="headerlink" title="Zookeeper 是做什么的（工作机制）"></a>Zookeeper 是做什么的（工作机制）</h3><p>​        Zookeeper用于为分布式框架提供协调服务。从设计模式的角度看，Zookeeper是一个基于观察者模式设计的分布式服务管理框架，负责存储和管理一些重要的数据，并接受观察者的注册，这样当数据的状态发生变化，Zookeeper就会通知这些观察者数据的状态变化。</p>
<p>​        Zookeeper的特点有：</p>
<ol>
<li>Zookeeper中存在多个服务器，这些服务器包含了一个Leader节点和多个Follower节点，Leader负责读写， Follower负责读，如果Follower接收到写请求，会提交给Leader。</li>
<li>集群中只要有半数以上的节点存活，Zookeeper就可以正常服务，所以适合安装奇数台服务器。</li>
<li>每个服务器中都保存了相同的数据副本，可以保证客户端无论连接哪台服务器，数据都是一致的。</li>
<li>对于客户端的更新请求，会按照发送的顺序依次执行。</li>
<li>数据的更新具有原子性，要么成功，要么失败。</li>
<li>具有实时性，在一定的时间范围内，客户端能读到最新的数据。说是一定时间范围，是因为服务器中的同步操作肯定会有一定的延迟，但是由于Zookeeper中存储的数据量小，只能存储1M的数据，所以同步的时间不会很长。</li>
</ol>
<span id="more"></span>



<h3 id="数据结构（底层存储原理）"><a href="#数据结构（底层存储原理）" class="headerlink" title="数据结构（底层存储原理）"></a>数据结构（底层存储原理）</h3><p>​        Zookeeper的底层结构和Linux文件系统很像，整体可以看成一棵树，每个节点被称作一个znode，默认存储容量是1M，所以不适合存储海量的数据，只能存储一些简单的配置。每个znode都可以通过它的路径被唯一标识。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>​        Zookeeper能提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器动态上下线、分布式锁和软负载均衡等。</p>
<h4 id="统一命名服务"><a href="#统一命名服务" class="headerlink" title="统一命名服务"></a>统一命名服务</h4><p>​        在分布式系统中，经常需要对应用或服务进行统一命名，以便于识别。比如IP地址不容易记住，但是域名可以。比如域名 <a href="http://www.123.com下可能部署多台服务器,客户端不需要知道这些服务器的ip地址,只需要输入对应的域名,zookeeper就可以根据负载情况返回合适的服务器,这样就算其中有服务器挂掉,也不会造成什么影响./">www.123.com下可能部署多台服务器，客户端不需要知道这些服务器的IP地址，只需要输入对应的域名，Zookeeper就可以根据负载情况返回合适的服务器，这样就算其中有服务器挂掉，也不会造成什么影响。</a></p>
<h4 id="统一配置管理"><a href="#统一配置管理" class="headerlink" title="统一配置管理"></a>统一配置管理</h4><p>​        一般要求一个集群中，所有的节点的配置信息必须是一致的，比如kafka集群。当某个节点上的配置信息发生更改，就希望能够快速的同步到其他的所有的节点上。Zookeeper会在一个znode上存储这个配置信息，然后kafka集群中的所有节点监听这个znode，当这个znode上的配置文件发生更改的时候，监听的节点就能马上接收到修改的信息，立刻同步。</p>
<h4 id="统一集群管理"><a href="#统一集群管理" class="headerlink" title="统一集群管理"></a>统一集群管理</h4><p>​        在分布式系统中需要实时掌握每个节点的状态，可以将这些节点的信息写入一个znode中，然后集群可以通过注册和监听这个znode获取实时的状态变化。</p>
<h4 id="服务器动态上下线"><a href="#服务器动态上下线" class="headerlink" title="服务器动态上下线"></a>服务器动态上下线</h4><p>​        为了让客户端能够实时监控服务器上下线的变化，服务器启动后会在Zookeeper上创建一个临时节点，并写入参数，如主机名称和目前已经连接的客户端个数，假设这些服务器都在servers节点下创建子节点存储信息。然后客户端可以监听这个servers节点，当这个节点下某个服务器断开连接，这个临时节点会被自动删除，这个节点的状态发生变化，就会发送给这个客户端这个服务器下线的通知，之后客户端要再次连接服务器就只知道哪些服务器可以连接了。</p>
<h4 id="软负载均衡"><a href="#软负载均衡" class="headerlink" title="软负载均衡"></a>软负载均衡</h4><p>​        比如登录服务，在Zookeeper中记录这个登陆域名下每台服务器的访问数，然后让访问数最少的服务器去处理最新的客户端请求。</p>
<h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p>​        首先简单说明一下分布式锁的概念，假设有多个线程要对一个资源进行操作，为了保证数据的一致性，需要对这个资源上锁。只要取到这个锁的线程才能对资源进行访问，这个线程用完该资源后会释放锁，让其他线程来争取。通过锁机制可以保证在分布式情况下多线程能够有序的访问该资源。我们把分布式环境下的这个锁称为分布式锁。</p>
<p>​        在Zookeeper中实现的思路是：接收到客户端请求后，会在父节点 &#x2F;locks 下创建一个临时的顺序节点，使用顺序节点的目的是，让请求能够按照这个节点的顺序依次次获取锁执行业务；这些临时节点会判断自己当前是不是最小的节点，如果是就获取锁执行业务；否则就监听前一个节点；一个节点获取锁执行完业务被释放后，会通知监听它的节点，让他它去获取锁执行业务。</p>
<h3 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h3><p>​        Zookeeper的选举机制在第一次启动和非第一次启动的情况是不一致的。</p>
<p>​        首先说明选举机制的三个核心原则：</p>
<ol>
<li>Zookeeper集群的服务器数量必须是奇数个，只有超过半数以上的服务器启动，集群才算启动成功；</li>
<li>服务器中myid小的服务器会给myid大的服务器投票，直到选出Leader；</li>
<li>选出Leader之后，之前的服务器状态会从Looking转变为Following，之后的服务器状态也都会自动变为Following。</li>
</ol>
<h4 id="第一次启动的情况"><a href="#第一次启动的情况" class="headerlink" title="第一次启动的情况"></a>第一次启动的情况</h4><ol>
<li>假设有3台服务器，第一台服务器启动，会给自己投一票，此时票数为1，不过半，处于Looking状态；</li>
<li>接着第二台服务器启动，会给自己投一票，由于第二台服务器的myid比第一台的大，第一台服务器将票改投给第二胎，此时票数为2，过半了，第二台服务器的状态修改为Leading，同时第一台服务器状态从Looking转变为Following；</li>
<li>最后第三台服务器启动，由于前两台的状态已经固定，票数不可更改，第三胎服务器的状态自动转变为Following。</li>
</ol>
<h4 id="非第一次启动的情况"><a href="#非第一次启动的情况" class="headerlink" title="非第一次启动的情况"></a>非第一次启动的情况</h4><p>首先需要简单介绍三个概念：</p>
<ol>
<li>zxid：每个写操作都有一个事务id，这个事务id被称为zxid，在某一时刻zxid不一定是一致的，因为只要超过半数的服务器执行成功，就算这个写操作成功了；</li>
<li>sid：是服务器id，用来唯一标识一台服务器，和myid一致；</li>
<li>epoch：每个leader任期时的代号，每投完一次票这个值会增加。</li>
</ol>
<p>​        当一台服务器在运行期间无法和Leader保持连接，会自动认为集群中的Leader已经挂掉了，就会触发选举。进入选举流程时，当前集群可能处于两种状态：</p>
<ol>
<li><p>集群中的Leader没有挂掉，只是这个服务器没有连上。</p>
<p>​        在这个服务器视图去选举Leader的时候，会被告知Leader的信息，然后这个服务器只需要和Leader重新建立连接，并行状态同步即可。</p>
</li>
<li><p>Leader确实挂掉了。</p>
<p>​        还是三台服务器，此时myid&#x3D;2的Leader服务器挂掉了，剩下的服务器，假设SID分别是 1和 3，ZXID分别是 8和7，EPOCH都是 1，会先比较EPOCH值，EPOCH大的直接胜出；如果相等，ZXID大的胜出；如果还相等，SID大的胜出。</p>
</li>
</ol>
<h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><p>有四种：</p>
<ol>
<li>持久节点：除非Zookeeper手动删除，否则就算客户端和服务器断开也不会被删掉。</li>
<li>持久顺序节点：和持久节点的特性一样，只是给节点名称结尾增加了自增序号，这个序号由父节点维护。</li>
<li>临时节点：当客户端和服务器断开连接，这个客户端创建的节点会被自动删除。</li>
<li>临时顺序节点：和临时节点具有相同的特性，只是节点名后面会跟一个父节点维护的自增序号。</li>
</ol>
<p><strong>带序号和不带序号的区别：创建同名节点时，带序号创建不报错，不带序号创建回报已经存在节点的错。</strong></p>
<p><strong>序号的作用：可以为所有事件做全局排序，方便客户端梳理事件的顺序。</strong></p>
<p>持久节点的创建：create &#x2F;abc “abc”</p>
<p>持久顺序节点的创建：create -s &#x2F;bcd “bcd”</p>
<p>临时节点的创建：create -e &#x2F;cdf “cdf”</p>
<h3 id="监听器原理"><a href="#监听器原理" class="headerlink" title="监听器原理"></a>监听器原理</h3><ol>
<li>首先在客户端创建一个main方法；</li>
<li>然后在这个main方法中会创建一个zkClient，这个client会创建两个线程，一个用于连接对应的服务端，一个负责监听连接的服务器中数据的变化；</li>
<li>其中，连接服务端的线程在连上后，会告诉服务端要监听哪些信息，当这些信息发生变化，就会回调给监听的线程，监听线程内部会调用 process 方法进行后续的处理。</li>
</ol>
<p>常见的监听内容包括：</p>
<ol>
<li>监听节点数据的变化。</li>
<li>监听子节点增删的变化。</li>
</ol>
<p>监听的实现是注册一次监听一次，回调一次更新的变化后，想要再次监听，需要再次注册。</p>
<h3 id="写数据流程"><a href="#写数据流程" class="headerlink" title="写数据流程"></a>写数据流程</h3><p>请求发送的目标有两种：发给Leader和发给Follower。</p>
<h4 id="发给Leader"><a href="#发给Leader" class="headerlink" title="发给Leader"></a>发给Leader</h4><p>​        假设有三台服务器，Leader执行写请求，写完后将请求发送给其中一个Follower执行，这个Follower执行成功后会返回给Leader一个ack码，此时已经有超过半数的服务器完成了请求的操作，就被认为是执行成功了，Leader返回给客户端成功的ack码。之后再将请求发送到另一台服务器执行写操作，这台服务器执行成功后也会返回给Leader执行成功。</p>
<p>​        因为不需要等到全部同步成功才返回结果，所以效率很高。</p>
<h4 id="发给Follower"><a href="#发给Follower" class="headerlink" title="发给Follower"></a>发给Follower</h4><p>​        也是假设三台服务器，Follower接收到写请求，会将请求传给Leader，然后Leader执行完后将请求发送给Follower，Follower执行完后返回ack给Leader，此时超过半数执行完成，Leader会将ack码发送给接收客户端请求的Follower，由这个Follower将ack码发回给客户端。之后Leader再将请求传递给其他Follower执行。</p>
<h3 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a>数据一致性问题</h3><h4 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h4><p>​        这个军队需要全体将军一致决定是否攻击某个敌军，但是这些将军在地理上是分开的，并且军中存在叛徒，如果这些叛徒从中作梗，促成了一个并不是所有将军都同意的决定，这个行动就会失败。</p>
<h4 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h4><p>​        Paxos算法是一种基于消息传递机制且具有高度容错特性的一致性算法，这个算法会保证集群中不管出现什么意外，所有节点的数据都是一致的。</p>
<p>​        这个算法将节点分为三种类型：提议者、接受者和学习者，每个节点都可以身兼数职。提议者是提出决议的人，接收者是参与投票的人，学习者弃权，只负责执行通过的决策。</p>
<p>​        具体的算法流程通过一个例子简单说明。假设有五个节点 A1、A2、A3、A4、A5，需要A2~A5通过A1提出的税率降低10%的提议。</p>
<ol>
<li>A1会生成全局唯一且递增的ID号，并发送给A2~A5，此时发送的信息只包含一个ID号；</li>
<li>然后A2~A5都会返回给A1同意接受的应答；</li>
<li>A1收到两份回复时再次发出请求，此时带上了税率降低10%的提议内容和ID号；</li>
<li>A2~A5返回同意的应答；</li>
<li>超过半数接受，提议通过。</li>
</ol>
<p>这是只有一个提议者的场景，如果有两个提议者，比如A1提议税率降低10%，A5提议降低15%。</p>
<ol>
<li>A1和A5同时发决议，ID号分别是1和2；</li>
<li>此时A2同意了A1，A4同意了A5，A3成为关键；</li>
</ol>
<p>接下来出现两种情况：</p>
<p>第一种：</p>
<ol>
<li>如果A3先接收到A1的请求，会答应A1；</li>
<li>这个时候A1收到半数以上的应答，开始发送实际的请求，A2和A3接受；</li>
<li>之后A3又接收到A5的第一次请求，因为A5的ID号比A1的大，所以也接受了A5的请求；</li>
<li>然后A5发出实际请求，A3、A4接受。</li>
<li>最后A1、A5同时广播决议。</li>
</ol>
<p>第二种：</p>
<ol>
<li>A3接受了A1的第一次请求后，A1的实际请求还没发出，又接收到A5的第一次请求，因为A5的ID号比A1的大，所以也接受了A5的请求；</li>
<li>接着A1发送实际的请求，但是没有足够的响应，就会重新发起只带ID号的请求，此时ID自增为3；这个时候A1的ID号比A5的大了，A3又接受来自A1的请求；</li>
<li>那么A5又会由于接收不到足够的回应而开始下一次的新请求，最终A1和A5就会陷入死循环。</li>
</ol>
<p>​        造成这种问题的原因是系统中存在一个以上的提议者互相争夺接受者而无法达成一致的决策。针对这种情况，提出了ZAB协议：也就是从系统中选出一个节点作为Leader，只有Leader才能发起决议。</p>
<h4 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h4><p>​        ZAB协议是特别为Zookeeper设计的支持崩溃恢复的原子广播协议，基于这种协议，Zookeeper设计为只有一个Leader负责处理写请求，然后由Leader将数据同步到其他的Follower节点。也就是只有Leader能发起决议。</p>
<p>​        ZAB有两种模式：消息广播和崩溃恢复。</p>
<p><strong>消息广播的流程：</strong></p>
<ol>
<li>客户端向Leader发送一个写数据的请求；</li>
<li>Leader会将这个请求转换为一个事务提案，并同时为这个提案提供全局ID，也就是zxid；</li>
<li>Leader会向每个Follower分配一个单独的FIFO队列，然后将需要广播的请求放到队列中；</li>
<li>Follower会根据这个队列的顺序先将请求以事务日志的方式写入本地磁盘，写成功后向Leader返回ack响应；</li>
<li>一旦Leader接收到半数以上的应答信息，就认为发送成功，开始广播commit信息，同时自身也完成事务的提交；Follower接收到commit信息后，也开始提交事务。</li>
</ol>
<p>这个过程可能会出现两个一致性问题：</p>
<ol>
<li>Leader发送提案后就宕机了，导致Follower接收不到；</li>
<li>Leader接收到半数应答后宕机了，来不及发送commit。</li>
</ol>
<p>这就引入了崩溃恢复模式。</p>
<p>这个模式要求满足两个条件：对于Leader已经发出的提案，Follower必须执行；必须丢弃Leader还没有发出的提案。</p>
<p>这个模式主要包括两个部分：Leader选举和数据恢复。</p>
<p>对于Leader选举，ZAB协议需要保证新选的Leader满足两个条件：</p>
<ol>
<li>新Leader不能包含未提交的事务；</li>
<li>新Leader必须含有最新的zxid。</li>
</ol>
<p>这样是为了保证新Leader不会丢弃掉一些工作。</p>
<p>数据同步的步骤是：</p>
<ol>
<li>选出新Leader后，需要先将之前未完成的事务完成；</li>
<li>等到Follower将所有事务提交完毕，新Leader才会认为这个Follower是合法可用的，否则不会把这个Follower放到可用列表中继续使用。</li>
</ol>
<h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><p>即一致性、可用性和分区容错性。</p>
<ol>
<li>一致性：保证所有节点在同一时间数据是一致的；</li>
<li>可用性：保证每个请求不管成功还是失败，在一定时间内都能返回响应；</li>
<li>分区容错性：保证系统中任意信息的丢失或失败都不会影响系统的正常运行。</li>
</ol>
<p>三个条件最多只能同时满足两个，因为分布式系统必须要满足分区容错性，所以一般都是在一致性和可用性上做选择。</p>
<p>Zookeeper保证的是一致性和分区容错。这就在一些极端情况下，可能会丢弃一些请求，消费者程序需要重新提交才能获得结果。并且在进行Leader选举时，集群不可用，因为此时没有Leader来发布请求。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找算法&amp;插值查找算法</title>
    <url>/2021/07/07/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="使用模型"><a href="#使用模型" class="headerlink" title="使用模型"></a>使用模型</h2><span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> ( left &lt;= right )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( nums[mid] == target )</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( nums[mid] &lt; target )</span><br><span class="line">    &#123;</span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分查找算法简单又快速，对数组要求元素有序，且数组是顺序存储。</p>
<p>时间复杂度是O(logn)，空间复杂度是O(1)。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://www.nowcoder.com/practice/4f470d1d3b734f8aaf2afb014185b395?tpId=188&amp;&amp;tqId=38588&amp;rp=1&amp;ru=/ta/job-code-high-week&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/4f470d1d3b734f8aaf2afb014185b395?tpId=188&amp;&amp;tqId=38588&amp;rp=1&amp;ru=/ta/job-code-high-week&amp;qru=/ta/job-code-high-week/question-ranking</a></p>
<h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果目标值存在返回下标，否则返回 -1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span> <span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span>( left &lt;= right )</span><br><span class="line">        &#123;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>( nums[mid] &gt; target )</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( nums[mid] &lt; target )</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>( mid != <span class="number">0</span> &amp;&amp; nums[mid] == nums[mid-<span class="number">1</span>] )</span><br><span class="line">                &#123;</span><br><span class="line">                    -- mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 如果目标值存在返回下标，否则返回 -1</span></span><br><span class="line"><span class="comment"># @param nums int整型一维数组 </span></span><br><span class="line"><span class="comment"># @param target int整型 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self , nums , target </span>):</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        mid = (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right :</span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">while</span> mid &gt; <span class="number">0</span> <span class="keyword">and</span> nums[mid] == nums[mid - <span class="number">1</span>]:</span><br><span class="line">                    mid -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>



<h2 id="二分查找的改进-插值查找"><a href="#二分查找的改进-插值查找" class="headerlink" title="二分查找的改进 - 插值查找"></a>二分查找的改进 - 插值查找</h2><p>插值查找和二分查找的区别在于<code>mid</code>值的选择。</p>
<p>二分查找：<code>mid = left + 1 / 2 * (right - left)</code>；</p>
<p>插值查找：<code>mid = left + (target - nums[left])/(nums[right] - nums[left]) * (right - left)</code></p>
<p>上述公式中，<code>mid</code>的根本区别是<code>(right - left)</code>的左边的数据：</p>
<p>二分查找是简单是获取居中的部分；插值查找是获取目标值与最小值之差在最值之差中的比重，可以更准确的定位范围，称这种方式为自适应。</p>
<p>还是以上述题目为例：</p>
<p>Java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果目标值存在返回下标，否则返回 -1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums int整型一维数组 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target int整型 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span> <span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( len == <span class="number">0</span> || nums[left] &gt; target || nums[right] &lt; target )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( nums[<span class="number">0</span>] == target )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>( left &lt;= right )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (target - nums[left]) / (nums[right] - nums[left]) * (right - left);</span><br><span class="line">            <span class="keyword">if</span>( nums[mid] &gt; target )</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( nums[mid] &lt; target )</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>( mid != <span class="number">0</span> &amp;&amp; nums[mid] == nums[mid-<span class="number">1</span>] )</span><br><span class="line">                &#123;</span><br><span class="line">                    -- mid;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>python：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 如果目标值存在返回下标，否则返回 -1</span></span><br><span class="line"><span class="comment"># @param nums int整型一维数组 </span></span><br><span class="line"><span class="comment"># @param target int整型 </span></span><br><span class="line"><span class="comment"># @return int整型</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self , nums , target </span>):</span></span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> right &lt;= <span class="number">0</span> <span class="keyword">or</span> nums[<span class="number">0</span>] &gt; target <span class="keyword">or</span> nums[right] &lt; target:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[<span class="number">0</span>] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = left + (target - nums[left]) // (nums[right] - nums[left]) * (right - left);</span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">while</span> mid &gt; <span class="number">0</span> <span class="keyword">and</span> nums[mid] == nums[mid - <span class="number">1</span>]:</span><br><span class="line">                    mid -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>插值查找</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划算法</title>
    <url>/2021/06/16/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义：是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。</p>
<p>​        按照定义，动态规划是将一个大问题拆分为多个小问题来解决。但是最终决定这个问题是否能用动态规划解决的因素是这些小问题是否能被重复调用。</p>
<p>​        如果能被重复利用，我们需要找出其中的状态转移方程，也就是找到相邻的两个结果之间的转换方程。</p>
<span id="more"></span>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="题目见下链接"><a href="#题目见下链接" class="headerlink" title="题目见下链接"></a>题目见下链接</h3><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a></p>
<h3 id="动态规划思想"><a href="#动态规划思想" class="headerlink" title="动态规划思想"></a>动态规划思想</h3><p>因为要求是连续数组的最大值，所以每一次计算的中间结果，也必须是以当前最后一个元素为当亲计算的结尾。</p>
<p>上述，可以得到状态转移方程：</p>
<p><code>maxn = max(maxn+num[i], num[i])</code></p>
<p>但是由于以当前最后一个元素结尾的最大值不一定是整体数组中的最大值，所以需要再使用一个变量来存储整体数组的最大值：</p>
<p><code>res = max(maxn, res)</code></p>
<p>经过分析，可以得到具体代码如下：</p>
<h4 id="java"><a href="#java" class="headerlink" title="java:"></a>java:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maxSubArray(int[] nums) &#123;</span><br><span class="line">        int pre = 0, res = nums[0];</span><br><span class="line">        for ( int n : nums )</span><br><span class="line">        &#123;</span><br><span class="line">            pre = Math.max(pre + n, n);</span><br><span class="line">            res = Math.max(pre, res);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="python"><a href="#python" class="headerlink" title="python:"></a>python:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def maxSubArray(self, nums: List[int]) -&gt; int:</span><br><span class="line">        pre, res = 0, nums[0]</span><br><span class="line">        for n in nums:</span><br><span class="line">            pre = max( pre + n, n )</span><br><span class="line">            res = max( pre, res )</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针</title>
    <url>/2021/10/20/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="双指针介绍"><a href="#双指针介绍" class="headerlink" title="双指针介绍"></a>双指针介绍</h2><p><strong>双指针</strong>，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（<em>快慢指针</em>）或者相反方向（<em>对撞指针</em>）的指针进行扫描，从而达到相应的目的。</p>
<span id="more"></span>



<h3 id="对撞指针"><a href="#对撞指针" class="headerlink" title="对撞指针"></a>对撞指针</h3><p>设计 <code>left</code> 和 <code>right</code> 两个指针，从两头开始向中间开始遍历，比如 <strong>快速排序</strong> ，使用到了对撞指针。</p>
<p>简易代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>( left &lt; right )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( nums[left] &lt;= nums[right] )</span><br><span class="line">    &#123;</span><br><span class="line">        left ++;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        right --;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>设计 <code>fast</code> 和 <code>slow</code> 两个指针，从同一侧开始遍历，二者以不同策略移动，通常来说，慢指针一次走一步，快指针一次走多步。</p>
<p>经典问题为：是否存在环问题。</p>
<p>思路为：在慢指针遍历完之前，如果与快指针相遇，存在环，否则不存在。</p>
<p>具体代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( head == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">if</span>( fast.next != <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( slow != <span class="keyword">null</span> &amp;&amp; fast != slow )</span><br><span class="line">        &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span>( fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( slow == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://zhuanlan.zhihu.com/p/71643340">算法一招鲜——双指针问题</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表</title>
    <url>/2021/10/14/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode-cn.com/problems/contains-duplicate/">https://leetcode-cn.com/problems/contains-duplicate/</a></p>
<span id="more"></span>



<h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><h3 id="第一思路"><a href="#第一思路" class="headerlink" title="第一思路"></a>第一思路</h3><p>​        本人的第一思路是使用 <code>arraylist</code> 存放遍历过的元素，如果当前元素在 <code>arraylist</code> 已经存在，返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p><strong>问题：</strong>当数组元素的个数大到一定程度，会超出时间限制。</p>
<p><strong>解决：</strong>使用 <code>hashset</code> 存储。</p>
<h4 id="ArrayList-和-HashSet-的区别"><a href="#ArrayList-和-HashSet-的区别" class="headerlink" title="ArrayList 和 HashSet 的区别"></a>ArrayList 和 HashSet 的区别</h4><p>实际上就是 <code>List</code> 和 <code>Set</code> 两种接口的区别，二者都继承 <code>Collection</code> 接口。</p>
<p>区别在于：</p>
<ol>
<li>ArrayList用于定义一个有序的可重复集合，HashSet用于定义一个无序的不可重复集合；</li>
<li>ArrayList底层用数组存储，所以如果查找某个元素，会从第一个元素开始顺序查找；HashSet底层由数组+链表的形式存储，先根据元素的 <code>hashcode</code> 值确定数组中的位置，再从该位置的链表从头开始遍历查找元素；所以，HashSet 的查询效率比 ArrayList 高。</li>
</ol>
<p><strong>HashSet存储数据的具体流程如下：</strong></p>
<p> 1.获取关键数据—通过元素的hashCode方法的返回值来获取；<br> 2.通过hash函数计算该数据需要存放在hash表哪个位置；<br> 3.如果没有发生hash碰撞   则放在该位置；<br> 4.如果发生了hash碰撞   形成hash桶（链表）；<br>         形成链表时会触发去重的机制  新来的元素要和链表中的每一个元素进行equals  如果不重复则插在链表末尾（JDK1.8）， 而JDK1.7则会插入在链表的最前面。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> n : nums )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( !set.add(n) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第二思路"><a href="#第二思路" class="headerlink" title="第二思路"></a>第二思路</h3><p>先对数组中的元素进行排序，再遍历数组，如果 <code>nums[i] == nums[i+1]</code>，则存在重复元素。</p>
<p>此处的排序很有讲究，得使用语言自带的排序函数才能通过。</p>
<p><strong>原因：</strong> 例如Java中自带的排序函数 <code>Arrays.sort()</code> 用到了三个排序算法：插入排序、快速排序、归并排序。</p>
<p>以数组元素的个数为划分的依据，小于 47 插入，大于等于 47 小于 286 快排，大于等于286 - 高度结构化用归并、非高度结构化用快排。</p>
<p>具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        devide(nums, <span class="number">0</span>, len - <span class="number">1</span>, tmp);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i] == nums[i+<span class="number">1</span>] )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">devide</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span>[] tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>( l &gt;= r )</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">          devide(nums, l, mid, tmp);</span><br><span class="line">          devide(nums, mid+<span class="number">1</span>, r, tmp);</span><br><span class="line">          merge(nums, l, r, mid, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> mid, <span class="keyword">int</span>[] tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( mid &gt;= r + <span class="number">1</span> || mid &lt; <span class="number">0</span> || l &gt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( i &lt;= mid &amp;&amp; j &lt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i] &lt;= nums[j] )</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[t++] = nums[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmp[t++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( i &lt;= mid )</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[t++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( j &lt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[t++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        i = l;</span><br><span class="line">        <span class="keyword">while</span>( l &lt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            nums[l++] = tmp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希表是根据关键键值进行直接访问的数据结构，查询速度非常快，时间复杂度几乎是 O(1) 。如果需要在一秒钟内查找上千条数据，通常就会使用哈希表。</p>
<p>获取键的哈希值：<code>hash(键)%k</code> 。但是这种方法可能会产生 <strong>哈希冲突</strong> 。实际中这种冲突不可避免，只能设法减少。</p>
<h4 id="生成哈希函数的方法"><a href="#生成哈希函数的方法" class="headerlink" title="生成哈希函数的方法"></a>生成哈希函数的方法</h4><ol>
<li><p>直接定址法</p>
<p>以键的线性函数作为哈希地址：hash(k) &#x3D; a * k + b(其中a,b为常数)&#96; 。</p>
<p>这种方法不会产生哈希冲突，但是要求键是连续的，否则产生的哈希表会造成较大的空间浪费，因此，该方法适应性不强。</p>
</li>
<li><p>数字分析法</p>
<p>如果键是位数比较多的数字，比如手机号有11位，且这些数字存在相同的规律，则可以抽取剩余规律不同的部分作为散列地址。</p>
<p>比如手机号的后四位是用户号，前7位很有可能是相同的，那么可以使用后四位作为散列地址。</p>
<p>如果事先知道关键字的<strong>分布</strong>且关键字的<strong>若干位分布较均匀</strong>，就可以考虑用这个方法。</p>
</li>
<li><p>折叠法</p>
<p>将键值从左到右分成几个部分，然后将几个部分叠加求和，并按散列表表长，取后几位作为散列地址。</p>
<p>比如 key &#x3D; 9876543210，散列表表长 &#x3D; 3，那么可以分为 987|654|321|0 ，叠加求和：987+654+321+0&#x3D;1962，再取后 3 位得到散列地址即为 962。</p>
<p>上述方式还不够分布均匀，可以尝试从一端到另一端折叠对齐相加。</p>
<p>还是上述例子，将 987 和 321 反转，叠加求和为：789+654+123+0&#x3D;1566，得到散列地址为 566。</p>
<p>折叠法事<strong>先不需要知道关键字的分布</strong>，<strong>适合</strong>关键字位数较多的情况。</p>
</li>
<li><p>平方取中法</p>
<p>取 键 的平方的中位数作为散列地址。</p>
<p>比如 key &#x3D; 4321，那么平方 &#x3D; 18671041，抽取中间的 3 位就可以是 671，也可以是 710，用做散列地址。</p>
<p>此方法适合不知道键值分布，而位数又不是很大的情况。</p>
</li>
<li><p>除留余数法</p>
<p>是最常用的构造散列函数的方法。</p>
<p>公式为：<code>hash(key) = key % k</code></p>
<p>该方法的关键在于合适的 <code>k</code> 值。根据前人的经验，若表长为 <code>m</code> ，通常 <code>k</code> 为小于等于表长（最好接近 <code>m</code>）的最小质数或不包含小于20的质因子的合数。</p>
</li>
<li><p>随机数法</p>
<p>取 键值 的随机函数值为它的散列地址：<code>hash(key) = random(key)</code></p>
<p>当键值的长度不等时，采用该方法是最合适的。</p>
</li>
</ol>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://blog.csdn.net/liu17234050/article/details/104270709/">数据结构—— 构造散列函数的六种方法</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序算法</title>
    <url>/2021/07/13/%E5%A0%86%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>简单来说就是完全二叉树，大顶堆的每个父节点会大于等于它的子节点；小顶堆的每个父节点会小于等于它的子节点。</p>
<span id="more"></span>



<h2 id="思路拆解"><a href="#思路拆解" class="headerlink" title="思路拆解"></a>思路拆解</h2><p>一般情况下，堆排序是针对数组的排序（应该吧。。。）：</p>
<ol>
<li><p>首先会将可能无序的数组初始化为一个堆，即构建堆；</p>
</li>
<li><p>对于堆的构建，是从数组的末尾、即最后一个父节点开始循环进行构建 - 也就是把三个节点中值最小的换到父节点；</p>
</li>
<li><p>但是这里有一个小问题 - 这样的构建方式相当于是在上一次构建完成的基础上进行构建，那么很有可能会破坏之前构建的结果；</p>
</li>
<li><p>针对这个问题，需要写一个函数对这样的部分堆进行从上往下的调整；</p>
</li>
<li><p>之后，初步构造的堆就完成了；</p>
</li>
<li><p>之后的升序或降序排序，只要将头尾的元素互换，数组的最后一个元素就是当前数组中最小的元素，然后将该元素去除（简单一点就是len-1），对剩余的前<code>n-1</code>个元素从头进行由上往下的调整，再将第一个元素和当前数组的最后一个元素交换，就可以得到第二小的元素，以此类推。</p>
</li>
</ol>
<p>下面以小顶堆为例说明上述思路。</p>
<h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><ol>
<li><p>先写一个会经常使用的元素交换函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = input[a];</span><br><span class="line">    input[a] = input[b];</span><br><span class="line">    input[b] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建小顶堆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initHeap</span><span class="params">(<span class="keyword">int</span>[] input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( input.length &lt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = input.length;</span><br><span class="line">    <span class="keyword">int</span> f = len / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(f &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = f * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        heapSort(input, i, len);</span><br><span class="line">        -- f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）<code>f = len / 2 - 1</code>：</p>
<p>默认元素从0开始取最后一个元素的父节点，如果从1开始就是<code>f = len / 2</code>；</p>
<p>（2）<code>i = f * 2 + 1</code>：</p>
<p>从0开始的父节点，子节点为<code>left = f * 2 + 1; right = f * 2 + 2</code>，从1开始的父节点，子节点为<code>left = f * 2; right = f * 2+ 1;</code> ；</p>
<p>（3）两个 <code>if</code> 语句：</p>
<p>先获取两个子节点中值最小的节点；然后判断父节点与最小子节点的大小，如果父节点比最小子节点大，则交换元素；</p>
<p>（4）<code>heapSort(input, i, len);</code></p>
<p>进行部分堆的调整。</p>
</li>
<li><p>排序（小顶堆就是逆序了）</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> f, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 重新调整为小顶堆</span></span><br><span class="line">    <span class="keyword">while</span>( f &lt; len )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = f * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>( i + <span class="number">1</span> &lt; len &amp;&amp; input[i] &gt; input[i + <span class="number">1</span>] )</span><br><span class="line">        &#123;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( i &lt; len &amp;&amp; input[f] &gt; input[i] )</span><br><span class="line">        &#123;</span><br><span class="line">            swap(input, i, f);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title>建立第一个独立博客</title>
    <url>/2021/05/30/%E5%BB%BA%E7%AB%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%8B%AC%E7%AB%8B%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>前人栽树，后人乘凉~</p>
<p>具体见<a href="https://zhuanlan.zhihu.com/p/102592286?tdsourcetag=s_pctim_aiomsg">https://zhuanlan.zhihu.com/p/102592286?tdsourcetag=s_pctim_aiomsg</a></p>
<span id="more"></span>



<p>此处记录日常生成并上传文件的方式。</p>
<h3 id="生成文件"><a href="#生成文件" class="headerlink" title="生成文件"></a>生成文件</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new &quot;文章标题&quot;</span><br></pre></td></tr></table></figure>

<p>文章标题可以不用双引号括住。</p>
<h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>学习笔记 - 《深度学习入门：基于 Python 的理论与实现》</title>
    <url>/2022/01/12/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E3%80%8A%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8%EF%BC%9A%E5%9F%BA%E4%BA%8E-Python-%E7%9A%84%E7%90%86%E8%AE%BA%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B/</url>
    <content><![CDATA[<h2 id="注明"><a href="#注明" class="headerlink" title="注明"></a>注明</h2><p>使用环境：<strong>Python3.x</strong></p>
<p>使用外部库：<strong>Numpy</strong>用于数值计算，提供许多高级数学算法和遍历的矩阵操作方法、<strong>Matplotlib</strong>用于画图。</p>
<span id="more"></span>



<h2 id="Python入门"><a href="#Python入门" class="headerlink" title="Python入门"></a>Python入门</h2><h3 id="python解释器（基本的使用）"><a href="#python解释器（基本的使用）" class="headerlink" title="python解释器（基本的使用）"></a>python解释器（基本的使用）</h3><h4 id="版本查询"><a href="#版本查询" class="headerlink" title="版本查询"></a>版本查询</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;python --version</span><br></pre></td></tr></table></figure>

<p>进入 python 命令行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;python</span><br></pre></td></tr></table></figure>

<h4 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h4><ol>
<li><p>加（+）减（-）乘（*）与Java一致；</p>
</li>
<li><p><strong>除</strong>有两种情况：<code>/</code> 结果是小数，<code>//</code> 结果是整数；</p>
</li>
<li><p>** 乘方。</p>
</li>
</ol>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>使用 <code>type()</code> 获取。</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>直接赋值。如 <code>x = 10</code> 即可。</p>
<p>变量的类型是根据赋值情况自动决定的，赋值的是计算结果，也会自动转换为更大的一边。</p>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>使用 <code>#</code> 后的内容会被注释。</p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>如 <code>arr = [1,2,3,4]</code></p>
<p>提供切片的方式访问某个值或某个子列表。如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;arr[<span class="number">0</span>] <span class="comment"># == 1</span></span><br><span class="line">&gt;&gt;&gt;arr[<span class="number">1</span>:] <span class="comment"># == [2,3,4]</span></span><br><span class="line">&gt;&gt;&gt;arr[<span class="number">1</span>:<span class="number">3</span>] <span class="comment"># == [2,3]</span></span><br><span class="line">&gt;&gt;&gt;arr[:<span class="number">3</span>] <span class="comment"># == [1,2,3]</span></span><br><span class="line">&gt;&gt;&gt;arr[:-<span class="number">1</span>] <span class="comment"># 从第一个元素到最后一个元素，不包括最后一个元素，即 [1,2,3]</span></span><br><span class="line">&gt;&gt;&gt;arr[:-<span class="number">2</span>] <span class="comment"># 从第一个元素到倒数第二个元素，不包括最后两个元素，即[1,2]</span></span><br></pre></td></tr></table></figure>

<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>me = &#123;<span class="string">&#x27;height&#x27;</span>:<span class="number">180</span>&#125; <span class="comment"># 生成字典 </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>me[<span class="string">&#x27;height&#x27;</span>]        <span class="comment"># 访问元素 180 </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>me[<span class="string">&#x27;weight&#x27;</span>] = <span class="number">70</span>   <span class="comment"># 添加新元素 </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(me) &#123;<span class="string">&#x27;height&#x27;</span>: <span class="number">180</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">70</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h4><p>取 <code>True</code> 或 <code>False</code>，针对的运算符有：<code>and</code> 、<code>or</code> 、<code>not</code> 。</p>
<h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h4><p>参考以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> hungry:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;赶紧去吃饭&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> sleepy:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;赶紧去睡觉&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;那就再运动一会&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h4><p>参考一下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]:</span><br><span class="line">	<span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># 1 2 3 4</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># 0 1 2 3</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># 1 2 3</span></span><br></pre></td></tr></table></figure>

<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">hello</span>():</span> </span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>) ... </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hello() </span><br><span class="line">Hello World!</span><br><span class="line"><span class="comment"># 此外，函数可以取参数。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params"><span class="built_in">object</span></span>):</span> </span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span>(<span class="string">&quot;Hello &quot;</span> + <span class="built_in">object</span> + <span class="string">&quot;!&quot;</span>) ... </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hello(<span class="string">&quot;cat&quot;</span>) </span><br><span class="line">Hello cat!</span><br></pre></td></tr></table></figure>



<h3 id="python脚本文件"><a href="#python脚本文件" class="headerlink" title="python脚本文件"></a>python脚本文件</h3><h4 id="保存为文件的步骤"><a href="#保存为文件的步骤" class="headerlink" title="保存为文件的步骤"></a>保存为文件的步骤</h4><ol>
<li><p>新建一个名为 <code>hungry.py</code> 的文件，内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;I am hungry!&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python hungry.py</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>模板：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, 参数, …</span>):</span> <span class="comment"># 构造函数</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> 方法名1(<span class="params">self, 参数, …</span>):</span> <span class="comment"># 方法1</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> 方法名2(<span class="params">self, 参数, …</span>):</span> <span class="comment"># 方法2</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<p>其中， <code>__init__</code> 进行初始化的方法，也称为构造 函数（constructor），只在生成类的实例时被调用一次。</p>
<p>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Initialized!&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello &quot;</span> + self.name + <span class="string">&quot;!&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">goodbye</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Good-bye &quot;</span> + self.name + <span class="string">&quot;!&quot;</span>)</span><br><span class="line">m = Man(<span class="string">&quot;David&quot;</span>)</span><br><span class="line">m.hello()</span><br><span class="line">m.goodbye()</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python man.py</span><br><span class="line">Initialized!</span><br><span class="line">Hello David!</span><br><span class="line">Good-bye David!</span><br></pre></td></tr></table></figure>



<h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>

<h4 id="Numpy数组"><a href="#Numpy数组" class="headerlink" title="Numpy数组"></a>Numpy数组</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.array([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(x)</span><br><span class="line">[ <span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(x)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">numpy</span>.<span class="title">ndarray</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="一维数组算术运算"><a href="#一维数组算术运算" class="headerlink" title="一维数组算术运算"></a>一维数组算术运算</h4><p>两个数组进行算术运算要求元素个数必须相同，否则会报错。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 准备两个数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.array([<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = np.array([<span class="number">2.0</span>, <span class="number">4.0</span>, <span class="number">6.0</span>])</span><br><span class="line"><span class="comment"># 相加</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x + y </span><br><span class="line">array([ <span class="number">3.</span>,  <span class="number">6.</span>, <span class="number">9.</span>]) </span><br><span class="line"><span class="comment"># 相减</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x - y</span><br><span class="line">array([ -<span class="number">1.</span>,  -<span class="number">2.</span>, -<span class="number">3.</span>])</span><br><span class="line"><span class="comment"># 相乘</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x * y </span><br><span class="line">array([  <span class="number">2.</span>,   <span class="number">8.</span>,  <span class="number">18.</span>])</span><br><span class="line"><span class="comment"># 相除</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x / y</span><br><span class="line">array([ <span class="number">0.5</span>,  <span class="number">0.5</span>,  <span class="number">0.5</span>])</span><br><span class="line"><span class="comment"># 和单一数值计算，也叫广播</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x / <span class="number">2.0</span></span><br><span class="line">array([ <span class="number">0.5</span>,  <span class="number">1.</span> ,  <span class="number">1.5</span>])</span><br></pre></td></tr></table></figure>

<h4 id="多维数组算术运算"><a href="#多维数组算术运算" class="headerlink" title="多维数组算术运算"></a>多维数组算术运算</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(A)</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span>] [<span class="number">3</span> <span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.shape</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.dtype</span><br><span class="line">dtype(<span class="string">&#x27;int64&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B = np.array([[<span class="number">3</span>, <span class="number">0</span>],[<span class="number">0</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A + B</span><br><span class="line">array([[ <span class="number">4</span>,  <span class="number">2</span>],</span><br><span class="line">	  [ <span class="number">3</span>, <span class="number">10</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A * B</span><br><span class="line">array([[ <span class="number">3</span>,  <span class="number">0</span>],</span><br><span class="line">       [ <span class="number">0</span>, <span class="number">24</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A * <span class="number">10</span></span><br><span class="line">array([[ <span class="number">10</span>, <span class="number">20</span>], </span><br><span class="line">       [ <span class="number">30</span>, <span class="number">40</span>]])</span><br></pre></td></tr></table></figure>

<p><code>shape</code> 查看行列数，<code>dtype</code> 查看数据类型。</p>
<h4 id="不同行列数的数组计算"><a href="#不同行列数的数组计算" class="headerlink" title="不同行列数的数组计算"></a>不同行列数的数组计算</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B = np.array([<span class="number">10</span>, <span class="number">20</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A * B</span><br><span class="line">array([[ <span class="number">10</span>, <span class="number">40</span>],</span><br><span class="line">       [ <span class="number">30</span>, <span class="number">80</span>]])</span><br></pre></td></tr></table></figure>

<p>上述例子，会将 <code>[10, 20]</code> 扩展成 <code>[[10,20],[10,20]]</code>，这种扩展功能叫广播。</p>
<h4 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h4><p>以下面数组为例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = np.array([[<span class="number">51</span>, <span class="number">55</span>], [<span class="number">14</span>, <span class="number">19</span>], [<span class="number">0</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(X)</span><br><span class="line">[[<span class="number">51</span> <span class="number">55</span>]</span><br><span class="line"> [<span class="number">14</span> <span class="number">19</span>]</span><br><span class="line"> [ <span class="number">0</span>  <span class="number">4</span>]]</span><br><span class="line"><span class="comment"># 正常使用，获取(0, 1) 的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"><span class="number">55</span></span><br></pre></td></tr></table></figure>

<p>获取第0行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X[<span class="number">0</span>]    <span class="comment"># 第0行 </span></span><br><span class="line">array([<span class="number">51</span>, <span class="number">55</span>])</span><br><span class="line"><span class="comment"># 循环所有行</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> X:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(row)</span><br><span class="line">...</span><br><span class="line">[<span class="number">51</span> <span class="number">55</span>]</span><br><span class="line">[<span class="number">14</span> <span class="number">19</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>将多维数组转换为一维数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = X.flatten() <span class="comment"># 将X转换为一维数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(X)</span><br><span class="line">[<span class="number">51</span> <span class="number">55</span> <span class="number">14</span> <span class="number">19</span>  <span class="number">0</span>  <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>过滤获取元素：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X &gt; <span class="number">15</span> </span><br><span class="line">array([ <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>], dtype=<span class="built_in">bool</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X[X&gt;<span class="number">15</span>]</span><br><span class="line">array([<span class="number">51</span>, <span class="number">55</span>, <span class="number">19</span>])</span><br><span class="line"><span class="comment"># 获取某几个下标的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>X[np.array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>])] <span class="comment"># 获取索引为0、2、4的元素</span></span><br><span class="line">array([<span class="number">51</span>, <span class="number">14</span>,  <span class="number">0</span>])</span><br></pre></td></tr></table></figure>



<h3 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h3><h4 id="绘制简单图形"><a href="#绘制简单图形" class="headerlink" title="绘制简单图形"></a>绘制简单图形</h4><p>绘制 sin 函数图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 生成数据</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">6</span>, <span class="number">0.1</span>) <span class="comment"># 以0.1为单位，生成0到6的数据</span></span><br><span class="line">y = np.sin(x)</span><br><span class="line"><span class="comment"># 绘制图形</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h4 id="pyplot"><a href="#pyplot" class="headerlink" title="pyplot"></a>pyplot</h4><p>追加cos函数的图形，并尝试使用 pyplot的添加标题和x轴标签名等其他功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># 生成数据</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">6</span>, <span class="number">0.1</span>) <span class="comment"># 以0.1为单位，生成0到6的数据</span></span><br><span class="line">y1 = np.sin(x)</span><br><span class="line">y2 = np.cos(x)</span><br><span class="line"><span class="comment"># 绘图</span></span><br><span class="line">plt.plot(x, y1, label=<span class="string">&quot;sin&quot;</span>)</span><br><span class="line">plt.plot(x, y2, linestyle = <span class="string">&quot;--&quot;</span>, label=<span class="string">&quot;cos&quot;</span>) <span class="comment"># 用虚线绘制</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;x&quot;</span>) <span class="comment"># x轴标签</span></span><br><span class="line">plt.ylabel(<span class="string">&quot;y&quot;</span>) <span class="comment"># y轴标签</span></span><br><span class="line">plt.title(<span class="string">&#x27;sin &amp; cos&#x27;</span>) <span class="comment"># 标题</span></span><br><span class="line">plt.legend() <span class="comment"># 显示图中标签</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h4 id="显示图像"><a href="#显示图像" class="headerlink" title="显示图像"></a>显示图像</h4><p>pyplot中的 <code>imshow()</code> 显示图像，image 的 <code>imread</code> 读取图像路径。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.image <span class="keyword">import</span> imread</span><br><span class="line">img = imread(<span class="string">&#x27;lena.png&#x27;</span>) <span class="comment"># 读入图像（设定合适的路径！）</span></span><br><span class="line">plt.imshow(img)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序算法</title>
    <url>/2021/07/15/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="1-知识点"><a href="#1-知识点" class="headerlink" title="1. 知识点"></a>1. 知识点</h2><p>一般情况下，将第一个元素作为基准，设置两个指针 <code>i = 0, j = n - 1</code> ，先用 <code>j</code> 从后往前找第一个小于基准的值，赋给 <code>i</code> 所在位置；然后再用 <code>i</code> 从前往后找第一个大于基准的值，赋给 <code>j</code> 所在位置。最终 <code>i &gt;= j </code> 的时候退出循环，以 <code>i == j</code> 的这个位置为分割线，将数组划分为两个，分别继续进行排序。</p>
<span id="more"></span>



<h2 id="2-具体实例和代码"><a href="#2-具体实例和代码" class="headerlink" title="2. 具体实例和代码"></a>2. 具体实例和代码</h2><h3 id="1-题目链接"><a href="#1-题目链接" class="headerlink" title="1. 题目链接"></a>1. 题目链接</h3><p><a href="https://www.nowcoder.com/practice/e016ad9b7f0b45048c58a9f27ba618bf?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1">https://www.nowcoder.com/practice/e016ad9b7f0b45048c58a9f27ba618bf?tpId=188&amp;tags=&amp;title=&amp;difficulty=0&amp;judgeStatus=0&amp;rp=1</a></p>
<h3 id="2-具体代码"><a href="#2-具体代码" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><p>通用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        quickSort(a, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> a[n-K];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( l &gt;= a.length || r &lt; <span class="number">0</span> || l &gt; r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = l, j = r;</span><br><span class="line">        <span class="keyword">int</span> f = a[l];</span><br><span class="line">        <span class="keyword">while</span>( i &lt; j )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>( i &lt; j &amp;&amp; a[j] &gt;= f )</span><br><span class="line">            &#123;</span><br><span class="line">                -- j;</span><br><span class="line">            &#125;</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            <span class="keyword">while</span>( i &lt; j &amp;&amp; a[i] &lt;= f )</span><br><span class="line">            &#123;</span><br><span class="line">                ++ i;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        a[i] = f;</span><br><span class="line">        quickSort(a, l, i-<span class="number">1</span>);</span><br><span class="line">        quickSort(a, j+<span class="number">1</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对具体问题进行改进：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKth</span>(<span class="params">self, a, n, K</span>):</span></span><br><span class="line">        self.findK(a, <span class="number">0</span>, n-<span class="number">1</span>, K-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> a[K-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findK</span>(<span class="params">self, a, l, r, k</span>):</span></span><br><span class="line">        <span class="keyword">if</span> l &gt;= <span class="built_in">len</span>(a) <span class="keyword">or</span> r &lt; <span class="number">0</span> <span class="keyword">or</span> k &lt; <span class="number">0</span> <span class="keyword">or</span> l &gt; r:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        i, j = l, r</span><br><span class="line">        f = a[i]</span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> a[j] &lt;= f:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            a[i] = a[j]</span><br><span class="line">            <span class="keyword">while</span> i &lt; j <span class="keyword">and</span> a[i] &gt;= f:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            a[j] = a[i]</span><br><span class="line">        a[i] = f</span><br><span class="line">        <span class="keyword">if</span> i &gt; k:</span><br><span class="line">            self.findK(a, l, i-<span class="number">1</span>, k)</span><br><span class="line">        <span class="keyword">elif</span> i &lt; k:</span><br><span class="line">            self.findK(a, j+<span class="number">1</span>, r, k)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法的时空复杂度比较 &amp; 冒泡排序 &amp; 归并排序</title>
    <url>/2022/01/25/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%AF%94%E8%BE%83-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="一-排序算法介绍"><a href="#一-排序算法介绍" class="headerlink" title="一. 排序算法介绍"></a>一. 排序算法介绍</h3><h4 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h4><p>排序算法分为比较类排序和非比较类排序，其中：</p>
<p>比较类排序有 冒泡排序、快速排序、插入排序、希尔排序、选择排序、堆排序、归并排序；</p>
<span id="more"></span>



<p>非比较类排序有 计数排序、桶排序、基数排序。</p>
<p>算法复杂度如下：</p>
<table>
<thead>
<tr>
<th align="center">比较类排序</th>
<th align="center">时间复杂度</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入排序</td>
<td align="center">O(n2)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">O(n1.3)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">选择排序</td>
<td align="center">O(n2)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">O(nlog2n)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">冒泡排序</td>
<td align="center">O(n2)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">O(nlog2n)</td>
<td align="center">O(nlog2n)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">O(nlog2n)</td>
<td align="center">O(n)</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">非比较类排序</th>
<th align="center">时间复杂度</th>
<th align="center">空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">计数排序</td>
<td align="center">O(n+k)</td>
<td align="center">O(n+k)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">桶排序</td>
<td align="center">O(n+k)</td>
<td align="center">O(n+k)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">O(n*k)</td>
<td align="center">O(n+k)</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<h4 id="算法选择"><a href="#算法选择" class="headerlink" title="算法选择"></a>算法选择</h4><p>参考 <code>Java</code> 中的 <code>Arrays.sort()</code> 的使用，可以大致划分：</p>
<ol>
<li>元素个数 <strong>少于47</strong> 进行插入排序；</li>
<li>元素个数 <strong>大于等于47、小于286</strong> 进行快速排序；</li>
<li>元素个数 <strong>大于等于286</strong> 时，检查数组是否是接近已经排序好的结构，如果是，进行归并排序，如果数组不是（即非高度结构化的），使用快速排序。</li>
</ol>
<h3 id="二-冒泡排序"><a href="#二-冒泡排序" class="headerlink" title="二. 冒泡排序"></a>二. 冒泡排序</h3><p>最基本的排序算法。</p>
<ol>
<li>比较相邻元素，如果两个元素之间不满足指定要求（比如降序或升序），则进行交换；</li>
<li>每次比较循环都是从第一个元素开始（下标为0），直到所有元素都排序完毕。</li>
</ol>
<p>实例：</p>
<blockquote>
<p>按升序排列：</p>
<p>第一次循环 - [2,1,4,3,7,5] </p>
<p>2&gt;1 -&gt; 1,2 -&gt; [1,2,4,3,7,5]</p>
<p>2&lt;4 ✔</p>
<p>4&gt;3 -&gt; 3,4 -&gt; [1,2,3,4,7,5]</p>
<p>4&lt;7 ✔</p>
<p>7&gt;5 -&gt; 5,7 -&gt; [1,2,3,4,5,7]</p>
<p>第二次循环：[1,2,3,4,5]    &#x2F;&#x2F;7是上次循环后得到的最大值，不再参与循环</p>
<p>1&lt;2 ✔</p>
<p>2&lt;3 ✔</p>
<p>3&lt;4 ✔</p>
<p>4&lt;5 ✔</p>
<p>…</p>
</blockquote>
<p>可以进行一个小优化：设置一个参数<code>flag=0</code>来判断该次循环是否存在交换，如果有，置<code>flag=1</code>，则继续进行循环；没有，则退出循环。</p>
<p>具体代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] list = &#123;<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>; <span class="comment">// 开辟一个临时空间, 存放交换的中间值</span></span><br><span class="line"><span class="comment">// 要遍历的次数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>; <span class="comment">//设置一个标志位</span></span><br><span class="line">    <span class="comment">//依次的比较相邻两个数的大小，遍历一次后，把数组中第i小的数放在第i个位置上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; list.length-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">        <span class="comment">// 比较相邻的元素，如果前面的数小于后面的数，交换</span></span><br><span class="line">        <span class="keyword">if</span> (list[j] &lt; list[j+<span class="number">1</span>]) &#123;</span><br><span class="line">            temp = list[j+<span class="number">1</span>];</span><br><span class="line">            list[j+<span class="number">1</span>] = list[j];</span><br><span class="line">            list[j] = temp;</span><br><span class="line">            flag = <span class="number">0</span>;  <span class="comment">//发生交换，标志位置0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.format(<span class="string">&quot;第 %d 遍最终结果：&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> count:list) &#123;</span><br><span class="line">        System.out.print(count);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;<span class="comment">//如果没有交换过元素，则已经有序</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="三-归并排序"><a href="#三-归并排序" class="headerlink" title="三. 归并排序"></a>三. 归并排序</h3><p>摘自 <a href="https://www.cnblogs.com/chengxiao/p/6194356.html">图解排序算法(四)之归并排序</a></p>
<p>适用于元素个数比较多的数组。</p>
<ol>
<li><p>分治：将数组对半分开，直到区间内只剩一个元素，开始向上递归；</p>
<p><img src="/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%AF%94%E8%BE%83-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.assets/1024555-20161218163120151-452283750.png" alt="img"></p>
</li>
<li><p>合并：当区间内的元素大于1个时，可以进行合并。</p>
</li>
</ol>
<p><img src="/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%AF%94%E8%BE%83-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.assets/1024555-20161218194508761-468169540.png" alt="img"></p>
<p>具体代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        devide(nums, <span class="number">0</span>, len - <span class="number">1</span>, tmp);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i] == nums[i+<span class="number">1</span>] )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">devide</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span>[] tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>( l &gt;= r )</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">          devide(nums, l, mid, tmp);</span><br><span class="line">          devide(nums, mid+<span class="number">1</span>, r, tmp);</span><br><span class="line">          merge(nums, l, r, mid, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> mid, <span class="keyword">int</span>[] tmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( mid &gt;= r + <span class="number">1</span> || mid &lt; <span class="number">0</span> || l &gt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( i &lt;= mid &amp;&amp; j &lt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( nums[i] &lt;= nums[j] )</span><br><span class="line">            &#123;</span><br><span class="line">                tmp[t++] = nums[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmp[t++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( i &lt;= mid )</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[t++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( j &lt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[t++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        i = l;</span><br><span class="line">        <span class="keyword">while</span>( l &lt;= r )</span><br><span class="line">        &#123;</span><br><span class="line">            nums[l++] = tmp[t++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>归并排序</tag>
        <tag>冒泡排序</tag>
      </tags>
  </entry>
  <entry>
    <title>笔试刷题</title>
    <url>/2021/12/24/%E7%AC%94%E8%AF%95%E5%88%B7%E9%A2%98/</url>
    <content><![CDATA[<h3 id="1-阅读下面的程序："><a href="#1-阅读下面的程序：" class="headerlink" title="1. 阅读下面的程序："></a>1. 阅读下面的程序：</h3><span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span> ; x &lt;=<span class="number">3</span> ; x++) &#123;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">         System.out.print(x%<span class="number">2</span> + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下列选项，哪个是结果：</p>
<p>A. 0 1 2 3</p>
<p>B. 0 1 2 1</p>
<p>C. 0 1 2</p>
<p>D. 编译失败</p>
<p><strong>结果：D</strong></p>
<blockquote>
<p>会报错：error: unreachable statement。</p>
<p>原因一：</p>
<p>下面的几种情况会出现 unreachable statement：<br>（1）在reutrn语句后写语句。<br>（2）在throw语句后写语句。<br>（3）break、continue语句之后定义语句。<br>（4）“\u10100”&#x2F;&#x2F;合法，相当于‘\u1010’和字符串“0”。<br>（5）移位运算符可以用于long int char short byte。<br>（6）类的访问控制符可以是public或什么都不加。<br>（7）goto是保留字但不是关键字。then什么都不是。<br>（8）把超类的类型强制转换后赋给子类的对象时，编译无异常，但运行时会出现异常。</p>
<p>原因二：</p>
<p>不可达语句的造成是因为：在此语句前面有一个返回操作，或者其他操作导致不管什么条件都无法执行到这一句。<br>最重要的是：检查前面语句是否有返回，并查看是否因为自己的疏忽，即使没有语法等错误，导致的任何条件都会在此语句前面返回。因为自己的疏忽，好几次在if 或for条件句后面加了; 导致下面的return语句不会执行之后的任何语句，就会返回1；</p>
</blockquote>
<h3 id="2-下列关于冒泡排序的描述中，正确的是（-）-多选"><a href="#2-下列关于冒泡排序的描述中，正确的是（-）-多选" class="headerlink" title="2. 下列关于冒泡排序的描述中，正确的是（ ） - 多选"></a>2. 下列关于冒泡排序的描述中，正确的是（ ） - 多选</h3><p>A. 冒泡排序是不断的比较数组中相邻的两个元素</p>
<p>B. 冒泡排序比较的总轮次是“数组长度-1”轮</p>
<p>C. 冒泡排序中会涉及到元素位置的置换</p>
<p>D. 其他说法均不正确</p>
<p><strong>结果：ABC</strong></p>
<blockquote>
<p>注意B说的是 <code>总轮次</code>。</p>
</blockquote>
<h3 id="3-下列关于二维数组定义的选项中，错误的是（-）"><a href="#3-下列关于二维数组定义的选项中，错误的是（-）" class="headerlink" title="3. 下列关于二维数组定义的选项中，错误的是（ ）"></a>3. 下列关于二维数组定义的选项中，错误的是（ ）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A. int\[][] arr = new int\[3][4];</span><br><span class="line">B. int\[][] arr = new int\[3][];</span><br><span class="line">C. int\[][] arr = new int\[][4];</span><br><span class="line">D. int[][] arr = &#123;&#123;1,2&#125;,&#123;3,4,5&#125;,&#123;6&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>结果：C</strong></p>
<blockquote>
<p>可以省略列，不能省略行。</p>
</blockquote>
<h3 id="4-下列选项中，哪些可以作为方法重载的判断条件（-）-多选"><a href="#4-下列选项中，哪些可以作为方法重载的判断条件（-）-多选" class="headerlink" title="4. 下列选项中，哪些可以作为方法重载的判断条件（ ） - 多选"></a>4. 下列选项中，哪些可以作为方法重载的判断条件（ ） - 多选</h3><p>A. 方法名</p>
<p>B. 方法的参数列表</p>
<p>C. 方法的返回值</p>
<p>D. 方法的修饰符</p>
<p><strong>结果：AB</strong></p>
<blockquote>
<p>方法重载是可以定义多个方法名相同、参数列表不同的方法。</p>
</blockquote>
<h3 id="5-下列关于方法重载的说法中，正确的是（-）-多选"><a href="#5-下列关于方法重载的说法中，正确的是（-）-多选" class="headerlink" title="5. 下列关于方法重载的说法中，正确的是（ ） - 多选"></a>5. 下列关于方法重载的说法中，正确的是（ ） - 多选</h3><p>A. 方法名相同，参数的个数不同可以形成方法重载。</p>
<p>B. 方法名相同，参数的类型不同可以形成方法重载。</p>
<p>C. 方法名相同，参数的类型排列顺序不同可以形成方法重载。</p>
<p>D. 方法名相同，返回值类型不同，可以形成方法重载。</p>
<p><strong>结果：ABC</strong></p>
<blockquote>
<p>注意看C，是 <code>类型</code> 排列顺序不同。</p>
</blockquote>
<h3 id="6-请阅读下面的程序："><a href="#6-请阅读下面的程序：" class="headerlink" title="6. 请阅读下面的程序："></a>6. 请阅读下面的程序：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(“<span class="keyword">int</span>:” + (a+b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">float</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(“<span class="keyword">float</span>:” + (a+b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">        System.out.println(“<span class="keyword">double</span>:” + (a+b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">long</span> b = <span class="number">20</span>;</span><br><span class="line">        sum(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下列选项中，哪一个是程序的正确运行结果（ ）</p>
<p>A. int:30<br>B. float:30.0<br>C. double:30.0<br>D. int:30.0</p>
<p><strong>结果：B</strong></p>
<blockquote>
<p>比long范围更大的是float</p>
</blockquote>
<h3 id="7-下面关于构造方法的描述中，正确的是（-）"><a href="#7-下面关于构造方法的描述中，正确的是（-）" class="headerlink" title="7. 下面关于构造方法的描述中，正确的是（ ）"></a>7. 下面关于构造方法的描述中，正确的是（ ）</h3><p>A. 构造方法在类定义的时候被调用<br>B. 构造方法在创建对象的时候被调用<br>C. 构造方法在调用对象的时候被调用<br>D. 构造方法在使用对象的时候被调用</p>
<p><strong>结果：B</strong></p>
<h3 id="8-下列关于this关键字的说法中，错误的是（-）"><a href="#8-下列关于this关键字的说法中，错误的是（-）" class="headerlink" title="8. 下列关于this关键字的说法中，错误的是（  ）"></a>8. 下列关于this关键字的说法中，错误的是（  ）</h3><p>A. this可以解决成员变量与局部变量重名的问题</p>
<p>B. this出现在成员方法中，代表的是调用这个方法的对象</p>
<p>C. this可以出现在任何方法中</p>
<p>D. this相当于一个引用，可以通过它调用成员属性与方法</p>
<p><strong>结果：C</strong></p>
<blockquote>
<p>this只能在类中的非静态方法中使用，静态方法和静态的代码块中绝对不能出现this。</p>
</blockquote>
<h3 id="9-以下代码执行后的结果是（-）"><a href="#9-以下代码执行后的结果是（-）" class="headerlink" title="9. 以下代码执行后的结果是（ ）"></a>9. 以下代码执行后的结果是（ ）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        String name = “小芳”;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            name = “小兰”;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = “小翠”;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Person p = <span class="keyword">new</span> Person(“小凤”);</span><br><span class="line">    System.out.println(p.name);</span><br><span class="line">    p.show();</span><br><span class="line">    System.out.println(p.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A. 小兰小翠</p>
<p>B.小凤小翠</p>
<p>C. 小芳小翠</p>
<p>D. 程序编译失败</p>
<p><strong>结果：C</strong></p>
<blockquote>
<p>小凤用来告诉系统应该调用一个有参的构造方法，而不是起赋值作用，至于小兰的话，name前面没有this，故小兰只是个局部变量，出不去。</p>
</blockquote>
<h3 id="10-以下关于方法重写，说法错误的是（-）-多选"><a href="#10-以下关于方法重写，说法错误的是（-）-多选" class="headerlink" title="10. 以下关于方法重写，说法错误的是（ ） - 多选"></a>10. 以下关于方法重写，说法错误的是（ ） - 多选</h3><p>A. 方法重写时，子类的函数名与参数列表必须与父类的一致</p>
<p>B. 方法重写时，子类的返回类型必须大于或者等于父类的返回类型</p>
<p>C. 方法重写时，子类的访问修饰符必须大于或者等于父类的访问修饰符</p>
<p>D. 方法重写与返回类型无关</p>
<p><strong>结果：BD</strong></p>
<blockquote>
<p>重写的规范</p>
<ol>
<li><p>子类方法的名称、参数列表与父类相同;</p>
</li>
<li><p>子类方法的返回类型与父类相同或更小;</p>
</li>
<li><p>子类方法声明的异常与父类相同或更小;</p>
</li>
<li><p>子类方法的访问权限与父类相同或更大。</p>
</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>笔试</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础知识 - 面试题</title>
    <url>/2021/12/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1-OSI七层网络模型"><a href="#1-OSI七层网络模型" class="headerlink" title="1. OSI七层网络模型"></a>1. OSI七层网络模型</h2><span id="more"></span>

<p>自下而上包括：</p>
<ol>
<li>物理层：比如将电脑连上网线，这个网线就属于物理层的一个设备；</li>
<li>链路层：比如mac地址就是链路层的一个协议；</li>
<li>网络层：IP协议就是网络层的一个协议；</li>
<li>传输层：TCP协议和UDP协议就是传输层的协议；</li>
<li>会话层、表示层：这两个层级一般就存在概念中，不具有实用性；</li>
<li>应用层：比如HTTP协议、FTP协议就是应用层的协议。</li>
</ol>
<h2 id="2-TCP-x2F-IP协议"><a href="#2-TCP-x2F-IP协议" class="headerlink" title="2. TCP &#x2F; IP协议"></a>2. TCP &#x2F; IP协议</h2><p>包含了物理层、链路层、网络层、传输层以及应用层，其中这里的应用层就涵盖了OSI七层模型里面的会话层、表示层和应用层。TCP&#x2F;IP协议相较于OSI模型，是实践性更高一种描述。</p>
<h2 id="3-TCP三次握手和四次握手"><a href="#3-TCP三次握手和四次握手" class="headerlink" title="3. TCP三次握手和四次握手"></a>3. TCP三次握手和四次握手</h2><p>建立TCP需要三次握手才能建立，而断开连接则需要四次握手。</p>
<h4 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a>三次握手：</h4><p>第一次握手，主机A通过向主机B发送一个含有同步序列号的标志位的数据段给主机B，向主机B请求建立连接，通过这个数据段，主机A对主机B说：我想与你通信，你可以用哪个序列号作为其实数据段来回应我；<br>第二次握手，主机B收到主机A的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应主机A，也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用这个序列号作为起始数据段来回应我；<br>第三次握手，主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B的数据段：”我已收到回复，我现在要开始传输实际数据了。</p>
<h4 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h4><p>第一次： 当主机A完成数据传输后,将控制位FIN置1，提出停止TCP连接的请求；<br>第二次： 主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将关闭,将ACK置1；<br>第三次： 由B 端再提出反方向的关闭请求,将FIN置1 ；<br>第四次： 主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束。</p>
<h2 id="4-TCP、UDP的区别"><a href="#4-TCP、UDP的区别" class="headerlink" title="4. TCP、UDP的区别"></a>4. TCP、UDP的区别</h2><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>UDP协议的全称是用户数据报协议，它和TCP一样用于处理数据包，它是一种无连接协议，在OSI模型中，二者位于传输层，在IP层的上一层，UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，因此，当数据报文传输后，无法确认是否能够安全完整的到达。<br><strong>UDP有如下几个特点：</strong><br>1）面向无连接：UDP是不需要和TCP一样通过三次握手建立连接的，想发数据的时候就可以发，并且也只是数据报文的搬运工，不会对数据报文进行任何拆分或拼接；<br>2）有单播、多播和广播功能：UDP不仅能够一对一传输，还能多对一、一对多、多对多传输，所以它有单播、多播和广播功能；<br>3）UDP是面向报文的：面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，接收方IP层则需要进行数据报的重组；<br>4）不可靠性：<br>（1）首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠；<br>（2）并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了；<br>（3）再者网络环境时好时坏，但是 UDP因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。 5）头部花销少，传输数据报文是高效的：UDP的头部包含以下几个数据：16位源端口号、16位目的端口号、16位UDP长度和16位UDP校验和；因为UDP的头部花销少，只有8个字节，相比TCP需要至少20个字节，在传输数据的时候是高效的。</p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>TCP协议全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的RFC 793定义。TCP是面向连接的、可靠的流协议。流就是指不间断的数据结构。<br><strong>TCP的特点如下：</strong><br>1）面向连接：面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。 2）仅支持单播传输： 每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。<br>3）面向字节流：TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。<br>4）可靠传输：对于可靠传输，判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。<br>5）提供拥塞控制：当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。<br>6）TCP提供全双工通信：TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于最大报文段长度MSS）</p>
<h4 id="二者的区别大致如下"><a href="#二者的区别大致如下" class="headerlink" title="二者的区别大致如下"></a>二者的区别大致如下</h4><p>1）TCP是面向连接的，而UDP是面向无连接即发送数据钱不需要建立连接；<br>2）TCP提供可靠的服务，而UDP无法保证；<br>3）TCP面向字节流，UDP面向报文；<br>4）TCP数据传输慢，UDP的数据传输快。</p>
<h2 id="5-TCP如何保证可靠传输"><a href="#5-TCP如何保证可靠传输" class="headerlink" title="5. TCP如何保证可靠传输"></a>5. TCP如何保证可靠传输</h2><p>TCP协议传输的特点主要就是面向字节流、传输可靠、面向连接。</p>
<p>TCP保证数据可靠传输的方式主要有以下六点：校验和、确认应答与序列号、超时重传、连接管理、流量控制、拥塞控制。</p>
<p>1）校验和</p>
<p>在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。发送方在发送数据之前计算校验和，并进行校验和的填充。接收方收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。</p>
<p>注意：如果接收方比对校验和与发送方不一致，那么数据一定传输有误。但是如果接收方比对校验和与发送方一致，数据不一定传输成功。</p>
<p>2）确认应答与序列号</p>
<p>序列号：TCP传输时将每个字节的数据都进行了编号，这就是序列号。</p>
<p>确认应答：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。</p>
<p>序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。这也是TCP传输可靠性的保证之一。</p>
<p>3）超时重传</p>
<p>简单理解就是发送方在发送完数据后等待一个时间，时间到达没有接受到ACK报文，那么对刚才发送的数据进行重新发送。由于TCP传输时保证能够在任何环境下都有一个高性能的通信，因此这个最大超时时间（也就是等待时间）是动态计算的。</p>
<p>4）连接管理</p>
<p>连接管理就是三次握手和四次挥手的过程，保证可靠的连接，是保证可靠性的前提。</p>
<p>5）流量控制</p>
<p>接收端在接收到数据后，对其进行处理。如果发送端的发送速度太快，导致接收端的结束缓冲区很快的填充满了。此时如果发送端仍旧发送数据，那么接下来发送的数据都会丢包，继而导致丢包的一系列连锁反应，超时重传。而TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制。</p>
<p>6）拥塞控制</p>
<p>TCP通过维护一个拥塞窗口来进行拥塞控制。网络中没有出现拥塞，拥塞窗口的值就可以再增大一些，以便把更多的数据发送出去。网络出现拥塞，拥塞窗口的值就应该减小一些，以减少注入到网络中的数据包数。</p>
<h2 id="6-浏览器输入url到显示网页过程"><a href="#6-浏览器输入url到显示网页过程" class="headerlink" title="6. 浏览器输入url到显示网页过程"></a>6. 浏览器输入url到显示网页过程</h2><ol>
<li>解析URL，生成发送给Web服务器的请求信息。</li>
</ol>
<h2 id="7-HTTP、HTTPS的区别"><a href="#7-HTTP、HTTPS的区别" class="headerlink" title="7. HTTP、HTTPS的区别"></a>7. HTTP、HTTPS的区别</h2><p>http是超文本传输协议，它是通过明文的方式发送内容，没有任何的加密，比如我们访问一个网站，我们可能需要在这个网站输入密码，之后账号和密码就会发送到网站的服务器上，但要是有人在中途截取了信息，这些信息很容易就会暴露，为了解决http在传输过程中不加密的问题，又增加了一个SSL协议，这个协议简单说就是提供数据安全和完整性的协议，也就是负责网络连接的加密，比如访问一个https的网站，电脑就会先和服务器建立一个安全的连接通道，然后服务器会先发送一份网站的证书信息到电脑，就相当于是告诉电脑，你访问的服务器没有问题，确认了信息之后，我们的服务器就会生成一个加锁的箱子，但是这把锁有两把不一样的钥匙，一把给电脑，一把自留，然后服务器就会把没有上锁的箱子和钥匙发给电脑，我们把信息放在箱子里面之后，用钥匙锁上，再发给服务器，服务器再用自己的钥匙打开箱子，来保证信息的安全，在这个过程中，即使箱子被人拦截，因为没有钥匙，以目前的技术来讲，还是很难打开箱子的，所以一些大的网站尤其是购物网站，或者是需要登录的网站，基本都是https的。</p>
<h2 id="8-http1-0和http1-1"><a href="#8-http1-0和http1-1" class="headerlink" title="8. http1.0和http1.1"></a>8. http1.0和http1.1</h2><h2 id="9-cookie和session的作用和区别"><a href="#9-cookie和session的作用和区别" class="headerlink" title="9. cookie和session的作用和区别"></a>9. cookie和session的作用和区别</h2><h2 id="10-什么是操作系统"><a href="#10-什么是操作系统" class="headerlink" title="10. 什么是操作系统"></a>10. 什么是操作系统</h2><h2 id="11-进程状态及通信方式"><a href="#11-进程状态及通信方式" class="headerlink" title="11. 进程状态及通信方式"></a>11. 进程状态及通信方式</h2><h2 id="12-线程间的同步方式"><a href="#12-线程间的同步方式" class="headerlink" title="12. 线程间的同步方式"></a>12. 线程间的同步方式</h2><h2 id="13-进程调度算法"><a href="#13-进程调度算法" class="headerlink" title="13. 进程调度算法"></a>13. 进程调度算法</h2><h2 id="14-内存管理"><a href="#14-内存管理" class="headerlink" title="14. 内存管理"></a>14. 内存管理</h2><h2 id="15-虚拟内存"><a href="#15-虚拟内存" class="headerlink" title="15. 虚拟内存"></a>15. 虚拟内存</h2><h2 id="16-什么是内核"><a href="#16-什么是内核" class="headerlink" title="16. 什么是内核"></a>16. 什么是内核</h2><h2 id="17-Shell编程和Linux基本命令"><a href="#17-Shell编程和Linux基本命令" class="headerlink" title="17. Shell编程和Linux基本命令"></a>17. Shell编程和Linux基本命令</h2><h2 id="18-什么是MySQL"><a href="#18-什么是MySQL" class="headerlink" title="18. 什么是MySQL"></a>18. 什么是MySQL</h2><h2 id="19-MySQL主从复制"><a href="#19-MySQL主从复制" class="headerlink" title="19. MySQL主从复制"></a>19. MySQL主从复制</h2><h2 id="20-存储引擎"><a href="#20-存储引擎" class="headerlink" title="20. 存储引擎"></a>20. 存储引擎</h2><h2 id="21-索引及索引底层结构"><a href="#21-索引及索引底层结构" class="headerlink" title="21. 索引及索引底层结构"></a>21. 索引及索引底层结构</h2><h2 id="22-查询缓存"><a href="#22-查询缓存" class="headerlink" title="22. 查询缓存"></a>22. 查询缓存</h2><h2 id="23-什么是事务"><a href="#23-什么是事务" class="headerlink" title="23. 什么是事务"></a>23. 什么是事务</h2><h2 id="24-事务四大特性"><a href="#24-事务四大特性" class="headerlink" title="24. 事务四大特性"></a>24. 事务四大特性</h2><h2 id="25-事务隔离及MySQL的默认隔离级别"><a href="#25-事务隔离及MySQL的默认隔离级别" class="headerlink" title="25. 事务隔离及MySQL的默认隔离级别"></a>25. 事务隔离及MySQL的默认隔离级别</h2><h2 id="26-并发事务带来的问题"><a href="#26-并发事务带来的问题" class="headerlink" title="26. 并发事务带来的问题"></a>26. 并发事务带来的问题</h2><h2 id="27-锁机制"><a href="#27-锁机制" class="headerlink" title="27. 锁机制"></a>27. 锁机制</h2><h2 id="28-大表优化"><a href="#28-大表优化" class="headerlink" title="28. 大表优化"></a>28. 大表优化</h2><h2 id="29-SQL语句的执行过程"><a href="#29-SQL语句的执行过程" class="headerlink" title="29. SQL语句的执行过程"></a>29. SQL语句的执行过程</h2><h2 id="30-MySQL高性能优化"><a href="#30-MySQL高性能优化" class="headerlink" title="30. MySQL高性能优化"></a>30. MySQL高性能优化</h2><h2 id="31-MVCC及视图"><a href="#31-MVCC及视图" class="headerlink" title="31. MVCC及视图"></a>31. MVCC及视图</h2><h2 id="32-SQL语句的熟练编写"><a href="#32-SQL语句的熟练编写" class="headerlink" title="32. SQL语句的熟练编写"></a>32. SQL语句的熟练编写</h2><h2 id="33-常用工具"><a href="#33-常用工具" class="headerlink" title="33. 常用工具"></a>33. 常用工具</h2>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>深度优先遍历DFS和广度优先遍历BFS算法</title>
    <url>/2022/01/30/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86DFS%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86BFS%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="实例（题目）"><a href="#实例（题目）" class="headerlink" title="实例（题目）"></a>实例（题目）</h2><p><a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></p>
<span id="more"></span>

<h2 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h2><p>对每一个分支走到最后一个节点，再往上回溯，走当前节点的下一个分支。下面给出深度优先遍历的过程图：</p>
<p><img src="/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86DFS%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86BFS%E7%AE%97%E6%B3%95.assets/%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86.png"></p>
<p>递归代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    grid[i][j] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>( i + <span class="number">1</span> &lt; m &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        dfs(grid, i + <span class="number">1</span>, j, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        dfs(grid, i - <span class="number">1</span>, j, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( j + <span class="number">1</span> &lt; n &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        dfs(grid, i, j + <span class="number">1</span>, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        dfs(grid, i, j - <span class="number">1</span>, m, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非递归代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; inds = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    inds.push(i * n + j);</span><br><span class="line">    <span class="keyword">while</span>( !inds.empty() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = inds.pop();</span><br><span class="line">        i = ind / n;</span><br><span class="line">        j = ind % n;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>( i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            inds.push((i - <span class="number">1</span>) * n + j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( i + <span class="number">1</span> &lt; m &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            inds.push((i + <span class="number">1</span>) * n + j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            inds.push(i * n + j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( j + <span class="number">1</span> &lt; n &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            inds.push(i * n + j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h2><p>没有递归调用，使用队列（Queue）存放元素，遍历当前元素相连的所有元素并记录。</p>
<p><img src="/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86DFS%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86BFS%E7%AE%97%E6%B3%95.assets/%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86.png"></p>
<p>具体代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; inds = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    inds.add(i * n + j);</span><br><span class="line">    <span class="keyword">while</span>( !inds.isEmpty() )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ind = inds.poll();</span><br><span class="line">        i = ind / n;</span><br><span class="line">        j = ind % n;</span><br><span class="line">        <span class="keyword">if</span>( i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            inds.add((i - <span class="number">1</span>) * n + j);</span><br><span class="line">            grid[i - <span class="number">1</span>][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( i + <span class="number">1</span> &lt; m &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            inds.add((i + <span class="number">1</span>) * n + j);</span><br><span class="line">            grid[i + <span class="number">1</span>][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            inds.add(i * n + j - <span class="number">1</span>);</span><br><span class="line">            grid[i][j - <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( j + <span class="number">1</span> &lt; n &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            inds.add(i * n + j + <span class="number">1</span>);</span><br><span class="line">            grid[i][j + <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，为了剪枝，将 <code>grid[i][j + 1] = &#39;0&#39;</code> 在每个 if 语句中实现。</p>
<h2 id="题中具体代码"><a href="#题中具体代码" class="headerlink" title="题中具体代码"></a>题中具体代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( grid[i][j] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    ++count;</span><br><span class="line">                    dfs(grid, i, j, m, n);</span><br><span class="line">                    <span class="comment">// grid[i][j] = &#x27;0&#x27;;</span></span><br><span class="line">                    <span class="comment">// bfs(grid, i, j, m, n);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// public void dfs(char[][] grid, int i, int j, int m, int n)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">// grid[i][j] = &#x27;2&#x27;;</span></span><br><span class="line">        <span class="comment">// if( i + 1 &lt; m &amp;&amp; grid[i + 1][j] == &#x27;1&#x27; )</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     dfs(grid, i + 1, j, m, n);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if( i - 1 &gt;= 0 &amp;&amp; grid[i - 1][j] == &#x27;1&#x27; )</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     dfs(grid, i - 1, j, m, n);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if( j + 1 &lt; n &amp;&amp; grid[i][j + 1] == &#x27;1&#x27; )</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     dfs(grid, i, j + 1, m, n);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// if( j - 1 &gt;= 0 &amp;&amp; grid[i][j - 1] == &#x27;1&#x27; )</span></span><br><span class="line">        <span class="comment">// &#123;</span></span><br><span class="line">        <span class="comment">//     dfs(grid, i, j - 1, m, n);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//     Stack&lt;Integer&gt; inds = new Stack&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     inds.push(i * n + j);</span></span><br><span class="line">    <span class="comment">//     while( !inds.empty() )</span></span><br><span class="line">    <span class="comment">//     &#123;</span></span><br><span class="line">    <span class="comment">//         int ind = inds.pop();</span></span><br><span class="line">    <span class="comment">//         i = ind / n;</span></span><br><span class="line">    <span class="comment">//         j = ind % n;</span></span><br><span class="line">    <span class="comment">//         grid[i][j] = &#x27;2&#x27;;</span></span><br><span class="line">    <span class="comment">//         if( i - 1 &gt;= 0 &amp;&amp; grid[i - 1][j] == &#x27;1&#x27; )</span></span><br><span class="line">    <span class="comment">//         &#123;</span></span><br><span class="line">    <span class="comment">//             inds.push((i - 1) * n + j);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         if( i + 1 &lt; m &amp;&amp; grid[i + 1][j] == &#x27;1&#x27; )</span></span><br><span class="line">    <span class="comment">//         &#123;</span></span><br><span class="line">    <span class="comment">//             inds.push((i + 1) * n + j);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         if( j - 1 &gt;= 0 &amp;&amp; grid[i][j - 1] == &#x27;1&#x27; )</span></span><br><span class="line">    <span class="comment">//         &#123;</span></span><br><span class="line">    <span class="comment">//             inds.push(i * n + j - 1);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         if( j + 1 &lt; n &amp;&amp; grid[i][j + 1] == &#x27;1&#x27; )</span></span><br><span class="line">    <span class="comment">//         &#123;</span></span><br><span class="line">    <span class="comment">//             inds.push(i * n + j + 1);</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">char</span>[][] grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; inds = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        inds.add(i * n + j);</span><br><span class="line">        <span class="keyword">while</span>( !inds.isEmpty() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ind = inds.poll();</span><br><span class="line">            i = ind / n;</span><br><span class="line">            j = ind % n;</span><br><span class="line">            <span class="keyword">if</span>( i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                inds.add((i - <span class="number">1</span>) * n + j);</span><br><span class="line">                grid[i - <span class="number">1</span>][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( i + <span class="number">1</span> &lt; m &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                inds.add((i + <span class="number">1</span>) * n + j);</span><br><span class="line">                grid[i + <span class="number">1</span>][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                inds.add(i * n + j - <span class="number">1</span>);</span><br><span class="line">                grid[i][j - <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>( j + <span class="number">1</span> &lt; n &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                inds.add(i * n + j + <span class="number">1</span>);</span><br><span class="line">                grid[i][j + <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>dfs</tag>
        <tag>bfs</tag>
      </tags>
  </entry>
  <entry>
    <title>此URL不支持Http方法GET</title>
    <url>/2022/01/16/%E6%AD%A4URL%E4%B8%8D%E6%94%AF%E6%8C%81Http%E6%96%B9%E6%B3%95GET/</url>
    <content><![CDATA[<h3 id="具体错误"><a href="#具体错误" class="headerlink" title="具体错误"></a>具体错误</h3><p><strong>类型</strong> 状态报告</p>
<p><strong>消息</strong> 此URL不支持Http方法GET</p>
<p><strong>描述</strong> 请求行中接收的方法由源服务器知道，但目标资源不支持</p>
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><ol>
<li>必须要实现 <code>doGet</code> 和 <code>doPost</code> 方法</li>
<li>必须要删除默认的 <code>super</code> 内容。</li>
</ol>
]]></content>
      <categories>
        <category>报错</category>
      </categories>
  </entry>
  <entry>
    <title>购物车结算系统-MySQL篇-项目小记</title>
    <url>/2022/01/11/%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%BB%93%E7%AE%97%E7%B3%BB%E7%BB%9F-MySQL%E7%AF%87-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="JDBC连接数据库"><a href="#JDBC连接数据库" class="headerlink" title="JDBC连接数据库"></a>JDBC连接数据库</h3><p>参考以下代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String driver = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">String url = <span class="string">&quot;jdbc:mysql://192.168.186.100:3306/goods_settlement&quot;</span>;</span><br><span class="line">String username = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">Class.forName(driver);</span><br><span class="line">System.out.println(<span class="string">&quot;连接数据库 -----------------&quot;</span>);</span><br><span class="line">Connection conn = DriverManager.getConnection(url, username, password);</span><br><span class="line"><span class="keyword">return</span> conn;</span><br></pre></td></tr></table></figure>

<p>需要导入 <code>mysql-connector-java-xxx.jar</code> 包，我从 <code>pom.xml</code> 导入：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="Java执行SQL语句"><a href="#Java执行SQL语句" class="headerlink" title="Java执行SQL语句"></a>Java执行SQL语句</h3><h4 id="有三种接口"><a href="#有三种接口" class="headerlink" title="有三种接口"></a>有三种接口</h4><p>Statement、PreparedStatement、CallableStatement 。常见的是前两种，下面说明前两种。</p>
<p>其中Statement适用于普通不带参的语句，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Statement s = conn.createStatement();</span><br><span class="line">String sql = <span class="string">&quot;select * from User where username = &quot;</span>abc<span class="string">&quot;&quot;</span>;</span><br><span class="line">s.executeQuery(sql);</span><br></pre></td></tr></table></figure>

<p>而PreparedStatement支持可变参数的语句，如  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">&quot;select * from User where username = ?&quot;</span>;</span><br><span class="line">PreparedStatement ps = conn.preparedStatement(sql);</span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">ps.executeQuery();</span><br></pre></td></tr></table></figure>

<p><strong>SQL的执行需要编译和解析</strong></p>
<p><strong>Statement每次的执行都需要编译SQL</strong></p>
<p><strong>PreparedStatement会预编译，会被缓冲，在缓存区中可以发现预编译的命令，虽然会被再次解析，但不会被再次编译，能够有效提高系统性能</strong></p>
<h4 id="有四种执行形式"><a href="#有四种执行形式" class="headerlink" title="有四种执行形式"></a>有四种执行形式</h4><p>executeQuery、executeUpdate、execute、batch。</p>
<ol>
<li><strong>executeQuery</strong>：用于执行 select 语句，返回单个结果集 ResultSet；</li>
<li><strong>executeUpdate</strong>：用于执行 INSERT、UPDATE 或 DELETE 语句以及 SQL DDL（数据定义语言）语句，例如 CREATE TABLE 和 DROP TABLE。返回值是一个整数，指示受影响的行数（即更新计数）。对于 CREATE TABLE 或 DROP TABLE 等不操作行的语句，executeUpdate 的返回值总为零。</li>
<li><strong>execute</strong>：可以执行所有SQL，返回值用于区分是返回的结果集还是受影响的行，换句话说，true表示SELECT false表示INSERT UPDATE DELETE。如果是返回结果集，必须使用方法 getResultSet 或 getUpdateCount 来获取结果，使用 getMoreResults 来移动后续结果。</li>
<li><strong>batch</strong>：即批处理，此处不做详述。</li>
</ol>
]]></content>
      <categories>
        <category>项目小记</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title>购物车结算系统 - HTML篇 - 项目小记</title>
    <url>/2022/01/03/%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%BB%93%E7%AE%97%E7%B3%BB%E7%BB%9F-HTML%E7%AF%87-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="form"><a href="#form" class="headerlink" title="form"></a>form</h3><h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><p>使用：<code>action=&quot;[跳转页面名称].jsp&quot;</code></p>
<p>如：<code>action=&quot;choose_goods.jsp&quot;</code></p>
<span id="more"></span>

<h4 id="method"><a href="#method" class="headerlink" title="method"></a>method</h4><p>有两个值：<code>post</code> 不显示中间 <code>input</code> 内容，<code>get</code> 显示。</p>
<p><strong>get：</strong></p>
<ol>
<li>请求参数会在地址栏中显示，会封装在请求行中</li>
<li>请求参数的大小是有限制的</li>
<li>请求方式不安全</li>
</ol>
<p><strong>post：</strong></p>
<ol>
<li>请求参数不会在地址栏中显示，会封装在请求体中</li>
<li>请求参数的大小没有限制</li>
<li>请求方式比较安全</li>
</ol>
<p>请求参数为中间 <code>&lt;input&gt;</code> 元素的结果。</p>
<p>一般情况 <code>&lt;form&gt;</code> 与 <code>&lt;input&gt;</code> 连用，当使用 <code>&lt;input type=&quot;submit&quot;&gt;</code> 按钮的时候会将其中的 <code>&lt;input&gt;</code> 的参数传第到指定跳转页面。</p>
<p>具体实例：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;choose_goods.jsp&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;input_field&quot;</span>&gt;</span><br><span class="line">          &lt;input name=<span class="string">&quot;username&quot;</span> type=<span class="string">&quot;text&quot;</span> required=<span class="string">&quot;required&quot;</span> placeholder=<span class="string">&quot;用户名&quot;</span>&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;input_field&quot;</span>&gt;</span><br><span class="line">          &lt;input name=<span class="string">&quot;password&quot;</span> type=<span class="string">&quot;password&quot;</span> required=<span class="string">&quot;required&quot;</span> placeholder=<span class="string">&quot;密码&quot;</span>&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;input_field&quot;</span>&gt;</span><br><span class="line">          &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;登录&quot;</span>&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<h4 id="onsubmit"><a href="#onsubmit" class="headerlink" title="onsubmit"></a>onsubmit</h4><p>点击 <code>&lt;input type=&quot;submit&quot;&gt;</code> 按钮时会触发指定函数。</p>
<p>使用：<code>onsubmit=&quot;checkPayword()&quot;</code>。</p>
<h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>常用的值如下：</p>
<ol>
<li>text：定义单行的输入字段，用户可在其中输入文本。默认宽度为 20 个字符。</li>
<li>submit：定义提交按钮。提交按钮会把表单数据发送到服务器。</li>
<li>buttom：定义可点击按钮（多数情况下，用于通过 JavaScript 启动脚本）。</li>
<li>password：定义密码字段。该字段中的字符被掩码。</li>
</ol>
<h4 id="required"><a href="#required" class="headerlink" title="required"></a>required</h4><p>表示该字段是必填的，不能为空。</p>
<h4 id="placeholder"><a href="#placeholder" class="headerlink" title="placeholder"></a>placeholder</h4><p>规定可描述输入字段预期值的简短的提示信息。也就是提示。</p>
<h4 id="value"><a href="#value" class="headerlink" title="value"></a>value</h4><p>input元素显示的值。</p>
<h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><p>该input元素的名称。</p>
<h4 id="maxlength"><a href="#maxlength" class="headerlink" title="maxlength"></a>maxlength</h4><p>规定输入字段的最大长度，以字符个数计。</p>
<h4 id="onclick"><a href="#onclick" class="headerlink" title="onclick"></a>onclick</h4><p>点击按钮事件。</p>
<h4 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h4><p>规定输入字段为只读，不可修改。</p>
<h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><h4 id="rel"><a href="#rel" class="headerlink" title="rel"></a>rel</h4><p>规定当前文档与被链接文档&#x2F;资源之间的关系，是必须的。</p>
<p>使用如：<code>rel=&quot;stylesheet&quot;</code></p>
<p>常用的值如下：</p>
<ol>
<li>stylesheet：要导入的样式表的 URL。</li>
<li>next： 表示该文档是集合中的一部分，且集合中的下一个文档是被引用的文档。</li>
<li>icon：导入表示该文档的图标。</li>
<li>alternate：链接到该文档的替代版本（比如打印页、翻译或镜像）。</li>
</ol>
<h4 id="href"><a href="#href" class="headerlink" title="href"></a>href</h4><p>规定外部资源（通常是样式表文件）的位置（URL）。</p>
<p>使用：<code>&lt;link href=&quot;URL&quot;&gt;</code></p>
<p>绝对URL - 指向另一个网站，如： <code>href=&quot;http://www.example.com/theme.css&quot;</code></p>
<p>相对URL - 指向网站内的一个文件，如： <code>href=&quot;/themes/theme.css&quot;</code></p>
<p><strong>此处有一个使用技巧：</strong></p>
<p>因为这种方式导入文件，这个文件就已经在浏览器加载过了，之后再进入此浏览器这个文件不会在被加载，为了保证每次进入浏览器的文件都是最新的，可以在导入的文件后添加这样的内容：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">?v=&lt;%= System.currentTimeMillis()%&gt;</span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">href=<span class="string">&quot;/themes/theme.css?v=&lt;%= System.currentTimeMillis()%&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>System.currentTimeMillis()</code> 就是获取系统的当前时间戳，相当于给文件一个版本号，这样每次进入浏览器，文件都会被更新。</p>
<h3 id="onclick-x3D-”this-form-onsubmit-”"><a href="#onclick-x3D-”this-form-onsubmit-”" class="headerlink" title="onclick&#x3D;”this.form.onsubmit()”"></a>onclick&#x3D;”this.form.onsubmit()”</h3><p>本项目使用在 点击 <code>&lt;input type=&quot;buttom&quot;&gt;</code> 按钮后检查密码是否合法。</p>
<p>意思就是点击这个按钮，会触发 <code>this</code> 这个 <code>form</code> 表单的 <code>obsubmit()</code> 这个方法指向的js方法。</p>
]]></content>
      <categories>
        <category>项目小记</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>购物车结算系统-CSS篇-项目小记</title>
    <url>/2022/01/06/%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%BB%93%E7%AE%97%E7%B3%BB%E7%BB%9F-CSS%E7%AF%87-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>常用的选择器如下：</p>
<span id="more"></span>

<ol>
<li><code>.exam</code> ：选择所有class&#x3D;”exam”的元素；</li>
<li><code>#exam</code> ：选择所有id&#x3D;”exam”的元素；</li>
<li><code>*</code> ：选择所有元素；</li>
<li><code>div</code> ：选择所有&lt;div&gt;元素；</li>
<li><code>div,p</code> ：选择所有&lt;div&gt;元素和&lt;p&gt;元素；</li>
<li><code>div p</code> ：选择&lt;div&gt;元素内的所有&lt;p&gt;元素；</li>
<li><code>div&gt;p</code> ：选择所有父级是 &lt;div&gt; 元素的 &lt;p&gt; 元素；</li>
<li><code>[input=text]</code> ：选择所有 &lt;input type&#x3D;”text”&gt; 元素；</li>
<li><code>a:link</code>：选择所有未访问链接；</li>
<li><code>a:visited</code>：选择所有访问过的链接；</li>
<li><code>a:active</code>：选择点击后的链接；</li>
<li><code>a:hover</code> ：选择鼠标在链接上面时。</li>
</ol>
<h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><p>应用于元素的2D或3D转换。这个属性允许你将元素旋转，缩放，移动，倾斜等。</p>
<p>本项目中使用：<code>transform: translate(-50%,-50%);</code></p>
<p>即往上（x轴）,左（y轴）移动自身长宽的 50%，以使其居于中心位置。</p>
<p><strong>用处：实现水平垂直居中。</strong></p>
<h3 id="box-shadow"><a href="#box-shadow" class="headerlink" title="box-shadow"></a>box-shadow</h3><p>设置一个或多个下拉阴影的框。</p>
<p>语法：<code>box-shadow: h-shadow v-shadow blur spread color inset;</code></p>
<table>
<thead>
<tr>
<th align="center"><em>h-shadow</em></th>
<th align="center">必需的。水平阴影的位置。允许负值</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><em>v-shadow</em></td>
<td align="center">必需的。垂直阴影的位置。允许负值</td>
</tr>
<tr>
<td align="center"><em>blur</em></td>
<td align="center">可选。模糊距离</td>
</tr>
<tr>
<td align="center"><em>spread</em></td>
<td align="center">可选。阴影的大小</td>
</tr>
<tr>
<td align="center"><em>color</em></td>
<td align="center">可选。阴影的颜色。</td>
</tr>
<tr>
<td align="center">inset</td>
<td align="center">可选。从外层的阴影（开始时）改变阴影内侧阴影</td>
</tr>
</tbody></table>
<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p>规定元素的定位类型。</p>
<table>
<thead>
<tr>
<th>absolute</th>
<th>生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</th>
</tr>
</thead>
<tbody><tr>
<td>fixed</td>
<td>生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</td>
</tr>
<tr>
<td>relative</td>
<td>生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。</td>
</tr>
<tr>
<td>static</td>
<td>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承 position 属性的值。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>项目小记</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>购物车结算系统-JS篇-项目小记</title>
    <url>/2022/01/07/%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%BB%93%E7%AE%97%E7%B3%BB%E7%BB%9F-JS%E7%AF%87-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="document"><a href="#document" class="headerlink" title="document"></a>document</h3><blockquote>
<p>借鉴：<a href="https://www.cnblogs.com/www1842564021/p/11830139.html">https://www.cnblogs.com/www1842564021/p/11830139.html</a></p>
</blockquote>
<ol>
<li><strong>document.getElementById()：返回对拥有指定 id 的第一个对象的引用。</strong></li>
<li><strong>document.getElementsByName()：返回带有指定名称的对象集合，也就是如果有多个相同name的元素，会返回数组。</strong></li>
<li><strong>document.getElementsByTagName()：返回带有指定标签名的对象集合。</strong></li>
<li><strong>document.getElementsByClassName()：返回对拥有指定 class 的对象集合。</strong></li>
</ol>
<span id="more"></span>

<h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><p>设置或返回密码域的默认值。</p>
<p>用法如：<code>document.getElementById(&quot;username&quot;).value</code>，返回结果为<strong>字符串</strong>。</p>
<h3 id="location-href"><a href="#location-href" class="headerlink" title="location.href"></a>location.href</h3><blockquote>
<p>借鉴：<a href="https://www.w3school.com.cn/js/js_window_location.asp">https://www.w3school.com.cn/js/js_window_location.asp</a></p>
</blockquote>
<p>一些类似的例子：</p>
<ul>
<li>window.location.href 返回当前页面的 href (URL)</li>
<li>window.location.hostname 返回 web 主机的域名</li>
<li>window.location.pathname 返回当前页面的路径或文件名</li>
<li>window.location.protocol 返回使用的 web 协议（http: 或 https:）</li>
<li>window.location.assign 加载新文档</li>
</ul>
<p>本项目将它与 &lt;form&gt; 表单的 <code>onsubmit</code> 方法连用，用于判断密码是否正确，如果正确跳转到指定的链接。</p>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">checkPassword</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">document</span>.getElementById(<span class="string">&quot;username&quot;</span>).value == <span class="string">&quot;&quot;</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          alert(<span class="string">&quot;用户名为空。&quot;</span>)</span><br><span class="line">      &#125;<span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">	location.href=<span class="string">&#x27;basic_info.jsp&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h3 id="alert"><a href="#alert" class="headerlink" title="alert"></a>alert</h3><blockquote>
<p>借鉴：<a href="https://www.w3school.com.cn/js/js_popup.asp">https://www.w3school.com.cn/js/js_popup.asp</a></p>
</blockquote>
<p>用于显示带有一条指定消息和一个 OK 按钮的警告框。</p>
<p>用法：<code>window.alert(&quot;I am an alert box!!&quot;)</code>，前缀 <code>window.</code> 可以省略不写。</p>
<p>类似的：</p>
<p><strong>confirm(“sometext”)</strong></p>
<p>确认框。如果用户单击“确定”，该框返回 true。如果用户单击“取消”，该框返回 false。</p>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = confirm(<span class="string">&quot;请按按钮&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (r == <span class="literal">true</span>) &#123;</span><br><span class="line">    x = <span class="string">&quot;您按了确认！&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    x = <span class="string">&quot;您按了取消！&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>prompt(“sometext”,”defaultText”)</strong></p>
<p>提示框。如果用户单击“确定”，该框返回输入值。如果用户单击“取消”，该框返回 NULL。</p>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = prompt(<span class="string">&quot;请输入您的姓名&quot;</span>, <span class="string">&quot;比尔盖茨&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (person != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>).innerHTML = <span class="string">&quot;你好 &quot;</span> + person + <span class="string">&quot;！今天过的怎么样？&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="for，if"><a href="#for，if" class="headerlink" title="for，if"></a>for，if</h3><p>和 java 一样。</p>
<p>不同的是，0 和 1 可以作为 false 和 true 使用。</p>
]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>购物车结算系统-Redis篇-项目小记</title>
    <url>/2022/02/18/%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%BB%93%E7%AE%97%E7%B3%BB%E7%BB%9F-Redis%E7%AF%87-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h3><blockquote>
<p>ClassNotFoundException: redis.clients.jedis.JedisPoolConfig</p>
</blockquote>
<p>就是没有找到类的意思。有两种可能：</p>
<ol>
<li><p>没有导包：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.9</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>没有put到tomcat中：</p>
<p>步骤：Project Structure -&gt; Artifacts -&gt; 在Available Elements中找到对应的包 -[右键] -&gt; Put into &#x2F;WEB-INF&#x2F;lib</p>
</li>
</ol>
]]></content>
      <categories>
        <category>项目小记</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>购物车结算系统-配置文件篇-项目小记</title>
    <url>/2022/01/11/%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%BB%93%E7%AE%97%E7%B3%BB%E7%BB%9F-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AF%87-%E9%A1%B9%E7%9B%AE%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="编写Properties文件"><a href="#编写Properties文件" class="headerlink" title="编写Properties文件"></a>编写Properties文件</h3><ol>
<li><p>文件名：<code>xxx.properties</code></p>
</li>
<li><p>内容格式：<code>key=value</code>，如 <code>driver=com.mysql.jdbc.Driver</code></p>
<p>如果 key 是多个单词组成，需要使用空格，可以使用反斜杠(\)对空格进行转移。如 <code>main form firstName=Stone</code> 可以修改为 <code>main\ form\ firstName=Stone</code></p>
</li>
</ol>
<span id="more"></span>



<h3 id="获取Properties文件的内容"><a href="#获取Properties文件的内容" class="headerlink" title="获取Properties文件的内容"></a>获取Properties文件的内容</h3><p>参考如下代码使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">      InputStream input;</span><br><span class="line">      String profile = <span class="string">&quot;jdbc.properties&quot;</span>;</span><br><span class="line">      <span class="comment">// 加载配置文件到输入流</span></span><br><span class="line">      input = DBUtil.class.getClassLoader().getResourceAsStream(profile);</span><br><span class="line">      <span class="comment">// 从输入流读取属性列表</span></span><br><span class="line">      pro.load(input);</span><br><span class="line">      <span class="comment">// 获取指定参数</span></span><br><span class="line">      String driver = pro.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">      String url = pro.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">      String username = pro.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">      String password = pro.getProperty(<span class="string">&quot;password&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>其中，需要将 <code>jdbc.properties</code> 文件放到 <code>resource</code> 目录下。</p>
]]></content>
      <categories>
        <category>项目小记</category>
      </categories>
      <tags>
        <tag>文件配置</tag>
      </tags>
  </entry>
  <entry>
    <title>非专业综合面试题</title>
    <url>/2022/01/29/%E9%9D%9E%E4%B8%93%E4%B8%9A%E7%BB%BC%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="面临压力最大的一次是什么时候，你是用什么方法解决的？"><a href="#面临压力最大的一次是什么时候，你是用什么方法解决的？" class="headerlink" title="面临压力最大的一次是什么时候，你是用什么方法解决的？"></a>面临压力最大的一次是什么时候，你是用什么方法解决的？</h3><h3 id="你说你能吃苦，具体体现在什么方面？"><a href="#你说你能吃苦，具体体现在什么方面？" class="headerlink" title="你说你能吃苦，具体体现在什么方面？"></a>你说你能吃苦，具体体现在什么方面？</h3><h3 id="怎样看待加班，能接受什么程度的加班情况？"><a href="#怎样看待加班，能接受什么程度的加班情况？" class="headerlink" title="怎样看待加班，能接受什么程度的加班情况？"></a>怎样看待加班，能接受什么程度的加班情况？</h3><h3 id="自我介绍（中英文）"><a href="#自我介绍（中英文）" class="headerlink" title="自我介绍（中英文）"></a>自我介绍（中英文）</h3><h3 id="期望薪资"><a href="#期望薪资" class="headerlink" title="期望薪资"></a>期望薪资</h3><h3 id="有没有男朋友"><a href="#有没有男朋友" class="headerlink" title="有没有男朋友"></a>有没有男朋友</h3><h3 id="岗位前后端介意吗"><a href="#岗位前后端介意吗" class="headerlink" title="岗位前后端介意吗"></a>岗位前后端介意吗</h3><h3 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h3><h3 id="未来两三年的规划"><a href="#未来两三年的规划" class="headerlink" title="未来两三年的规划"></a>未来两三年的规划</h3><h3 id="月底交付，时间赶，怎么处理风险问题"><a href="#月底交付，时间赶，怎么处理风险问题" class="headerlink" title="月底交付，时间赶，怎么处理风险问题"></a>月底交付，时间赶，怎么处理风险问题</h3>]]></content>
      <categories>
        <category>面试题</category>
      </categories>
  </entry>
  <entry>
    <title>Sqoop50题</title>
    <url>/2021/06/27/Sqoop50%E9%A2%98/</url>
    <content><![CDATA[<p>Sqoop导出操作</p>
<p>\1. 准备数据</p>
<span id="more"></span>

<p>CREATE TABLE student (</p>
<p>id int(11) DEFAULT NULL,</p>
<p>name varchar(100) DEFAULT NULL,</p>
<p>class varchar(100) DEFAULT NULL,</p>
<p>age int(11) DEFAULT NULL,</p>
<p>high varchar(10) DEFAULT NULL</p>
<p>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;latin1;</p>
<p>INSERT INTO student VALUES (‘1001’, ‘James’, ‘12’, ‘16’, ‘158’);</p>
<p>INSERT INTO student VALUES (‘1002’, ‘Mark’, ‘34’, ‘17’, ‘169’);</p>
<p>INSERT INTO student VALUES (‘1003’, ‘Henry’, ‘13’, ‘18’, ‘178’);</p>
<p>INSERT INTO student VALUES (‘1004’, ‘Kitte’, ‘24’, ‘17’, ‘175’);</p>
<p>INSERT INTO student VALUES (‘1005’, ‘Tom’, ‘23’, ‘20’, ‘180’);</p>
<p>使用sqoop把部分数据导入到HDFS的 &#x2F;MysqlToHDFS3 目录下,要求使用query sql语句查询，导入的字段为id,name,age,查询条件为age&gt;16,两个map，以id字段进行划分。语句是？</p>
<p>A.  bin&#x2F;sqoop import</p>
<p>–connect jdbc:mysql:&#x2F;&#x2F;192.168.10.10:3306&#x2F;userdb</p>
<p>–username root</p>
<p>–delete-target-dir</p>
<p>–target-dir &#x2F;MysqlToHDFS3</p>
<p>–query “select id,name,age from student WHERE age &gt; 16 and $CONDITIONS”</p>
<p>–split-by id</p>
<p>–fields-terminated-by ‘\t’</p>
<p>–num-mappers 2</p>
<p>B. bin&#x2F;sqoop import</p>
<p>–connect jdbc:mysql:&#x2F;&#x2F;192.168.10.10:3306&#x2F;userdb</p>
<p>–username root</p>
<p>–delete-target-dir</p>
<p>–target-dir &#x2F;MysqlToHDFS3</p>
<p>–query ‘select id,name,age from student WHERE age &gt; 16’</p>
<p>–split-by id</p>
<p>–fields-terminated-by ‘\t’</p>
<p>–num-mappers 2</p>
<p>C. bin&#x2F;sqoop import</p>
<p>–connect jdbc:mysql:&#x2F;&#x2F;192.168.10.10:3306&#x2F;userdb</p>
<p>–username root</p>
<p>–delete-target-dir</p>
<p>–target-dir &#x2F;MysqlToHDFS3</p>
<p>–query ‘select id,name,age from student WHERE age &gt; 16 and $CONDITIONS’</p>
<p>–split-by id</p>
<p>–fields-terminated-by ‘\t’</p>
<p>–m 2</p>
<p>D. bin&#x2F;sqoop import</p>
<p>–connect jdbc:mysql:&#x2F;&#x2F;192.168.10.10:3306&#x2F;userdb</p>
<p>–username root</p>
<p>–delete-target-dir</p>
<p>–target-dir &#x2F;MysqlToHDFS3</p>
<p>–query “select id,name,age from student WHERE age &gt; 16 and $CONDITIONS”</p>
<p>–split-by id</p>
<p>–fields-terminated-by ‘\t’</p>
<p>–m 2</p>
<p>参考答案C</p>
<p>2.阅读下面两个陈述：</p>
<p>A. 用Sqoop将关系型数据库中的数据导入Hive，当Hive中没有对应表时，则自动创建。</p>
<p>B. Sqoop命令create-hive-table可以生成与关系数据库表结构对应的hive表结构。</p>
<p>A.A 错B 错</p>
<p>B.A 错 B 对 </p>
<p>C.A 对 B 对 </p>
<p>D.A 对 B 错</p>
<p>参考答案C</p>
<p>3.______工具将文件从HDFS传输到RDBMS</p>
<p>A. export</p>
<p>B. transfer</p>
<p>C. import</p>
<p>D. output</p>
<p>参考答案A</p>
<p>\4. 关于Sqoop说法正确的是？</p>
<p>A.可以列出关系型数据库的某个说数据库下的所有表</p>
<p>B.可以列出关系型数据库的所有数据库</p>
<p>C.以上都是</p>
<p>D.可以执行SQL语句</p>
<p>参考答案C</p>
<p>\5. 下面哪个场景适合使用Sqoop？</p>
<p>A.将HDFS数据传输到Oracle数据库中</p>
<p>B.将服务器日志传输到Kafka消息中间件中</p>
<p>C.将Kafka主题的消息传输到HDFS</p>
<p>D.将一个MySQL服务器数据同步到另外一个MySQL服务器中</p>
<p>参考答案A</p>
<p>\6. ___ 就是只导入表中新添加的记录的导入方式。</p>
<p>A减量导入</p>
<p>B.全量导入</p>
<p>C.以上都不对</p>
<p>D.增量导入</p>
<p>参考答案D</p>
<p>7.Sqoop导出操作失败的原因可能是？</p>
<p>A. RAM不足</p>
<p>B. 磁盘空间不足</p>
<p>C. 以上都是</p>
<p>D.使用错误的定界符解析记录</p>
<p>参考答案C</p>
<p>\8. Sqoop将导入或导出命令翻译成MapReduce程序，而MapReduce 中主要是对_______和______进行定制</p>
<p>A.以上都不对</p>
<p>B. InputText, OutputText</p>
<p>C. InputFormat, OutputFormat</p>
<p>D. InputTextFormat, OutputTextFormat</p>
<p>参考答案C</p>
<p>9.在使用Sqoop导入数据到hive时，添加那个属性可以去掉数据中的\r\n\013\010这样的字符?</p>
<p>A. –input-lines-terminated-by</p>
<p>B. –hive-delims-replacement </p>
<p>C. –hive-drop-import-delims</p>
<p>D. –input-lines-terminated-by</p>
<p>参考答案C</p>
<p>\10. 导入MySQL数据库dbtest下emp表数据到HDFS语句正确的是？</p>
<p>A. sqoop-import –connect jdbc:mysql:&#x2F;&#x2F;node01:3306&#x2F;dbtest –password 123456 –username root –schema emp -m 1</p>
<p>B. sqoop-import –connect jdbc:mysql:&#x2F;&#x2F;node01:3306&#x2F;dbtest –password 123456 –username root –table emp -m 1</p>
<p>C. sqoop export –connect jdbc:mysql:&#x2F;&#x2F;node01:3306&#x2F;dbtest –password 123456 –username root –table emp -m 1</p>
<p>D. sqoop export –connect jdbc:mysql:&#x2F;&#x2F;node01:3306&#x2F;dbtest –password 123456 –username root –schema emp -m 1</p>
<p>参考答案B</p>
<p>\11. 默认情况下，Sqoop将在导出过程中并行使用____个任务。</p>
<p>A.4</p>
<p>B.2</p>
<p>C.3</p>
<p>D.1</p>
<p>参考答案A</p>
<p>12.A. Sqoop可以保存作业反复执行</p>
<p>B. sqoop在创建job时，使用–password-file参数，可以避免输入mysql密码, 而是从本地文件系统的指定文件获取密码</p>
<p>A.A 错 B 错</p>
<p>B.A 错 B 对 </p>
<p>C.A 对 B 对 </p>
<p>D.A 对 B 错</p>
<p>参考答案D</p>
<p>13.对于Sqoop导出控制参数，说明正确的是？</p>
<p>A. –input-null-string 字符串列将被解释为null的字符串表示</p>
<p>B. –input-null-non-string 非字符串列将被解释为null的字符串</p>
<p>C. –table 可以不指定</p>
<p>D. –export-dir 可以不指定</p>
<p>参考答案C</p>
<p>\14. Sqoop导出操作失败的原因可能是？</p>
<p>A.以上都是</p>
<p>B. Hadoop集群与数据库之间的连接丢失</p>
<p>C.尝试从HDFS源数据中解析不完整或格式不正确的记录</p>
<p>D.尝试在关系型数据库中插入违反一致性约束的记录</p>
<p>参考答案A</p>
<p>\15. 关于sqoop的导出操作说法错误的是？</p>
<p>A.默认导出操作是转换为UPDATE语句实现的</p>
<p>B.可以使用命令 sqoop-export实现导出</p>
<p>C.导出的目标表必须已经存在于数据库中</p>
<p>D.可以使用命令 sqoop export实现导出</p>
<p>参考答案A</p>
<p>Sqoop介绍和导入操作</p>
<p>1.Sqoop Import 命令中如果没有制定 -m 或者 –num-mappers 参数，则默认的mapper任务数量为？</p>
<p>A.4</p>
<p>B.2</p>
<p>C.3</p>
<p>D.1</p>
<p>参考答案A</p>
<p>\2. 哪个选项不会是下面这个命令执行失败的原因？</p>
<p>sqoop import \</p>
<p>–connect jdbc:mysql:&#x2F;&#x2F;192.168.186.100:3306&#x2F;test \</p>
<p>–username root \</p>
<p>–password niit1234 \</p>
<p>–table message \</p>
<p>–delete-target-dir \</p>
<p>–target-dir &#x2F;sqoop&#x2F;result \</p>
<p>-m 1</p>
<p>A.导入的目标路径里面已经有文件存在</p>
<p>B.没有配置环境变量</p>
<p>C. Hadoop文件系统服务资源不足</p>
<p>D. MySQL用户root没有配置远程访问</p>
<p>参考答案A</p>
<p>3.在sqoop导入命令中，中的有关–split-by参数的用途说法正确的是 ？</p>
<p>A:如果指定了主键，默认按照主键进行分片</p>
<p>B:如果没有指定主键，则必须指定–split-by才能实现分片</p>
<p>A.A对B对</p>
<p>B.A对B错</p>
<p>C.B对A错</p>
<p>D.A错B错</p>
<p>参考答案A</p>
<p>\4. 关于Apache Sqoop 的版本说法正确的是 ？</p>
<p>A.只有 Sqoop 2 可以用于生产环境</p>
<p>B. Sqoop 1 和 Sqoop 2 都可以用于生产环境</p>
<p>C. Sqoop 1 和 Sqoop 2 都不可以用于生产环境</p>
<p>D.只有 Sqoop 1 可以用于生产环境</p>
<p>参考答案D</p>
<p>\5. sqoop导入到Hive的数据。默认的行分隔符为？</p>
<p>A.”\t”</p>
<p>B.”\001”</p>
<p>C.”\012”</p>
<p>D.”,”</p>
<p>参考答案C</p>
<p>\6. 使用Sqoop导入到Hive时，如果没有指定Hive表名会怎么样？</p>
<p>A.默认会在Hive中创建和MySQL同名的数据库和表</p>
<p>B.以上都不对</p>
<p>C.默认会在Hive中创建和MySQL同名的表，数据库需要另外指定</p>
<p>D.报错，必须指定表名</p>
<p>参考答案C</p>
<p>7.使用Sqoop工具将MySQL数据传送到HDFS文件系统应该使用什么命令 ？</p>
<p>A. sqoop export</p>
<p>B. sqoop transfer</p>
<p>C. sqoop transport</p>
<p>D. sqoop import</p>
<p>参考答案D</p>
<p>\8. Apache Sqoop 是一款____的工具，主要用于数据的____？</p>
<p>A.开源、采集</p>
<p>B.开源、传输</p>
<p>C.闭源、采集</p>
<p>D.闭源、传输</p>
<p>参考答案B</p>
<p>9.如何使用Sqoop导入关系型数据库中某个表的满足某个条件下的记录中的部分列数据到HDFS中 ？</p>
<p>A.以上都不对</p>
<p>B.指定–where</p>
<p>C.指定–query</p>
<p>D.指定–columns</p>
<p>参考答案C</p>
<p>10.Sqoop导入命令中，如何修改字段分隔符为制表符？</p>
<p>A. –fields-terminated-by &#x3D; ‘&#x2F;t’</p>
<p>B. –fields-terminated-by &#x3D; ‘\t’</p>
<p>C. –fields-terminated-by ‘\t’</p>
<p>D. –fields-terminated-by ‘&#x2F;t’</p>
<p>参考答案C</p>
<p>\11. 使用Sqoop还可以 ____ ?</p>
<p>A.连接关系型数据库并执行SQL语句</p>
<p>B.列出关系型数据库的某个数据库下的所有表</p>
<p>C.以上都是</p>
<p>D.列出关系型数据库的所有数据库</p>
<p>参考答案C</p>
<p>\12. 关于增量导入：</p>
<p>说法A：只能由一个列作为检查列 –check-column</p>
<p>说法B：必须指定 –last-value</p>
<p>A.A对B对</p>
<p>B.A错B错</p>
<p>C.A错B对</p>
<p>D.A对B错</p>
<p>参考答案C</p>
<p>\13. sqoop导入到Hive的数据。默认的列分隔符为？</p>
<p>A.”\t”</p>
<p>B.”\001”</p>
<p>C.”\012”</p>
<p>D.”,”</p>
<p>参考答案B</p>
<p>14.在Linux系统中配置Sqoop环境变量的方式正确的是 ？</p>
<p>A. export $SQOOP_HOME&#x3D;&#x2F;home&#x2F;soft&#x2F;sqoop-1.4.6.bin_hadoop-2.0.4-alpha</p>
<p>export PATH&#x3D;$PATH:$SQOOP_HOME&#x2F;bin</p>
<p>B. export SQOOP_HOME&#x3D;&#x2F;home&#x2F;soft&#x2F;sqoop-1.4.6.bin_hadoop-2.0.4-alpha</p>
<p>export PATH&#x3D;$PATH:$SQOOP_HOME&#x2F;bin</p>
<p>C. export SQOOP_HOME&#x3D;&#x2F;home&#x2F;soft&#x2F;sqoop-1.4.6.bin_hadoop-2.0.4-alpha</p>
<p>export $PATH&#x3D;$PATH:$SQOOP_HOME&#x2F;bin</p>
<p>D. export SQOOP_HOME&#x3D;&#x2F;home&#x2F;soft&#x2F;sqoop-1.4.6.bin_hadoop-2.0.4-alpha</p>
<p>export PATH&#x3D;PATH:$SQOOP_HOME&#x2F;bin</p>
<p>参考答案B</p>
<p>15.下面哪个选项是属于Sqoop import ？</p>
<p>A.将Oracle数据库中的数据保存到Hive表中</p>
<p>B.将MongoDB数据库中的数据传输到HDFS文件系统</p>
<p>C.将HBase数据库中的数据转存到Hive表中</p>
<p>D.将Storm中拓扑处理的数据持久化到HBase数据库中</p>
<p>参考答案A</p>
<p>16.Sqoop导入数据的方式有？</p>
<p>A.以上都对</p>
<p>B.部分导入</p>
<p>C.全量导入</p>
<p>D.增量导入</p>
<p>参考答案A</p>
<p>\17. 如何使用sqoop import 导入部分记录？</p>
<p>A. –columns</p>
<p>B. –where</p>
<p>C以上都是</p>
<p>D. –query</p>
<p>参考答案C</p>
<p>18.sqoop导入到HDFS中的所有记录存储为____格式。</p>
<p>A.以上都不对</p>
<p>B.文本格式</p>
<p>C.二进制</p>
<p>D.十六进制</p>
<p>参考答案B</p>
<p>\1. 根据时间上晚于某列来进行数据增量导入，应使用____类型的增量模式配合_____属性</p>
<p>A.append –last-value</p>
<p>B.append –last-time</p>
<p>C.lastmodified –last-value</p>
<p>D.lastmodified –last-time</p>
<p>参考答案C</p>
<p>2.根据自增数值型主键进行增量导入，应使用____类型的增量模式配合_____属性</p>
<p>A.append –last-value</p>
<p>B.append –last-time</p>
<p>C.lastmodified –last-value</p>
<p>D.lastmodified –last-time</p>
<p>参考答案A</p>
<p>3.增量导入的check-colume参数是指？</p>
<p>A.设置作为增量导入检查依据的列，只能指定1列</p>
<p>B.设置作为增量导入检查依据的列，可以指定多列</p>
<p>C.指定增量导入的实际列，只能指定1列</p>
<p>D.指定增量导入的实际列，可以指定多列</p>
<p>参考答案B</p>
<p>4.Sqoop从MySQL到HDFS传输数据属于___________, 使用Sqoop从HDFS到MySQL传输数据属于________</p>
<p>A.导入，导出    </p>
<p>B.导出，导入</p>
<p>回答正确，得分 2</p>
<p>参考答案A</p>
<p>\5. A. Sqoop可以保存作业反复执行</p>
<p>B. sqoop在创建job时，使用–password-file参数，可以避免输入mysql密码, 而是从本地文件系统的指定文件获取密码</p>
<p>A.A 对 B 错</p>
<p>B.A 错 B 对 </p>
<p>C.A 错 B 错</p>
<p>D.A 对 B 对 </p>
<p>参考答案A</p>
<p>\6. 准备数据</p>
<p>CREATE TABLE student (</p>
<p>id int(11) DEFAULT NULL,</p>
<p>name varchar(100) DEFAULT NULL,</p>
<p>class varchar(100) DEFAULT NULL,</p>
<p>age int(11) DEFAULT NULL,</p>
<p>high varchar(10) DEFAULT NULL</p>
<p>) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;latin1;</p>
<p>INSERT INTO student VALUES (‘1001’, ‘James’, ‘12’, ‘16’, ‘158’);</p>
<p>INSERT INTO student VALUES (‘1002’, ‘Mark’, ‘34’, ‘17’, ‘169’);</p>
<p>INSERT INTO student VALUES (‘1003’, ‘Henry’, ‘13’, ‘18’, ‘178’);</p>
<p>INSERT INTO student VALUES (‘1004’, ‘Kitte’, ‘24’, ‘17’, ‘175’);</p>
<p>INSERT INTO student VALUES (‘1005’, ‘Tom’, ‘23’, ‘20’, ‘180’);</p>
<p>使用sqoop把部分数据导入到HDFS的 &#x2F;MysqlToHDFS3 目录下,要求使用query sql语句查询，导入的字段为id,name,age,查询条件为age&gt;16,两个map，以id字段进行划分。语句是？</p>
<p>A.bin&#x2F;sqoop import</p>
<p>–connect jdbc:mysql:&#x2F;&#x2F;192.168.10.10:3306&#x2F;userdb</p>
<p>–username root</p>
<p>–delete-target-dir</p>
<p>–target-dir &#x2F;MysqlToHDFS3</p>
<p>–query ‘select id,name,age from student WHERE age &gt; 16 and $CONDITIONS’</p>
<p>–split-by id</p>
<p>–fields-terminated-by ‘\t’</p>
<p>–m 2</p>
<p>B.bin&#x2F;sqoop import</p>
<p>–connect jdbc:mysql:&#x2F;&#x2F;192.168.10.10:3306&#x2F;userdb</p>
<p>–username root</p>
<p>–delete-target-dir</p>
<p>–target-dir &#x2F;MysqlToHDFS3</p>
<p>–query “select id,name,age from student WHERE age &gt; 16 and $CONDITIONS”</p>
<p>–split-by id</p>
<p>–fields-terminated-by ‘\t’</p>
<p>–m 2</p>
<p>C.bin&#x2F;sqoop import</p>
<p>–connect jdbc:mysql:&#x2F;&#x2F;192.168.10.10:3306&#x2F;userdb</p>
<p>–username root</p>
<p>–delete-target-dir</p>
<p>–target-dir &#x2F;MysqlToHDFS3</p>
<p>–query “select id,name,age from student WHERE age &gt; 16 and $CONDITIONS”</p>
<p>–split-by id</p>
<p>–fields-terminated-by ‘\t’</p>
<p>–num-mappers 2</p>
<p>D.bin&#x2F;sqoop import</p>
<p>–connect jdbc:mysql:&#x2F;&#x2F;192.168.10.10:3306&#x2F;userdb</p>
<p>–username root</p>
<p>–delete-target-dir</p>
<p>–target-dir &#x2F;MysqlToHDFS3</p>
<p>–query ‘select id,name,age from student WHERE age &gt; 16’</p>
<p>–split-by id</p>
<p>–fields-terminated-by ‘\t’</p>
<p>–num-mappers 2</p>
<p>参考答案A</p>
<p>\7. 关于Sqoop说法正确的是？</p>
<p>A.可以列出关系型数据库的所有数据库</p>
<p>B.可以列出关系型数据库的某个说数据库下的所有表</p>
<p>C.可以执行SQL语句</p>
<p>D.以上都是</p>
<p>参考答案D</p>
<p>\8. 阅读下面两个陈述：</p>
<p>A. 用Sqoop将关系型数据库中的数据导入Hive，当Hive中没有对应表时，则自动创建。</p>
<p>B. Sqoop命令create-hive-table可以生成与关系数据库表结构对应的hive表结构。</p>
<p>A.A 对 B 错</p>
<p>B.A 错 B 对 </p>
<p>C.A 对 B 对 </p>
<p>D.A 错B 错</p>
<p>参考答案C</p>
<p>\9. 在使用Sqoop导入数据到hive时，添加那个属性可以去掉数据中的\r\n\013\010这样的字符?</p>
<p>A.–hive-delims-replacement </p>
<p>B.–hive-drop-import-delims</p>
<p>C.–input-lines-terminated-by</p>
<p>D.–input-lines-terminated-by</p>
<p>参考答案B</p>
<p>10.导入MySQL数据库dbtest下emp表数据到HDFS语句正确的是？</p>
<p>A.sqoop export –connect jdbc:mysql:&#x2F;&#x2F;node01:3306&#x2F;dbtest –password 123456 –username root –table emp -m 1</p>
<p>B.sqoop-import –connect jdbc:mysql:&#x2F;&#x2F;node01:3306&#x2F;dbtest –password 123456 –username root –table emp -m 1</p>
<p>C.sqoop-import –connect jdbc:mysql:&#x2F;&#x2F;node01:3306&#x2F;dbtest –password 123456 –username root –schema emp -m 1</p>
<p>D.sqoop export –connect jdbc:mysql:&#x2F;&#x2F;node01:3306&#x2F;dbtest –password 123456 –username root –schema emp -m 1</p>
<p>参考答案B</p>
<p>\11. 下面哪个场景适合使用Sqoop？</p>
<p>A.将服务器日志传输到Kafka消息中间件中</p>
<p>B.将一个MySQL服务器数据同步到另外一个MySQL服务器中</p>
<p>C.将HDFS数据传输到Oracle数据库中</p>
<p>D.将Kafka主题的消息传输到HDFS</p>
<p>参考答案C</p>
<p>\12. Sqoop将导入或导出命令翻译成MapReduce程序，而MapReduce 中主要是对_______和______进行定制</p>
<p>A.InputText, OutputText</p>
<p>B.InputTextFormat, OutputTextFormat</p>
<p>C.InputFormat, OutputFormat</p>
<p>D.以上都不对</p>
<p>参考答案C</p>
<p>13.___ 就是只导入表中新添加的记录的导入方式。</p>
<p>A.全量导入</p>
<p>B.增量导入</p>
<p>C.减量导入</p>
<p>D.以上都不对</p>
<p>参考答案B</p>
<p>\14. Sqoop导出操作失败的原因可能是？</p>
<p>A.Hadoop集群与数据库之间的连接丢失</p>
<p>B.尝试在关系型数据库中插入违反一致性约束的记录</p>
<p>C.尝试从HDFS源数据中解析不完整或格式不正确的记录</p>
<p>D.以上都是</p>
<p>参考答案D</p>
<p>\15. 默认情况下，Sqoop将在导出过程中并行使用____个任务。</p>
<p>A.1</p>
<p>B.2</p>
<p>C.3</p>
<p>D.4</p>
<p>参考答案D</p>
<p>\16. 对于Sqoop导出控制参数，说明正确的是？</p>
<p>A.–input-null-string 非字符串列将被解释为null的字符串</p>
<p>B.–input-null-non-string 字符串列将被解释为null的字符串表示</p>
<p>C.–export-dir 可以不指定</p>
<p>D.–table 可以不指定</p>
<p>参考答案D</p>
<p>\17. 关于sqoop的导出操作说法错误的是？</p>
<p>A.导出的目标表必须已经存在于数据库中</p>
<p>B.可以使用命令 sqoop export实现导出</p>
<p>C.可以使用命令 sqoop-export实现导出</p>
<p>D.默认导出操作是转换为UPDATE语句实现的</p>
<p>参考答案D</p>
<p>\18. ______工具将文件从HDFS传输到RDBMS</p>
<p>A.import</p>
<p>B.export</p>
<p>C.output</p>
<p>D.transfer</p>
<p>参考答案B</p>
<p>\19. 关于增量导入：</p>
<p>说法A：</p>
<p>只能由一个列作为检查列 –check-column</p>
<p>说法B：</p>
<p>必须指定 –last-value</p>
<p>A.A对B错</p>
<p>B.A错B对</p>
<p>C.A对B对</p>
<p>D.A错B错</p>
<p>参考答案B</p>
<p>\20. 如何使用sqoop import 导入部分记录？</p>
<p>A.–query</p>
<p>B.–where</p>
<p>C.–columns</p>
<p>D.以上都是</p>
<p>参考答案D</p>
<p>\21. 哪个选项不会是下面这个命令执行失败的原因？</p>
<p>sqoop import \</p>
<p>–connect jdbc:mysql:&#x2F;&#x2F;192.168.186.100:3306&#x2F;test \</p>
<p>–username root \</p>
<p>–password niit1234 \</p>
<p>–table message \</p>
<p>–delete-target-dir \</p>
<p>–target-dir &#x2F;sqoop&#x2F;result \</p>
<p>-m 1</p>
<p>A.没有配置环境变量</p>
<p>B.MySQL用户root没有配置远程访问</p>
<p>C.导入的目标路径里面已经有文件存在</p>
<p>D.Hadoop文件系统服务资源不足</p>
<p>参考答案C</p>
<p>22.如何使用Sqoop导入关系型数据库中某个表的满足某个条件下的记录中的部分列数据到HDFS中 ？</p>
<p>A.指定–where</p>
<p>B.指定–query</p>
<p>C.指定–columns</p>
<p>D.以上都不对</p>
<p>参考答案B</p>
<p>\23. 在sqoop导入命令中，中的有关–split-by参数的用途说法正确的是 ？</p>
<p>A:如果指定了主键，默认按照主键进行分片</p>
<p>B:如果没有指定主键，则必须指定–split-by才能实现分片</p>
<p>A.A对B错</p>
<p>B.B对A错</p>
<p>C.A对B对</p>
<p>D.A错B错</p>
<p>参考答案C</p>
<p>\24. 使用Sqoop导入到Hive时，如果没有指定Hive表名会怎么样？</p>
<p>A.报错，必须指定表名</p>
<p>B.默认会在Hive中创建和MySQL同名的数据库和表</p>
<p>C.默认会在Hive中创建和MySQL同名的表，数据库需要另外指定</p>
<p>D.以上都不对</p>
<p>参考答案C</p>
<p>\25. sqoop导入到Hive的数据。默认的行分隔符为？</p>
<p>A.”,”</p>
<p>B.”\t”</p>
<p>C.”\001”</p>
<p>D.”\012”</p>
<p>参考答案D</p>
<p>\26. sqoop导入到Hive的数据。默认的列分隔符为？</p>
<p>A.”,”</p>
<p>B.”\t”</p>
<p>C.”\012”</p>
<p>D.”\001”</p>
<p>参考答案D</p>
<p>\27. Sqoop导入命令中，如何修改字段分隔符为制表符？</p>
<p>A.–fields-terminated-by &#x3D; ‘\t’</p>
<p>B.–fields-terminated-by ‘\t’</p>
<p>C.–fields-terminated-by &#x3D; ‘&#x2F;t’</p>
<p>D.–fields-terminated-by ‘&#x2F;t’</p>
<p>参考答案B</p>
<p>\28. Sqoop导入数据的方式有？</p>
<p>A.全量导入</p>
<p>B.增量导入</p>
<p>C.部分导入</p>
<p>D.以上都对</p>
<p>参考答案D</p>
<p>\29. sqoop导入到HDFS中的所有记录存储为____格式。</p>
<p>A.二进制</p>
<p>B.十六进制</p>
<p>C.文本格式</p>
<p>D.以上都不对</p>
<p>参考答案C</p>
<p>\30. Sqoop Import 命令中如果没有制定 -m 或者 –num-mappers 参数，则默认的mapper任务数量为？</p>
<p>A.1</p>
<p>B.2</p>
<p>C.3</p>
<p>D.4</p>
<p>参考答案D</p>
<p>31.使用Sqoop还可以 ____ ?</p>
<p>A.列出关系型数据库的所有数据库</p>
<p>B.列出关系型数据库的某个数据库下的所有表</p>
<p>C.连接关系型数据库并执行SQL语句</p>
<p>D.以上都是</p>
<p>参考答案D</p>
<p>\32. 在Linux系统中配置Sqoop环境变量的方式正确的是 ？</p>
<p>A.export SQOOP_HOME&#x3D;&#x2F;home&#x2F;soft&#x2F;sqoop-1.4.6.bin_hadoop-2.0.4-alpha</p>
<p>export $PATH&#x3D;$PATH:$SQOOP_HOME&#x2F;bin</p>
<p>B.export $SQOOP_HOME&#x3D;&#x2F;home&#x2F;soft&#x2F;sqoop-1.4.6.bin_hadoop-2.0.4-alpha</p>
<p>export PATH&#x3D;$PATH:$SQOOP_HOME&#x2F;bin</p>
<p>C.export SQOOP_HOME&#x3D;&#x2F;home&#x2F;soft&#x2F;sqoop-1.4.6.bin_hadoop-2.0.4-alpha</p>
<p>export PATH&#x3D;PATH:$SQOOP_HOME&#x2F;bin</p>
<p>D.export SQOOP_HOME&#x3D;&#x2F;home&#x2F;soft&#x2F;sqoop-1.4.6.bin_hadoop-2.0.4-alpha</p>
<p>export PATH&#x3D;$PATH:$SQOOP_HOME&#x2F;bin</p>
<p>回答错误，得分 0</p>
<p>参考答案D</p>
<p>\33. 关于Apache Sqoop 的版本说法正确的是 ？</p>
<p>A.只有 Sqoop 1 可以用于生产环境</p>
<p>B.只有 Sqoop 2 可以用于生产环境</p>
<p>C.Sqoop 1 和 Sqoop 2 都可以用于生产环境</p>
<p>D.Sqoop 1 和 Sqoop 2 都不可以用于生产环境</p>
<p>参考答案A</p>
<p>\34. 使用Sqoop工具将MySQL数据传送到HDFS文件系统应该使用什么命令 ？</p>
<p>A.sqoop import</p>
<p>B.sqoop export</p>
<p>C.sqoop transfer</p>
<p>D.sqoop transport</p>
<p>参考答案A</p>
<p>\35. 下面哪个选项是属于Sqoop import ？</p>
<p>A.将HBase数据库中的数据转存到Hive表中</p>
<p>B.将Storm中拓扑处理的数据持久化到HBase数据库中</p>
<p>C.将MongoDB数据库中的数据传输到HDFS文件系统</p>
<p>D.将Oracle数据库中的数据保存到Hive表中</p>
<p>参考答案D</p>
<p>\36. Apache Sqoop 是一款____的工具，主要用于数据的____？</p>
<p>A.闭源、采集</p>
<p>B.开源、采集</p>
<p>C.闭源、传输</p>
<p>D.开源、传输</p>
<p>参考答案D</p>
<p>\37. 选出不属于RDBMS的数据库</p>
<p>A.MySQL</p>
<p>B.MongoDB</p>
<p>C.Redis</p>
<p>D.HBase</p>
<p>参考答案BCD</p>
<p>\38. sqoop import 包括从____到____</p>
<p>A.HBase -&gt; HDFS</p>
<p>B.Hive -&gt; HDFS</p>
<p>C.MySQL -&gt; HIVE</p>
<p>D.Oracle -&gt; HDFS</p>
<p>参考答案CD</p>
<p>\39. Sqoop工具中最核心的是____和_____</p>
<p>A.import</p>
<p>B.export</p>
<p>C.job</p>
<p>D.help</p>
<p>参考答案AB</p>
<p>\40. 增量导入必须指定last-value属性值</p>
<p>对</p>
<p>错</p>
<p>参考答案对</p>
<p>41.MySQL表用SQOOP传输到HDFS后默认字段分割符号是逗号</p>
<p>对</p>
<p>错</p>
<p>参考答案对</p>
<p>\42. 导入HDFS操作时，可以同时指定target-dir和warehouse-dir属性。</p>
<p>对</p>
<p>错</p>
<p>参考答案错</p>
<p>\43. 使用sqoop job工具，命令如下，可以立即执行一个导入操作。</p>
<p>sqoop job –create sqoopimport1 – import –connect jdbc:mysql:</p>
<p>对</p>
<p>错</p>
<p>参考答案错</p>
<p>\44. Sqoop工具适用于数据库管理员、数据分析师和数据工程师。</p>
<p>对</p>
<p>错</p>
<p>参考答案对</p>
<p>\45. Sqoop可以用于关系型数据库之间的数据传输。</p>
<p>对</p>
<p>错</p>
<p>参考答案错</p>
<p>\46. Sqoop导入命令中使用_______________属性可以修改字段分隔符</p>
<p>参考答案–fields-terminated-by</p>
<p>\47. HIVE表的默认字段分隔符是”<em>“，Hive表的默认记录分隔符是”</em>“</p>
<p>47.1</p>
<p>参考答案\001;CTRL+A;SOH;^A</p>
<p>47.2</p>
<p>参考答案\012;\N;\n</p>
<p>\48. Sqoop import 工具指定数据传输到HDFS的目标路径用_________属性。</p>
<p>参考答案–target-dir</p>
<p>49.SQOOP传输数据到HDFS时，如果需要预先清空目标路径再执行数据传输可以使用__________属性</p>
<p>参考答案–delete-target-dir</p>
<p>\50. Apache Sqoop 是一款____的工具，主要用于数据的____</p>
<p>50.1</p>
<p>参考答案开源;开放源代码</p>
<p>50.2</p>
<p>参考答案传输;导入导出</p>
]]></content>
      <tags>
        <tag>sqoop</tag>
      </tags>
  </entry>
  <entry>
    <title>hadoop - 面试题</title>
    <url>/2021/08/03/hadoop-%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="hadoop解决哪些问题，有哪些特性"><a href="#hadoop解决哪些问题，有哪些特性" class="headerlink" title="hadoop解决哪些问题，有哪些特性"></a>hadoop解决哪些问题，有哪些特性</h3><ol>
<li><p>主要用于解决海量数据的存储和分析计算的问题。</p>
</li>
<li><p>特性有如下四个：</p>
<p>（1）高可靠性：hadoop底层维护多个数据副本，即使某个节点的计算出现问题或存储出现故障，数据也不会丢失；</p>
<p>（2）高扩展性：天然支持分布式，可以方便地扩展出几千个节点；</p>
<p>（3）高效性：在mapreduce的思想中，hadoop是并行工作的，这就提高了任务的处理效率；</p>
<p>（4）高容错性：可以自动将运行失败的任务重新分配到新的节点运行。</p>
</li>
</ol>
<span id="more"></span>

<h3 id="hadoop的版本区别"><a href="#hadoop的版本区别" class="headerlink" title="hadoop的版本区别"></a>hadoop的版本区别</h3><p>1.x的版本包含辅助工具，hdfs和mapreduce。其中hdfs负责数据存储，mapreduce负责数据计算和资源调度。</p>
<p>2.x的版本与1.x版本大致相同，唯一的区别在于将mapreduce的任务一分为二，mapreduce继续负责数据的运算，将资源调度的任务分配给yarn框架。</p>
<h3 id="常用端口号"><a href="#常用端口号" class="headerlink" title="常用端口号"></a>常用端口号</h3><p>hadoop2：</p>
<ol>
<li>HDFS NameNode内部通信端口：8020、9000；</li>
<li>HDFS NameNode的用户查询端口：50070；</li>
<li>Yarn查询任务运行情况端口：8080；</li>
<li>查看历史服务器：19888.</li>
</ol>
<p>hadoop3：</p>
<ol>
<li>NameNode内部通信端口：8020、9000、9820；</li>
<li>NameNode对用户开放的查询端口：9870；</li>
<li>Yarn查询任务运行情况端口：8080；</li>
<li>查看历史服务器端口：19888.</li>
</ol>
<h3 id="常用的配置文件"><a href="#常用的配置文件" class="headerlink" title="常用的配置文件"></a>常用的配置文件</h3><p>2.x：hdfs-site.xml、mapred-site.xml、yarn-site.xml、core-site.xml、slaves；</p>
<p>3.x：hdfs-site.xml、mapred-site.xml、core-site.xml、yarn-site.xml、workers。</p>
<h3 id="HDFS相关"><a href="#HDFS相关" class="headerlink" title="HDFS相关"></a>HDFS相关</h3><h4 id="组成架构"><a href="#组成架构" class="headerlink" title="组成架构"></a>组成架构</h4><ol>
<li>NameNode：用于存储文件的元数据，比如文件名、文件目录结构、文件的块列表以及块所在的datanode等，并处理客户端的读写请求。</li>
<li>DataNode：存储实际的数据块，并执行数据块的读写操作。</li>
<li>SecondaryNameNode：它不是NameNode的热备，不能在NameNode挂掉时进行替换，而是辅助NameNode，分担其工作量，比如定期合并fsimage和edits，在NameNode挂掉时辅助恢复NameNode。</li>
</ol>
<h4 id="机架感知机制（副本节点的选择）"><a href="#机架感知机制（副本节点的选择）" class="headerlink" title="机架感知机制（副本节点的选择）"></a>机架感知机制（副本节点的选择）</h4><p>默认情况下是三个副本，可以通过dfs.replication参数修改副本数。该参数的范围是1-16，修改后需要重启hdfs。</p>
<p>默认三个副本的情况下，第一个副本存储在客户端所在的节点上 <code>localstorage</code>，如果客户端不在集群中，就任意选择一个；第二个副本保存在和第一副本不同机架的节点上 <code>chooseremoterack</code>；第三个副本保存在与第二个副本相同的机架的不同节点中，会先判断前两个副本是否在一个机架，为了保证数据的可靠性，副本需要存储在至少两个机架上；如果前两个副本不在同一机架，就将该副本存到第二副本相同机架的不同节点上，因为在保证可靠性的同时，也需要兼顾效率，同一机架的效率比跨机架的效率要高一些。</p>
<h4 id="NameNode和SecondaryNameNode运行机制"><a href="#NameNode和SecondaryNameNode运行机制" class="headerlink" title="NameNode和SecondaryNameNode运行机制"></a>NameNode和SecondaryNameNode运行机制</h4><p>​        首先已知元数据信息被存储在NameNode节点的磁盘中，因此如果频繁的进行读写请求，会导致NameNode的处理效率变低。但是如果将其存储在内存中，那么一旦出现断电，元数据会因为无法及时保存到磁盘而导致数据丢失。于是引入了fsimage，将元数据存储在内存，并备份到磁盘的fsimage中。</p>
<p>​        但是这里又会出现一个新的问题：如果将元数据保存到内存的时候，同步备份到fsimage，同样会造成NameNode的效率变低；但如果不同步进行，一旦出现断电等情况，内存中的元数据依然会丢失。于是又引入了edits文件。edits只执行追加操作，将数据的变更操作写入edits，这样断电重启的时候就可以直接合并，形成完整的元数据信息。</p>
<p>​        但是这种合并需要定期执行，否则edits的数据量过大也会导致执行效率变低。如果使用NameNode负责定期合并的操作，会加大NameNode的处理压力，所以引入了SecondaryNameNode来执行定期合并的操作。它的定期将fsimage和edits文件合并生成一个新的fsimage.chkpoint文件，然后拷贝到NameNode中，NameNode会将其重命名为fsimage。</p>
<h4 id="HDFS中小文件的处理"><a href="#HDFS中小文件的处理" class="headerlink" title="HDFS中小文件的处理"></a>HDFS中小文件的处理</h4><ol>
<li><p>小文件的影响：因为一个文件不管在磁盘中多大，在HDFS中至少会占用一个数据块存储，如果一个文件的大小为1M，那么存储到数据块中，这个块的其余127M空间都不能再被使用。并且，存储大量小文件，会占用NameNode的大部分内存，甚至会耗尽内存。</p>
</li>
<li><p>解决的方法：</p>
<p>（1）har文件：将多个小文件打包为一个har文件，在HDFS中只会存储这个har文件的元数据信息，但是实际操作中，允许对里面的文件进行透明访问，大致的访问过程是先访问文件的索引数据，然后再定位实际的数据，这种方式会比直接访问hdfs文件的速度要慢一些；</p>
<p>（2）sequencefile：将文件名作为key，文件内容作为value存储，可以将多个kv形式的文件合并为一个大文件进行存储，这种方式读取数据比较方便，并且不限制数目，但是不能执行追加操作，适用于一次写入大量小文件的场景；</p>
<p>（3）CombineTextInputFormat：是新的InputFormat的格式，可以将多个小文件从逻辑上划分到一个切片中，但是这种方式不能区分输入的来源。</p>
</li>
</ol>
<h4 id="HDFS的读写过程"><a href="#HDFS的读写过程" class="headerlink" title="HDFS的读写过程"></a>HDFS的读写过程</h4><ol>
<li><p>写过程：</p>
<p>（1）客户端首先通过分布式文件系统向NameNode请求上传文件，NameNode检查目标文件机器路径是否存在，然后返回给系统是否可以上传；</p>
<p>（2）如果可以上传，客户端接着向NameNode询问第一个block要上传到哪个DataNode中，NameNode会返回三个DataNode：dn1、dn2和dn3；</p>
<p>（3）然后客户端向dn1请求上传block，dn1将请求传递给dn2，dn2在传递给dn3，此时没有其他的datanode节点了，dn3开始向dn2返回响应信息，dn2收到后向dn1返回响应，dn1收到后向客户端返回，于是传输管道建成；</p>
<p>（4）客户端开始上传block给dn1，dn1以packet为单位接收数据，接收到一个packet数量的数据后将数据发送给dn2，dn2发送给dn3；</p>
<p>（5）当第一个block传输成功后，客户端再向NameNode请求上传第二个block。</p>
</li>
<li><p>读过程：</p>
<p>（1）客户端通过分布式文件系统向NameNode请求下载文件，NameNode通过查询元数据，返回block所在的DataNode地址；</p>
<p>（2）客户端会依据先就近再随机的原则选择一个DataNode，请求读取数据；</p>
<p>（3）DataNode开始传输数据给客户端，客户端以packet为单位接收数据，先在本地缓存，然后再写入目标文件。</p>
</li>
</ol>
<h4 id="为什么数据块不能设置太小也不能设置太大"><a href="#为什么数据块不能设置太小也不能设置太大" class="headerlink" title="为什么数据块不能设置太小也不能设置太大"></a>为什么数据块不能设置太小也不能设置太大</h4><p>HDFS文件在物理上是分块存储的，块的大小可以通过dfs.blocksize调整。默认情况下，hadoop1的块大小是64M，hadoop2的块大小是128M。</p>
<p>（1）如果设置太小，会增加寻址时间，并且每个块都会在NameNode中存储元数据，也会增大NameNode的开销；</p>
<p>（2）如果设置太大，以至于从磁盘获取数据的时间明显大于定位这个块开始位置的时间，会导致程序处理这块数据会非常慢。</p>
<h4 id="HDFS实现高可用"><a href="#HDFS实现高可用" class="headerlink" title="HDFS实现高可用"></a>HDFS实现高可用</h4><p>​        同时启动2个NameNode，一个处于活动状态，一个处于随时待命状态。这样可以保证运行状态的NameNode出现故障的时候，可以在数据不丢失的情况下，手动或自动将待命的NameNode切换到活动状态继续执行。</p>
<p>​        为了使两个NameNode保持同步，两个NameNode会与一组名为JournalNode的守护程序进行通信。当活动的NameNode修改命名空间时，会定期将执行的操作记录到editlog中，并写入JN的多数节点，比如写入 2n + 1 个守护节点上，只要 n+1 个守护节点成功写入就表示写入成功，而待命的NameNode会一直监听守护节点上editlog的变化，如果出现改动就会读取这个日志并与当前的命名空间合并，保证活动的NameNode发生错误时，待命的NameNode能够与活动的NameNode的命名空间保持一致。</p>
<p>​        为了让状态切换尽快完成，还需要保证待命的NameNode也实时保存了数据块的存储信息，这样在错误切换的时候，待命的NameNode就不需要等待所有数据块全部汇报完后再切换，而是直接切换到活动状态。我们只需要让DataNode同时向这两个NameNode发送块位置信息和心跳。</p>
<h3 id="MapReduce相关"><a href="#MapReduce相关" class="headerlink" title="MapReduce相关"></a>MapReduce相关</h3><h4 id="组成架构-1"><a href="#组成架构-1" class="headerlink" title="组成架构"></a>组成架构</h4><p>MapReduce使用主从架构，包含JobClient、JobTracker、TaskTracker和Task。</p>
<ol>
<li>在用户端使用JobClient将打包好的jar文件存储到HDFS上，然后将路径提交给JobTracker，JobTracker会创建Task，分发给多个TaskTracker执行；</li>
<li>JobTracker是主从结构中的主节点，会调度和监控每个Task的状态，如果某个Task执行失败，就会重新运行它；</li>
<li>TaskTracker是主从结构中的从节点，运行在HDFS的DataNode上，会主动和JobTracker进行通信，接收并执行从JobTracker传过来的任务；</li>
<li>Task分为Map Task和Reduce Task，由TaskTracker来启动，我们知道在HDFS中使用block为单位存储数据，在MapReduce中则使用split为单位处理数据，这个split是一个逻辑概念，只存储一些元数据信息，比如数据的起始位置、数据的长度、数据所在的节点等。它的划分方法由用户决定，一个split对应一个map task。</li>
</ol>
<h4 id="MapReduce核心编程思想（WordCount编程思想）"><a href="#MapReduce核心编程思想（WordCount编程思想）" class="headerlink" title="MapReduce核心编程思想（WordCount编程思想）"></a>MapReduce核心编程思想（WordCount编程思想）</h4><p>​        MapReduce一般会分为Map阶段和Reduce阶段。</p>
<p>​        在Map阶段，逐行读取数据，按空格分割单词，组成 &lt;单词,1&gt; 的键值对形式，假设这里存在两个分区，分别对应首字母为 a-p、q-z的单词，那么就会将对应首字母的键值对发送到相应的分区，再溢写到磁盘。Map阶段并发执行Map Task，是完全的并行操作，互不干扰。</p>
<p>​        在Reduce阶段，会开启两个Reduce Task，分别处理 a-p、q-z的分区。Reduce Task也是并发执行的，相互之间不干扰，但是它们的数据依赖于Map Task的输出。</p>
<h4 id="数据切片和Map-Task并行度"><a href="#数据切片和Map-Task并行度" class="headerlink" title="数据切片和Map Task并行度"></a>数据切片和Map Task并行度</h4><p>Split即数据切片，是逻辑存储，假设要切分130M的数据，数据块会将其切分为128M和2M使用两个数据块实现物理存储，想要切分为三片，需要记录 0-65、65-130的索引，这是数据切分的实现。切片的大小可以大于或小于一个数据块的大小，也可以等于一个数据块的大小，但是大于或小于数据块的时候，就比如刚刚的例子，将数据平分切片，就会涉及跨节点取数据的问题，效率肯定会比获取本地数据要低；如果按照数据块大小切片，在本地文件系统获取数据块，效率就会更高一些。切片不会考虑数据集整体，也就是如果有两个文件输入，不会将两个文件看成一个整体切分，而是每个文件单独切片。</p>
<p>具体切片的逻辑是：</p>
<p>首先需要获取 splitsize 一片的大小，涉及三个值：minsize默认1、maxsize默认Long类型的最大值和blocksize数据块的大小，依据max(minsize, min(maxsize, blocksize)) 的逻辑可以得到 一片的大小默认是数据块的大小，然后判断被切数据和splitsize的比值如果大于1.1，就切片，否则不再切片。</p>
<p>从这个逻辑可以看出，如果控制了 minsize 和 maxsize 的值，就可以控制切片的大小，如果想要调大切片修改 minsize，调小切片修改 maxsize。</p>
<h4 id="Job提交流程"><a href="#Job提交流程" class="headerlink" title="Job提交流程"></a>Job提交流程</h4><p>通过 <code>waitForCompletion</code> 方法进入提交流程，首先会判断输出路径是否存在，然后建立连接，<code>providerList</code> 有两种连接，YarnClient和LocalClient，选择对应的连接方式，然后给这个任务创建一个JobID，并以这个ID为名称创建存提交文件的文件夹，接着对输入数据执行切片，最后提交的内容包括配置文件、切片信息，如果是集群运行还包括jar包，最后将 DEFINE 状态修改为 RUNNING，提交Job成功。</p>
<h4 id="Map-Task工作机制"><a href="#Map-Task工作机制" class="headerlink" title="Map Task工作机制"></a>Map Task工作机制</h4><p>分为5个阶段：</p>
<p>Read阶段：<br>通过InputFormat调用RecorderReader的reader()方法读取数据，默认使用TextInputFormat，其中 k 对应偏移量，v对应一行内容。</p>
<p>Map阶段：<br>将读取的数据返回给Map，开始执行用户写的Mapper逻辑。</p>
<p>Collect阶段：</p>
<p>Mapper阶段的数据会输出到环形缓冲区，默认大小100M，分两个部分存，一半存实际数据，一半存数据的索引，其中所有的数据都是按照分区存储，存储的数据到达80%的阈值或者文件输入完后，执行 <code>sortAndSpill()</code> 方法先对索引数据进行快排再反向溢写。</p>
<p>溢写阶段：<br>遍历分区，溢写到本地文件中，并记录分区数据在文件中的索引位置。</p>
<p>Merge阶段：<br>溢写操作结束后，进入 <code>mergeParts</code> 阶段，将溢写文件归并为一个，并生成一个index文件存储归并后的文件的索引，最终Reduce Task按照index文件中对应的分区读取归并文件中的数据。</p>
<p><strong>并行度决定机制：</strong></p>
<ol>
<li>切片：max(minsize, min(maxsize, blocksize))。</li>
<li>InputFormat的类型。</li>
</ol>
<h4 id="ReduceTask工作机制"><a href="#ReduceTask工作机制" class="headerlink" title="ReduceTask工作机制"></a>ReduceTask工作机制</h4><p>包括344个阶段。</p>
<p>Copy阶段：</p>
<p>首先获取Map Task的个数，要知道需要从几个map task中拉取数据，接着初始化内存和磁盘，之后开始执行抓取操作，Reduce Task根据自己的分区号抓取对应Map Task上的内容，；</p>
<p>Merge阶段：</p>
<p>拉取数据的同时，</p>
<p>Sort阶段：<br>对拉取的数据进行归并排序，</p>
<p>Reduce阶段：<br>依据用户的逻辑处理数据并输出文件。最后默认通过TextOutputFormat输出数据。</p>
<p><strong>并行度决定机制：</strong></p>
<p>可以直接手动设置：job.setNumReduceTasks(num)，默认是1。这个数值一般会通过实验求正态分布中的最大值，具体会比较不同task数目的执行时间，可以通过8088端口开启Yarn界面查看。</p>
<p><strong>Partition分区数和Reduce Task个数的关系：</strong></p>
<ol>
<li>如果Reduce Task的数目 &gt; Partition分区数，会产生空的输出文件，因为生成每个输出文件都会消耗CPU和1G的内存，这样就产生了资源浪费；</li>
<li>Reduce Task的数目 &gt; 1 &amp;&amp; &lt; Partition分区数，则有一部分数据无处安放，会报错；</li>
<li>如果Reduce Task的数目为1，最终结果都会输出到这个文件中。</li>
</ol>
<h4 id="shuffle过程详解"><a href="#shuffle过程详解" class="headerlink" title="shuffle过程详解"></a>shuffle过程详解</h4><p>​        Map方法之后，Reduce方法之前的混洗的过程就叫做Shuffle。</p>
<p>​        从Map方法出来之后，会先进入 getPartition() 方法，标记数据是哪个分区的，然后进入环形缓冲区。这个缓冲区默认100M，左侧存索引，右侧存实际的数据，存储的数据量到达80%的阈值后开始反向溢写，这样就可以让缓冲区一直高效运转，不至于在缓冲区满了以后阻塞等待。在溢写之前，还需要对数据中的key的索引，按照字典序进行快排。</p>
<p>​        溢出后，会产生两个文件，一个是实际溢出的数据文件，一个是这个数据文件的索引文件，之后可以执行Combiner过程，可以看成是本地的reduce过程，将相同key的数据合并，这样能够减少reduce task拉取的次数。</p>
<p>​        之后会对溢出文件执行归并排序，归并排序后，也可以执行Combiner操作，之后还可以执行压缩的操作，以减少网络传输的内容。最后写入本地磁盘，等待Reduce拉取。</p>
<p>​        Reduce端拉取数据，会先尝试放到内存中，内存不够的情况下会溢写到磁盘。拉取完后会对内存和磁盘中的数据执行归并排序，最后将相同key的数据分配到一个reduce中执行。</p>
<h4 id="Combiner-过程"><a href="#Combiner-过程" class="headerlink" title="Combiner 过程"></a>Combiner 过程</h4><p>​        Combiner不是MR程序默认的组件，可以看成是一个插件，父类是Reducer，所以会继承Reduce端的业务逻辑，但是实际上在每个Map Task所在的节点运行。它的目的是对每个Map Task的输出进行局部汇总，以减小网络传输量，比如一个Map Task中有100个 &lt;a,1&gt;，汇总以后变成 &lt;a,100&gt;，那么原来需要传100次，现在只需要传1次。但是Combiner应用的前提是不能影响最终的业务逻辑。假设Mapper端有两个Task，<code>3 5 7</code>和 <code>2 4</code> ，最终的业务逻辑是累加求平均值，这里如果使用Combiner，会分别计算 <code>(3+5+7)/3</code> 和 <code>(2+4)/2</code> ，这和最终的 <code>(2+5+7+2+4)/5</code> 的结果就不一致了。</p>
<h4 id="序列化概述"><a href="#序列化概述" class="headerlink" title="序列化概述"></a>序列化概述</h4><p>​        假设机器 hadoop102 的内存中存储数据 abc，想要将其拷贝到机器 hadoop103 上，需要先将 hadoop102 内存中的数据转换为字节码的形式存储到磁盘，然后通过网络传输到 hadoop103 中，再转换到 hadoop103 的内存上。其中，hadoop102 将内存的数据转换为字节码格式的过程叫做序列化，hadoop103 将字节码加载到内存的过程叫做反序列化。</p>
<p>​        Java中其实本身自带了序列化框架 Serializable，它大致的流程是在要传输数据的末尾再加上各种校验信息、头信息、继承体系等，然后一起打包传输到另一个机器后再序列化，这种机制比较复杂。对Hadoop来说，因为是在系统内部进行传输，所以只需要一个简单的校验。相比于Java的序列化机制，Hadoop序列化因为传输的信息更少，所以存储的空间更小，传输速度更快。</p>
<p>​        如果想要自定义序列化可以继承 Writable 接口，此处就不过多赘述。</p>
<h4 id="Map-Join-和-Reduce-Join"><a href="#Map-Join-和-Reduce-Join" class="headerlink" title="Map Join 和 Reduce Join"></a>Map Join 和 Reduce Join</h4><p>reduce join是在map阶段完成数据的标记，在reduce阶段完成数据的合并；</p>
<p>map join是直接在map阶段完成数据的合并，没有reduce阶段。</p>
<p>Reduce Join的缺陷：</p>
<p>1、合并的任务在reduce端执行，reduce端处理压力大，而map端默认情况下一次会处理一个数据块，负载比较低，那么资源利用率不高。<br>2、在Key值分布不均匀的情况下，很容易产生数据倾斜。</p>
<p>所以如果是一张小表和一张大表执行Join操作，可以考虑将小表加载到内存，在Map端执行Join操作，也就是使用Map Join，Map Join由于没有Reduce阶段，可以极大的减少网络传输和IO的代价。</p>
<h4 id="hadoop的二级排序"><a href="#hadoop的二级排序" class="headerlink" title="hadoop的二级排序"></a>hadoop的二级排序</h4><p>即对key和value双排序。默认情况下，Map输出的结果会对Key进行默认的排序，但是有时候需要对Key排序的同时还需要对Value进行排序，这时候就要用到二次排序了。<br>有两种方法进行二次排序，分别为：buffer and in memory sort和 value-to-key conversion。<br>1、buffer and in memory sort<br>在reduce()函数中，将某个key对应的所有value保存到内存中，然后进行排序。 这种方法最大的缺点是：可能会造成out of memory。<br>2、value-to-key conversion<br>MapReduce程序中，Mapper输出的键值对会经历shuffle过程再交给 Reducer。在shuffle阶段，Mapper输出的键值对会经过partition(分区)-&gt;sort(排序)-&gt;group(分组) 三个阶段。<br>将key和部分value拼接成一个组合key，这样reduce获取的结果便是先按key排序，后按value排序的结果，需要注意的是，用户需 要自己实现Paritioner，以便只按照key进行数据划分。Hadoop显式的支持二次排序，在Configuration类中有setSotComparatorClass()方法可以对key值进行处理，setGroupingComparatorClass()方法对相同key的value值进行处理。<br>shuffle 的 sort 过程会根据键值对&lt;key, value&gt;的 key 进行排序，但是二次排序中，value 也是需要排序的字段。因此需要将 value 字段合并到 key 中作为新的 key，形成新的键值对&lt;key#value, value&gt;。在排序时使其先根据 key 排序，如果相同，再根据 value 排序。</p>
<h4 id="MapReduce优化"><a href="#MapReduce优化" class="headerlink" title="MapReduce优化"></a>MapReduce优化</h4><h5 id="跑得慢的原因"><a href="#跑得慢的原因" class="headerlink" title="跑得慢的原因"></a>跑得慢的原因</h5><p>Mapreduce的瓶颈在于两点：</p>
<p>（1）计算机性能：CPU、内存、磁盘健康、网络等。</p>
<p>（2）I&#x2F;O操作：数据倾斜、Map和Reduce数设置不合理、Map运行时间太长导致Reduce等待过久、小文件过多、大量的不可分块的超大文件、spill次数过多、Merge次数过多等。</p>
<h5 id="具体的优化方法"><a href="#具体的优化方法" class="headerlink" title="具体的优化方法"></a>具体的优化方法</h5><p>主要从六个方面考虑：数据输入、Map阶段、Reduce阶段、IO传输、数据倾斜问题和常用的调优参数。</p>
<p><strong>1）数据输入</strong></p>
<p>（1）合并小文件：在执行MR任务前将小文件进行合并，大量的小文件会产生大量的Map任务，增大Map任务装载次数，而任务的装载比较耗时，从而导致MR运行较慢。</p>
<p>（2）采用CombineTextInputFormat来作为输入，解决输入端大量小文件场景。</p>
<p><strong>2）Map阶段</strong></p>
<p>（1）减少溢写(Spill)次数：通过调整io.sort.mb及sort.spill.percent参数值，增大触发Spill的内存上限，减少Spill次数，从而减少磁盘IO。</p>
<p>（2）减少合并(Merge)次数：通过调整io.sort.factor参数，增大Merge的文件数目，减少Merge的次数，从而缩短MR处理时间。</p>
<p>（3）在Map之后，不影响业务逻辑前提下，先进行Conbine处理，减少IO。</p>
<p><strong>3）Reduce阶段</strong></p>
<p>（1）合理设置Map和Reduce数：两个都不能设置太少，也不能设置太多。太少，会导致Task等待，延长处理时间；太多，会导致Map、Reduce任务间竞争资源，造成处理超时等错误。</p>
<p>（2）设置Map、Redce共存：调整slowstart.completedmaps参数，使Map运行到—定程度后，Recuce也开始运行，减少Reduce的等待时间。</p>
<p>（3）规避使用Reduce：因为Reduce在用于连接数据集的时候将会产生大量的网络消耗。</p>
<p>（4）合理设置Reduce端的Buffer：默认情况下，数据达到一个阈值的时候，Buffer中的数据就会写入磁盘，然后Recuce会从磁盘中获得所有的数据。也就是说，Buffer和Recuce是没有直接关联的，中间多次写磁盘-&gt;读磁盘的过程，既然有这个弊端，那么就可以通过参数来配置，使得Buffer中的一部分数据可以直接输送到Reduce，从而减少Io开销：mapreduce.reduce.input.buffer.percent，默认为0.0。当值大于0的时候，会保留指定比例的内存读Buffer中的数据直接拿给Recuce使用。但是这样一来，设置Buffer需要内存，读取数据需要内存，Recuce计算也要内存，所以要根据作业的运行情况进行调整。</p>
<p><strong>4）IO传输</strong></p>
<p>（1）采用数据压缩的方式，减少网络Io的的时间。安装Snappy和LZo压缩编码器。</p>
<p>（2）使用SequenceFile二进制文件。</p>
<p><strong>5）数据倾斜</strong></p>
<p>（1）数据倾斜现象<br>大量的相同key被分配到一个分区里，map &#x2F;reduce程序执行时，reduce节点大部分执行完毕，但是有一个或者几个reduce节点运行很慢，导致整个程序的处理时间很长。<br>（2）减少数据倾斜的方法</p>
<p>方法一：将不均匀的key值打散。</p>
<p>这种方式适用于绝大部分key对应10%的数据，而很少部分的key对应90%的数据。对于这种情况，可以给key值加上随机数，将数据量很大的key值打散到不同的reduce中计算。</p>
<p>方法二：使用map join代替 reduce join。</p>
<p>适用于小表join大表的情况。可以将小表放到内存，然后将map task的数据通过hash取余的方式选择小表中对应的key值，进行join操作。在map端的每个map task中完成join操作，后续就不需要进入reduce端处理了，能够避免shuffle过程，从而避免数据倾斜。</p>
<p>方法三：使用group by代替distinct。</p>
<p>在统计数量的时候经常会用到 <code>select count(distinct name)</code> ，这样会将name的key值全都shuffle到一个reduce中处理，很容易产生数据倾斜。采用group by+聚合函数的方式可以将数据根据key值分配到不同的reduce中，避免数据倾斜。</p>
<p><strong>6）常见的调优参数</strong></p>
<p>mapreduce中比如有 <code>mapreduce.map.cpu.vcores</code> 设置每个MapTask可使用的最多cpu core数目，默认值: 1；</p>
<p>yarn中比如有 <code>yarn.scheduler.minimum-allocation-vcores </code> 设置每个Container申请的最小CPU核数，默认值：1；</p>
<p>shuffle中比如有 <code>mapreduce.map.sort.spill.percent</code> 设置环形缓冲区溢出的阈值，默认80%；</p>
<p>容错相关系数比如有 <code>mapreduce.map.maxattempts</code> 设置每个Map Task最大重试次数，一旦重试参数超过该值，则认为Map Task运行失败，默认值：4。</p>
<h3 id="Yarn相关"><a href="#Yarn相关" class="headerlink" title="Yarn相关"></a>Yarn相关</h3><h4 id="组成架构-2"><a href="#组成架构-2" class="headerlink" title="组成架构"></a>组成架构</h4><p>Yarn使用主从架构，包含ResourceManager、NodeManager、ApplicationMaster和Container。</p>
<p>​        ResourceManager负责整个集群资源的管理，负责处理客户端的请求，监控所有NodeManager的运行情况，当哪个NodeManager的资源不够就可以即使分配资源；也负责启动和监控所有ApplicationMaster，当ApplicationMaster里面有任务挂了可以及时将这个任务分配到其他节点运行。</p>
<p>​        NodeManager负责管理单个节点的资源，并定时向RM汇报本节点的资源使用情况，以及处理来自RM的命令和来自AM的命令。</p>
<p>​        ApplicationMaster会为应用程序向RM申请资源并分配给内部的任务，然后监控任务的执行，当任务挂掉可以及时向RM反应。</p>
<p>​        Container是Yarn中的集群抽象，封装了某个节点上的多维度资源，比如内存、磁盘、CPU、网络等。</p>
<h4 id="Yarn工作机制"><a href="#Yarn工作机制" class="headerlink" title="Yarn工作机制"></a>Yarn工作机制</h4><ol>
<li>首先执行Jar文件，入口main方法，走到 <code>job.waitForCompletion()</code> 方法会建立一个YarnRunner，开始向RM申请一个Application；</li>
<li>RM会返回Application资源提交的路径，程序会向这个路径提交三样东西：xml配置文件、jar包、切片文件；</li>
<li>资源提交完毕后，程序向RM申请运行这个任务的ApplicationMaster，RM会将用户的请求初始化为一个Task，保存到调度队列上，这个调度队列默认使用容量调度器；</li>
<li>等到NodeManager从调度队列上获取该Task，会创建一个Container，并在这个Container内启动AM，这个AM会下载对应路径下提交的资源，然后根据切片信息向RM申请对应数量的MapTask容器，这个请求也会存到调度队列上等待调度；</li>
<li>有NodeManager领取到这个任务后，会创建相应数量的Container，然后将对应的jar包拷贝过来；</li>
<li>接着AM发送程序启动的脚本到这些Container中，让它们启动并运行MapTask；</li>
<li>MapTask运行结束后，将输出数据按照分区持久化到磁盘；</li>
<li>然后AM开始向RM申请ReduceTask数目的容器，之后向这些Container发送启动ReduceTask命令，Reduce开始向Map端拉取数据并执行业务逻辑；</li>
<li>等到所有程序运行完毕，AM会向RM申请注销自己。</li>
</ol>
<h4 id="作业提交全过程"><a href="#作业提交全过程" class="headerlink" title="作业提交全过程"></a>作业提交全过程</h4><p>画一个大图，将这三者的整个流程全画一遍。<strong>这是必须要会的内容！！！</strong></p>
<h4 id="调度器的种类"><a href="#调度器的种类" class="headerlink" title="调度器的种类"></a>调度器的种类</h4><p>调度器的种类有三种：</p>
<ol>
<li><p>FIFO调度器：</p>
<p>​        所有作业被提交到一个队列中，然后先按照优先级高低、再按照作业提交时间选择被执行的作业。这种算法简单，但是如果前一个作业占用了全部的资源，会导致后面的任务一直无法处理。</p>
</li>
<li><p>容量调度器：</p>
<p>（1）是apache hadoop3的默认调度器，支持多个队列，每个队列使用FIFO算法调度；</p>
<p>（2）管理员可以为每个队列设置最低资源保证和资源上限，这个上限不是固定的，如果一个队列的资源有剩余，可以暂时共享给其他需要资源的队列，但是一旦该队列有新的任务提交，其他队列借调的资源需要立刻归还给该队列；</p>
<p>（3）支持多用户共享集群和多程序同时运行，此处为了防止同一用户独占队列的资源，会对同一用户所占资源进行限定。</p>
<p><strong>资源分配算法：</strong></p>
<p>（1）先确定分配的队列：优先选择资源占用率最低的队列；</p>
<p>（2）接着定位要分配资源的作业：默认按照作业的优先级和提交顺序来执行；</p>
<p>（3）最后确定分配资源的容器：先按照容器的优先级分配，如果优先级相同，按照数据本地性原则分配：先任务和数据在同意节点、然后任务和数据在同一机架、最后任务和数据不在一个节点也不在一个机架。</p>
</li>
<li><p>公平调度器：也支持多队列，尽可能保证所有作业都能获得等量的资源，系统中只有一个作业时，会独占所有资源，有其他作业提交时再将资源平分给其他任务。</p>
</li>
</ol>
<p><strong>计算能力调度器和公平调度器的比较：</strong></p>
<p>二者核心的区别在于，提交任务到队列中，是采用公平调度还是FIFO调度。对于公平调度器，因为能够尽量保证任务获得等量的资源，所以能够避免因为长时间运行大任务而阻塞小任务；但是容量调度器也可以针对不同的任务创建不同的队列，然后由任务提交者根据任务的特点提交到不同队列中，也可以实现和公平调度器一样的效果。</p>
<p>调度器的修改参数是 <code>yarn-site.xml</code> 中的 <code>yarn.resourcemanager.scheduler.class</code> 。</p>
<h4 id="Yarn怎么保证高可用"><a href="#Yarn怎么保证高可用" class="headerlink" title="Yarn怎么保证高可用"></a>Yarn怎么保证高可用</h4><p>在hadoop2.4版本之前，Yarn框架的RM存在单点故障的问题，也就是如果RM挂掉了，恢复的时间会比较长，这就会导致正在运行的程序丢失，影响范围较大，所以从hadoop2.4版本开始，引入了RM高可用机制，典型的高可用集群中，默认会配置两个独立的ResourceManager，在任意时间，有且仅有一个RM处于运行状态，另一台处于待命状态，一旦运行状态的RM出现故障，就可以将待命状态的RM切换为运行状态继续执行任务。切换的方式可以是手动切换，也可以基于Zookeeper实现自动切换。</p>
<h3 id="三者关系的简述"><a href="#三者关系的简述" class="headerlink" title="三者关系的简述"></a>三者关系的简述</h3><p>客户端将任务提交到RM，RM到某个NM下启动一个container，并在该container内放置传输的AM；接着AM向RM申请资源，RM返回相应的资源列表，然后AM启动这些对应的资源，这些资源在对应的DN上处理相应的任务，这部分称为maptask，maptask处理完后，将所有maptask的结果传输到reduce端执行，最终将reduce端的结果对应的元数据信息传输到namenode中；2NN会每隔一段时间对NM的元数据进行备份。</p>
<h3 id="ETL的几个过程分别是什么？"><a href="#ETL的几个过程分别是什么？" class="headerlink" title="ETL的几个过程分别是什么？"></a>ETL的几个过程分别是什么？</h3><p>ETL是Extract Transform Load三个英文单词的缩写，中文意思就是抽取、转换、加载。说到ETL就必须提到数据仓库，ETL负责完成数据从数据源向目标数据仓库转化的过程，是实施数据仓库的重要步骤。<br>构建数据仓库的核心是建模，在数据仓库的构建中，ETL贯穿于项目始终，它是整个数据仓库的生命线。从数据源中抽取数据，然后对这些数据进行转化，最终加载到目标数据库或者数据仓库中去，这就是ETL 过程。<br>通常数据抽取工作分抽取、清洗、转换、装载几个步骤：</p>
<p>抽取主要是针对各个业务系统及不同服务器的分散数据，充分理解数据定义后，规划需要的数据源及数据定义，制定可操作的数据源，制定增量抽取和缓慢渐变的规则。</p>
<p>清洗主要是针对系统的各个环节可能出现的数据二义性、重复、不完整、违反业务规则等数据质量问题，允许通过数据抽取设定的数据质量规则，将有问题的记录先剔除出来，根据实际情况调整相应的清洗操作。</p>
<p>转换主要是针对数据仓库建立的模型，通过一系列的转换来实现将数据从业务模型到分析模型，通过ETL工具可视化拖拽操作可以直接使用标准的内置代码片段功能、自定义脚本、函数、存储过程以及其他的扩展方式，实现了各种复杂的转换，并且支持自动分析日志，清楚的监控数据转换的状态并优化分析模型。</p>
<p>装载主要是将经过转换的数据装载到数据仓库里面，可以通过直连数据库的方式来进行数据装载，可以充分体现高效性。在应用的时候可以随时调整数据抽取工作的运行方式，可以灵活的集成到其他管理系统中。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>hive面试题</title>
    <url>/2021/07/21/hive%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="Hive的架构"><a href="#Hive的架构" class="headerlink" title="Hive的架构"></a>Hive的架构</h3><p>Hive架构包含客户端Client、元数据Metastore、Hadoop和驱动器Driver。</p>
<ol>
<li>Client：包括CLI，即hive shell、JDBC&#x2F;ODBC、WEBUI。</li>
<li>Metastore：元数据，表示文件从HDFS到Hive的映射信息，包括表名、表所属数据库(默认是default)、表的拥有者、表的类型(是否是外部表)、列和分区字段等，默认使用Derby数据库存储，但是derby属于嵌套式数据库，一次只能支持一个会话，所以建议使用Mysql存储元数据。</li>
<li>Hadoop：使用HDFS进行存储，Mapreduce进行计算。</li>
<li>Driver：包括解析器、编译器、优化器和执行器，其中解析器检查基本的语法；编译器将hql语句翻译为MR程序；优化器对程序进行优化；执行器将程序提交到Yarn。</li>
</ol>
<span id="more"></span>



<h3 id="Hive的优缺点以及和数据库的区别"><a href="#Hive的优缺点以及和数据库的区别" class="headerlink" title="Hive的优缺点以及和数据库的区别"></a>Hive的优缺点以及和数据库的区别</h3><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优点是：</p>
<ol>
<li>使用类SQL语法编写MR程序的逻辑，可以快速开发，也能减少学习成本；</li>
<li>因为底层是Hadoop，所以延迟肯定比较高，主要用于进行数据分析，适用于对实时性能要求不高的场景；</li>
<li>Hive的优势是处理大数据，因为无论文件大小，都会使用MR对文件进行处理，对于小文件来说，可能开关虚拟机的时间都比执行程序的时间长，不值得；</li>
<li>Hive支持用户根据自身需求自定义函数。</li>
</ol>
<p>缺点是：</p>
<ol>
<li>HQL语言的表达能力有限：迭代算法无法表达，假设要反复的对结果数据进行处理，这是迭代，这种处理的方式在Hive实现上需要不断的创建新的MR程序进行运算，速度太慢；所以数据挖掘方面也不擅长，因为数据挖掘方面也是通过不断迭代找到合适结果的。</li>
<li>效率比较低：由于是自动生成的MR作业，通常情况下不够智能；并且调优比较困难，力度较粗，因为调优肯定是在SQL层面或者资源层面进行调优，而不能修改生成的模板。</li>
</ol>
<h4 id="Hive和数据库比较"><a href="#Hive和数据库比较" class="headerlink" title="Hive和数据库比较"></a>Hive和数据库比较</h4><ol>
<li>查询语言：数据库使用SQL语言，Hive使用类SQL的HQL语言。</li>
<li>数据存储位置：Hive建立在Hadoop之上，Hive所有真实数据的存储都在HDFS中；而数据库可以将数据保存在块设备或本地系统中。</li>
<li>数据更新：Hive中不建议对数据进行改写，所有的数据在加载时就确定好，数据库因为会接在线业务，里面的数据会经常进行增删改查的操作。</li>
<li>执行：Hive中大多数的查询是通过MapReduce来完成的，而数据库有自己的搜索引擎，比如MySQL使用的是InnoDB。</li>
<li>执行延迟：Hive在查询数据的时候，因为没有索引，需要扫描整张表，因此延迟会较高，又因为Mapreduec本身具有比较高的延迟，当Hive使用Mapreduce执行查询时，延迟会更高；相较而言，数据库的延迟就会比较低；当数据规模比较小，但仍超过数据库的处理能力时，Hive的并行计算才显出优势。</li>
<li>可扩展性：由于Hive建立在Hadoop之上，所以二者的扩展性是一致的；而数据库由于ACID语义的严格限制，扩展行非常有限。</li>
<li>数据规模：由于Hive建立在集群上并可以利用Mapreduce进行并行计算，所以可以处理大规模的数据；相对而言，数据库的处理规模就比较小。<br>注 - ACID语义：<br>1）原子性：即操作要么全部完成，要么全部不完成，不会结束在中间的某个环节；<br>2）一致性：操作开始到结束，数据对象的完整性不会被破坏；<br>3）隔离性：操作独立于其他并发操作完成；<br>4）持久性：操作处理结束后，对数据的修改将永久有效，即使出现故障，该修改也不会丢失。</li>
</ol>
<h3 id="外部表和内部表（hive表有几种）"><a href="#外部表和内部表（hive表有几种）" class="headerlink" title="外部表和内部表（hive表有几种）"></a>外部表和内部表（hive表有几种）</h3><p>删除外部表只会删除元数据，保留原始数据，这样的数据是可以恢复的；</p>
<p>删除内部表会将元数据和原始数据全都删掉，这样的数据不可恢复。</p>
<h3 id="分区和分桶的区别"><a href="#分区和分桶的区别" class="headerlink" title="分区和分桶的区别"></a>分区和分桶的区别</h3><p>​        分区使用 <code>partitioned by</code> 来执行，按照某一列或某几个列分为多个分区存储，从hdfs上看就是分成多个文件夹来进行存储，比如按照月份分区，插入的数据会根据月份字段插入相应的分区内。</p>
<p>​        分桶类似于MR的分区，根据某一列的hash值将数据插入到同一文件夹的不同文件中。使用 <code>cluster by(字段) into n buckets</code> ，其中 n 指的是桶的个数。</p>
<p>​        分区的目的是提高查询的效率，指定分区查找而不需要扫描全表。分桶的作用有两个：可以进行抽样测试，使用hash值切分的数据集比分区的数据集更均匀；可以高效实现map端的join操作，假设要连接两个在相同列上分桶的表，可以将相同桶的数据进行join操作，减少join的数据量。</p>
<h3 id="排序的4个By区别"><a href="#排序的4个By区别" class="headerlink" title="排序的4个By区别"></a>排序的4个By区别</h3><ol>
<li>order by：全局排序，只会有一个Reducer；</li>
<li>sort by：局部排序，只在每个Reducer内部排序，对全局结果集来说是无序的；</li>
<li>distribute by：类似MR中的partition，进行分区，需要结合sort by使用，且要写在sort by之前；</li>
<li>cluster by：当distribute by所用字段和sort by所用字段相同时，就使用cluster by，它兼具了前二者的功能，但是只能升序排序，不能降序。</li>
</ol>
<h3 id="常用的系统函数"><a href="#常用的系统函数" class="headerlink" title="常用的系统函数"></a>常用的系统函数</h3><h4 id="1-聚合函数"><a href="#1-聚合函数" class="headerlink" title="1. 聚合函数"></a>1. 聚合函数</h4><ol>
<li>sum() - 求和；</li>
<li>count() - 求个数；</li>
<li>avg() - 求平均值；</li>
<li>distict - 去重；</li>
<li>min() - 求最小值;</li>
<li>max() - 求最大值；</li>
</ol>
<h4 id="2-分析函数"><a href="#2-分析函数" class="headerlink" title="2. 分析函数"></a>2. 分析函数</h4><ol>
<li>rank()：生成的数据项是在组内的排名，如果排名相等会在名次中留下空位；</li>
<li>row_number()：生成的数据项从1开始，按照顺序生成在组内的序列号；</li>
<li>dense_rank()：与rank()类似，但是如果排名相等，不会留下空位；</li>
<li>cume_dist() &#x3D; 小于等于<code>当前元素的值</code>的行数&#x2F;总行数；</li>
<li>percent_rank() &#x3D; 分组内当前行的rank值-1&#x2F;总行数-1。</li>
</ol>
<h4 id="3-字符串连接函数"><a href="#3-字符串连接函数" class="headerlink" title="3. 字符串连接函数"></a>3. 字符串连接函数</h4><ol>
<li>concat(str1, str2, …)：用于将多个字符串连接成一个字符串；</li>
<li>concat_ws(sep, str1, str2, …)：指定分隔符将多个字符串连接成一个，其中，<code>sep</code>为分隔符；</li>
<li>collect_set(字段)：根据指定内容分组后，将分在一组的该字段的列值合并为数组，默认分隔符为<code>,</code>，可以将concat_ws和concat_set组合指定分隔符；</li>
<li>collect_list(字段)：与collect_set相似，区别是collect_set可以去重，collect_list不行。</li>
</ol>
<h4 id="4-还有一些其他类型函数"><a href="#4-还有一些其他类型函数" class="headerlink" title="4. 还有一些其他类型函数"></a>4. 还有一些其他类型函数</h4><ol>
<li>cast(字段名 as 转换的类型)：转换字段的类型；</li>
<li>if(表达式, trueValue, falseValue_or_NULL)：相当于Java的三目运算符。</li>
</ol>
<h3 id="sql语句的顺序"><a href="#sql语句的顺序" class="headerlink" title="sql语句的顺序"></a>sql语句的顺序</h3><p>11个关键字，有两种顺序：</p>
<p>（1）关键字顺序：</p>
<blockquote>
<p>select -&gt; distinct -&gt; from -&gt; join -&gt; on -&gt; where -&gt; group by -&gt; with -&gt; having -&gt; order by -&gt; limit</p>
</blockquote>
<p>（2）执行顺序</p>
<blockquote>
<p>from -&gt; on -&gt; join -&gt; where -&gt; group by -&gt; with -&gt; having -&gt; select -&gt; distinct -&gt; order by -&gt; limit</p>
</blockquote>
<h3 id="是否了解数仓分层"><a href="#是否了解数仓分层" class="headerlink" title="是否了解数仓分层"></a>是否了解数仓分层</h3><p>首先我们知道数仓即数据仓库，是为企业制定决策，提供数据支持的，可以帮助企业，改进业务流程、提高产品质量等。</p>
<p>数据仓库的来源如下：</p>
<ol>
<li>爬虫数据；</li>
<li>用户行为数据：比如用户和网站交互产生的数据；</li>
<li>业务数据：存储在后台MySQL对应的数据库中。</li>
</ol>
<p>具体分层如下：</p>
<ol>
<li>ODS：原始数据层，存放原始数据，用来直接加载原始日志、数据，数据保持原貌不做处理；</li>
<li>DWD：明细数据层，对ODS层数据进行清洗(去除空值，脏数据，超过极限范围的数据)；</li>
<li>DWS：服务数据层，以DWD为基础，进行轻度汇总，一般聚集到以用户当日，设备当日，商家当日，商品当日等等的粒度；</li>
<li>ADS：数据应用层，面向实际的数据需求，以DWD或者DWS层的数据为基础，组成各种统计报表，一般ADS层的指标是提供给高层来进行决策的。</li>
</ol>
<h3 id="udf、udaf、udtf自定义函数的实现过程"><a href="#udf、udaf、udtf自定义函数的实现过程" class="headerlink" title="udf、udaf、udtf自定义函数的实现过程"></a>udf、udaf、udtf自定义函数的实现过程</h3><h4 id="UDF、UDAF、UDTF"><a href="#UDF、UDAF、UDTF" class="headerlink" title="UDF、UDAF、UDTF"></a>UDF、UDAF、UDTF</h4><p>UDF是一进一出；UDAF是多进一出，比如count等聚合函数；UDTF是一进多出，比如lateral view explode()一行转多行操作。</p>
<h4 id="自定义的步骤"><a href="#自定义的步骤" class="headerlink" title="自定义的步骤"></a>自定义的步骤</h4><ol>
<li><p>自定义UDF：继承UDF，实现evaluate()方法；</p>
</li>
<li><p>自定义UDTF：继承GenericUDTF，重写三个方法 - initialize、process、close；</p>
</li>
<li><p>自定义UDAF：继承UDAF，并在内部创建一个实现UDAFEvaluator接口的内部类，之后在这个类中实现如下几个方法：</p>
<p>（1）init()：初始化内部字段，一般会包含存放最终结果的变量；</p>
<p>（2）iterate()：逐行接收传入的数据，并进行聚合操作，最后计算正确或输入合法就返回true；</p>
<p>（3）terminatePartial()：类似于MR的Combiner，会在iterate方法遍历结束后调用；</p>
<p>（4）merge()：用于合并两个部分聚合的数据时会调用；</p>
<p>（5）terminate()：返回最终的聚合结果。</p>
</li>
</ol>
<h4 id="hive为什么需要自定义函数"><a href="#hive为什么需要自定义函数" class="headerlink" title="hive为什么需要自定义函数"></a>hive为什么需要自定义函数</h4><ol>
<li>内置函数不能满足所有的业务需求；</li>
<li>自定义函数可以自己打印日志，方便调试。</li>
</ol>
<h3 id="Hive常见的存储文件类型？"><a href="#Hive常见的存储文件类型？" class="headerlink" title="Hive常见的存储文件类型？"></a>Hive常见的存储文件类型？</h3><p>常用的存储文件类型：SEQUENCEFILE（二进制序列文件）、TEXTFILE（文本）、RCFILE（列式记录文件）、ORCFILE、PARQUET。<br>如果文件数据是纯文本，可以使用 STORED AS TEXTFILE。<br>如果数据需要压缩，使用 STORED AS SEQUENCEFILE。</p>
<h3 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h3><p>​        窗口函数over()是分析函数的一种，一般会和聚合函数或其他分析函数一起使用，可以联合 partition by、order by等子句对前面合用的函数的数据范围进行约束。其中 partition by 用于分组，order by用于排序。</p>
<p>​        假设有一张明细表，需要以id分组统计总个数，但是最终输出的列除了id、总个数之外，还要有一个标签列，这样可以在 count 方法后连用 over()，在窗口函数内使用 partition by id 进行分组，这样就可以将查询 id和总个数的列与查询标签列的操作合二为一了。</p>
<h3 id="Hive创建表的几种方式和加载数据的几种方式"><a href="#Hive创建表的几种方式和加载数据的几种方式" class="headerlink" title="Hive创建表的几种方式和加载数据的几种方式"></a>Hive创建表的几种方式和加载数据的几种方式</h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><p>有三种：直接创建、查询创建和like创建。其中查询创建会存储数据，like 创建会构建相同结构的表，但内部没有数据。</p>
<h4 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h4><p>有四种方式。</p>
<ol>
<li>本地导入：load data local inpath ‘…’；</li>
<li>hdfs导入：load data inpath ‘…’；</li>
<li>创建表时查询导入：create table select；</li>
<li>插入查询结果：insert into table select。</li>
</ol>
<h3 id="事实表和维度表，以及事实表的种类"><a href="#事实表和维度表，以及事实表的种类" class="headerlink" title="事实表和维度表，以及事实表的种类"></a>事实表和维度表，以及事实表的种类</h3><p>​        维表就是看待某个事务有哪些方面，比如想要快递供货，我们需要一张地域维表存储省市编码等标记供货地；事实表就是这个快递供货的实际信息，比如需要记录哪个用户要供货到哪个地址。</p>
<p>​        事实表分为事务型事实表、周期型快照事实表和累积型快照事实表。</p>
<ol>
<li>事务型事实表以一个事务或事件为单位，比如一条支付明细，被提交之后是不能在被更改的；</li>
<li>周期性快照事实表会保留固定时间间隔的数据，比如每月的销售记录；</li>
<li>累积型快照事实表用于跟踪业务的实时变化，这种数据被提交之后可以被修改，就比如供货的实际日期没有办法提前就准确得知，可以先写一个代表未知的占位符，等到实际出货后再填写上去。</li>
</ol>
<h3 id="Hive有哪些方式保存元数据，各有哪些特点？"><a href="#Hive有哪些方式保存元数据，各有哪些特点？" class="headerlink" title="Hive有哪些方式保存元数据，各有哪些特点？"></a>Hive有哪些方式保存元数据，各有哪些特点？</h3><p>1）内嵌模式：将元数据保存在本地内嵌的derby数据库中，内嵌的derby数据库每次允许一个客户端连接，这种设置只能在本地测试，在实际的生产环境中效率会很低。 </p>
<p>2）本地模式：将元数据保存在本地mysql，它支持多会话连接。 </p>
<p>3）远程模式：把元数据保存在远程独立的mysql数据库中，避免每个客户端都去安装mysql数据库。</p>
<h3 id="Hive数据倾斜"><a href="#Hive数据倾斜" class="headerlink" title="Hive数据倾斜"></a>Hive数据倾斜</h3><h4 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h4><p>在两个表做join操作的时候，reducetask中一个任务处理的时间明显大于其他任务处理的时间，就会出现数据倾斜。</p>
<h4 id="解决的方法"><a href="#解决的方法" class="headerlink" title="解决的方法"></a>解决的方法</h4><p>设置 <code>hive.groupby.skewindata = true</code> 开启数据倾斜的负载均衡，它的思路是先随即分发再聚合处理。这里会产生两个mr程序，第一个mr中，在map阶段输出结果，partition操作时给key添加随机的标记，让数据能够随机分发到不同的reduce中，然后reduce中去除随即标记，对相同key的数据做部分聚合。这样的操作会将不同key的数据分发到同一个reduce中，就把数据打散了，也就不会出现数据倾斜的问题，就能达到负载均衡的目的。第二个mr接收第一个mr输出的结果，将相同key的数据分发到同一个reduce中处理，做最终的聚合操作。</p>
<h3 id="Hive里边字段的分隔符用的什么？为什么用-t？有遇到过字段里边有-t的情况吗，怎么处理的？"><a href="#Hive里边字段的分隔符用的什么？为什么用-t？有遇到过字段里边有-t的情况吗，怎么处理的？" class="headerlink" title="Hive里边字段的分隔符用的什么？为什么用\t？有遇到过字段里边有\t的情况吗，怎么处理的？"></a>Hive里边字段的分隔符用的什么？为什么用\t？有遇到过字段里边有\t的情况吗，怎么处理的？</h3><p>字段分隔符默认是<code>^A</code>，即ascII码的\001，行分隔符默认是 <code>\n</code>。<br>如果采用<code>\t</code>或<code>\001</code>等作为分隔符，需要要求前端埋点和JavaEE后台传递过来的数据不能存在该分隔符，依据代码规范约束，如果出现该分隔符，需要到前一级数据中去删除或者替换。<br>可以设置如下参数：</p>
<blockquote>
<p>-hive.drop.import.delims 导入到hive时删除分隔符；<br>-hive.delims.replacement 导入到hive时用自定义的分隔符替代</p>
</blockquote>
<h3 id="Hive优化"><a href="#Hive优化" class="headerlink" title="Hive优化"></a>Hive优化</h3><h4 id="1）-fetch抓取"><a href="#1）-fetch抓取" class="headerlink" title="1）. fetch抓取"></a>1）. fetch抓取</h4><p>​        即Hive中某些情况的查询可以不必经过MapReduce计算。<br>​        通过修改hive-default.xml中的hive.fetch.task.conversion参数为more，使得全局查找、字段查找、limit查找等都不用经过MapReduce。</p>
<h4 id="2）-本地模式"><a href="#2）-本地模式" class="headerlink" title="2）. 本地模式"></a>2）. 本地模式</h4><p>​        Hadoop的任务在大多数情况下都需要使用多台机器完成，有时Hive的输入数据量非常小，这种情况，为查询触发执行任务消耗的时间可能会比实际任务运行的时间要多得多，这种情况下，HIve可以通过本地模式在单台机器上处理所有的任务，对于小数据集，执行时间会被明显缩短。</p>
<p>​        通过修改 hive.exec.mode.local.auto &#x3D; true ，可以让hive在适当的时候启动这个优化。和它相关的参数有两个，<code>hive.exec.mode.local.auto.inputbytes.max</code>设置触发local mr的最大数据量，默认值是128M；<code>hive.exec.local.mode.auto.files.max</code> 参数设置触发local mr的最大文件数量。</p>
<h4 id="3）-表的优化"><a href="#3）-表的优化" class="headerlink" title="3）. 表的优化"></a>3）. 表的优化</h4><p><strong>（1）大表Join大表</strong>：<br>a）过滤：有些Join超时是因为某些key对应的数据太多，而相同的key对应的数据都会被放到同一个reducer，会导致内存不够用；此时我们可以仔细分析这些异常的key，很多情况下这些key对应的都是异常数据，我们使用SQL语句将这些异常数据过滤就行。<br>b）转换：有时候这些key对应的数据并不是异常数据，我们可以将这些空key随机转换为不同的值，使得数据能随即均匀的分不到不同的reducer上。<br><strong>（2）MapJoin</strong>：<br>如果不指定MapJoin或者不符合MapJoin的条件，Hive解析器会将这些数据给Reduce端处理，容易造成数据倾斜，可以使用MapJoin将小表都加载到内存，在map端进行Join操作。<br><strong>（3）尽量不适用笛卡尔积</strong>：<br>因为Hive只能在一个reducer上完成笛卡尔积。<br><strong>（4）行列过滤</strong>：<br>如果是列处理，只拿需要的列，尽量使用分区过滤，少用 select *；如果是行处理，两个表进行join操作的时候，先子查询过滤出需要的行，再进行join操作，需要连接的数据量就少了。<br><strong>（5）使用动态分区</strong>：<br>动态分区可以不指定实际的内容，比如 <code>partition(dt=&#39;20210101&#39;)</code> ，这种是静态分区的实现方式，必须在编译阶段就指定分区内容，动态分区只需要指定分区字段，也就是 <code>partition(dt)</code> ，具体的分区内容等到插入数据时才会知道。使用 <code>hive.exec.dynamic.partition = true</code> 来开启动态分区，之后还需要设置 <code>hive.exec.dynamic.partition.mode = nonstrict</code>，这个参数默认是严格模式，不允许使用动态分区。</p>
<h4 id="4）-MR优化"><a href="#4）-MR优化" class="headerlink" title="4） MR优化"></a>4） MR优化</h4><h5 id="（1）合理设置Map数"><a href="#（1）合理设置Map数" class="headerlink" title="（1）合理设置Map数"></a>（1）合理设置Map数</h5><p>​        当Map数过大，如果一个任务有许多小文件，哪怕这些小文件的大小远小于一个块的大小，也都会使用一个块存，用一个map来完成，而一个map的启动和初始化的时间远大于逻辑处理时间，这样会对造成很大的资源浪费，而且，同时可执行的map数是有限的。</p>
<p>​        针对这种情况，需要合并小文件处理，Hive默认使用的CombineHiveInputFormat就具有对小文件进行合并的功能。        </p>
<p>但是，如果每个Map都处理将近一个块的大小的数据也不行，假设有一个127M的文件，其中只有一到两个字段，却有成千上万的数据，这时当Map处理的逻辑比较复杂的时候，也会很耗时，这时候就需要减少传入map的数据量，也就是减少切片值，设置 <code>mapreduce.input.fileinputformat.split.maxsize</code> 小于128M。</p>
<h5 id="（2）合理设置Reduce数"><a href="#（2）合理设置Reduce数" class="headerlink" title="（2）合理设置Reduce数"></a>（2）合理设置Reduce数</h5><p>reduce个数并不是越多越好：<br>1）过多的启动和初始化会消耗时间和资源；<br>2）多少个reduce就会生成多少个输出文件，当输出多个小文件，同时这些文件会作为下一个任务的输入，也会造成小文件过多的问题；<br>3）在设置reduce数的时候也要遵循两个原则：大数据量要有合适的reduce数；每个reduce要有合适的数据量。</p>
<h5 id="（3）并行执行"><a href="#（3）并行执行" class="headerlink" title="（3）并行执行"></a>（3）并行执行</h5><p>Hive会将一个查询转换为一至多个阶段，这些阶段可能并非完全相互依赖，甚至可能可以并行执行，这样就有可能将整个job的执行时间缩短。如果有更多的阶段可以并行执行，那么job就有可能越快完成；当然，这得是在系统资源比较空闲的时候才有优势，不然就算想并行也起不来。可以通过设置参数：hive.exec.parallel值为true来开启并行。</p>
<h3 id="SQL转化为MapReduce的过程"><a href="#SQL转化为MapReduce的过程" class="headerlink" title="SQL转化为MapReduce的过程"></a>SQL转化为MapReduce的过程</h3><p>SQL转化为MapReduce会经过解析器、编译器、优化器和执行器。首先解析器检查基本的语法是否符合规范；接着编译器将HQL语句转化为具体的MR程序；优化器会根据MR程序做一些优化，随着hive版本的迭代，生成mr的模板也是在不断优化的；执行器将程序提交给yarn，执行过程中，会访问元数据，查找实际数据，然后将实际数据读进来，执行mr程序。</p>
<h3 id="group-by和partition-by的区别"><a href="#group-by和partition-by的区别" class="headerlink" title="group by和partition by的区别"></a>group by和partition by的区别</h3><ol>
<li>group by是分组函数，partition by是分析函数；</li>
<li>在执行顺序上，对于group by而言：from&gt;where&gt;group by&gt;having&gt;order by；对于prtition by而言，在执行完select之后，会在所得结果上进行partition；</li>
<li>在group by结果集上进行聚合，会作用在分组下的所有记录上；而在partition by的结果集上进行聚合，就要注意聚合函数是逐条累计进行计算的；</li>
<li>group by将分组记录汇总成一条记录，具有去重效果；partition by会显示所有数据，不会去重。</li>
</ol>
<h3 id="数据库与数据仓库"><a href="#数据库与数据仓库" class="headerlink" title="数据库与数据仓库"></a>数据库与数据仓库</h3><p>当今的数据处理大致可以分成两大类：联机事务处理OLTP（on-line transaction processing）、联机分析处理OLAP（On-Line Analytical Processing）。<br>       基本日常的事务处理，比如数据库记录的增删查改，通常被称为OLTP（On-Line Transaction Processing，联机事务处理），OLTP是数据库的主要应用。<br>       OLAP（On-Line Analytical Processing，联机分析处理）支持复杂的分析操作，侧重提供决策支持，并且提供直观易懂的分析结果，目标是探索并挖掘数据价值，作为企业高层进行决策的参考，OLAP是数据仓库的主要应用。</p>
<p>OLTP的特点一般有：</p>
<ol>
<li>实时性要求高。</li>
<li>数据量不是很大，生产库上的数据量一般不会太大，而且会及时做相应的数据处理与转移。</li>
<li>OLTP是对确定性的数据进行存取。</li>
<li>高并发，并且要求满足ACID原则。比如两人同时操作一个银行卡账户，比如大型的购物网站秒杀活动时上万的QPS请求。</li>
</ol>
<p>OLAP的特点一般有：</p>
<ol>
<li>实时性要求不是很高，比如最常见的应用就是天级更新数据，然后出对应的数据报表。</li>
<li>数据量大，因为OLAP支持的是动态查询，所以用户也许要通过将很多数据进行统计后才能得到想要知道的信息，例如时间序列分析等等，所以处理的数据量很大。</li>
<li>OLAP系统的重点是通过数据提供决策支持。</li>
</ol>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka面试题</title>
    <url>/2022/03/03/kafka%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="Kafka-的概念"><a href="#Kafka-的概念" class="headerlink" title="Kafka 的概念"></a>Kafka 的概念</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>​        做缓冲。正常情况下，网站的行为日志传输到hdfs会使用flume。当flume传输的速率大于hdfs上传的速率，就容易产生数据丢失，于是引入了kafka来做中间的缓存。它是分布式基于发布订阅模式的消息队列，主要用于处理流数据。</p>
<span id="more"></span>

<h4 id="应用场景（使用消息队列的原因，应该也可以看成是使用kafka的原因）"><a href="#应用场景（使用消息队列的原因，应该也可以看成是使用kafka的原因）" class="headerlink" title="应用场景（使用消息队列的原因，应该也可以看成是使用kafka的原因）"></a>应用场景（使用消息队列的原因，应该也可以看成是使用kafka的原因）</h4><ol>
<li>缓冲和削峰：就是用于解决发布和消费的处理速度不一致的情况。</li>
<li>解耦：假设发布者有三个，消费者也有三个，如果不使用消息队列，那么每个发布者都需要写三个接口发往不同的目的地；如果使用消息队列，就可以让发布者将消息统一发给队列，然后消费者再根据需要到队列获取特定的消息，两边的处理过程可以独立扩展或修改。</li>
<li>异步通信：假设用户注册信息写入数据库，正常的步骤是会发送短信告诉用户注册成功。如果是同步通信，就需要等待注册信息写入，并调用接口发送短信，之后页面才会响应注册成功，这个过程会很耗时；如果是异步通信，当用户注册信息成功后，会将发送短信的请求写入消息队列，然后页面直接响应成功，之后等到消息队列处理到这个请求再发送短信，这个过程就不需要等待太多时间。也就是先将核心业务处理完成，也就是注册信息和响应页面处理完成，发送短信这种部署很重要的事情可以发送到队列慢慢完成。</li>
</ol>
<h3 id="消息队列的两种模式（传统的消息传递方式）"><a href="#消息队列的两种模式（传统的消息传递方式）" class="headerlink" title="消息队列的两种模式（传统的消息传递方式）"></a>消息队列的两种模式（传统的消息传递方式）</h3><h4 id="点对点模式"><a href="#点对点模式" class="headerlink" title="点对点模式"></a>点对点模式</h4><p>​        发布者发送消息给消息队列，然后一个消费者会主动拉取消息队列中的数据，然后返回应答，之后消息队列就会删除这条被消费过的数据。</p>
<h4 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h4><p>​        可以在消息队列中存储不同类型的topic，然后消费者消费数据后，消息队列不会删除数据，每个消费者相互独立，都可以消费到数据。</p>
<h4 id="Kafka相较于传统消息传递的优势"><a href="#Kafka相较于传统消息传递的优势" class="headerlink" title="Kafka相较于传统消息传递的优势"></a>Kafka相较于传统消息传递的优势</h4><ol>
<li>快速：单一的kafka代理可以处理成千上万的客户端，每秒处理数兆字节的数据；</li>
<li>可伸缩：在多态服务器上对数据进行分区，以支持更大的数据量；</li>
<li>持久：存储在kafka上的数据具有持久性，且提供副本机制防止数据丢失。</li>
</ol>
<h3 id="Kafka基础架构"><a href="#Kafka基础架构" class="headerlink" title="Kafka基础架构"></a>Kafka基础架构</h3><ol>
<li>Producer：是负责发布数据的生产者；</li>
<li>Consumer：是消费数据的消费者；</li>
<li>Consumer Group：是消费者组，一个组内包含多个消费者，消费者组之间是互相独立的，组内的消费者负责消费不同分区的数据，一个分区只能由消费者组中的一个消费者消费；</li>
<li>Partition：分区，一个非常大的topic可以切分为多个分区，保存在多个broker上，每个partition都是一个有序的队列；</li>
<li>Broker：一个服务器就是一个broker，kafka集群可以包含多个broker，一个broker可以包含多个topic；</li>
<li>replica：为了保证集群中某个节点出现故障时数据不丢失，让kafka能够正常持续的运行，kafka提供了副本机制，为每个分区提供若干个副本，一个leader和多个follower，其中，生产者发布和消费者消费的对象都是leader。</li>
<li>zookeeper：kafka2.4版本之前引入了zookeeper框架来存储broker的节点信息和每个分区的副本信息，在2.4版本之后，出现了kraft代替zookeeper执行相同的内容。</li>
</ol>
<h3 id="Kafka发布数据的流程"><a href="#Kafka发布数据的流程" class="headerlink" title="Kafka发布数据的流程"></a>Kafka发布数据的流程</h3><ol>
<li>由main线程创建一个producer，执行send方法发送数据；</li>
<li>数据首先可以被发送到拦截器，在拦截器内可以对数据进行一些加工处理；</li>
<li>接着数据会经过序列化器将数据序列化后，传到分区器，在分区器内对数据进行分区，然后根据分区的规则分别发布到不同的分区内存储，这些分区存储在内存，分配的内存总大小默认是32M；</li>
<li>分完区后，启动一个sender线程，某一分区的数据量达到batch.size参数设置的16k后，才开始自动将这一批次的数据发往kafka broker；但是如果某一批次的数据量一直没满16k，那么在等待linger.ms参数设置的时间后也会发送数据，这个参数单位是ms，默认是0，也就是没有延迟；</li>
<li>sender线程读取到数据后，会将这些数据封装成一个一个的请求，这些请求是以kv的形式存在的，key是要发往的brokerid，value是发送的数据，然后将请求发往对应的broker；</li>
<li>发送这个过程的底层由一个selector来连接输入和输出流；</li>
<li>broker接收到数据以后，会有一个应答机制：如果是0，那么生产者不需要等待服务器的应答，可以一直发送；如果是1，生产者发布消息，leader接收到后会返回应答；如果是-1或all，那么leader和所有follower接收到数据后才会应答；</li>
<li>这个应答ack会发给selector，如果成功，删除对应的请求，并删除分区中对应的数据；如果失败了会重试，如果一直没有应答，每个broker美容嗯最多只能缓存5个请求。</li>
</ol>
<h3 id="Kafka同步发送和异步发送"><a href="#Kafka同步发送和异步发送" class="headerlink" title="Kafka同步发送和异步发送"></a>Kafka同步发送和异步发送</h3><p>​        同步发送指的是分区内这个批次的数据发送完了，下一批次才能继续发送；异步发送是无论这一批数据是否发送，下一批数据都会继续发送过来。</p>
<p>​        kafka使用的send方法默认就是异步发送，如果想要使用带回调函数的异步发送机制，也就是能够返回这个数据的分区、broker等信息，就使用带callback回调参数的 send(, new callback(){…}) 方法；如果想要同步发送，就在 send() 方法使用 <code>.get()</code> 实现。</p>
<h3 id="Kafka-分区"><a href="#Kafka-分区" class="headerlink" title="Kafka 分区"></a>Kafka 分区</h3><h4 id="使用分区的好处："><a href="#使用分区的好处：" class="headerlink" title="使用分区的好处："></a>使用分区的好处：</h4><ol>
<li>能够合理使用存储资源，将海量数据分别存储在多个服务器上，起到负载均衡的效果；</li>
<li>提高并行度，生产者可以以分区为单位传输数据，消费者也可以以分区为单位消费数据。</li>
</ol>
<h4 id="分区策略："><a href="#分区策略：" class="headerlink" title="分区策略："></a>分区策略：</h4><ol>
<li><p>默认的分区策略：</p>
<p>​        如果传入的数据指定了分区，就向指定分区发布数据；如果没有指定分区，但是指定了key值，就将key值对分区数取模，发布到对应的分区上；如果没有指定分区也没有指定key值，就使用粘性分区器，也就是随机选择一个分区，并在之后一直使用这个分区，直到这个分区内装满一个批次发送出去，再开始随机选择与上一个分区不同的其他分区。</p>
<p>​        <strong>这里有一个面试题</strong>，如果mysql中有一张订单表，希望将这个表的所有数据都发到一个分区，应该怎么做？应该将表名设置为key，那么相同key的数据就会发送到一个分区。</p>
</li>
<li><p>自定义分区器：</p>
<p>​        具体的步骤是：实现Partitioner接口，声明partition、close和configure方法，主要重写的是partition，partition中传入指定的topic、key和value，然后根据传入的参数指定发往某一个分区，分区从0开始。</p>
</li>
</ol>
<h3 id="Kafka丢不丢数据和应答机制有关"><a href="#Kafka丢不丢数据和应答机制有关" class="headerlink" title="Kafka丢不丢数据和应答机制有关"></a>Kafka丢不丢数据和应答机制有关</h3><p>​        当应答为0，也就是producer发送数据后，不需要等待leader的应答，会一直发送数据，此时如果leader还没有将数据从内存持久化到磁盘就宕机，数据就会丢失，虽然效率高，但一般生产环境极少使用；</p>
<p>​        当应答为1，也就是producer发送数据后，会等待leader返回应该后再继续发送数据，此时如果follower还没有进行同步，leader就挂了，新leader无法获取没同步数据，producer也不会重发已经接收的数据，就会导致数据丢失，效率中等，可靠性中等，适合传输普通日志，允许个别丢数据；</p>
<p>​        当应答为-1，也就是producer发送数据后，会等待leader和所有的follower接收到后返回应答，才会继续发送数据，效率查，但是可靠性高，适合传输钱相关的数据。</p>
<p><strong>应答为-1会产生一个问题，如果有一个follower在同步之前出现故障，迟迟不能与leader进行同步，leader会一直等待这个follower。</strong></p>
<p>解决：Leader维护一个动态的ISR队列，也就是和Leader保持同步的follower+leader的集合，如果这个集合中的某个follower长时间未向leader发送请求或同步数据，这个follower就会被提出这个isr队列，这样久不用等待长时间联系不上的节点了。这个时间由参数replica.lag.time.max.ms控制，默认是30s。</p>
<p>​        但是应答为-1的机制也不能完全保证数据的可靠性，如果副本数为1，或者这个isr队列的最小应答数为1，那么当follower全挂的时候，和ack&#x3D;1的效果就是一样的了，仍然会有丢数的风险。</p>
<p>​        如果想要保证数据的完全可靠，在ack&#x3D;-1的情况下，还需要设置分区副本数要大于等于2，isr队列里最小应答数量大于等于2。</p>
<h3 id="Kafka-数据重复"><a href="#Kafka-数据重复" class="headerlink" title="Kafka 数据重复"></a>Kafka 数据重复</h3><p>​        应答为-1除了可靠性的问题，还有数据重复的问题：如果leader在发送ack之前故障了，生产者由于接收不到应答会重发数据，就会导致数据重复。</p>
<p>​        为了解决这个问题，kafka0.11版本后，引入了<strong>幂等性和事务</strong>的特性。</p>
<p>​        幂等性指的是无论生产者向broker发送多少重复的数据，broker只会持久化一条，来保证不重复。这里判断重复的标准是具有相同主键的数据就是重复的，这个主键由三部分组成：pid是生产者的id号，kafka重启一次会给producer分配一个新的id；分区号；sequence number，是一个单调自增的数值。这个方法只能保证在kafka没有挂掉之前的这一次运行过程中，一个分区内不会有重复数据产生。</p>
<p>​        为了解决pid这个问题，引入了事务。事务是建立在幂等性上执行的。在broker上，有两个内容：事务协调器用于处理事务，存储事务的特殊主题，用于持久化存储事务的信息，这个主题的底层也是一个磁盘。其中，事务协调器在每个broker中都有， 如何决定使用哪个broker的事务协调器？首先这个特殊主题默认有50个分区，每个分区负责一部分事务，事务的划分是根据传过来的事务id的哈希值对50取模，然后计算出该事务放到哪个分区，然后由这个分区leader所在的broker上的事务协调器处理这个事务。这个事务id需要由用户手动指定，必须是全局唯一值。这个事务id可以让客户端即使重启也能继续处理未完成的事务。</p>
<p>​        具体的步骤如下：</p>
<ol>
<li>生产者首先向对应的事务协调器请求幂等性要用的pid；</li>
<li>接收到返回的pid后，生产者开始向对应的leader发送数据，发送完后，生产者会向事务协调器请求提交；</li>
<li>事务协调器会将提交请求持久化到特殊主题，持久化后会给生产者返回应答；</li>
<li>接着，事务协调器会向leader发送提交请求，leader将数据接收完后会向协调器返回ack，协调器就会将提交成功的信息持久化到特殊主题。</li>
</ol>
<h3 id="生产者如何提高吞吐量"><a href="#生产者如何提高吞吐量" class="headerlink" title="生产者如何提高吞吐量"></a>生产者如何提高吞吐量</h3><ol>
<li>设置参数 batch.size 和 linger.ms ，调整每批次拉取的数据量和多久拉取一次的时间来提高吞吐量，一般会将 linger.ms 设置为5~100ms，因为太小可能每次拉取的时候都不到一批次的大小，如果太大，那么拉去一次的延时就高了；</li>
<li>设置 compression.type 参数为压缩 snappy，压缩之后一个批次拉取的数据量会更大；</li>
<li>当分区数较多，比如1万的时候，可以增大缓冲区大小，来增大存储的批次，默认 buffer.memory &#x3D; 32M 。</li>
</ol>
<h3 id="生产者发布的数据乱序的问题（面试重点）"><a href="#生产者发布的数据乱序的问题（面试重点）" class="headerlink" title="生产者发布的数据乱序的问题（面试重点）"></a>生产者发布的数据乱序的问题（面试重点）</h3><h4 id="数据乱序的产生"><a href="#数据乱序的产生" class="headerlink" title="数据乱序的产生"></a>数据乱序的产生</h4><p>​        因为brober默认可以连存5个请求而不需要应答，假设1和2成功发送3发送失败了，此时4就顺位继续发送，然后重发3的时候，就会出现乱序，应该是1234的，结果变成1243。</p>
<h4 id="数据乱序的解决"><a href="#数据乱序的解决" class="headerlink" title="数据乱序的解决"></a>数据乱序的解决</h4><ol>
<li>在kafka1版本之前，设置分区内的请求数量为1，只能等到当前请求成功发送才能接收下一个请求；</li>
<li>1版本之后引入了幂等性，如果不开启幂等性，还是需要将分区缓存数设置为1；如果开启幂等性，就可以设置缓存数小于等于5，因为此时broker会缓存生产者发来的最近5个请求的元数据，能够保证最近5个数据都是有序的。具体实现有序的步骤是：broker中请求落盘的顺序是按照seqnumber的自增顺序进行的，例子中当number不为3的时候，哪怕到了4、5也会继续等待，直到请求3到达，会对broker中未落盘的请求按照sqnumber排序，再一次落盘。</li>
</ol>
<h3 id="Broker-ZK存储内容"><a href="#Broker-ZK存储内容" class="headerlink" title="Broker ZK存储内容"></a>Broker ZK存储内容</h3><ol>
<li>在线的brokerid；</li>
<li>每个分区对应的副本所在的brokerid；</li>
<li>在某个分区的leader挂掉后，帮助选举新leader。leader的信息存储在&#x2F;kafka&#x2F;controller目录下，每个broker上都有一个controller模块，旧leader挂掉后，现有节点中的controller都会去注册zookeeper上的controller节点，第一个注册上的Controller负责进行选举。</li>
</ol>
<h3 id="Broker工作流程"><a href="#Broker工作流程" class="headerlink" title="Broker工作流程"></a>Broker工作流程</h3><ol>
<li>启动一台服务器会向ZK注册brokerid；</li>
<li>接着每台服务器上的controller都会去抢占ZK中的controller节点，第一个抢到的负责选举；</li>
<li>选举之前会监听zk上brokers节点的变化，然后以在isr队列中存活为前提，按照ar的顺序轮询，排在前面的优先，ar是kafka分区中所有副本的统称，ar的顺序就是服务器启动并注册到brokers的顺序，选举完后，这个controller将节点信息上传到zk；</li>
<li>其他controller会从zk中同步这个节点信息；</li>
<li>然后，生产者开始发送消息给leader，follower主动向leader同步数据；之后按照应答机制，leader向生产者返回ack；</li>
<li>如果leader挂掉了，zk会返回给监听他的controller，这个controller会从zk拉取节点信息，重新选举leader；</li>
<li>选举出新leader，这个controller再向zk更新节点信息。</li>
</ol>
<h3 id="Kafka副本"><a href="#Kafka副本" class="headerlink" title="Kafka副本"></a>Kafka副本</h3><p>​        副本的作用是提高数据的可靠性，默认副本数是1，在生产环境中一般设置为2，不宜太多，因为副本也会消耗磁盘空间和进行网络运输，太多影响效率。</p>
<p>​        Kafka中所有副本统称为AR，包含了ISR和OSR，ISR中保存和Leader保持同步的leader和follower集合，当ISR中有follower与leader长时间没有通信，会被踢出到OSR集合，这个OSR就是存储超时的follower。这个实际默认是30s，由replica.lag.time.max.ms控制。</p>
<h3 id="Leader和Follower故障处理"><a href="#Leader和Follower故障处理" class="headerlink" title="Leader和Follower故障处理"></a>Leader和Follower故障处理</h3><p>​        这里涉及两个词：LEO指的是每个副本的offset+1，HW指的是所有副本中最小的LEO。</p>
<h4 id="Follower故障"><a href="#Follower故障" class="headerlink" title="Follower故障"></a>Follower故障</h4><p>​        当follower出现故障，会被临时踢出ISR，在恢复期间其他的服务器继续接收数据，并更新LEO和HW。等到这个follower恢复后，会先获取本地磁盘记录中故障前的HW，并将log中高于这个HW的部分删掉重新同步，因为这部分数据对于这个follower是没有验证过的。等到follower的HW等于leader的HW后，再重新加入ISR。</p>
<h4 id="Leader故障"><a href="#Leader故障" class="headerlink" title="Leader故障"></a>Leader故障</h4><p>​        Leader出现故障后，会从ISR中重新选举新Leader。为了保证数据的一致性，会将follower中HW高于leader的部分删掉，对于低于Leader的部分，重新同步。这只能保证数据的一致性，但是不能保证数据不丢失或不重复。</p>
<h3 id="Kafka-Partition自动平衡"><a href="#Kafka-Partition自动平衡" class="headerlink" title="Kafka Partition自动平衡"></a>Kafka Partition自动平衡</h3><p>​        在正常情况下，Kafka会自动把leader partition均匀的分布在集群上，来保证每台服务器的吞吐量是均匀的，但是如果某些broker出现故障，会导致这些broker上的leader会分布到其他broker上，就会导致这些broker的读写请求过多，并且这些leader在故障的broker重启后也不会自动回到之前的broker运行，就会导致集群负载不均衡。</p>
<p>​        有三个参数来优化：</p>
<ol>
<li>auto.leader.rebalance.enable，默认是true，也就是开启leader自平衡；</li>
<li>leader.imbalance.per.broker.percentage，默认是10%，当一个broker的不平衡率到达10%会触发自平衡；</li>
<li>leader.imbalance.check.interval.seconds，默认300s，每过300s检查一次不平衡率。</li>
</ol>
<p>​        不平衡率的计算是，假设一个分区中，leader的brokerid是0，ar队列是 [1,0,2,3]，那么不平衡数会依次比较ar队列和leader的id，如果不相等不平衡数会加一，然后再除以副本总数，也就是这里面的 1&#x2F;4&gt;10% ，那么就会触发自平衡。</p>
<p>​        在生产环境中，这个自平衡不建议开，或者也可以把不平衡率调高，因为自平衡的过程回暂停这个分区的运行，直到平衡完，效率不高。</p>
<h3 id="Broker-文件存储机制"><a href="#Broker-文件存储机制" class="headerlink" title="Broker 文件存储机制"></a>Broker 文件存储机制</h3><p>​        Kafka中，topic只是一个逻辑概念，实际存储的是partition。每个partition对应一个log文件，这个log用于存储发布的数据，生产者会将生产的数据不断追加到log文件的结尾，为了避免log文件过大导致定位效率低下，将一个log文件切分为多个segment存储，一个segment是1G，里面主要包含的文件有.log存储实际的文件、.index存储.log中数据的索引、.timeindex存储索引进入的时间戳，因为数据默认是保存7天，这个时间戳文件用于在规定时间到后删除数据。</p>
<p>​        一个partition的数据会存在一个文件夹下，以 topic名称-分区号 命名，其中每个segment下的文件以当前segment的第一条消息的offset命名。</p>
<p>​        其中，index是稀疏索引，大约每往log中插入4k的数据会写入一条索引，这个4k可以通过 log.index.interval.bytes 修改。index文件中存放的offset是相对的offset，这样能够确保offset的值所占空间不会太大，因此能将offset控制在固定大小。</p>
<p>​        比如想要在log中定位 offset &#x3D; 600 的数据，会先比较index文件的文件名，找到小于600的最大的值，定位到这个index文件，然后在index文件中找到绝对offset中小于600的最大的offset，因为文件中存的是相对offset，那么绝对offset旧等于文件名对应的值加上这个相对offset，然后取出这个offset对应的position，也就是log文件中这个offset的起始位置，就能得到log中offset为600的数据了。</p>
<h3 id="文件清理策略"><a href="#文件清理策略" class="headerlink" title="文件清理策略"></a>文件清理策略</h3><p>​        Kafka中默认的日志保存时间是7天，可以通过调整如下参数来修改保存时间：</p>
<ol>
<li>log.retention.hours，设置保存的小时数，默认7天；</li>
<li>log.retention.minutes，设置保存的分钟数，设置这个，小时数的参数就不起作用；</li>
<li>log.retention.ms，设置保存的毫秒数，设置这个，分钟数举不起作用。</li>
<li>log.retention.check.intervals.ms，设置检查的周期，默认是5分钟，这个值应该要比保存时间要小。</li>
</ol>
<p>​        一旦数据超过了保存的时间，就会触发清理。清理的策略有delete和compact。默认的策略是删除。</p>
<p>​        删除就是当一个segment中最新写入的数据超过这个保存的时间，就会把这个segment删掉。压缩是对相同key的不同value值，只保留最新版本的数据。压缩后的offset实际是不连续的，只适用于一些特殊场景，比如key是用户id，value是用户资料，可以只保留用户最近的资料。如果想要设置清理策略为compact，可以修改参数 log.cleanup.policy &#x3D; compact 。</p>
<h3 id="Kafka高效读写（高频面试）"><a href="#Kafka高效读写（高频面试）" class="headerlink" title="Kafka高效读写（高频面试）"></a>Kafka高效读写（高频面试）</h3><ol>
<li>Kafka本身是分布式集群，采用分区技术，并行度高；</li>
<li>读数据采用稀疏索引，定位快；</li>
<li>producer发布数据的时候，是顺序追加到log文件的，可以减少寻址时间；</li>
<li>采用零拷贝+页缓存的技术。</li>
</ol>
<p>​        页缓存：Kafka重度依赖底层操作系统提高的页缓存功能，当上层有写操作时，操作系统只是把数据写入页缓存，之后数据什么时候落盘取决于linux内核，当读操作时，先从页缓存中查找，没有再到磁盘查找。实际上，页缓存是把尽可能多的空闲内存当作磁盘来使用。</p>
<p>​        零拷贝：kafka将数据的加工处理操作都交给生产者和消费者，本身不用于存储数据，所以数据的读取在查找磁盘和缓存后直接不需要再上传到kafka，而是直接通过网卡发送给消费者，提高了传输的效率。</p>
<h3 id="消费者的总体工作流程"><a href="#消费者的总体工作流程" class="headerlink" title="消费者的总体工作流程"></a>消费者的总体工作流程</h3><p>​        由于消费者之间互相独立，那么传输的速度肯定不可能一致，所以消费者的消费是主动从leader拉取数据的过程。一个消费者可以消费多个分区，但是一个分区只能被消费者组中的一个消费者消费。为了避免消费者挂掉重启后重复消费数据，会记录分区中最新读取到的offset。在0.9版本之前，这个信息是存储在zookeeper上的，但是由于所有消费者都需要通过网络和zookeeper交互获取offset，效率太低，在0.9版本之后改为使用本地的系统主题来存储offset，因为kafka中的主题数据最终都是存储在磁盘，所以可靠性得到保证。在系统主题中，使用kv的形式存储，key是 groupid+topic+分区号，value是当前offset的值。每隔一段时间，kafka会对系统主题中的数据进行压缩，也就是每个key只保留最新的数据。</p>
<h3 id="消费者组的初始化流程（重点）"><a href="#消费者组的初始化流程（重点）" class="headerlink" title="消费者组的初始化流程（重点）"></a>消费者组的初始化流程（重点）</h3><p>​        通过使用coordinator来辅助实现消费者组的初始化和分区的分配。每个broker都存在一个coordinator。首先使用消费者组的groupid的hash值对存储offset的系统主题的分区数，默认是50取模，然后选择这个分区所在的broker上coordinator进行之后的操作。</p>
<ol>
<li>每个consumer都会往这个coodinator上发送加入这个消费者组的请求；</li>
<li>coodinator会随机从这些请求的消费者中选出一个leader，并将接收到的所有信息都发给这个leader；</li>
<li>leader负责指定消费的方案，也就是哪个consumer消费哪个分区；</li>
<li>制定完后发回给coordinator，然后coordinator群发给所有的consumer；</li>
<li>每个consumer都会和coordinator保持默认3秒的心跳通信，也就是会定期汇报自己还活着，一旦超过 session.timeout.ms 参数默认的时间45s，该消费者就会被移除出组，并触发再平衡，或者这个消费者处理消息的时间超过 max.poll.interval.ms 默认是5分钟，也会触发再平衡。</li>
</ol>
<h3 id="消费者组具体消费流程"><a href="#消费者组具体消费流程" class="headerlink" title="消费者组具体消费流程"></a>消费者组具体消费流程</h3><p>​        首先创建一个消费者网络客户端，主要用于和kafka集群做交互。消费者组会向这个客户端发送消费请求，这个请求默认每批次最小抓取量 fetch.min.bytes &#x3D; 1字节，默认每批次最小值未达到的超时时间 fetch.max.wait.ms &#x3D; 500ms ，默认每批次最大抓取量 fetch.max.bytes &#x3D; 50M 。</p>
<p>​        接着客户端调用send方法发送请求到对应的leader，然后通过addListener方法中的 onSuccess 回调函数拉取数据到一个叫 completedFetches 的消息队列中，之后消费者会从这个消息队列拉取对应的数据，max.poll.records 默认拉取的最大条数是500条。拉取的数据首先会被反序列化，接着经过拦截器，对数据进行加工或处理后就可以正常处理数据了。</p>
<h3 id="分区的分配和再平衡"><a href="#分区的分配和再平衡" class="headerlink" title="分区的分配和再平衡"></a>分区的分配和再平衡</h3><h4 id="分区的分配"><a href="#分区的分配" class="headerlink" title="分区的分配"></a>分区的分配</h4><p>​        也就是如何规定哪个consumer消费哪个分区。kafka提供了四种分配策略：range、rangeRobin、Sticky、CooporativeSticky。默认使用的是rage+CooporativeSticky策略，配置的参数是 partition.assignment.strategy 。可以同时使用多个策略。</p>
<h5 id="Range分配"><a href="#Range分配" class="headerlink" title="Range分配"></a>Range分配</h5><p>​        Range是针对每个topic来说的。会将这个topic中的分区按照序号排序，然后将consumer按照字母顺序排序。将分区数除以消费者数，得到每个消费者消费的分区数，如果除不尽就交由前面的消费者分别处理一个分区。</p>
<p>​        比如有8个分区，3个消费者，8 &#x2F; 3 &#x3D; 2 …… 2，那么第一个消费者消费0-2的分区，第二个消费者消费3-5的分区，第三个消费者消费6-7的分区。</p>
<p>​        这种模式如果在消费多topic的情况下，前面的消费者处理的内容就会很多，那么就容易造成数据倾斜。</p>
<p>​        这种模式下，如果消费者组的某个消费者出现故障，那么这个消费者负责的分区正在处理的操作会全部分配到另一个消费者上，等到处理完这一波，下一次接收数据的时候，再根据range策略重新分配分区。</p>
<h5 id="RangeRobin分配以及再平衡"><a href="#RangeRobin分配以及再平衡" class="headerlink" title="RangeRobin分配以及再平衡"></a>RangeRobin分配以及再平衡</h5><p>​        RangeRobin是针对所有topic来说的。会将所有topic的分区和所有consumer都列出来，按照hashcode排序，最后通过轮询算法来分配分区。</p>
<p>​        如果某个消费者出现故障，这个消费者负责的分区依然会按照轮询的策略均分给其他的消费者。</p>
<h5 id="Sticky分配以及再平衡"><a href="#Sticky分配以及再平衡" class="headerlink" title="Sticky分配以及再平衡"></a>Sticky分配以及再平衡</h5><p>​        是0.11版本引入的，首先会尽量均衡的分配分区，如果同消费组的某个消费者出现问题，会尽量保证原有分配的分区不变化。</p>
<p>​        该策略的首次分配和Range很像，但是粘性策略不进行排序。如果某个消费者出现故障，会将这个消费者负责的分区尽量均衡分配到其他分区上。这个再平衡的过程会让所有消费者放弃原有分区进行重分配。</p>
<h5 id="CooporativeSticky分配以及再平衡"><a href="#CooporativeSticky分配以及再平衡" class="headerlink" title="CooporativeSticky分配以及再平衡"></a>CooporativeSticky分配以及再平衡</h5><p>​        这个策略和Sticky策略很像，但是在消费者故障之后，不会让所有其他消费者放弃已有分区进行全局重平衡，而是改成多次小规模分区重平衡。</p>
<h3 id="Offset的保存和提交"><a href="#Offset的保存和提交" class="headerlink" title="Offset的保存和提交"></a>Offset的保存和提交</h3><h4 id="Offset的保存"><a href="#Offset的保存" class="headerlink" title="Offset的保存"></a>Offset的保存</h4><p>​        在0.9版本之前使用zookeeper存储，但是所有的消费者都和zookeeper进行交互，效率就会很低，所以在0.9版本之后引入了系统主题来存储offset。存储的是kv形式的数据，key保存 groupid+topic+分区号，value保存当前offset的位置。kafka每隔一段时间就会对系统主题的内容进行压缩，也就是只保留每个key中最新的数据。</p>
<h4 id="Offset的提交"><a href="#Offset的提交" class="headerlink" title="Offset的提交"></a>Offset的提交</h4><h5 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h5><p>​        enable.auto.commit 默认是true，也就是默认开启自动提交的功能，auto.commit.interval.ms 默认5s自动提交一次。</p>
<p>​        具体的提交流程是：consumer不断的从分区拉取数据，然后每隔5s向系统主题提交一次当前拉取的offset。</p>
<h5 id="手动提交"><a href="#手动提交" class="headerlink" title="手动提交"></a>手动提交</h5><p>​        自动提交虽然便利，但是因为是基于时间提交的，所以提交时机不好把控。于是kafka提供了手动提交的api实现。</p>
<p>​        手动提交的方式有两种：同步和异步。二者都是将本次提交的最高偏移量提交。不同的是，同步提交是等到offset提交到系统主题完成后再拉取下一波数据，这种模式会阻塞当前线程直到提交成功，并在失败时重试；异步提交是发送完offset提交请求后就继续拉取下一波数据了，不会进行失败重试，可能提交失败。</p>
<h4 id="指定offset消费"><a href="#指定offset消费" class="headerlink" title="指定offset消费"></a>指定offset消费</h4><p>​        通过参数 auto.offset.reset 指定消费的位置。包括三种：</p>
<ol>
<li>earliest：从分区最开始的位置消费；</li>
<li>latest：从分区最新的位置开始消费，这是默认值；</li>
<li>none：如果没有找到消费者组之前消费的位置，会向消费者抛出异常。</li>
</ol>
<p>​        如果既不想从开始的位置消费，也不想从最新的位置消费，而是想从中间的某个指定位置开始消费，可以在代码中手动指定：consumer.seek(partition, offset) 。因为消费者组的初始化过程会消耗一定时间，而在代码中因为是顺序执行，可能在还没有分配完分区就已经执行到这个代码，就会导致获取不到数据。为了避免这个错误，可以指定消费之前使用 while 循环，在还没有制定好分配方案时不往下进行，并在循环中频繁获取分区信息，一旦分配完毕旧立刻退出。</p>
<h3 id="消费者事务"><a href="#消费者事务" class="headerlink" title="消费者事务"></a>消费者事务</h3><h4 id="重复消费和漏消费"><a href="#重复消费和漏消费" class="headerlink" title="重复消费和漏消费"></a>重复消费和漏消费</h4><p>​        重复消费一般是由自动提交引起的。具体的过程是：consumer默认会5s提交一次offset，并且在发送完这个提交请求后继续拉取数据。假设提交这个offset &#x3D; 2 的请求完成后，这个consumer消费到offset &#x3D; 4的时候挂掉了，此时因为还没到5s，所以还没有发送请求，再次重启就会从offset&#x3D;2的位置继续消费，那么offset&gt;2&amp;&amp;offset&lt;&#x3D;4的位置的数据就被重复消费了。</p>
<p>​        漏消费的场景是：假设offset设置为手动提交，当consumer拉取数据，并向系统主题提交offset的时候，当offset提交完成，但是数据还没有完全落盘的时候，这个消费者挂掉了，这个时候就会导致还未落盘的这部分数据丢失。</p>
<h4 id="消费者事务解决重复消费和漏消费"><a href="#消费者事务解决重复消费和漏消费" class="headerlink" title="消费者事务解决重复消费和漏消费"></a>消费者事务解决重复消费和漏消费</h4><p>​        想要完成consumer端的一次性精准消费，就需要将消费的过程和提交offset的过程作为一个事务进行处理，同时消费者需要支持事务回滚而当操作，比如mysql、kafka其他主题等就可以，但是hbase因为不支持事务回滚，所以是会存在问题的。</p>
<p>​        想要完全做到精确一次消费，除了消费端要使用事务，生产者也需要采用幂等性+事务的特性，同时也需要做到ack&#x3D;-1、副本数大于等于2、isr最小应答数大于等于2。</p>
<h3 id="数据积压（消费者如何提高吞吐量）（重要）"><a href="#数据积压（消费者如何提高吞吐量）（重要）" class="headerlink" title="数据积压（消费者如何提高吞吐量）（重要）"></a>数据积压（消费者如何提高吞吐量）（重要）</h3><ol>
<li>如果是kafka的topic数据量大，导致消费速度慢，可以考虑增加分区，但是多个分区使用一个消费者消费也不会很快，于是需要同时提升二者的数量，保证消费者数 &#x3D;&#x3D; 分区数。</li>
<li>如果是消费者处理的速度慢，可以考虑增大每批次拉取的数据量，但是这个数据量有设置上限为fetch.max.bytes &#x3D; 50M ，应该如果每批次拉取的量太大，也需要增大这个上限。</li>
</ol>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL刷题 &amp; 笔记</title>
    <url>/2021/07/09/SQL%E5%88%B7%E9%A2%98%20&amp;%20%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="获取每一个分组中的最大元素"><a href="#获取每一个分组中的最大元素" class="headerlink" title="获取每一个分组中的最大元素"></a>获取每一个分组中的最大元素</h2><p><a href="https://www.nowcoder.com/practice/4a052e3e1df5435880d4353eb18a91c6?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL12 获取每个部门中当前员工薪水最高的相关信息</a></p>
<span id="more"></span>

<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-知识点"><a href="#1-知识点" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p>要求获取每一个分组中的最大元素（也可以看作获取每个分组的第一个元素）。</p>
<p>错误的思考：在同一个语句中group by+order by - </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 错误</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> a <span class="keyword">order</span> <span class="keyword">by</span> b</span><br></pre></td></tr></table></figure>

<p>原因：group by后显示的就会是每个分组的第一条数据；之后进行order by就是对每个分组的第一条数据进行排序，即组间排序，并没有意义。</p>
<p>分析：有一种方法是可以先order by limit再进行group by，但是这种方法不够灵活有效；还有一种方法就算下述，先获取每个分组的目标元素的最大值和目标分组的字段，然后联表获取所有所需字段和目标分组字段，将两个部分进行连接就可以了。</p>
<h4 id="2-具体题解"><a href="#2-具体题解" class="headerlink" title="2. 具体题解"></a>2. 具体题解</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> B1.dept_no</span><br><span class="line">      ,B2.emp_no</span><br><span class="line">      ,B1.maxSalary</span><br><span class="line">  <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">        <span class="keyword">select</span> A1.dept_no, <span class="built_in">max</span>(A2.salary) <span class="keyword">as</span> maxSalary</span><br><span class="line">          <span class="keyword">from</span> dept_emp <span class="keyword">as</span> A1</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> salaries <span class="keyword">as</span> A2</span><br><span class="line">            <span class="keyword">on</span> A1.emp_no <span class="operator">=</span> A2.emp_no</span><br><span class="line">      <span class="keyword">group</span> <span class="keyword">by</span> A1.dept_no</span><br><span class="line">) B1</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line">(</span><br><span class="line">        <span class="keyword">select</span> A1.dept_no, A1.emp_no, A2.salary</span><br><span class="line">          <span class="keyword">from</span> dept_emp <span class="keyword">as</span> A1</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> salaries <span class="keyword">as</span> A2</span><br><span class="line">            <span class="keyword">on</span> A1.emp_no <span class="operator">=</span> A2.emp_no</span><br><span class="line">) B2</span><br><span class="line">     <span class="keyword">on</span> B1.dept_no <span class="operator">=</span> B2.dept_no</span><br><span class="line">     <span class="keyword">and</span> B1.maxSalary <span class="operator">=</span> B2.salary</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> B1.dept_no</span><br><span class="line">;</span><br></pre></td></tr></table></figure>



<h2 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h2><p><a href="https://www.nowcoder.com/practice/a32669eb1d1740e785f105fa22741d5c?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL15 查找employees表emp_no与last_name的员工信息</a></p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-知识点-1"><a href="#1-知识点-1" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p>不相等的三种表达：<code>!=、&lt;&gt;、is not</code>；</p>
<p>求余：<code>%、MOD</code>；</p>
<p>判断是否为奇数：<code>val%2 = 1、val&amp;1</code>；</p>
<p>判断是否为偶数：<code>val = (val &gt;&gt; 1 &lt;&lt; 1)</code> - 即先右移一位再左移一位，如果是奇数，二进制最后一位一定是1，右移一位后再左移一位最后一个二进制数会补0而不是1，此时如果是奇数会与原值不等，如果是偶数会相等；</p>
<p>除法计算：默认 - <code>/</code>、取指定小数位 - <code>convert(val1 / val2, decimal(10, 2))</code> - 取两位小数，为0取整不保留小数、直接取整 - <code>val1 DIV val2</code>；</p>
<h4 id="2-具体代码"><a href="#2-具体代码" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">from</span> employees</span><br><span class="line">   <span class="keyword">where</span> emp_no <span class="operator">%</span> <span class="number">2</span> <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">     <span class="keyword">and</span> last_name <span class="operator">&lt;&gt;</span> &quot;Mary&quot;</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> hire_date</span><br><span class="line">    <span class="keyword">desc</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">--或者</span></span><br><span class="line">  <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">from</span> employees</span><br><span class="line">   <span class="keyword">where</span> emp_no <span class="operator">&amp;</span> <span class="number">1</span></span><br><span class="line">     <span class="keyword">and</span> last_name <span class="operator">&lt;&gt;</span> &quot;Mary&quot;</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> hire_date</span><br><span class="line">    <span class="keyword">desc</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>



<h2 id="生成序号"><a href="#生成序号" class="headerlink" title="生成序号"></a>生成序号</h2><p><a href="https://www.nowcoder.com/practice/b9068bfe5df74276bd015b9729eec4bf?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL23 对所有员工的薪水按照salary降序进行1-N的排名</a></p>
<h3 id="求解思路"><a href="#求解思路" class="headerlink" title="求解思路"></a>求解思路</h3><h4 id="1-知识点-2"><a href="#1-知识点-2" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><ol>
<li><code>row_number</code> - 生成连续唯一的序号，即序号不重复：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>)</span><br></pre></td></tr></table></figure>

<p>得到结果：</p>
<blockquote>
<p>1</p>
<p>2</p>
<p>2</p>
<p>3</p>
</blockquote>
<ol start="2">
<li><code>rank</code> - 分区内排名，即一个分区的排名一致，但会产生间断：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>)</span><br></pre></td></tr></table></figure>

<p>得到结果：</p>
<blockquote>
<p>1</p>
<p>2</p>
<p>2</p>
<p>4</p>
</blockquote>
<ol start="2">
<li><code>dense_rank</code> - 分区内排名，不会产生间断：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ... <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>)</span><br></pre></td></tr></table></figure>

<p>得到结果：</p>
<blockquote>
<p>1</p>
<p>2</p>
<p>2</p>
<p>3</p>
</blockquote>
<ol start="2">
<li><code>ntile</code> - 按照指定的排序规则均分成指定数目的组</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ntile</span>(<span class="number">2</span>) <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>)</span><br></pre></td></tr></table></figure>

<p>得到结果：</p>
<blockquote>
<p>1</p>
<p>1</p>
<p>2</p>
<p>2</p>
</blockquote>
<h4 id="2-具体代码-1"><a href="#2-具体代码-1" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> emp_no</span><br><span class="line">       ,salary</span><br><span class="line">       ,<span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>) <span class="keyword">as</span> t_rank</span><br><span class="line">  <span class="keyword">from</span> salaries</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> t_rank <span class="keyword">asc</span>, emp_no <span class="keyword">asc</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>



<h2 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h2><p><a href="https://www.nowcoder.com/practice/979b1a5a16d44afaba5191b22152f64a?tpId=199&tags=&title=&difficulty=0&judgeStatus=0&rp=0">SQL25 查找山东大学或者性别为男生的信息</a></p>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题第一个想到的解法是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">where</span> university <span class="operator">=</span> <span class="string">&#x27;山东大学&#x27;</span> <span class="keyword">or</span> gender <span class="operator">=</span> <span class="string">&#x27;male&#x27;</span></span><br></pre></td></tr></table></figure>

<p>但是题目中有两个提示：</p>
<ol>
<li>结果不去重；</li>
<li>注意输出的顺序，先输出学校为山东大学再输出性别为男生的信息。</li>
</ol>
<p>从第一个提示看应该会有去不去重两种可能，这道题其实有两种思路：<code>or</code> 和 <code>union</code>。对于 <code>or</code> 肯定不会存在去不去重的问题，确定是 <code>union</code> 的关键是第二个提示，使用 <code>union</code> 方法都会默认 <code>union</code> 前的结果会放在 <code>union</code> 后的结果前。</p>
<p>去重的问题：union会去重，union all 不会去重。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> device_id, gender, age, gpa</span><br><span class="line">  <span class="keyword">from</span> user_profile</span><br><span class="line"> <span class="keyword">where</span> university <span class="operator">=</span> <span class="string">&#x27;山东大学&#x27;</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> device_id, gender, age, gpa</span><br><span class="line">  <span class="keyword">from</span> user_profile</span><br><span class="line"> <span class="keyword">where</span> gender <span class="operator">=</span> <span class="string">&#x27;male&#x27;</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>



<h2 id="insert-ignore-和-replace-into"><a href="#insert-ignore-和-replace-into" class="headerlink" title="insert ignore 和 replace into"></a>insert ignore 和 replace into</h2><p><a href="https://www.nowcoder.com/practice/153c8a8e7805400ba8e384e03acc6b3e?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL35 批量插入数据，不使用replace操作</a></p>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>主要是insert ignore 和 replace into 的区别：</strong></p>
<p>使用 <code>ignore</code> 关键字。</p>
<p><code>insert ignore</code>  - 如果数据库中不存在这条数据就插入，存在就跳过。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> </span><br><span class="line">ignore </span><br><span class="line">  <span class="keyword">into</span> actor </span><br><span class="line"><span class="keyword">values</span>(<span class="number">3</span>, <span class="string">&#x27;ED&#x27;</span>, <span class="string">&#x27;CHASE&#x27;</span>, <span class="string">&#x27;2006-02-15 12:34:33&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>使用 <code>replace</code> 关键字。</p>
<p><code>replace into</code> - 如果存在 <code>primary key</code> 或 <code>unique</code> 相同的记录，先删除原有记录，再添加此新记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">replace </span><br><span class="line">   <span class="keyword">into</span> actor</span><br><span class="line"> <span class="keyword">select</span> <span class="number">3</span></span><br><span class="line">        ,<span class="string">&#x27;ED&#x27;</span></span><br><span class="line">        ,<span class="string">&#x27;CHASE&#x27;</span></span><br><span class="line">        ,<span class="string">&#x27;2006-02-15 12:34:33&#x27;</span></span><br><span class="line">   <span class="keyword">from</span> actor</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p><strong>ignore 和 replace 是mysql8之后有的内容。</strong></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><a href="https://www.nowcoder.com/practice/e1824daa0c49404aa602cf0cb34bdd75?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL37 对first_name创建唯一索引uniq_idx_firstname</a></p>
<p><a href="https://www.nowcoder.com/practice/4963f6d63dde48d787aaa2b43460fb4b?tpId=240&tags=&title=&difficulty=0&judgeStatus=0&rp=0"><strong>SQL13</strong> <strong>删除索引</strong></a></p>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><h3 id="1-知识点-3"><a href="#1-知识点-3" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>有以下几种索引 <code>index</code> ：</p>
<ul>
<li>UNIQUE:可选。表示索引为唯一性索引。</li>
<li>FULLTEXT:可选。表示索引为全文索引。</li>
<li>SPATIAL:可选。表示索引为空间索引。</li>
<li>默认上述关键字都不加，表示索引为普通索引。</li>
</ul>
<p>添加索引的几种方式：</p>
<ol>
<li>创建表时添加：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test</span><br><span class="line">(</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">    filename <span class="type">VARCHAR</span> (<span class="number">512</span>),</span><br><span class="line">    fileurl <span class="type">VARCHAR</span> (<span class="number">512</span>),</span><br><span class="line">    filesize <span class="type">BIGINT</span>,</span><br><span class="line">    <span class="comment">-- 带关键字索引</span></span><br><span class="line">    <span class="keyword">unique</span> index (id),</span><br><span class="line">    <span class="comment">-- 普通索引</span></span><br><span class="line">    index (filename),</span><br><span class="line">    <span class="comment">--组合索引</span></span><br><span class="line">    index (fileurl, filesize)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>为已有表添加：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 带关键字的索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test <span class="keyword">add</span> <span class="keyword">unique</span> index (id);</span><br><span class="line"><span class="comment">-- 不带关键字的索引</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test <span class="keyword">add</span> index (filename);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>删除索引：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">drop</span> index index_name;</span><br></pre></td></tr></table></figure>



<h4 id="2-具体代码-2"><a href="#2-具体代码-2" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> actor <span class="keyword">add</span> <span class="keyword">unique</span> index uniq_idx_firstname (first_name);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> actor <span class="keyword">add</span> index idx_lastname (last_name);</span><br></pre></td></tr></table></figure>



<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p><a href="https://www.nowcoder.com/practice/b9db784b5e3d488cbd30bd78fdb2a862?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL38 针对actor表创建视图actor_name_view</a></p>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-知识点-4"><a href="#1-知识点-4" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p>创建视图：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br></pre></td></tr></table></figure>

<p>查询视图：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> view_name;</span><br></pre></td></tr></table></figure>

<p>更新视图：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br></pre></td></tr></table></figure>

<p>撤销视图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW view_name</span><br></pre></td></tr></table></figure>

<h4 id="2-具体解决代码"><a href="#2-具体解决代码" class="headerlink" title="2. 具体解决代码"></a>2. 具体解决代码</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> actor_name_view <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">select</span> first_name <span class="keyword">as</span> first_name_v</span><br><span class="line">       ,last_name <span class="keyword">as</span> last_name_v</span><br><span class="line">  <span class="keyword">from</span> actor;</span><br></pre></td></tr></table></figure>



<h2 id="强制使用索引"><a href="#强制使用索引" class="headerlink" title="强制使用索引"></a>强制使用索引</h2><p><a href="https://www.nowcoder.com/practice/f9fa9dc1a1fc4130b08e26c22c7a1e5f?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL39 强制使用索引</a></p>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-知识点-5"><a href="#1-知识点-5" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p>强制使用索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> TABLE1 FORCE INDEX (索引名或<span class="keyword">PRIMARY</span>) ;</span><br></pre></td></tr></table></figure>

<h4 id="2-具体代码-3"><a href="#2-具体代码-3" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> salaries FORCE INDEX (idx_emp_no) <span class="keyword">where</span> emp_no <span class="operator">=</span> <span class="number">10005</span>;</span><br></pre></td></tr></table></figure>



<h2 id="给已有表新建列"><a href="#给已有表新建列" class="headerlink" title="给已有表新建列"></a>给已有表新建列</h2><p><a href="https://www.nowcoder.com/practice/119f04716d284cb7a19fba65dd876b03?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL40 在指定列后添加新列</a></p>
<h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-知识点-6"><a href="#1-知识点-6" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">alter</span> </span><br><span class="line">  <span class="keyword">table</span> table_name</span><br><span class="line">    <span class="keyword">add</span></span><br><span class="line"> <span class="keyword">COLUMN</span> column_name column_type [<span class="keyword">not</span> <span class="keyword">NULL</span>]</span><br><span class="line">[<span class="keyword">DEFAULT</span> default_context]</span><br><span class="line">[  after column_name]</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>其中，<code>after</code> 用来指定在某个列后面添加新列，<code>default</code> 指定默认值。</p>
<h4 id="2-具体代码-4"><a href="#2-具体代码-4" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">alter</span> </span><br><span class="line">  <span class="keyword">table</span> actor</span><br><span class="line">    <span class="keyword">add</span></span><br><span class="line"> <span class="keyword">COLUMN</span> create_date datetime <span class="keyword">not</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">DEFAULT</span> <span class="string">&#x27;2020-10-01 00:00:00&#x27;</span></span><br><span class="line">  after last_update</span><br><span class="line">;</span><br></pre></td></tr></table></figure>



<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p><a href="https://www.nowcoder.com/practice/7e920bb2e1e74c4e83750f5c16033e2e?tpId=82&&tqId=29809&rp=1&ru=/activity/oj&qru=/ta/sql/question-ranking">SQL41 构造一个触发器</a></p>
<h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-知识点-7"><a href="#1-知识点-7" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p>Trigger创建的语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">       trigger_time trigger_event </span><br><span class="line">    <span class="keyword">ON</span> tbl_name</span><br><span class="line">   <span class="keyword">FOR</span> </span><br><span class="line">  <span class="keyword">EACH</span> </span><br><span class="line">   <span class="type">ROW</span></span><br><span class="line">       trigger_stmt</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<blockquote>
<p><strong>参数解析</strong></p>
<p>trigger_name：标识触发器名称，用户自行指定；<br>trigger_time：标识触发时机，取值为 BEFORE 或 AFTER；<br>trigger_event：标识触发事件，取值为 INSERT、UPDATE 或 DELETE；<br>tbl_name：标识建立触发器的表名，即在哪张表上建立触发器；<br>trigger_stmt：触发器程序体，可以是一句SQL语句，或者用 BEGIN 和 END 包含的多条语句，每条语句结束要分号结尾。</p>
<p><strong>new 和 old</strong></p>
<p>MySQL 中定义了 NEW 和 OLD，用来表示触发器的所在表中，触发了触发器的那一行数据。<br>具体地：</p>
<ol>
<li>在 INSERT 型触发器中，NEW 用来表示将要（BEFORE）或已经（AFTER）插入的新数据；</li>
<li>在 UPDATE 型触发器中，OLD 用来表示将要或已经被修改的原数据，NEW 用来表示将要或已经修改为的新数据；</li>
<li>在 DELETE 型触发器中，OLD 用来表示将要或已经被删除的原数据；</li>
<li>使用方法： NEW.columnName （columnName 为相应数据表某一列名）</li>
</ol>
</blockquote>
<h4 id="2-具体代码-5"><a href="#2-具体代码-5" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">      <span class="keyword">create</span> </span><br><span class="line">     <span class="keyword">trigger</span> audit_log</span><br><span class="line">       after </span><br><span class="line">      <span class="keyword">insert</span> </span><br><span class="line">          <span class="keyword">on</span> employees_test</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line">       <span class="keyword">begin</span></span><br><span class="line">             <span class="keyword">insert</span> <span class="keyword">into</span> audit <span class="keyword">values</span>(new.ID, new.NAME);</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<h4 id="3-摘自"><a href="#3-摘自" class="headerlink" title="3. 摘自"></a>3. 摘自</h4><p><a href="https://blog.csdn.net/haut_ykc/article/details/110226668">SQL编程：构造触发器</a></p>
<h2 id="表的更新和删除"><a href="#表的更新和删除" class="headerlink" title="表的更新和删除"></a>表的更新和删除</h2><p><a href="https://www.nowcoder.com/practice/3d92551a6f6d4f1ebde272d20872cf05?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL42 对表进行条件删除</a></p>
<p><a href="https://www.nowcoder.com/practice/859f28f43496404886a77600ea68ef59?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL43 对表进行条件更新</a></p>
<h3 id="解题思路-9"><a href="#解题思路-9" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-知识点-8"><a href="#1-知识点-8" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p>删除语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name [<span class="keyword">WHERE</span> Clause]</span><br></pre></td></tr></table></figure>

<p>更新语法：</p>
<ol>
<li>设置为新值：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE table_name <span class="keyword">SET</span> field1<span class="operator">=</span><span class="keyword">new</span><span class="operator">-</span>value1, field2<span class="operator">=</span><span class="keyword">new</span><span class="operator">-</span>value2</span><br><span class="line">[<span class="keyword">WHERE</span> Clause]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>根据已有值替换：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE table_name <span class="keyword">SET</span> key1<span class="operator">=</span>replace(key1, <span class="string">&#x27;查找内容&#x27;</span>, <span class="string">&#x27;替换成内容&#x27;</span>)</span><br><span class="line">[<span class="keyword">WHERE</span> Clause]</span><br></pre></td></tr></table></figure>

<h4 id="2-具体代码-6"><a href="#2-具体代码-6" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> titles_test</span><br><span class="line"><span class="keyword">where</span> id <span class="keyword">not</span> <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">select</span> <span class="built_in">min</span>(id)</span><br><span class="line">        <span class="keyword">from</span> titles_test</span><br><span class="line">        <span class="keyword">group</span> <span class="keyword">by</span> emp_no</span><br><span class="line">    )A1</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">--更新</span></span><br><span class="line">UPDATE titles_test</span><br><span class="line">   <span class="keyword">SET</span> to_date<span class="operator">=</span><span class="keyword">NULL</span></span><br><span class="line">       ,from_date<span class="operator">=</span><span class="string">&#x27;2001-01-01&#x27;</span></span><br><span class="line"> <span class="keyword">WHERE</span> to_date <span class="operator">=</span> <span class="string">&#x27;9999-01-01&#x27;</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>这里有一个犯过的错误：</p>
<p><strong>group by前面的select语句中要用聚合函数！！！不然是没有作用的。</strong></p>
<h2 id="alter和update"><a href="#alter和update" class="headerlink" title="alter和update"></a>alter和update</h2><p><a href="https://www.nowcoder.com/practice/5277d7f92aa746ab8aa42886e5d570d4?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL44 alter</a></p>
<p><a href="https://www.nowcoder.com/practice/2bec4d94f525458ca3d0ebf3bc8cd240?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL45 update</a></p>
<h3 id="解题思路-10"><a href="#解题思路-10" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-知识点-9"><a href="#1-知识点-9" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p>update和alter的<strong>区别</strong>：</p>
<p>alter 是DDL语句，是修改数据库中对象（表，数据库，视图。。）的语句；update是DML语句，是修改表中数据的语句。</p>
<p>alter中：</p>
<p>（1）添加列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">        <span class="keyword">ADD</span> column_name column_type</span><br><span class="line">           [, column_name colum_type ...];</span><br></pre></td></tr></table></figure>

<p>（2）删除列：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">       <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> column_name;</span><br></pre></td></tr></table></figure>

<p>（3）改变数据类型：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">MODIFY <span class="keyword">COLUMN</span> column_name column_type;</span><br></pre></td></tr></table></figure>

<p>（4）修改表名：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> old_name</span><br><span class="line">  RENAME <span class="keyword">TO</span> new_name;</span><br></pre></td></tr></table></figure>

<p>（5）同时修改字段名和数据类型：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">CHANGE <span class="keyword">COLUMN</span> old_column_name new_column_name new_column_type;</span><br></pre></td></tr></table></figure>



<p>update中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE table_name </span><br><span class="line">   <span class="keyword">SET</span> field1<span class="operator">=</span><span class="keyword">new</span><span class="operator">-</span>value1, field2<span class="operator">=</span><span class="keyword">new</span><span class="operator">-</span>value2</span><br><span class="line">[<span class="keyword">WHERE</span> Clause]</span><br></pre></td></tr></table></figure>

<p>特殊的，题中出现替代值,这就用到了 <code>replace函数</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">replace(<span class="keyword">column</span>, old_value, new_value)</span><br></pre></td></tr></table></figure>

<p>出现在 <code>update</code> 也是一样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">set</span> column_name <span class="operator">=</span> replace(column_name, <span class="keyword">old</span>, <span class="keyword">new</span>)</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<h4 id="2-具体代码-7"><a href="#2-具体代码-7" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sql44</span></span><br><span class="line"> UPDATE titles_test </span><br><span class="line">    <span class="keyword">SET</span> emp_no <span class="operator">=</span> REPLACE(emp_no, <span class="number">10001</span>, <span class="number">10005</span>)</span><br><span class="line">  <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">5</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="comment">--sql45</span></span><br><span class="line"> <span class="keyword">alter</span> </span><br><span class="line"> <span class="keyword">table</span> titles_test </span><br><span class="line">rename </span><br><span class="line">    <span class="keyword">to</span> titles_2017</span><br><span class="line">;</span><br></pre></td></tr></table></figure>



<h2 id="group-concat"><a href="#group-concat" class="headerlink" title="group_concat"></a>group_concat</h2><p><a href="https://www.nowcoder.com/practice/6e86365af15e49d8abe2c3d4b5126e87?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL53 按照dept_no进行汇总</a></p>
<h3 id="解题思路-11"><a href="#解题思路-11" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-知识点-10"><a href="#1-知识点-10" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p><code>group_concat(column, delim)</code></p>
<p>将聚合后的字段进行连接， <code>delim</code> 参数默认是 <code>,</code> 逗号。</p>
<h4 id="2-具体代码-8"><a href="#2-具体代码-8" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">select</span> dept_no</span><br><span class="line">         ,GROUP_CONCAT(emp_no)</span><br><span class="line">    <span class="keyword">from</span> dept_emp </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_no;</span><br></pre></td></tr></table></figure>



<h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p><a href="https://www.nowcoder.com/practice/f24966e0cb8a49c192b5e65339bc8c03?tpId=82&tags=&title=&difficulty=0&judgeStatus=0&rp=1">SQL55 分页查询employees表，每5行一页，返回第2页的数据</a></p>
<h3 id="解题思路-12"><a href="#解题思路-12" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-知识点-11"><a href="#1-知识点-11" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p><strong>分页查询。每页n行，取第k页的全部数据。</strong></p>
<h4 id="1-limit进行分页"><a href="#1-limit进行分页" class="headerlink" title="1. limit进行分页"></a>1. limit进行分页</h4><p>公式：<code>limit n * (k - 1), n </code></p>
<p>具体代码：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> emp_no</span><br><span class="line">limit <span class="number">5</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>在具体代码中，<strong>limit后不支持计算</strong>。</p>
<h4 id="2-row-number实现分页查询"><a href="#2-row-number实现分页查询" class="headerlink" title="2. row_number实现分页查询"></a>2. row_number实现分页查询</h4><p>具体代码：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> emp_no,birth_date,first_name,last_name,gender,hire_date</span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">       ,<span class="built_in">floor</span>(rn <span class="operator">/</span> <span class="number">5</span>) <span class="keyword">as</span> dr</span><br><span class="line">  <span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> e.<span class="operator">*</span></span><br><span class="line">       ,<span class="built_in">row_number</span>() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> emp_no) <span class="operator">-</span> <span class="number">1</span> <span class="keyword">as</span> rn</span><br><span class="line">  <span class="keyword">from</span> employees e</span><br><span class="line">)e1</span><br><span class="line">)e2 <span class="keyword">where</span> dr <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>思路是：</p>
<ol>
<li>首先对整体数据添加序号：<code>row_number() over</code> 至少需要用 <code>order by</code> 进行排序；</li>
<li>先使用 <code>rn / 5</code> 对数据分页，已知 <code>0/5 == 1/5 == 2/5 == 3/5 == 4/5 == 0</code>（仅整数部分），但是由于此处的计算结果是小数，使用 <code>floor()</code> 函数向下取整。</li>
<li>最终取分页值为 <code>(k-1)</code> 的数据即可。</li>
</ol>
<h2 id="切分字符串"><a href="#切分字符串" class="headerlink" title="切分字符串"></a>切分字符串</h2><p><a href="%5Bhttps://www.nowcoder.com/practice/f04189f92f8d4f6fa0f383d413af7cb8?tpId=199&tqId=1975682&ru=/exam/oj&qru=/ta/sql-quick-study/question-ranking&sourceUrl=/exam/oj?tab=SQL%25E7%25AF%2587&topicId=199%5D(https://www.nowcoder.com/practice/f04189f92f8d4f6fa0f383d413af7cb8?tpId=199&tqId=1975682&ru=/exam/oj&qru=/ta/sql-quick-study/question-ranking&sourceUrl=/exam/oj?tab=SQL%E7%AF%87&topicId=199)">SQL30 统计每种性别的人数</a></p>
<h3 id="解题思路-13"><a href="#解题思路-13" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-知识点-12"><a href="#1-知识点-12" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p>使用 <code>SUBSTRING_INDEX(str, delim, pos)</code>。</p>
<h4 id="2-具体代码-9"><a href="#2-具体代码-9" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> gender, <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line">  <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> SUBSTRING_INDEX(profile, <span class="string">&#x27;,&#x27;</span>, <span class="number">-1</span>) gender</span><br><span class="line">  <span class="keyword">from</span> user_submit</span><br><span class="line">)A</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> gender</span><br><span class="line">;</span><br></pre></td></tr></table></figure>



<h2 id="表中记录替换"><a href="#表中记录替换" class="headerlink" title="表中记录替换"></a>表中记录替换</h2><p><a href="https://www.nowcoder.com/practice/978bcee6530a430fb0be716423d84082?tpId=240&tqId=2223554&ru=/exam/oj&qru=/ta/sql-advanced/question-ranking&sourceUrl=/exam/oj?tab=SQL%25E7%25AF%2587&topicId=240">SQL3 插入记录（三）</a></p>
<h3 id="1-知识点-13"><a href="#1-知识点-13" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>可以先删除 <code>delete</code> ，再添加。</p>
<p>也可以直接使用 <code>replace</code> 关键字替换。</p>
<h3 id="2-具体代码-10"><a href="#2-具体代码-10" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># replace <span class="keyword">into</span> examination_info <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">9003</span>, <span class="string">&#x27;SQL&#x27;</span>, <span class="string">&#x27;hard&#x27;</span>, <span class="string">&#x27;90&#x27;</span>, <span class="string">&#x27;2021-01-01 00:00:00&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> examination_info <span class="keyword">where</span> exam_id <span class="operator">=</span> <span class="number">9003</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> examination_info <span class="keyword">values</span>(<span class="keyword">null</span>, <span class="number">9003</span>, <span class="string">&#x27;SQL&#x27;</span>, <span class="string">&#x27;hard&#x27;</span>, <span class="string">&#x27;90&#x27;</span>, <span class="string">&#x27;2021-01-01 00:00:00&#x27;</span>);</span><br></pre></td></tr></table></figure>



<h2 id="日期相减"><a href="#日期相减" class="headerlink" title="日期相减"></a>日期相减</h2><p><a href="https://www.nowcoder.com/practice/d331359c5ca04a3b87f06b97da42159c?tpId=240&tags=&title=&difficulty=0&judgeStatus=0&rp=0">SQL6删除记录（一）</a></p>
<p><a href="https://www.nowcoder.com/practice/9dcc0eebb8394e79ada1d4d4e979d73c?tpId=240&tqId=2183405&ru=/exam/oj&qru=/ta/sql-advanced/question-ranking&sourceUrl=/exam/oj?tab=SQL%25E7%25AF%2587&topicId=240"><strong>SQL29</strong> <strong>连续两次作答试卷的最大时间窗</strong></a></p>
<h3 id="1-知识点-14"><a href="#1-知识点-14" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><ul>
<li>TIMESTAMPDIFF(interval, time_start, time_end)可计算time_start-time_end的时间差，单位以指定的interval为准，常用可选：<ul>
<li>SECOND 秒</li>
<li>MINUTE 分钟（返回秒数差除以60的整数部分）</li>
<li>HOUR 小时（返回秒数差除以3600的整数部分）</li>
<li>DAY 天数（返回秒数差除以3600*24的整数部分）</li>
<li>MONTH 月数</li>
<li>YEAR 年数</li>
</ul>
</li>
<li>DATEDIFF(next_date, cur_date)返回两个日期间的<strong>天数</strong>。</li>
</ul>
<h3 id="2-具体代码-11"><a href="#2-具体代码-11" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> exam_record </span><br><span class="line"> <span class="keyword">where</span> TIMESTAMPDIFF(<span class="keyword">MINUTE</span>, start_time, submit_time) <span class="operator">&lt;</span> <span class="number">5</span> </span><br><span class="line">   <span class="keyword">and</span> score <span class="operator">&lt;</span> <span class="number">60</span>;</span><br></pre></td></tr></table></figure>



<h2 id="删除表中所有记录并重置自增主键"><a href="#删除表中所有记录并重置自增主键" class="headerlink" title="删除表中所有记录并重置自增主键"></a>删除表中所有记录并重置自增主键</h2><p><a href="https://www.nowcoder.com/practice/3abefc6fc73e4f219dad0ab66e6b1e3f?tpId=240&tags=&title=&difficulty=0&judgeStatus=0&rp=0"><strong>SQL8</strong> <strong>删除记录（三）</strong></a></p>
<h3 id="1-知识点-15"><a href="#1-知识点-15" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>truncate删除表中的所有行,但表结构及其列、约束、索引等保持不变。新行标识所用的计数值<strong>重置</strong>为该列的种子。也就是<strong>truncate可以删除所有记录以及重置自增主键。</strong></p>
<h3 id="2-具体代码-12"><a href="#2-具体代码-12" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> exam_record;</span><br></pre></td></tr></table></figure>



<h2 id="创建自增主键和唯一键"><a href="#创建自增主键和唯一键" class="headerlink" title="创建自增主键和唯一键"></a>创建自增主键和唯一键</h2><p><a href="https://www.nowcoder.com/practice/a61ee5519d14444aa99e530309a8e043?tpId=240&tags=&title=&difficulty=0&judgeStatus=0&rp=0"><strong>SQL9</strong> <strong>创建一张新表</strong></a></p>
<h3 id="1-知识点-16"><a href="#1-知识点-16" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>自增关键字：<code>auto_increment</code>；唯一关键字：<code>unique</code>；注释：<code>comment</code>。</p>
<h3 id="2-具体代码-13"><a href="#2-具体代码-13" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> user_info_vip</span><br><span class="line">(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment comment <span class="string">&#x27;自增ID&#x27;</span>,</span><br><span class="line">    uid <span class="type">int</span> <span class="keyword">unique</span> <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">    nick_name <span class="type">varchar</span>(<span class="number">64</span>) comment <span class="string">&#x27;昵称&#x27;</span>,</span><br><span class="line">    achievement <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span> comment <span class="string">&#x27;成就值&#x27;</span>,</span><br><span class="line">    level <span class="type">int</span> comment <span class="string">&#x27;用户等级&#x27;</span>,</span><br><span class="line">    job <span class="type">varchar</span>(<span class="number">32</span>) comment <span class="string">&#x27;职业方向&#x27;</span>,</span><br><span class="line">    register_time datetime <span class="keyword">default</span> <span class="built_in">CURRENT_TIMESTAMP</span> comment <span class="string">&#x27;注册时间&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h2 id="日期匹配"><a href="#日期匹配" class="headerlink" title="日期匹配"></a>日期匹配</h2><p><a href="https://www.nowcoder.com/practice/9e2fb674b58b4f60ac765b7a37dde1b9?tpId=240&tags=&title=&difficulty=0&judgeStatus=0&rp=0"><strong>SQL17</strong> <strong>平均活跃天数和月活人数</strong></a></p>
<h3 id="1-知识点-17"><a href="#1-知识点-17" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p><code>date_format(date_, &quot;%Y%m%d&quot;)</code> 格式匹配字符串。具体匹配字符参照 <a href="https://www.w3school.com.cn/sql/func_date_format.asp">此文章</a>。</p>
<p><code>year(date_)</code> 取日期中的年份。类似的有：</p>
<ol>
<li><code>month()</code> 获取月份；</li>
<li><code>dayofmonth()</code>显示日期；</li>
<li><code>day()</code> 显示天；</li>
<li><code>last_day()</code> 显示所传日期的最后一天。</li>
</ol>
<h3 id="2-具体代码-14"><a href="#2-具体代码-14" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><p>注意题意，用户平均月活跃天数的计算应该是有 m 个人，活跃了 n 天，然后 n &#x2F; m 就是平均月活跃天数。那么这个 m 个人应该取 <code>distinct</code> ，而活跃 n 天应该取 <code>distinct 人+天</code> 。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> date_format(submit_time, &quot;%Y%m&quot;), </span><br><span class="line">       round(<span class="built_in">count</span>(<span class="keyword">distinct</span> uid, DATE_FORMAT(submit_time, &quot;%Y%m%d&quot;)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> uid), <span class="number">2</span>), </span><br><span class="line">       <span class="built_in">count</span>(<span class="keyword">distinct</span> uid)</span><br><span class="line"><span class="keyword">from</span> exam_record </span><br><span class="line"><span class="keyword">where</span> submit_time <span class="keyword">like</span> &quot;2021%&quot; <span class="keyword">and</span> score <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> date_format(submit_time, &quot;%Y%m&quot;)</span><br><span class="line">;</span><br></pre></td></tr></table></figure>



<h2 id="some、all、any的用法"><a href="#some、all、any的用法" class="headerlink" title="some、all、any的用法"></a>some、all、any的用法</h2><p><a href="https://leetcode-cn.com/problems/game-play-analysis-ii/">512. 游戏玩法分析 II</a></p>
<h3 id="1-知识点-18"><a href="#1-知识点-18" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p><a href="https://github.com/astak16/blog-mysql/issues/19">借鉴</a></p>
<p>这三个关键字是子查询的关键词之一，必须和比较操作符一起使用。</p>
<ol>
<li>any和some：和子查询返回的列中任一值比较为true，返回true。二者的区别在于，在 <code>!=</code> 的场景下，使用some更容易理解。</li>
<li>all：和子查询返回的列中的所有值比较为true，返回true。</li>
</ol>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 (id <span class="type">int</span>, <span class="keyword">value</span> <span class="type">int</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 (id <span class="type">int</span>, <span class="keyword">value</span> <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">10</span>), (<span class="number">2</span>, <span class="number">300</span>), (<span class="number">3</span>, <span class="number">40</span>), (<span class="number">4</span>, <span class="number">60</span>), (<span class="number">5</span>, <span class="number">70</span>), (<span class="number">6</span>, <span class="number">80</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">100</span>), (<span class="number">2</span>, <span class="number">300</span>), (<span class="number">3</span>, <span class="number">40</span>), (<span class="number">4</span>, <span class="number">600</span>), (<span class="number">5</span>, <span class="number">70</span>), (<span class="number">6</span>, <span class="number">800</span>);</span><br></pre></td></tr></table></figure>

<h4 id="all："><a href="#all：" class="headerlink" title="all："></a>all：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="keyword">value</span> <span class="operator">&lt;=</span> <span class="keyword">all</span>(</span><br><span class="line">	<span class="keyword">select</span> <span class="keyword">value</span> <span class="keyword">from</span> t2</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>子查询 <code>t2</code> 的结果返回 <code>(100,300,40,600,70,800)</code> ，当 <code>t1.value = 10</code> 是 <code>&lt;=</code> 子查询的所有结果，返回 <code>true</code> ；<code>t1.value = 300</code>  并没有 <code>&lt;=</code> 子查询的所有结果，如 <code>100</code> ，返回 <code>false</code> 。</p>
<h5 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h5><ul>
<li>如果子查询中结果为 <strong>空</strong>，结果为 <code>true</code></li>
<li>如果有一条数据为 <code>null</code> ，结果为 <code>false</code> ，也就是说查不出结果</li>
<li>如果有所有数据为 <code>null</code> ，结果为 <code>false</code> ，和结果为空不是一个概念</li>
</ul>
<h4 id="any："><a href="#any：" class="headerlink" title="any："></a>any：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="keyword">value</span> <span class="operator">&lt;=</span> <span class="keyword">any</span>(</span><br><span class="line">	<span class="keyword">select</span> <span class="keyword">value</span> <span class="keyword">from</span> t2</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如上，子查询结果为 <code>(100,300,40,600,70,800)</code> ，当 <code>t1.value = 10 &lt;=</code> 子查询列表中的 <code>100</code>，返回true；<code>t1.value = 300 &lt;=</code> 子查询列表中的 <code>600</code> ，返回 <code>true</code> 。</p>
<h5 id="tips："><a href="#tips：" class="headerlink" title="tips："></a>tips：</h5><ul>
<li>如果子查询中结果为 <strong>空</strong>，结果为 <code>false</code>，也就是说查不出结果</li>
<li>如果子查询中所有结果都为 <code>null</code> ，结果为 <code>false</code></li>
</ul>
<h4 id="some："><a href="#some：" class="headerlink" title="some："></a>some：</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="keyword">value</span> <span class="operator">!=</span> <span class="keyword">some</span>(</span><br><span class="line">	<span class="keyword">select</span> <span class="keyword">value</span> <span class="keyword">from</span> t2</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>t1</code> 列表与 <code>t2</code> 列表有部分数据不相等；或者从 <code>any</code> 来看，<code>t1</code> 列表的值与 <code>t2</code> 列表的任意值不相等，二者结果相等。</p>
<h3 id="2-具体代码-15"><a href="#2-具体代码-15" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"># <span class="number">1.</span></span><br><span class="line"># <span class="keyword">select</span> A.player_id, B.device_id <span class="keyword">from</span> Activity B <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line"># (</span><br><span class="line">#     <span class="keyword">select</span> player_id, <span class="built_in">min</span>(event_date) first_login <span class="keyword">from</span> Activity <span class="keyword">group</span> <span class="keyword">by</span> player_id</span><br><span class="line"># )A</span><br><span class="line"># <span class="keyword">on</span> A.player_id <span class="operator">=</span> B.player_id <span class="keyword">and</span> B.event_date <span class="operator">=</span> A.first_login;</span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span></span><br><span class="line"># <span class="keyword">select</span> player_id, device_id <span class="keyword">from</span></span><br><span class="line"># (</span><br><span class="line">#     <span class="keyword">select</span> player_id, device_id, <span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> player_id <span class="keyword">order</span> <span class="keyword">by</span> event_date) num</span><br><span class="line">#     <span class="keyword">from</span> Activity</span><br><span class="line"># )A</span><br><span class="line"># <span class="keyword">where</span> num <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># <span class="number">3.</span></span><br><span class="line"><span class="keyword">select</span> player_id, device_id <span class="keyword">from</span> Activity A2 <span class="keyword">where</span> A2.event_date <span class="operator">&lt;=</span></span><br><span class="line"><span class="keyword">all</span>(</span><br><span class="line">    <span class="keyword">select</span> event_date <span class="keyword">from</span> Activity A1 <span class="keyword">where</span> A1.player_id <span class="operator">=</span> A2.player_id</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h2 id="over-函数的使用"><a href="#over-函数的使用" class="headerlink" title="over() 函数的使用"></a>over() 函数的使用</h2><p><a href="https://leetcode-cn.com/problems/game-play-analysis-iii/">534. 游戏玩法分析 III</a></p>
<h3 id="1-知识点-19"><a href="#1-知识点-19" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p><a href="https://blog.csdn.net/qq_43725031/article/details/104785986">借鉴</a></p>
<p><code>over(partition by ... order by ...)</code> 函数不能单独使用，要和分析函数一起使用。</p>
<p>常见的分析函数如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">-</span> <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ...)		<span class="comment">--分组排序</span></span><br><span class="line"><span class="operator">-</span> <span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ...)		<span class="comment">--分组排序</span></span><br><span class="line"><span class="operator">-</span> <span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ...)		<span class="comment">--分组排序</span></span><br><span class="line"><span class="operator">-</span> <span class="built_in">count</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ...)		<span class="comment">--分组计数</span></span><br><span class="line"><span class="operator">-</span> <span class="built_in">max</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ...) 		<span class="comment">--分组取最大值</span></span><br><span class="line"><span class="operator">-</span> <span class="built_in">min</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span>    ... <span class="keyword">order</span> <span class="keyword">by</span> ...)		<span class="comment">--分组取最小值</span></span><br><span class="line"><span class="operator">-</span> <span class="built_in">sum</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ...)		<span class="comment">--分组求和</span></span><br><span class="line"><span class="operator">-</span> <span class="built_in">avg</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ...)		<span class="comment">--分组取平均值</span></span><br><span class="line"><span class="operator">-</span> <span class="built_in">first_value</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ...)		<span class="comment">--取分组第一条</span></span><br><span class="line"><span class="operator">-</span> <span class="built_in">last_value</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ...)			<span class="comment">--取分组最后一条</span></span><br><span class="line"><span class="operator">-</span> <span class="built_in">lag</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ...)		<span class="comment">--取出同一字段的前N行的数据</span></span><br><span class="line"><span class="operator">-</span> <span class="built_in">lead</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> ... <span class="keyword">order</span> <span class="keyword">by</span> ...)		<span class="comment">--取出同一字段的前N行的数据</span></span><br></pre></td></tr></table></figure>

<h3 id="2-具体代码-16"><a href="#2-具体代码-16" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><h4 id="和-sum-的连用"><a href="#和-sum-的连用" class="headerlink" title="和 sum()的连用"></a>和 sum()的连用</h4><p>此处和 <code>sum()</code> 函数连用，实现逐层累加。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> player_id, </span><br><span class="line">       event_date, </span><br><span class="line">       <span class="built_in">sum</span>(games_played) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> player_id <span class="keyword">order</span> <span class="keyword">by</span> event_date) games_played_so_far</span><br><span class="line"><span class="keyword">from</span> Activity</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> player_id, event_date <span class="keyword">desc</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>这道题的常规解法是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> A.player_id, B.event_date, <span class="built_in">sum</span>(A.games_played) <span class="keyword">as</span> games_played_so_far</span><br><span class="line"><span class="keyword">from</span> Activity A <span class="keyword">inner</span> <span class="keyword">join</span> Activity B</span><br><span class="line"><span class="keyword">on</span> A.player_id <span class="operator">=</span> B.player_id </span><br><span class="line"><span class="keyword">where</span> A.event_date <span class="operator">&lt;=</span> B.event_date</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> A.player_id, B.event_date</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> A.player_id, A.event_date <span class="keyword">desc</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>此处有一个可能没有考虑到的点：就是这里取的 <code>event_date</code> 应该是 <code>&lt;=</code> 后的变量或 <code>&gt;=</code> 前的变量。</p>
<h4 id="和min-的连用，和-datediff函数的嵌套"><a href="#和min-的连用，和-datediff函数的嵌套" class="headerlink" title="和min()的连用，和 datediff函数的嵌套"></a>和min()的连用，和 datediff函数的嵌套</h4><p><a href="https://leetcode-cn.com/problems/game-play-analysis-iv/">550. 游戏玩法分析 IV</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">round((<span class="keyword">select</span> <span class="built_in">count</span>(player_id) <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> player_id, datediff(event_date, <span class="built_in">min</span>(event_date) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> player_id)) date_diff</span><br><span class="line">    <span class="keyword">from</span> Activity</span><br><span class="line">)A <span class="keyword">where</span> date_diff <span class="operator">=</span> <span class="number">1</span>) <span class="operator">/</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> player_id), <span class="number">2</span>) fraction</span><br><span class="line"><span class="keyword">from</span> Activity;</span><br></pre></td></tr></table></figure>



<h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><h3 id="字符串连接函数（普通连接和组内连接）"><a href="#字符串连接函数（普通连接和组内连接）" class="headerlink" title="字符串连接函数（普通连接和组内连接）"></a>字符串连接函数（普通连接和组内连接）</h3><p><a href="https://www.nowcoder.com/practice/46cb7a33f7204f3ba7f6536d2fc04286?tpId=240&tqId=2183007&ru=/exam/oj&qru=/ta/sql-advanced/question-ranking&sourceUrl=/exam/oj?tab=SQL%25E7%25AF%2587&topicId=240"><strong>SQL19</strong> <strong>未完成试卷数大于1的有效用户</strong></a></p>
<h4 id="1-知识点-20"><a href="#1-知识点-20" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p><strong>（1）concat(str1, str2, str3, …)</strong> </p>
<p>不能专门指定分隔符，默认逗号连接。</p>
<p><strong>（2）concat_ws(sep, str1, str2, …)</strong></p>
<p><code>sep</code> 指定分隔符，默认逗号连接。</p>
<p>如本例中使用：<code>CONCAT_WS(&quot;:&quot;, date_format(A.start_time, &quot;%Y-%m-%d&quot;), B.tag)</code></p>
<p><strong>（3）group_concat([DISTINCT] 要连接的字段 [Order BY ASC&#x2F;DESC 排序字段] [Separator ‘分隔符’])</strong></p>
<p>如本例中使用的：<code>GROUP_CONCAT(distinct date_tag SEPARATOR &quot;;&quot;)</code></p>
<h4 id="2-具体代码-17"><a href="#2-具体代码-17" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> uid, incomplete_cnt, complete_cnt, GROUP_CONCAT(<span class="keyword">distinct</span> date_tag SEPARATOR &quot;;&quot;) detail</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> A.uid, </span><br><span class="line">       A.incomplete_cnt, </span><br><span class="line">       A.complete_cnt,</span><br><span class="line">       CONCAT_WS(&quot;:&quot;, date_format(A.start_time, &quot;%Y-%m-%d&quot;), B.tag) date_tag</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line"># 获取有效用户</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> uid, exam_id, start_time, complete_cnt, incomplete_cnt</span><br><span class="line">    <span class="keyword">from</span> </span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">select</span> uid, exam_id, start_time,</span><br><span class="line">               <span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> submit_time <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">end</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> uid) complete_cnt,</span><br><span class="line">               <span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> submit_time <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> uid) incomplete_cnt</span><br><span class="line">        <span class="keyword">from</span> exam_record</span><br><span class="line">        <span class="keyword">where</span> <span class="keyword">year</span>(start_time) <span class="operator">=</span> <span class="number">2021</span></span><br><span class="line">    )A </span><br><span class="line">    <span class="keyword">where</span> complete_cnt <span class="operator">&gt;=</span> <span class="number">1</span> <span class="keyword">and</span> incomplete_cnt <span class="operator">&lt;</span> <span class="number">5</span></span><br><span class="line">) A</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> examination_info B <span class="keyword">on</span> A.exam_id <span class="operator">=</span> B.exam_id <span class="keyword">and</span> A.incomplete_cnt <span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line">)A</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> uid, incomplete_cnt, complete_cnt</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> incomplete_cnt <span class="keyword">desc</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>注意，获取未完成应该判断字段 <code>submit_time</code> 是否为 null，因为未完成的答卷也可能会有分数。</p>
<h3 id="left"><a href="#left" class="headerlink" title="left()"></a>left()</h3><p><a href="https://www.nowcoder.com/practice/203d0aed8928429a8978185d9a03babc?tpId=240&tqId=2183297&ru=/exam/oj&qru=/ta/sql-advanced/question-ranking&sourceUrl=/exam/oj?tab=SQL%25E7%25AF%2587&topicId=240"><strong>SQL23</strong> <strong>每个题目和每份试卷被作答的人数和次数</strong></a></p>
<h4 id="1-知识点-21"><a href="#1-知识点-21" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p>返回字符串左边指定长度的子串。</p>
<p>语法：<code>LEFT(str,length);</code></p>
<p>其中，<code>str</code>是是被提取的字符串，<code>length</code> 指定提取的长度。</p>
<p><code>length</code> 是正整数，<code>&lt;= 0</code> 返回空字符串，<code>null</code> 返回 <code>NULL</code> ，指定长度大于字符串本身的长度，返回整个字符串。</p>
<h4 id="2-具体代码-18"><a href="#2-具体代码-18" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 试卷</span><br><span class="line"><span class="keyword">select</span> exam_id tid, <span class="built_in">count</span>(<span class="keyword">distinct</span> uid) uv, <span class="built_in">count</span>(<span class="operator">*</span>) pv</span><br><span class="line"><span class="keyword">from</span> exam_record </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> exam_id</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"># 做题</span><br><span class="line"><span class="keyword">select</span> question_id tid, <span class="built_in">count</span>(<span class="keyword">distinct</span> uid) uv, <span class="built_in">count</span>(<span class="operator">*</span>) pv</span><br><span class="line"><span class="keyword">from</span> practice_record </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> question_id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">left</span>(tid, <span class="number">1</span>) <span class="keyword">desc</span>, uv <span class="keyword">desc</span>, pv <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>



<h3 id="空值匹配"><a href="#空值匹配" class="headerlink" title="空值匹配"></a>空值匹配</h3><h4 id="1-知识点-22"><a href="#1-知识点-22" class="headerlink" title="1. 知识点"></a>1. 知识点</h4><p><code>COALESCE(v1, v2, v3, ...)</code> 可以传入多个数值，会返回第一个不为 null 的数值。</p>
<p><a href="https://www.nowcoder.com/practice/a32c7c8590324c96950417c57fa6ecd1?tpId=240&tags=&title=&difficulty=0&judgeStatus=0&rp=0"><strong>SQL26</strong> <strong>每个6&#x2F;7级用户活跃情况</strong></a></p>
<h4 id="2-具体代码-19"><a href="#2-具体代码-19" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> A.uid</span><br><span class="line">       ,<span class="built_in">COALESCE</span>(B.act_month_total, <span class="number">0</span>) act_month_total</span><br><span class="line">       ,<span class="built_in">COALESCE</span>(B.act_days_2021, <span class="number">0</span>) act_days_2021</span><br><span class="line">       ,<span class="built_in">COALESCE</span>(B.act_days_2021_exam, <span class="number">0</span>) act_days_2021_exam</span><br><span class="line">       ,<span class="built_in">COALESCE</span>(B.act_days_2021_question, <span class="number">0</span>) act_days_2021_question</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> uid <span class="keyword">from</span> user_info <span class="keyword">where</span> level <span class="keyword">in</span> (<span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">) A <span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> uid</span><br><span class="line">       ,<span class="built_in">count</span>(<span class="keyword">distinct</span> DATE_FORMAT(act_time, &quot;%Y%m&quot;)) act_month_total# 总活跃月份数</span><br><span class="line">       ,<span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">case</span> <span class="keyword">when</span> <span class="keyword">year</span>(act_time) <span class="operator">=</span> <span class="number">2021</span> </span><br><span class="line">                       <span class="keyword">then</span> date_format(act_time, &quot;%Y%m%d&quot;) </span><br><span class="line">                       <span class="keyword">end</span>) act_days_2021# <span class="number">2021</span>年活跃天数</span><br><span class="line">       ,<span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">case</span> <span class="keyword">when</span> tb <span class="operator">=</span> &quot;exam&quot; <span class="keyword">and</span> <span class="keyword">year</span>(act_time) <span class="operator">=</span> <span class="number">2021</span></span><br><span class="line">                       <span class="keyword">then</span> date_format(act_time, &quot;%Y%m%d&quot;) </span><br><span class="line">                       <span class="keyword">end</span>) act_days_2021_exam# <span class="number">2021</span>年试卷作答活跃天数</span><br><span class="line">       ,<span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="keyword">case</span> <span class="keyword">when</span> tb <span class="operator">=</span> &quot;prac&quot; <span class="keyword">and</span> <span class="keyword">year</span>(act_time) <span class="operator">=</span> <span class="number">2021</span></span><br><span class="line">                       <span class="keyword">then</span> date_format(act_time, &quot;%Y%m%d&quot;)</span><br><span class="line">                       <span class="keyword">end</span>) act_days_2021_question# <span class="number">2021</span>年答题活跃天数</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> uid, start_time act_time, &quot;exam&quot; tb <span class="keyword">from</span> exam_record</span><br><span class="line">    <span class="keyword">union</span></span><br><span class="line">    <span class="keyword">select</span> uid, submit_time act_time, &quot;prac&quot; tb <span class="keyword">from</span> practice_record</span><br><span class="line">) A</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> uid</span><br><span class="line">) B <span class="keyword">on</span> A.uid <span class="operator">=</span> B.uid</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> act_month_total <span class="keyword">desc</span>, act_days_2021 <span class="keyword">desc</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>



<h2 id="获取当前行数据的前n行或后n行"><a href="#获取当前行数据的前n行或后n行" class="headerlink" title="获取当前行数据的前n行或后n行"></a>获取当前行数据的前n行或后n行</h2><p><a href="https://www.nowcoder.com/practice/9dcc0eebb8394e79ada1d4d4e979d73c?tpId=240&tqId=2183405&ru=/exam/oj&qru=/ta/sql-advanced/question-ranking&sourceUrl=/exam/oj?tab=SQL%25E7%25AF%2587&topicId=240"><strong>SQL29</strong> <strong>连续两次作答试卷的最大时间窗</strong></a></p>
<h3 id="1-知识点-23"><a href="#1-知识点-23" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>当前行数据的前n行：<code>lead(col, n)</code>；</p>
<p>当前行数据的后n行：<code>lag(col, n)</code> 。</p>
<h3 id="2-具体代码-20"><a href="#2-具体代码-20" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 最大时间窗</span><br><span class="line"><span class="keyword">select</span> uid, days_window, round(exam_cnt <span class="operator">/</span> diff_day <span class="operator">*</span> days_window, <span class="number">2</span>) avg_exam_cnt</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> uid</span><br><span class="line">       ,<span class="built_in">count</span>(start_time) exam_cnt</span><br><span class="line">       ,datediff(<span class="built_in">max</span>(next_time), <span class="built_in">min</span>(start_time)) <span class="operator">+</span> <span class="number">1</span> diff_day</span><br><span class="line">       ,<span class="built_in">max</span>(DATEDIFF(next_time, start_time)) <span class="operator">+</span> <span class="number">1</span> days_window</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> uid</span><br><span class="line">       ,start_time</span><br><span class="line">       ,<span class="built_in">lead</span>(start_time, <span class="number">1</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> uid <span class="keyword">order</span> <span class="keyword">by</span> start_time) next_time</span><br><span class="line"><span class="keyword">from</span> exam_record </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">year</span>(start_time) <span class="operator">=</span> <span class="number">2021</span></span><br><span class="line">) A </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> uid</span><br><span class="line">)A</span><br><span class="line"><span class="keyword">where</span> diff_day <span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> days_window <span class="keyword">desc</span>, avg_exam_cnt <span class="keyword">desc</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>



<h2 id="row-number-和-dense-rank-的选择"><a href="#row-number-和-dense-rank-的选择" class="headerlink" title="row_number() 和 dense_rank() 的选择"></a>row_number() 和 dense_rank() 的选择</h2><p><a href="https://www.nowcoder.com/practice/3e598a2dcd854db8b1a3c48e5904fe1c?tpId=240&tqId=2183408&ru=/exam/oj&qru=/ta/sql-advanced/question-ranking&sourceUrl=/exam/oj?tab=SQL%25E7%25AF%2587&topicId=240">SQL31 未完成率较高的50%用户近三个月答卷情况</a></p>
<h3 id="1-知识点-24"><a href="#1-知识点-24" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>已知的是，row_number() 是生成不重复的序号，dense_rank() 生成组内排名，对于相同的值，排名是相同的。</p>
<p>题中，对 over() 内有时候只会使用 <code>order by</code> 进行全局排序，在对 uid 生成序号的时候，<code>rate</code> 相同时会产生并列的排名，这对获取前50%用户的题意来说，会产生歧义：只要包括在3以内的排名，都可以获取。但实际上是只取三个的意思。</p>
<h3 id="2-具体代码-21"><a href="#2-具体代码-21" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 近三个月</span><br><span class="line"><span class="keyword">select</span> uid</span><br><span class="line">       ,date_format(start_time, &quot;%Y%m&quot;) mt</span><br><span class="line">       ,<span class="built_in">count</span>(start_time) total_cnt</span><br><span class="line">       ,<span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> submit_time <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">end</span>) complete_cnt</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> uid</span><br><span class="line">       ,start_time</span><br><span class="line">       ,submit_time</span><br><span class="line">       ,<span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> uid <span class="keyword">order</span> <span class="keyword">by</span> date_format(start_time, &quot;%Y%m&quot;) <span class="keyword">desc</span>) rank2</span><br><span class="line"><span class="keyword">from</span> exam_record</span><br><span class="line"><span class="keyword">where</span> uid <span class="keyword">in</span></span><br><span class="line">(</span><br><span class="line"># <span class="number">50</span><span class="operator">%</span><span class="number">6</span>级和<span class="number">7</span>级用户</span><br><span class="line"><span class="keyword">select</span> uid <span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> uid</span><br><span class="line">       ,<span class="built_in">count</span>(uid) <span class="keyword">over</span>() tot_uid</span><br><span class="line">       ,<span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> rate <span class="keyword">desc</span>) rank1</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"># <span class="keyword">SQL</span>试卷上未完成率</span><br><span class="line"><span class="keyword">select</span> uid</span><br><span class="line">       ,<span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> submit_time <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">end</span>) <span class="operator">/</span> <span class="built_in">count</span>(start_time) rate</span><br><span class="line"><span class="keyword">from</span> exam_record </span><br><span class="line"><span class="keyword">where</span> exam_id <span class="keyword">in</span> (<span class="keyword">select</span> exam_id <span class="keyword">from</span> examination_info <span class="keyword">where</span> tag <span class="operator">=</span> &quot;SQL&quot;)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> uid</span><br><span class="line">)A</span><br><span class="line">)A </span><br><span class="line"><span class="keyword">where</span> rank1 <span class="operator">&lt;=</span> <span class="built_in">ceiling</span>(tot_uid <span class="operator">/</span> <span class="number">2</span>) </span><br><span class="line"><span class="keyword">and</span> uid <span class="keyword">in</span> (<span class="keyword">select</span> uid <span class="keyword">from</span> user_info <span class="keyword">where</span> level <span class="keyword">in</span> (<span class="number">6</span>, <span class="number">7</span>))</span><br><span class="line">)</span><br><span class="line">)A <span class="keyword">where</span> rank2 <span class="operator">&lt;=</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> uid, mt</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> uid, mt</span><br></pre></td></tr></table></figure>



<h2 id="百分比-和-排名函数的类型问题"><a href="#百分比-和-排名函数的类型问题" class="headerlink" title="百分比 和 排名函数的类型问题"></a>百分比 和 排名函数的类型问题</h2><p><a href="https://www.nowcoder.com/practice/13415dff75784a57bedb6d195262be7b?tpId=240&tqId=2183409&ru=/exam/oj&qru=/ta/sql-advanced/question-ranking&sourceUrl=/exam/oj?tab=SQL%25E7%25AF%2587&topicId=240"><strong>SQL32</strong> <strong>试卷完成数同比2020年的增长率及排名变化</strong></a></p>
<h3 id="1-知识点-25"><a href="#1-知识点-25" class="headerlink" title="1. 知识点"></a>1. 知识点</h3><p>想要获取 <code>1 / 5</code> 的百分比参数，并保留一位小数，可以这样写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CONCAT(round(<span class="number">1</span> <span class="operator">/</span> <span class="number">5</span> <span class="operator">*</span> <span class="number">100</span>, <span class="number">1</span>), <span class="string">&#x27;%&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>排名函数如 <code>rank()</code> 生成的排名值的类型是 <code>bigint unsigned</code> ，也就是表示，如果要对这些元素进行加减乘除的运算，需要保证结果必须是非负数，否则会报错。可以使用 <code>cast(value as signed)</code> 进行类型转换。</p>
<h3 id="2-具体代码-22"><a href="#2-具体代码-22" class="headerlink" title="2. 具体代码"></a>2. 具体代码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> tag</span><br><span class="line">       ,exam_cnt_20</span><br><span class="line">       ,exam_cnt_21</span><br><span class="line">       ,CONCAT(round((exam_cnt_21 <span class="operator">-</span> exam_cnt_20) <span class="operator">/</span> exam_cnt_20 <span class="operator">*</span> <span class="number">100</span>, <span class="number">1</span>), <span class="string">&#x27;%&#x27;</span>) growth_rate</span><br><span class="line">       ,rank1 exam_cnt_rank_20</span><br><span class="line">       ,rank2 exam_cnt_rank_21</span><br><span class="line">       ,<span class="built_in">cast</span>(rank2 <span class="keyword">as</span> signed) <span class="operator">-</span> <span class="built_in">cast</span>(rank1 <span class="keyword">as</span> signed) rank_delta</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> tag</span><br><span class="line">       ,exam_cnt_20</span><br><span class="line">       ,<span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> exam_cnt_20 <span class="keyword">desc</span>) rank1</span><br><span class="line">       ,exam_cnt_21</span><br><span class="line">       ,<span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> exam_cnt_21 <span class="keyword">desc</span>) rank2</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"># <span class="number">2021</span>年上半年 和 <span class="number">2020</span>年上半年</span><br><span class="line"><span class="keyword">select</span> B.tag</span><br><span class="line">       ,<span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> yt <span class="operator">=</span> <span class="number">2020</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">end</span>) exam_cnt_20</span><br><span class="line">       ,<span class="built_in">sum</span>(<span class="keyword">case</span> <span class="keyword">when</span> yt <span class="operator">=</span> <span class="number">2021</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">end</span>) exam_cnt_21</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">select</span> exam_id, <span class="keyword">year</span>(submit_time) yt <span class="keyword">from</span> exam_record </span><br><span class="line"><span class="keyword">where</span> <span class="keyword">year</span>(submit_time) <span class="keyword">in</span> (<span class="number">2021</span>, <span class="number">2020</span>) <span class="keyword">and</span> <span class="keyword">MONTH</span>(submit_time) <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">6</span></span><br><span class="line">)A <span class="keyword">inner</span> <span class="keyword">join</span> examination_info B <span class="keyword">using</span>(exam_id)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> B.tag</span><br><span class="line">)A</span><br><span class="line">)A <span class="keyword">where</span> exam_cnt_20 <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">and</span> exam_cnt_21 <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> growth_rate <span class="keyword">desc</span>, exam_cnt_rank_21 <span class="keyword">desc</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>spark - 面试题</title>
    <url>/2021/05/31/spark-%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h3 id="1-spark是什么"><a href="#1-spark是什么" class="headerlink" title="1. spark是什么"></a>1. spark是什么</h3><p>spark是一种与hadoop相似的开源集群计算框架，是基于内存的快速、通用、可扩展的大数据分析计算引擎。</p>
<p>基于内存：并不是说spark是内存计算，因为它的shuffle过程也是需要硬盘落地的，它的特点是多个任务之间的数据通信是通过内存进行的。</p>
<span id="more"></span>



<h3 id="2-spark的hadoop的对比"><a href="#2-spark的hadoop的对比" class="headerlink" title="2. spark的hadoop的对比"></a>2. spark的hadoop的对比</h3><p><strong>MapReduce框架局限性：</strong></p>
<p>1）仅支持Map和Reduce两种操作；</p>
<p>2）处理效率低效；</p>
<p>Map中间结果写磁盘，Reduce写HDFS，多个MR之间通过HDFS交换数据;，任务调度和启动开销大，无法充分利用内存，Map端和Reduce端均需要排序；</p>
<p>3）不适合迭代计算(如机器学习、图计算等)，交互式处理（数据挖掘)）和流式处理(点击日志分析）。</p>
<p><strong>Spark相比的优势：</strong><br>1.高性能：Spark采用内存计算引擎，允许用户将数据放到内存中以加快数据读取；同时，Spark提供了更加通用的DAG计算引擎，使得数据可通过本地磁盘或内存流向不同的计算单元。</p>
<p>2.简单易用：Spark提供了丰富的高层次API，包括sortByKey、groupByKey等操作，并且提供了四种编程语言API：Scala、Python、Java和R，从代码量看，Spark比MapReduce少2~5倍。</p>
<p>3.与Hadoop完好集成：Spark作为新型框架，可以部署在YARN集群上，读取和存储HDFS&#x2F;HBase中的数据。</p>
<p>经过上述比较可知，在绝大多数的数据计算场景下，spark比hadoop更具有优势，但是spark是基于内存的，在实际的生产环境中，由于内存的限制，可能会因为内存资源不够而导致job运行失败，此时，hadoop的mapreduce就是一个更好的选择，所以spark并不能完全替代hadoop。</p>
<h3 id="3-spark核心模块简介"><a href="#3-spark核心模块简介" class="headerlink" title="3. spark核心模块简介"></a>3. spark核心模块简介</h3><p>即spark sql、spark streaming、spark mllib、spark graphx和spark core。</p>
<p>其中，位于最底层的是spark core，它是整个spark框架的核心，其余的功能模块都是基于core来实现和完善的。</p>
<p>spark sql：用于操作结构化数据的功能模块，通过spark sql，用户可以使用sql或apache hive版本的sql语言来查询数据；</p>
<p>spark streaming：用于对流式数据进行处理的功能模块，提供了丰富的处理数据流的API；</p>
<p>spark mllib：是spark提供的一个机器学习算法库，不仅提供了模型评估、数据导入等额外的功能，还提供了一些更底层的机器学习原语；</p>
<p>spark graphx：是面向图计算提供的框架和算法库。</p>
<h3 id="4-RDD、DataFrame和DataSet的区别和联系"><a href="#4-RDD、DataFrame和DataSet的区别和联系" class="headerlink" title="4. RDD、DataFrame和DataSet的区别和联系"></a>4. RDD、DataFrame和DataSet的区别和联系</h3><h4 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h4><p>1、RDD、DataFrame、Dataset全都是spark平台下的分布式弹性数据集，为处理超大型数据提供便利；</p>
<p>2、三者都有惰性机制，在进行创建、转换，如map方法时，不会立即执行，只有在遇到Action如foreach、count、collect等时，三者才会开始运算，极端情况下，如果代码里面有创建、转换，但是后面没有Action操作，在执行时会被直接跳过；    </p>
<p>3、三者都会根据spark的内存情况自动缓存运算，这样即使数据量很大，也不用担心会内存溢出；</p>
<p>4、三者都有partition的概念；</p>
<p>5、三者有许多共同的函数，如filter，排序等；</p>
<p>6、对DataFrame和Dataset的许多操作都需要import spark.implicits._进行支持；</p>
<p>7、DataFrame和Dataset均可使用模式匹配获取各个字段的值和类型；</p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol>
<li><p>RDD</p>
<p>1、RDD一般和spark mllib同时使用；</p>
<p>2、RDD不支持sparksql操作；</p>
</li>
<li><p>DataFrame</p>
<p>1、与RDD和Dataset不同，DataFrame每一行的类型固定为Row，只有通过解析才能获取各个字段的值，即每一列的值不能直接访问；</p>
<p>2、DataFrame与Dataset一般与spark mllib同时使用；</p>
<p>3、DataFrame与Dataset均支持sparksql的操作，比如select，groupby之类，还能注册临时表&#x2F;视窗，进行sql语句操作；</p>
<p>4、DataFrame与Dataset支持一些特别方便的保存方式，比如保存成csv，可以带上表头，这样每一列的字段名一目了然，利用这样的保存方式，可以方便的获得字段名和列的对应，而且分隔符（delimiter）可以自由指定；</p>
</li>
<li><p>DataSet</p>
<p> 主要是与DataFrame的比较，因为Dataset和DataFrame拥有完全相同的成员函数，区别只是每一行的数据类型不同；</p>
<p>DataFrame也可以叫Dataset[Row],每一行的类型是Row，不解析，每一行究竟有哪些字段，各个字段又是什么类型都无从得知，只能用getAS模式匹配取出特定字段；</p>
<p>而Dataset中，每一行是什么类型是不一定的，在自定义了case class之后可以很自由的获得每一行的信息；</p>
<p>相较而言，DataSet访问列的某个字段是方便的，然后，如果要写一些适配性比较强的函数，如果使用DataSet，行的类型又不确定，可以使用DataFrame。</p>
</li>
</ol>
<h3 id="5-SparkSession和SparkContext的区别和联系"><a href="#5-SparkSession和SparkContext的区别和联系" class="headerlink" title="5. SparkSession和SparkContext的区别和联系"></a>5. SparkSession和SparkContext的区别和联系</h3><p>SparkSession实质上是SparkContext和HiveContext的组合，所以在SparkContext和HiveContext上可用的API在SparkSession上同样可用。</p>
<p>SparkSession的内部封装了SparkContext，所以它的计算实际上是由SparkContext完成的。即需要SpakSQL活Hive时使用SparkSession，否则用SparkContext就行。</p>
<h3 id="6-DataSet、DataFrame常见的Action行动算子"><a href="#6-DataSet、DataFrame常见的Action行动算子" class="headerlink" title="6. DataSet、DataFrame常见的Action行动算子"></a>6. DataSet、DataFrame常见的Action行动算子</h3><blockquote>
<p>show(n) - 显示n条记录，n省略时显示全部；</p>
<p>collect - 获取所有数据并返回Array结构；</p>
<p>collectAsList - 获取所有数据并返回list结构；</p>
<p>first - 获取第一行数据；</p>
<p>head - 获取第一行数据 - head(n:int) - 获取前n行数据；</p>
<p>take(n:int) - 获取前n行数据；</p>
<p>takeAsList(n:int) - 获取前n行数据并以list形式展示；</p>
<p>printSchema - 输出数据结构信息；</p>
<p>explain - 将物理计划打印到控制台以进行调试；</p>
<p>count - 统计个数；</p>
<p>reduce - 对数据进行规约操作。</p>
</blockquote>
<h3 id="7-DataSet、DataFrame常见的Transformation转换算子"><a href="#7-DataSet、DataFrame常见的Transformation转换算子" class="headerlink" title="7. DataSet、DataFrame常见的Transformation转换算子"></a>7. DataSet、DataFrame常见的Transformation转换算子</h3><blockquote>
<p>map - 分析表中的数据；</p>
<p>flatMap - 在map的基础上将String扁平化为字符数组；</p>
<p>filter - 过滤；</p>
<p>select和selectExpr - 查询，select写查询语句，selectExpr写要查询的字段；</p>
<p>drop - 将表从内存删除；</p>
<p>withColumn - 用于向DataFrame添加列、更新现有列的值、转换列的数据类型以及从现有列派生新列；</p>
<p>join - 连接；</p>
<p>where - 指定条件；</p>
<p>groupBy - 分组；</p>
<p>agg - 对整个数据集聚合；</p>
<p>orderBy - 先将数据按照指定字段分区，在进行分区内排序；</p>
<p>sortBy - 分区内排序；</p>
<p>union、intersect、except - 并、交、差。</p>
</blockquote>
<h3 id="8-Spark有哪几种部署模式，每种模式有哪些特点"><a href="#8-Spark有哪几种部署模式，每种模式有哪些特点" class="headerlink" title="8. Spark有哪几种部署模式，每种模式有哪些特点"></a>8. Spark有哪几种部署模式，每种模式有哪些特点</h3><ol>
<li>本地模式：该模式被称为local[N]模式，是利用本地的多个线程来模拟spark的分布式计算，便于调试；它有以下分类：local - 只运行一个线程；local[K] - 运行K个executor；local[*] - 运行和cpu数目相同的executor。</li>
<li>standalone模式：是Spark自身的一个调度系统。 对集群性能要求非常高；分布式部署集群，自带完整的服务，其中资源管理和任务监控都由spark自己监控，该模式是其他模式的基础。</li>
<li>spark on yarn模式：分布式部署集群，资源和任务监控交给yarn管理，它是粗粒度资源分配方式，包含cluster和client运行模式：cluster 适合生产，driver运行在集群子节点，具有容错功能；client 适合调试，dirver运行在客户端。</li>
<li>spark on mesos模式：官方推荐这种模式（当然，原因之一是血缘关系）。正是由于Spark开发之初就考虑到支持Mesos，因此，目前而言，Spark运行在Mesos上会比运行在YARN上更加灵活，更加自然。用户可选择两种调度模式之一运行自己的应用程序：<br>  ①粗粒度模式（Coarse-grained Mode）：每个应用程序的运行环境由一个Dirver和若干个Executor组成，其中，每个Executor占用若干资源，内部可运行多个Task（对应多少个“slot”）。应用程序的各个任务正式运行之前，需要将运行环境中的资源全部申请好，且运行过程中要一直占用这些资源，即使不用，最后程序运行结束后，回收这些资源。<br>  ② 细粒度模式（Fine-grained Mode）：鉴于粗粒度模式会造成大量资源浪费，Spark On Mesos还提供了另外一种调度模式：细粒度模式，这种模式类似于现在的云计算，思想是按需分配。</li>
</ol>
<p><strong>Spark 客户端直接连接 Mesos；不需要额外构建 Spark 集群。国内应用比较少，更多的是运用 yarn 调度。</strong></p>
<h3 id="9-Spark的常用端口号"><a href="#9-Spark的常用端口号" class="headerlink" title="9. Spark的常用端口号"></a>9. Spark的常用端口号</h3><p>（1）4040：spark shell任务端口；<br>（2）7077：内部通讯端口，类似于hadoop的8020；<br>（3）8080：查看任务执行情况的端口号，类似hadoop的8088；<br>（4）18080：历史服务器，类似于hadoop的19888。</p>
<h3 id="10-SparkSQL中的三种join操作"><a href="#10-SparkSQL中的三种join操作" class="headerlink" title="10. SparkSQL中的三种join操作"></a>10. SparkSQL中的三种join操作</h3><p>用于小表join大表的 <code>broadcast join</code> 和 <code>shuffle join</code>，以及用于将两个大表连接的 <code>sort merge join</code>。</p>
<ol>
<li>broadcast join：将小表的数据通过广播的数据，分发到各个excutor中，即每个excutor都存储小表的全部数据，然后将大表分区，每个分区都和本地的广播变量进行join操作，这种方式会消耗空间，但会缩短shuffle的时间；</li>
<li>shuffle join：broadcast join适用于比较小的表，这个小的程度由spark.sql.broadcastTreshold参数来设置，默认是10M。对于表较大的小表，可以对两个表进行shuffle操作，将相同key的数据分到同一个分区，在分区之间进行join操作，这就相当于是将两张表分成若干份，小份和小份之间进行join，充分利用集群资源；</li>
<li>sort merge join：<code>broadcast join</code> 和 <code>shuffle join</code> 都是采用hash join，即将小表的数据完全加载到内存，然后通过hashcode取join key相等的方式进行连接，如果两个表都是大表就不适用了。此时就需要用到 <code>sort merge join</code>。它将两张表依照join key进行分区，然后对分区中的数据进行排序，排序后在对相应分区的数据遍历，碰到key相同就输出，这种方式大大提高了大数据量下sql join的稳定性。</li>
</ol>
<h3 id="11-Spark任务的提交流程-有时间再看看这个"><a href="#11-Spark任务的提交流程-有时间再看看这个" class="headerlink" title="11. Spark任务的提交流程**有时间再看看这个"></a>11. Spark任务的提交流程**有时间再看看这个</h3><p>spark的任务，在生产环境中一般会在yarn上运行，具体流程如下：</p>
<ol>
<li>用户通过client将任务提交到RM；</li>
<li>RM会启动一个AM；</li>
<li>AM会在内部启动一个driver线程，并向RM申请资源；</li>
<li>RM会返回一个资源可用列表；</li>
<li>Driver会在内部初始化SC、进行任务的划分和调度；</li>
<li>AM通过NM启动Container，并在Container内部启动一个ExcutorBanked进程；</li>
<li>Excutor反向注册给Driver；</li>
<li>Excutor启动任务。</li>
</ol>
<h3 id="12-如何划分Spark的stage"><a href="#12-如何划分Spark的stage" class="headerlink" title="12. 如何划分Spark的stage"></a>12. 如何划分Spark的stage</h3><p>有两个点，概念和划分的思路。</p>
<ol>
<li>窄依赖是父RDD的一个分区最多只能被子RDD的一个分区依赖，常见的有map、flatmap、filter等；</li>
<li>宽依赖是父RDD的一个分区可以由子RDD的多个分区所依赖，常见的有groupbykey、sortbykey、reducebykey等；</li>
<li>shuffle的概念是，在spark中，每个任务对应一个分区，通常不会跨区域操作数据，但遇到宽依赖的操作，spark必须从多个分区中读取数据，并查找所有键对应的值，最终汇总在一起以计算每个键最终的结果；</li>
<li>stage划分的思路：stage是以result和shuffle两种类型来划分task的，对于窄依赖，由于分区依赖关系的确定性，partition转换处理可以在同一个线程完成，这成为resulttask；对于宽依赖，需要等待父RDD的shuffle处理完成，在下一个stage才能开始接下来的计算，这成为shuffletask。</li>
<li>因此，stage的划分原则为：从后往前推RDD算子，如果遇到宽依赖就断开，划分为一个stage；如果是窄依赖，就将该RDD加入当前的stage中。</li>
</ol>
<h3 id="13-spark的懒加载机制"><a href="#13-spark的懒加载机制" class="headerlink" title="13. spark的懒加载机制"></a>13. spark的懒加载机制</h3><p>在spark中，RDD包含两种操作，一种是转换，泛指接收rdd作为输入，并输出一个rdd的函数，划分为窄依赖和宽依赖；另一种是行为，将rdd转换为非rdd的变量的操作，通常用于返回rdd计算的结果。其中转换操作就是懒操作，转换操作是延迟计算的，也就是说一个rdd转换生成另一个rdd的过程不会立即执行，而是等到出现行为操作的时候才会真正触发运算。</p>
<p>转化操作返回的数据类型是一个rdd类型；行为运算返回的数据类型是其他类型，二者的区别在于spark计算rdd的方式不同。</p>
<h3 id="14-spark的DAG？"><a href="#14-spark的DAG？" class="headerlink" title="14. spark的DAG？"></a>14. spark的DAG？</h3><p>DAG的中文全称是有向无环图，在spark中，使用DAG来描述我们的计算逻辑。</p>
<p>DAG简单的说就是一个RDD的执行流程和依赖关系。 有方向无闭环。创建RDD的时候构建DAG图，执行行动算子时一个DAG图形成。一个应用里面有多少个DAG取决于执行了多少次行动算子。</p>
<h3 id="15-spark的数据倾斜问题"><a href="#15-spark的数据倾斜问题" class="headerlink" title="15. spark的数据倾斜问题"></a>15. spark的数据倾斜问题</h3><p><strong>一. 产生的原因</strong></p>
<p>spark 中的数据倾斜并不是说原始数据存在倾斜，原始数据都是一个一个的 block，大小都一样，不存在数据倾斜；</p>
<p>而是指 shuffle 过程中产生的数据倾斜，由于不同的 key 对应的数据量不同导致不同 task 处理的数据量不同。</p>
<p>这里需要注意一点，数据倾斜和数据过量不同，数据倾斜是某几个task处理的数据量很大，数据过量是所有task的数据量都很大。</p>
<p><strong>二. 数据倾斜的表现</strong></p>
<p>大部分 task 都快速执行完毕，少数 task 执行缓慢，甚至报错 OOM，即使最终运行完毕，也叫数据倾斜。</p>
<p><strong>三. 后果</strong></p>
<ol>
<li>程序运行缓慢；</li>
<li>报错OOM；</li>
</ol>
<p><strong>四. 定位问题</strong></p>
<ol>
<li>查看代码中的shuffle算子，如reduceByKey、sortByKey、groupByKey、join等，根据代码逻辑推断是否会出现数据倾斜；</li>
<li>查看spark log文件，log记录错误发生在哪一行，再根据自己的理解定位到哪个shuffle算子；</li>
<li>使用spark web UI查看。</li>
</ol>
<p><strong>五. 解决方案</strong></p>
<ol>
<li><p>使用Hive FTL预处理数据</p>
<p>​        适用于导致数据倾斜的表是hive表。如果该hive表中的数据本身就很不均匀，如某个key对应100万条数据，而其他key才对应10条数据，而且业务场景需要频繁使用spark对hive表执行某个分析操作，就比较适合使用这种技术。</p>
<p>​        该方法的优点是实现起来简单便捷，效果还非常好，完全规避掉了数据倾斜，Spark作业的性能会大幅度提升。</p>
<p>​        缺点是治标不治本，Hive ETL中还是会发生数据倾斜。</p>
</li>
<li><p>过滤少数会导致倾斜的key</p>
<p>​        如果我们判断哪少数几个数据量特别多的key，对作业的执行和计算结果不是特别重要的话，那么干脆就直接过滤掉那少数几个key。比如，在Spark SQL中可以使用where子句过滤掉这些key或者在Spark Core中对RDD执行filter算子过滤掉这些key。如果需要每次作业执行时，动态判定哪些key的数据量最多然后再进行过滤，那么可以使用sample算子对RDD进行采样，然后计算出每个key的数量，取数据量最多的key过滤掉即可。</p>
<p>​        优点是实现简单，而且效果也很好，可以完全规避掉数据倾斜。</p>
<p>​        缺点是适用场景不多，大多数情况下，导致倾斜的key还是很多的，并不是只有少数几个。</p>
</li>
<li><p>提高shuffle操作的并行度</p>
<p>​        在对RDD执行shuffle算子时，给shuffle算子传入一个参数，比如reduceByKey(1000)，该参数就设置了这个shuffle算子执行时shuffle read task的数量。对于Spark SQL中的shuffle类语句，比如group by、join等，需要设置一个参数，即spark.sql.shuffle.partitions，该参数代表了shuffle read task的并行度，该值默认是200，对于很多场景来说都有点过小。</p>
<p>​        优点是实现起来比较简单，可以有效缓解和减轻数据倾斜的影响。</p>
<p>​        缺点是只是缓解了数据倾斜而已，没有彻底根除问题，其效果有限。</p>
</li>
<li><p>局部和全局两阶段聚合</p>
<p>​        对RDD执行reduceByKey等聚合类shuffle算子或者在Spark SQL中使用group by语句进行分组聚合时，比较适用这种方案。</p>
<p>​        该方法的原理是将原本相同的key通过附加随机前缀的方式，变成多个不同的key，就可以让原本被一个task处理的数据分散到多个task上去做局部聚合，进而解决单个task处理数据量过多的问题。接着去除掉随机前缀，再次进行全局聚合，就可以得到最终的结果。</p>
<p>​        优点是对于聚合类的shuffle操作导致的数据倾斜，效果是非常不错的。通常都可以解决掉数据倾斜，或者至少是大幅度缓解数据倾斜，将Spark作业的性能提升数倍以上。</p>
<p>​        缺点是仅仅适用于聚合类的shuffle操作，适用范围相对较窄。如果是join类的shuffle操作，还得用其他的解决方案。</p>
</li>
<li><p>将reduce join转为map join</p>
<p>​        正常情况下，join 会产生 shuffle 过程，而且是 reduce join，即先将相同 key 对应的 value 汇聚到一个 reduce task 中，再进行 join。如果其中有一个 RDD 很小，就可以采用 广播小 RDD + map 大 RDD 实现 join 功能，此时没有 shuffle 操作，自然不会有数据倾斜。</p>
<p>​        该方法的优点是对join操作导致的数据倾斜，效果非常好，因为根本就不会发生shuffle，也就根本不会发生数据倾斜。</p>
<p>​        缺点是适用场景较少，因为这个方案只适用于一个大表和一个小表的情况。毕竟我们需要将小表进行广播，此时会比较消耗内存资源，driver和每个Executor内存中都会驻留一份小RDD的全量数据。如果我们广播出去的RDD数据比较大，比如10G以上，那么就可能发生内存溢出了。因此并不适合两个都是大表的情况。</p>
</li>
<li><p>采样倾斜key并分拆join操作</p>
<p>​        适于大表join大表，对于join导致的数据倾斜，如果只是某几个key导致了倾斜，可以将少数几个key分拆成独立RDD，并附加随机前缀打散成n份去进行join，此时这几个key对应的数据就不会集中在少数几个task上，而是分散到多个task进行join了。</p>
<p>​        优点是对于join导致的数据倾斜，如果只是某几个key导致了倾斜，采用该方式可以用最有效的方式打散key进行join。而且只需要针对少数倾斜key对应的数据进行扩容n倍，不需要对全量数据进行扩容。避免了占用过多内存。</p>
<p>​        缺点是如果导致倾斜的key特别多的话，比如成千上万个key都导致数据倾斜，那么这种方式也不适合。</p>
</li>
<li><p>使用随机前缀和扩容RDD进行join</p>
<p>​        适用于在进行join操作时，有大量的key导致数据倾斜。</p>
<p>​        它将原先一样的key通过附加随机前缀变成不一样的key，然后就可以将这些处理后的“不同key”分散到多个task中去处理，而不是让一个task处理大量的相同key。该方案上种方法的不同之处就在于，上一种方法是尽量只对少数倾斜key对应的数据进行特殊处理，由于处理过程需要扩容RDD，因此上一种方案扩容RDD后对内存的占用并不大；而这一种方案是针对有大量倾斜key的情况，没法将部分key拆分出来进行单独处理，因此只能对整个RDD进行数据扩容，对内存资源要求很高。</p>
<p>​        优点是对join类型的数据倾斜基本都可以处理，而且效果也相对比较显著，性能提升效果非常不错。</p>
<p>​        缺点是该方法更多的是缓解数据倾斜，而不是彻底避免数据倾斜。而且需要对整个RDD进行扩容，对内存资源要求很高。</p>
</li>
<li><p>多种方法组合使用</p>
<p>​        如果只是处理较为简单的数据倾斜场景，那么使用上述方案中的某一种基本就可以解决。但是如果要处理一个较为复杂的数据倾斜场景，那么可能需要将多种方案组合起来使用。比如说，我们针对出现了多个数据倾斜环节的Spark作业，可以先运用解决方案一和二，预处理一部分数据，并过滤一部分数据来缓解；其次可以对某些shuffle操作提升并行度，优化其性能；最后还可以针对不同的聚合或join操作，选择一种方案来优化其性能。</p>
</li>
</ol>
<h3 id="16-Spark的内存管理机制"><a href="#16-Spark的内存管理机制" class="headerlink" title="16. Spark的内存管理机制"></a>16. Spark的内存管理机制</h3><h4 id="B站摘："><a href="#B站摘：" class="headerlink" title="B站摘："></a>B站摘：</h4><p>​        在一个executor节点上，内存被分为堆内内存和堆外内存，堆外内存由JVM来使用，对spark来说是不可见的，所以更多讨论的是堆内内存的内容。</p>
<p>​        这一块分为四个部分，首先它会默认保留300M的Reserved保留存储，剩下的for执行、for缓存、和for用户的memory，默认是按照334的比例进行划分。其中for执行指的是在计算过程中，特别是shuffle过程中，所需要使用到的临时的内存，而for缓存是缓存rdd时需要用到的内存。在1.6版本之前，这些配置都是相对静态的，1.6之后spark引入了统一内存管理的特性，极大的简化和优化了这个问题。</p>
<p>​        在默认情况下，执行和缓存各占一半的内存，而在统一内存管理中，当缓存需要内存多于一半的时候，它可以部分的占用原本属于执行的内存空间，反过来也一样，从而使它们之间有一个buffer的区域，可以互相占用，这种方式可以保证在大多数情况下，内存能有一个很好的利用。</p>
<h4 id="网上找："><a href="#网上找：" class="headerlink" title="网上找："></a>网上找：</h4><p>在执行 Spark 的应用程序时，Spark 集群会启动 Driver 和 Executor 两种 JVM 进程，前者为主控进程，负责创建 Spark 上下文，提交 Spark 作业（Job），并将作业转化为计算任务（Task），在各个 Executor 进程间协调任务的调度，后者负责在工作节点上执行具体的计算任务，并将结果返回给 Driver，同时为需要持久化的 RDD 提供存储功能。</p>
<p>1）堆内和堆外内存划分<br>堆内内存受到 JVM 统一管理，堆外内存是直接向操作系统进行内存的申请和释放。<br>1&gt;堆内内存<br>Executor 内运行的并发任务共享 JVM 堆内内存，这些任务在缓存 RDD 数据和广播（Broadcast）数据时占用的内存被规划为存储（Storage）内存 ， 而这些任务在执行 Shuffle 时占用的内存被规划为执行（Execution）内存，剩余的部分不做特殊规划，那些 Spark 内部的对象实例，或者用户定义的 Spark 应用程序中的对象实例，均占用剩余的空间。</p>
<p>Spark 对堆内内存的管理是一种逻辑上的”规划式”的管理，因为对象实例占用内存的申请和释放都由 JVM 完成，Spark 只能在申请后和释放前记录这些内存，我们来看其具体流程：<br>申请内存流程如下：<br>1.Spark 在代码中 new 一个对象实例；<br>2.JVM 从堆内内存分配空间，创建对象并返回对象引用；<br>3.Spark 保存该对象的引用，记录该对象占用的内存。<br>释放内存流程如下：<br>1.Spark 记录该对象释放的内存，删除该对象的引用；<br>2.等待 JVM 的垃圾回收机制释放该对象占用的堆内内存。<br>java虚拟机管理的内存（堆内内存），若想去控制它，比如说资源的释放是无法做到的，通知释放指令后，什么时候释放是不确定的，只能通知而不能控制，导致不灵活，即被 Spark 标记为释放的对象实例，很有可能在实际上并没有被 JVM 回收，导致实际可用的内存小于 Spark 记录的可用内存，比如想要去加载数据，但是发现内存没释放，导致内存不够用。所以 Spark 并不能准确记录实际可用的堆内内存。<br>2&gt;堆外内存<br>为了进一步优化内存的使用以及提高 Shuffle 时排序的效率，Spark 引入了堆外（Off-heap）内存。堆外内存意味着把内存对象分配在 Java 虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机）。这样做的结果就是能保持一个较小的堆，以减少垃圾收集对应用的影响。<br>堆外内存可以被精确地申请和释放（堆外内存之所以能够被精确的申请和释放，是由于内存的申请和释放不再通过 JVM 机制，而是直接向操作系统申请，JVM 对于内存的清理是无法准确指定时间点的，因此无法实现精确的释放），而且堆外内存序列化的数据占用的空间可以被精确计算，所以相比堆内内存来说降低了管理的难度，也降低了误差。但是相对来说也就不安全。因为它不是自动化的，而是人为控制的，存在人为操作错误的风险。<br>2）内存空间分配<br>和java虚拟机内存结构进行分类管理类似，Spark也将内存进行分类，分为：存储内存、执行内存、其他内存。</p>
<p>存储内存主要存储RDD缓存数据以及广播变量（广播变量：把task重复的数据独立出来共享到Excuter，所以放在存储内存中）。<br>执行内存存储的是Shuffle过程中的操作。<br>其他内存：系统自带的数据以及RDD元数据的信息。<br>预留内存：固定大小300M。<br>存储内存占除了预留内存其余内存的30%，执行内存占30%，其他内存占40%。</p>
<p>在 Spark 最初采用的静态内存管理机制下，存储内存、执行内存和其他内存的大小在 Spark 应用程序运行期间均为固定的，Spark 1.6 之后引入的统一内存管理机制，与静态内存管理的区别在于存储内存和执行内存共享同一块空间，可以动态占用对方的空闲区域。</p>
<p>其中最重要的优化在于动态占用机制，其规则如下：<br>1&gt;设定基本的存储内存和执行内存区域（spark.storage.storageFraction 参数），该设定确定了双方各自拥有的空间的范围；<br>2&gt;双方的空间都不足时，则存储到硬盘；若一方空间不足而对方空余时，可借用对方的空间;（存储空间不足是指不足以放下一个完整的 Block）.<br>3&gt;存储内存不够的时候，向执行内存借的内存需要还回去。可让对方将占用的部分转存到硬盘，然后”归还”借用的空间；<br>4&gt;执行内存不够用向存储内存借的内存不用还，因为如果执行内存还回借用的内存，会造成数据丢失，shuffle在Excuter中执行，意味着需要做统计分析。数据丢失，那么统计的结果将不正确。因此Excuter不能淘汰内存还给存储内存。<br>        存储内存不够的时候，向执行内存借的内存需要还回去，而执行内存不够用向存储内存借的内存不用还。因为存储内存如果丢失了，可以再走一遍，程序不会出现太多问题，只不过性能差一些，延时更长一些。如果执行内存还回借用的内存，会造成数据丢失，shuffle在Excuter中执行，意味着需要做统计分析。数据丢失，那么统计的结果将不正确。因此Excuter不能淘汰内存还给存储内存。</p>
<h3 id="17-spark中可以引起shuffle的算子"><a href="#17-spark中可以引起shuffle的算子" class="headerlink" title="17. spark中可以引起shuffle的算子"></a>17. spark中可以引起shuffle的算子</h3><ol>
<li>去重：distinct</li>
<li>聚合：reduceByKey、groupByKey、aggregateByKey、combineByKey。</li>
<li>排序：sortByKey、sortBy</li>
<li>重分区：coalesce、repartition</li>
<li>集合或表操作：intersection、subtract、subtractByKey、join、leftOuterJoin</li>
</ol>
<h3 id="18-Spark中的Shuffle"><a href="#18-Spark中的Shuffle" class="headerlink" title="18. Spark中的Shuffle"></a>18. Spark中的Shuffle</h3><p>​        Shuffle描述着数据从map task输出到reduce task输入的这段过程。shuffle是连接Map和Reduce之间的桥梁，Map的输出要用到Reduce中必须经过shuffle这个环节，shuffle的性能高低直接影响了整个程序的性能和吞吐量。因为在分布式情况下，reduce task需要跨节点去拉取其它节点上的map task结果。这一过程将会产生网络资源消耗和内存，磁盘IO的消耗。通常shuffle分为两部分：Map阶段的数据准备和Reduce阶段的数据拷贝处理。一般将在map端的Shuffle称之为Shuffle Write，在Reduce端的Shuffle称之为Shuffle Read。</p>
<p>​        在Spark的中，负责shuffle过程的执行、计算和处理的组件主要就是ShuffleManager，也即shuffle管理器。ShuffleManager随着Spark的发展有两种实现的方式，分别为HashShuffleManager和SortShuffleManager，因此spark的Shuffle有Hash Shuffle和Sort Shuffle两种。</p>
<p>1）Hash shuffle</p>
<p>这种shuffle类型在2.0之后就不再使用了。优化前的hashshuffle，每个task 会生成reducer类别数的数据文件，然后reducer会将每个task中对应类别的数据收集汇聚，这种方式会得到n个task和m个reducer数量输出的n * m数量的小文件；优化后的hashshuffle会复用buffer，即无论多少个task，都只会将数据存放在m个reducer数量的buffer中。</p>
<p>2）Sort Shuffle</p>
<p>​        这种方式以更少的中间磁盘文件产生而远远优于HashShuffle。而它的运行机制主要分为两种。一种为普通机制，另一种为bypass机制。而bypass机制的启动条件为，当shuffle read task的数量小于等于spark.shuffle.sort.bypassMergeThreshold参数的值时（默认为200），就会启用bypass机制。</p>
<p>（1）普通机制：</p>
<p>​        在该模式下，数据会先写入一个数据结构，聚合算子写入Map，一边通过Map局部聚合，一遍写入内存。Join算子写入ArrayList直接写入内存中。然后需要判断是否达到阈值，如果达到就会将内存数据结构的数据写入到磁盘，清空内存数据结构。</p>
<p>​        在溢写磁盘前，先根据key进行排序，排序过后的数据，会分批写入到磁盘文件中。默认批次为10000条，数据会以每批一万条写入到磁盘文件。写入磁盘文件通过缓冲区溢写的方式，每次溢写都会产生一个磁盘文件，也就是说一个task过程会产生多个临时文件。</p>
<p>​        最后在每个task中，将所有的临时文件合并，这就是merge过程，此过程将所有临时文件读取出来，一次写入到最终文件。意味着一个task的所有数据都在这一个文件中。同时单独写一份索引文件，标识下游各个task的数据在文件中的索引，start offset和end offset。</p>
<p>​        这样算来如果第一个stage 50个task，每个Executor执行一个task，那么无论下游有几个task，就需要50个磁盘文件。</p>
<p>（2）bypass机制</p>
<p>bypass机制运行条件：</p>
<p>① shuffle map task数量小于spark.shuffle.sort.bypassMergeThreshold参数的值。<br>② 不是聚合类的shuffle算子（比如reduceByKey）。<br>        在这种机制下，当前stage的task会为每个下游的task都创建临时磁盘文件。将数据按照key值进行hash，然后根据hash值，将key写入对应的磁盘文件中（个人觉得这也相当于一次另类的排序，将相同的key放在一起了）。最终，同样会将所有临时文件依次合并成一个磁盘文件，建立索引。</p>
<p>​        该机制与未优化的hashshuffle相比，没有那么多磁盘文件，下游task的read操作相对性能会更好。</p>
<p>​        该机制与sortshuffle的普通机制相比，在readtask不多的情况下，首先写的机制是不同，其次不会进行排序。这样就可以节约一部分性能开销。</p>
<h3 id="19-foreach和foreachPartition的区别"><a href="#19-foreach和foreachPartition的区别" class="headerlink" title="19. foreach和foreachPartition的区别"></a>19. foreach和foreachPartition的区别</h3><h4 id="我自己的理解"><a href="#我自己的理解" class="headerlink" title="我自己的理解"></a>我自己的理解</h4><p>二者都用来迭代rdd，前者一次迭代一个数据，后者一次迭代一批数据。</p>
<h4 id="找到的答案"><a href="#找到的答案" class="headerlink" title="找到的答案"></a>找到的答案</h4><p>每个partition中iterator时行迭代的处理，通过用户传入的function对iterator进行内容的处理。</p>
<p>（1）foreach</p>
<p>​        Foreach中，传入一个function，这个函数的传入参数就是每个partition中，每次的foreach得到的一个rdd的kv实例，也就是具体的内容<br>​        这种处理你并不知道这个iterator的foreach什么时候结果，只能是在foreach过程中，你得到一条数据，就处理一条数据。</p>
<p>（2）foreachPartition</p>
<p>​        这个函数也是根据传入的function进行处理，但是不同之处再有这里function传入的参数是一个partition对应数据的iterator，而不是直接使用iterator的foreach。</p>
<h3 id="20-map和mapPartitions的区别"><a href="#20-map和mapPartitions的区别" class="headerlink" title="20 map和mapPartitions的区别"></a>20 map和mapPartitions的区别</h3><p>（1）主要区别在于：</p>
<p>1） map ：一次处理一个元素的数据；</p>
<p>2）mapPartitions：一次处理一批数据。</p>
<p>（2）mapPartitions的优缺点：</p>
<p>优点：速度快，一次处理一批数据，即一次接收所有的partition数据，在map过程中需要频繁创建额外的对象(例如将rdd中的数据通过jdbc写入数据库，map需要为每个元素创建一个链接，而mapPartition为每个partition创建一个链接)，则mapPartitions效率比map高的多。</p>
<p>缺点：容易出现内存溢出，当接收的partition的数据量较大时，例如100万数据， 一次传入一个function以后，那么可能一下子内存不够，但是又没有办法去腾出内存空间来，可能就导致OOM（内存溢出）；而map一般较少出现内存溢出。</p>
<p>（3）mapPartitions()出现内存溢出时的解决方法：</p>
<ol>
<li>将数据切成较多的partition：<br><code>repartition(100).mapPartitions(xx)</code></li>
<li>设置较大的处理器内存<br><code>--executor-memory 8g</code></li>
</ol>
<h3 id="21-Spark-Sql支持的存储文件类型？"><a href="#21-Spark-Sql支持的存储文件类型？" class="headerlink" title="21 Spark Sql支持的存储文件类型？"></a>21 Spark Sql支持的存储文件类型？</h3><p>常见的文件存储类型：Text文件、Json文件、Sequence文件和Object文件。<br>Spark Sql的默认存储格式是Parquet，Parquet是一种列式存储格式。</p>
<h3 id="22-spark的核心组件"><a href="#22-spark的核心组件" class="headerlink" title="22 spark的核心组件"></a>22 spark的核心组件</h3><ol>
<li><p>Driver：Spark驱动节点，用于执行Spark任务中的main方法，负责实际代码的执行工作。Driver在Spark作业执行时主要负责：</p>
<p>1）将用户程序转化为job；</p>
<p>2）在Executor之间调度Task；</p>
<p>3）跟踪Executor的执行情况；</p>
<p>4）通过UI查询展示运行情况；</p>
</li>
<li><p>Executor：Executor节点是一个JVM进程，负责运行具体任务，任务之间相互独立。</p>
<p>Spark应用启动时，Executor节点被同时启动，并且始终伴随着整个Spark应用的生命周期。</p>
<p>如果有Executor节点发生故障或者崩溃，Spark应用会将出错节点上的任务调度到其他Executor节点上继续运行。</p>
<p>Executor有两个核心功能：</p>
<p>1）负责运行组成Spark应用的任务，并将结果返回给驱动器进程；</p>
<p>2）Executor通过自身的块管理器（Block Manager）为用户程序中要求缓存的RDD提供内存式存储。RDD是直接缓存在Executor进程内的，因此任务可以在运行时充分利用缓存数据加速运算。</p>
</li>
</ol>
<h3 id="23-什么是RDD"><a href="#23-什么是RDD" class="headerlink" title="23 什么是RDD"></a>23 什么是RDD</h3><p>RDD (Resilient Distributed Dataset)叫做弹性分布式数据集，是Spark中最基本的数据处理模型。代码中是一个抽象类，它代表一个弹性的、不可变、可分区、里面的元素可并行计算的集合。</p>
<p>它有五大特性：</p>
<ol>
<li><p><strong>分区列表( a list of partitions)</strong></p>
<p>Spark RDD是被分区的，每一个分区都会被一个计算任务(Task)处理，分区数决定了并行计算的数量，RDD的并行度默认从父RDD传给子RDD。默认情况下，一个HDFS上的数据分片就是一个 partiton，RDD分片数决定了并行计算的力度，可以在创建RDD时指定RDD分片个数（分区）。</p>
</li>
<li><p><strong>每一个分区（分片）都有一个计算函数( a function for computing each split）</strong></p>
<p>每个分区都会有计算函数， Spark的RDD的计算函数是以分片为基本单位的，每个RDD都会实现 compute函数，对具体的分片进行计算，RDD中的分片是并行的，所以是分布式并行计算。</p>
</li>
<li><p><strong>依赖于其他RDD的列表</strong></p>
<p>RDD会记录它的依赖 ，为了容错，也就是说在内存中的RDD操作时出错或丢失会进行重算。</p>
</li>
<li><p><strong>key- value数据类型的RDD分区</strong></p>
<p>如果RDD里面存的数据是key-value形式，则可以传递一个自定义的Partitioner进行重新分区，例如这里自定义的Partitioner是基于key进行分区，那则会将不同RDD里面的相同key的数据放到同一个partition里面。</p>
</li>
<li><p><strong>每个分区都有一个优先位置列表</strong></p>
<p>优先位置列表会存储每个 Partition的优先位置，对于一个HDFS文件来说，就是每个Partition块的位置。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础面试题</title>
    <url>/2022/01/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><span id="more"></span>

<h3 id="1-什么是MySQL"><a href="#1-什么是MySQL" class="headerlink" title="1. 什么是MySQL"></a>1. 什么是MySQL</h3><p>​        首先简单说明一下关系数据库，关系数据库中存放的是实体之间的关系，比如订单和商品两个实体之间会存在包含的关系。关系数据库将数据保存在不同的表中，而不是存在一个大仓库，这样就提高了速度和灵活性。MySQL就是一种RDBMS，即关系数据库管理系统。MySQL使用的SQL语言是用于访问数据库的最常用标准化语言。MySQL采用双授权政策，分为社区版和商业版，由于体积小、速度快、总体成本低，尤其是开放源码的特点，一般中小型网站的开发都会选择MySQL作为网站数据库。</p>
<p>​        MySQL存储的方式是，一台电脑如果安装了MySQL，这台电脑可以称为MySQL数据库服务器。在服务器内部，通过数据库存储数据，通常一个应用创建一个数据库；在数据库中，用表存储数据，在一个系统中，通常为一个实体创建一张表；在一个表中，往往会有很多记录，一个实体的实例，会创建一条记录。</p>
<hr>
<p>上面的太复杂，应该也不需要说的这么复杂，简短答一下就好：</p>
<p>MySQL是关系型数据库管理系统，将数据存放在不同的表中，而不是一个大仓库，提高了速度和灵活性。</p>
<h3 id="2-SQL和NoSQL的区别"><a href="#2-SQL和NoSQL的区别" class="headerlink" title="2. SQL和NoSQL的区别"></a>2. SQL和NoSQL的区别</h3><p>​        实际上就是关系型数据库和非关系型数据库的区别。</p>
<p>​        关系型数据库最大的特点就是事务的一致性，传统的关系型数据库的操作都是事务的，都需要具有ACID特性，这个特性使得关系型数据库能够应用在绝大多数对一致性有要求的系统中，典型的有银行系统。但是这个特性在网络应用，尤其是社交网络应用中显得不那么重要，两个用户看到同一好友更新的内容差那么几秒是可以容忍的。对于诸如微博、facebook这类社交网络应用，对读写性能具有极高的要求，但是关系型数据库为了维护一致性所付出的代价就是读写性能比较差，这是社交应用不能容忍的。</p>
<p>​        关系型数据库还有一个特点就是它具有固定的表结构，这就导致扩展性极差。而系统的升级和功能的增加，往往会导致数据结构进行大幅更改，这对关系型数据库也非常不友好。</p>
<p>​        针对这些问题，就提出了nosql，泛指非关系型数据库。nosql的存储格式多样，可以是json，也可以是哈希表或者其他形式，并且由于nosql不需要具备ACID的特性，所以读写性能极高。</p>
<p>​        但是对数据的持久化存储，尤其是海量量数据的持久化存储，还是要依靠关系型数据库的。</p>
<h3 id="3-主从复制原理、作用"><a href="#3-主从复制原理、作用" class="headerlink" title="3. 主从复制原理、作用"></a>3. 主从复制原理、作用</h3><p>​        MySQL主从复制指的是数据可以从一个MySQL数据库服务器主节点复制到一个至多个从节点。MySQL默认采用异步复制的方式，这样就不用一直访问主节点来更新自己的数据。数据的更新可以在远程连接上进行，从节点可以复制主节点上的所有数据库或者特定的数据库或特定的表。</p>
<p>​        具体的原理是：主库将变更写入binlog日志，然后从库连接主库后，从库有一个IO线程，将主库的binlog日志拷贝到本地的中继日志中，然后从库的SQL线程从中继日志读取并执行其中的内容，也就是自己在本地也执行一遍SQL，这样就可以保证自己跟主库的数据是一致的。</p>
<p>​        由于从库同步数据是串行的，但是主库是并行操作，在高并发的场景下，就很容易出现延时，即从库的数据一定会比主库慢一些。在这个问题的基础上，如果主库突然宕机，此时恰巧从库还没来得及同步，那么有些数据就会丢失了。</p>
<p>​        针对上述这些情况，使用两个机制：半同步复制用于解决数据丢失的问题；并行复制用于解决延时的问题。</p>
<p>​        半同步复制指的是将主库变更写入binlog日志中，会强制立刻同步数据到从库，从库将日志写入本地的中继日志后，会返回一个ack给主库，当主库得到至少一个从库的ack才会认为写操作成功。</p>
<p>​        并行复制指的是让从库开启多个线程，并行读取binlog日志中不同库的日志，然后并行存放不同库的日志，这是库级别的并行。</p>
<p>​        主从原理的作用是：</p>
<ol>
<li>做数据的热备，当主库出现故障，可以切换到从库继续执行，避免数据丢失；</li>
<li>读写分离，主库执行写操作，从库执行读操作，分担了主库的压力，可以很大程度上避免数据丢失；</li>
<li>架构的扩展：当业务量越来越大，IO访问的频率越来越高，单机无法满足，就可以使用多库存储，降低IO访问的频率，提高单个机器的IO性能。</li>
</ol>
<h3 id="3-连接查询与子查询的比较"><a href="#3-连接查询与子查询的比较" class="headerlink" title="3. 连接查询与子查询的比较"></a>3. 连接查询与子查询的比较</h3><p>​        子查询是进行select语句的嵌套查询，可以一次完成很多逻辑上需要多个步骤才能完成的操作，但是每执行一个子查询都要创建一个临时表，等到查询完毕才会将这个临时表销毁，创建和销毁临时表的过程会消耗很多实际，所以效率不高。</p>
<p>​        连接查询不需要创建临时表，所以效率回避子查询快。</p>
<hr>
<p>扩展：多表联查的性能优化：使用索引，后面有。</p>
<h3 id="4-drop、delete、truncate-比较"><a href="#4-drop、delete、truncate-比较" class="headerlink" title="4. drop、delete、truncate 比较"></a>4. drop、delete、truncate 比较</h3><p>其中，delete和truncate用于删除数据，drop用于删表。</p>
<p>delete是DML数据操纵语言，结合where使用可以删除部分满足条件的数据，逐行删除，并将该行的删除操作记录到日志中以便进行回滚；</p>
<p>truncate和drop是DDL数据定义语言，不能进行回滚，所以执行速度比delete要快。</p>
<h3 id="5-视图的作用，以及何时能更新视图"><a href="#5-视图的作用，以及何时能更新视图" class="headerlink" title="5. 视图的作用，以及何时能更新视图"></a>5. 视图的作用，以及何时能更新视图</h3><p>​        视图是由一个或几个基本表或视图导出的结果集，是一个虚拟表，不存储实际的数据。</p>
<p>​        视图的作用有两个：其一是简化用户的操作，如果关键信息来源于多个复杂关联的表，可以将这些关键信息提取到视图处理，简化操作；其二是对一些机密信息提供保护作用，只显示希望用户访问的内容。</p>
<p>​        更新视图指的是，在MySQL中，可以通过视图来Insert、Update、Delete表中的数据，因为视图是虚拟表，所以通过视图实际更新的是基本表中的真实数据。但是有一部分数据不能被更新：聚合函数、distinct、group by等操作的数据如果更新会失败。所以一般情况下最好通过视图查询数据，而不是更新数据，如果没有全面考虑在视图中更新数据的限制，很可能会导致更新失败。</p>
<h3 id="6-理解存储过程、触发器的作用。"><a href="#6-理解存储过程、触发器的作用。" class="headerlink" title="6. 理解存储过程、触发器的作用。"></a>6. 理解存储过程、触发器的作用。</h3><p><strong>存储过程：</strong></p>
<p>SQL语句需要先编译再执行，存储过程就是编译好了的一些SQL语句的集合，应用程序需要用的时候就可以直接调用，而不需要重复编译，所以效率会比较高。</p>
<p><strong>触发器：</strong></p>
<p>如果想要某条或某些语句在事件发生时自动执行，就可以创建触发器来实现。触发器在响应Insert、Delete、Update语句的时候会被自动执行。</p>
<h3 id="7-ACID-的作用以及实现原理"><a href="#7-ACID-的作用以及实现原理" class="headerlink" title="7. ACID 的作用以及实现原理"></a>7. ACID 的作用以及实现原理</h3><p>​        首先简单说明一下什么是事务：事务是对表中进行更新的单位，简单来说就是需要在同一个处理单元内执行的一系列更新处理的集合。比如现在有一个需求，需要对Products表中的数据进行更新，将T恤的单价提高10块钱，将裤子的单价降低10元，那么提高T恤单价的操作和降低裤子单价的操作就需要在一个处理单元内进行处理，仅处理其中一个都不算完成任务。</p>
<p>​        事务的ACID特性有四个：</p>
<ol>
<li><p>原子性：将事务中的所有操作看成一个整体，要么全部成功，要么全部失败。</p>
<p>​        实现的原理主要是基于回滚日志undo log，当事务中有一条sql语句出现错误，就会回滚撤销这个事务报错之前进行的所有操作，这是原子性实现的关键。</p>
</li>
<li><p>持久性：事务一旦提交，对数据库的更改就是永久的，之后其他的操作或者异常都不应该对其产生影响。</p>
<p>​        持久性的实现原理基于redo log重做日志。InnoDB作为MySQL1.5之后的存储引擎，数据存在磁盘上，但是每次读写数据都通过磁盘IO，效率会很低，所有使用Buffer Pool缓存来作为访问数据库的缓冲。当读取时，会先读取缓存，缓存中没有再从数据库读取到缓存；当写入时，会首先写入缓存，之后再定期加写入的数据刷到磁盘中，这一过程也被称为刷脏。</p>
<p>​        这种方式提高了效率，但是如果MySQL宕机，没有刷到磁盘的数据就会丢失，此时持久性就无法得到保障。于是引入了重做日志，redo log采用的是预写式日志，所有对数据的更改，会先将修改的操作写入日志，再更新到缓存，这样就算MySQL宕机，重启时也可以根据日志对数据库进行恢复，从而满足持久性的要求。</p>
</li>
<li><p>隔离性：保证不同事务之间互不干扰。</p>
<p>​        仅考虑写操作和读操作，那么隔离性可以分为两个方面：写操作通过锁机制保证隔离性；读操作通过MVCC保证隔离性。</p>
<p>​        锁机制为事务在修改数据前需要获得相应的锁，等到当前事务提交或回滚后才释放锁。</p>
<p>​        MVCC是多版本的并发控制，不同事务同一时刻读取到的数据可能是不同的，也就是多版本的，对MVCC来说最大的优点是读不加锁，因此读写不冲突，并发性能好。InnoDB实现MVCC，让多个版本的数据可以共存，主要是依靠隐藏列和undo log，其中隐藏列包括该列数据的版本号、删除时间、指向回滚日志的指针等，读取数据时，MySQL可以通过隐藏列判断是否需要回滚并找到回滚需要的回滚日志，从而实现MVCC。</p>
</li>
<li><p>一致性：指的是事务中包含的处理要满足数据库中提前设定好的约束，如主键、not null等。</p>
<p>​        一致性是事务追求的最终目标，保证原子性、持久性和隔离性都是为了保证一致性；此外，数据库底层需要提供保障，例如不允许向整形列插入字符串值等；应用层面也需要得到保证，例如转账操作不能只扣除转账者的余额，不增加接收者的余额。</p>
</li>
</ol>
<h3 id="8-四大隔离级别，以及不可重复读和幻影读的出现原因"><a href="#8-四大隔离级别，以及不可重复读和幻影读的出现原因" class="headerlink" title="8. 四大隔离级别，以及不可重复读和幻影读的出现原因"></a>8. 四大隔离级别，以及不可重复读和幻影读的出现原因</h3><h4 id="出现隔离级别的原因是：并发情况下事务引发的问题"><a href="#出现隔离级别的原因是：并发情况下事务引发的问题" class="headerlink" title="出现隔离级别的原因是：并发情况下事务引发的问题"></a>出现隔离级别的原因是：并发情况下事务引发的问题</h4><p>一般情况下，多个单元操作并发执行，会出现以下问题：</p>
<ol>
<li>脏读：A事务还未提交，B事务就读取到了A事务的结果，破坏了隔离性；</li>
<li>不可重复读：A事务在本次事务中，对自己未操作过的数据，进行多次读取，结果出现了不一致或记录不存在的情况，破坏了一致性，主要在update和delete操作；</li>
<li>幻读：A事务在本次事务中，对自己未操作过的数据，进行多次读取，第一次读取，记录不存在；第二次读取，记录存在了，也破坏了一致性，主要在insert操作。</li>
</ol>
<p>为了权衡隔离和并发之间的矛盾，引入了隔离级别。</p>
<ol>
<li>未提交读RU：是最低的级别，只能保证持久性，三个问题都会出现；</li>
<li>已提交读RC：语句级别，只能解决脏读的问题；</li>
<li>可重复读RR：事务级别，是MySQL的默认隔离级别，能够解决脏读和可重复读的问题；</li>
<li>串行化SE：是最高级别，事务与事务之间串行处理，毫无并发可言，性能极低，但能解决三个问题。</li>
</ol>
<p>这四个级别只是一个标准，在实际情况中并不是完全按照这个情况实现。</p>
<p>常见的实现有两种：锁机制和MVCC机制。</p>
<ol>
<li><p>锁机制：阻止其他事务对数据进行操作，不同隔离级别主要体现在读取数据时加锁以及释放锁的时机。</p>
<p>1.1 RU：事务读取的时候不加锁；</p>
<p>1.2 RC：事务提交的时候加行级共享锁（读到才加锁），一旦读完，立刻释放；</p>
<p>1.3 RR：事务提交加行级共享锁，直到事务结束才释放；</p>
<p>1.4 SE：事务提交时加表记共享锁，直到事务结束才释放。</p>
</li>
<li><p>MVCC机制：生成一个数据快照，并用这个快照来提供一定级别的一致性的读取，也称为多版本数据控制。</p>
<p>实际上就算CAS版本控制和读写分离的思想。主要作用于RC和RR级别。</p>
</li>
</ol>
<h3 id="9-乐观锁与悲观锁"><a href="#9-乐观锁与悲观锁" class="headerlink" title="9. 乐观锁与悲观锁"></a>9. 乐观锁与悲观锁</h3><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>​        乐观锁是每次读取数据的时候都认为不会发生任何问题，也就不会上锁，只是在更新数据的时候判断一下这个数据有没有被其他线程更改。如果没有被修改，更新成功；如果已经被修改，则事务回滚并提示错误。</p>
<p>​        判断更新的常见机制为版本号控制，读取数据时获取这个数据当前的版本号，更新时比较这个数据现在的版本号与获取的是否一致，如果不一致就说明有其他线程修改过数据。</p>
<h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>​        总是假设最坏的情况，认为每次读取数据都会有其他线程在同步修改数据，所以每次读取都会加锁。一旦加锁，同一时刻只会有一个线程执行，其他线程被阻塞等待。</p>
<p>​        常见的应用有MySQL的读写锁、行锁等，或者是Java语言的synchronized关键字。</p>
<p>​        使用悲观锁的时候需要确定使用了索引，而不是全表扫描，否则会将整个表锁住。</p>
<h3 id="10-MVCC-原理，当前读以及快照读，Next-Key-Locks-解决幻影读。"><a href="#10-MVCC-原理，当前读以及快照读，Next-Key-Locks-解决幻影读。" class="headerlink" title="10. MVCC 原理，当前读以及快照读，Next-Key Locks 解决幻影读。"></a>10. MVCC 原理，当前读以及快照读，Next-Key Locks 解决幻影读。</h3><h4 id="MVCC原理"><a href="#MVCC原理" class="headerlink" title="MVCC原理"></a>MVCC原理</h4><p>​        MVCC可以看成是行级锁的一个变种，但是在大多数情况下都避免了加锁操作，开销更低。虽然MVCC在不同数据库系统的实现机制不同，但是大都实现了非阻塞的读操作，写操作也只锁必要的行。</p>
<p>​        MVCC通过保存数据在某一个时间节点的快照来实现，也就是说，无论执行了多长时间，每个事务所看到的数据都是一致的。下面简单说明InnoDB下的MVCC具体是怎么工作的。</p>
<p>​        MVCC会对创建两个隐藏列，一列存储行的创建时间，一列存储行的删除时间。这里的时间都不是真实的时间，而是系统版本号。在开启一个新事务的时候，系统版本号会自动递增，将事务开始时的系统版本号作为该事务的版本号，与查询到的所有行的版本号进行比较，以实现各种操作。</p>
<p>​        以RR隔离级别下的select语句为例，InnoDB会通过两个条件来判断某一行记录是否能够称为查询的结果。首先会判断行的创建时间是否小于或等于当前事务的版本号，也就是这个行应该在事务开启之前已经存在或者这工行是由该事务插入或修改的；接着查看行的删除时间是否未定义或者大于当前事务的版本号，也就是要确定在事务开启之前这个行还没有被删除。满足这两个条件的行记录才会被查询到。</p>
<p>​        隐藏列的使用使得许多读操作都可以不加锁，提高了读取数据的效率，也能够保证读取的正确性，但是会给每行数据增加两个额外的列，并且需要做更多的行检查操作和一些额外的维护工作。</p>
<p>​        MVCC只能在RR和RC隔离级别下使用，其他两个隔离级别与MVCC不兼容，RU级别综上读取最新数据行，而不受当前事务的行；SE级别会给所有读取到的行都上锁。</p>
<h4 id="当前读和快照读"><a href="#当前读和快照读" class="headerlink" title="当前读和快照读"></a>当前读和快照读</h4><p>​        快照读是单纯的select语句，在RC级别下，事务开启就生成一个快照读；在RR级别下，事务开启后遇到第一个select语句才会生成快照读。实现的方式是undo log + mvcc机制。先使用排它锁住当前行，然后将该行的值写入undolog中，然后结合mvcc机制真正开始更新值。最后填写事务ID和回滚指针，事务ID指的是最后更新的事务的ID，回滚指针指向前一个版本的undo log记录。</p>
<p>​        当前读读取的是最新版本的数据，会对读取的记录加锁，阻塞其他想要同时修改记录的线程，避免出现安全问题。当前读的实现方式是next-key锁。</p>
<h4 id="Next-Key-Locks-解决幻影读"><a href="#Next-Key-Locks-解决幻影读" class="headerlink" title="Next-Key Locks 解决幻影读"></a>Next-Key Locks 解决幻影读</h4><p>​        next-key结合了行锁和间隙锁。行锁对表中一行记录加锁。间隙锁的含义是，举一个例子，比如 a、b、c站成一排，想要新来的d不能站在b的旁边，就需要对a和b以及b和c之间的空隙加锁，这就是间隙锁。还是这个例子，间隙锁锁定的范围就是根据索引条件b向左寻找最靠近条件的值a，作为左区间，然后向右寻找最靠近b的值c，作为右区间，即该间隙锁的锁定范围是 (a, c)。</p>
<p>​        使用间隙锁的目的是防止间隙内有新数据插入或已有的数据被更新为间隙内的数据，这就避免了幻读的问题。</p>
<p>​        next-key锁结合行锁和间隙锁，就是锁定一个范围，并且还锁定这个记录本身。next-key锁是InnoDB默认的加锁方式。</p>
<h3 id="11-数据库的三大范式？"><a href="#11-数据库的三大范式？" class="headerlink" title="11. 数据库的三大范式？"></a>11. 数据库的三大范式？</h3><p>第一范式（1NF）：要求数据库表中的每一列数据都是不可分割的原子数据项，比如有一列名为家庭信息的数据为几口人、住哪里，就不是源自数据项，需要将其拆分为家庭人口和户籍。</p>
<p>第二范式（2NF）：在1NF的基础上消除非码属性对候选码的部份依赖，也就是要求数据库表中的每一列都和主键相关，而不是只与部分主键相关。比如一张表中有订单号、产品号、产品数量、订单金额，可以将订单号和产品号看成一个主键，产品数量依赖于这个主键，但是订单金额只与订单号有关，可以将它拆成两张表，一张表以订单号和产品号为主键，一张表以订单号为主键。</p>
<p>第三范式（3NF）：在2NF的基础上消除传递依赖，也就是确保数据库表的每一列都与主键直接相关，而不是间接相关。比如一张表中的列为学号、姓名、班主任姓名、班主任性别，此时班主任性别与学号就是间接相关，可以拆分成两张表存储。</p>
<h3 id="12-redo、undo、binlog-日志的作用"><a href="#12-redo、undo、binlog-日志的作用" class="headerlink" title="12. redo、undo、binlog 日志的作用"></a>12. redo、undo、binlog 日志的作用</h3><ol>
<li>redo log是重做日志，用于保证事务的持久性。在MySQL宕机的时候，缓存中如果存在还没有写入到磁盘的数据，这些数据就会丢失；redo log保存事务对数据页的更改，这样在重启MySQL的时候，就可以读取redo log进行重做，从而保证事务的持久性；</li>
<li>undo log是回滚日志，用于保存事务开始之前的数据的一个版本，方便回滚；</li>
<li>bin log是二进制日志，有两个作用。其一用于复制，在主从复制中，从库会通过主库的bin log进行重播，来实现主从同步。</li>
</ol>
<p>redo log和bin log有点相似，都是用于还原，但是redo log是事务级别的还原，存储的是物理日志，也就是事务对数据页的更改；而bin log是还原整个数据库，存储的是逻辑日志，也就是sql语句。</p>
<h3 id="13-存储过程和存储函数的区别"><a href="#13-存储过程和存储函数的区别" class="headerlink" title="13. 存储过程和存储函数的区别"></a>13. 存储过程和存储函数的区别</h3><p>存储过程没有返回值，存储函数有返回值。存储过程可以通过 out 关键字来输出内容，但是本质是对 out 关键字指定的参数赋值。</p>
<h3 id="14-B-Tree-原理，与其它查找树的比较。"><a href="#14-B-Tree-原理，与其它查找树的比较。" class="headerlink" title="14. B+ Tree 原理，与其它查找树的比较。"></a>14. B+ Tree 原理，与其它查找树的比较。</h3><p>说到B+树，就需要先了解B树。一棵m阶B树的特点是：</p>
<ol>
<li>每个节点最多只有m个子节点；</li>
<li>除了根节点和叶子节点，每个节点最少有m&#x2F;2个子节点，这里的m&#x2F;2向上取整；</li>
<li>如果根节点不是叶子节点，根节点至少包含两个子节点；</li>
<li>所有叶子节点都在同一层；</li>
<li>每个节点都包含k个元素，k的取值范围是 [m&#x2F;2, m)，这里的 m&#x2F;2 向下取整；</li>
<li>每个元素左节点的值都小于或等于该元素，右节点的值都大于或等于该元素。</li>
</ol>
<p>以网上找到的3阶B树为例：</p>
<p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98.assets/bVcLtDW"></p>
<p><em><a href="https://segmentfault.com/a/1190000038445697">图片来源</a></em></p>
<p>假设将数组 [0,1,2,3,4,5,6] 插入3阶B树，具体的过程是：</p>
<ol>
<li>在根节点插入元素0；</li>
<li>因为 m&#x2F;2 向下取整为1，所以每个节点可以包含1-2个元素，可以在根节点元素0的右侧插入元素1；</li>
<li>在根节点元素1的右侧插入元素2后，根节点的元素个数超过两个，于是根节点发生裂变，将元素1的左右元素0和2转变为左右子节点，元素1独占根节点，此时满足根节点不是叶子节点，则根节点至少包含两个子节点的特性；</li>
<li>接着在元素2所在的右节点插入元素3；</li>
<li>在元素3的右侧插入元素4的时候该右节点元素的个数超过2个，发生裂变，将中间的元素3插入根节点中，此时构成元素1和3在根节点，元素0、2、4独立为子节点分别成为左子节点、中间子节点和右子节点;</li>
<li>同理，当元素5和6插入元素4的右侧，他们所在的节点的元素个数超过2，向上发生裂变，会将中间元素5插入父节点，也就是根节点中，但是此时根节点已经有2个元素了，插入5后超过了2，于是根节点向下发生裂变，元素3独占根节点，元素0和5转变为根节点的左右子节点。</li>
</ol>
<p>B+树是B树的一种优化，也是mysql的索引机制。B+树与B树很像，区别在于：</p>
<ol>
<li>所有非叶子节点只存主键信息，具体的数据都存到叶子节点；</li>
<li>所有叶子节点包含全部元素的信息；</li>
<li>所有叶子节点之间都有链指针。因为mysql的innodb以页作为存储单位，B+树的叶子节点都是一个页的大小的整倍数，而每页都有两个页指针，一个指向上一页，一个指向下一页，所以叶子节点之间可以看成是一个双向链表。</li>
</ol>
<p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98.assets/bVcLtDX"></p>
<p><em><a href="https://segmentfault.com/a/1190000038445697">图片来源</a></em></p>
<p>最后是与其他查找树的比较：首先二叉搜索树在升序插入时容易导致偏科，甚至一棵树很可能会退化为线性链表的结构；而对于平衡二叉树，假设将100w条数据插入，那么树的高度在20左右，也就是在100w条数据中查找一个数据，最坏的情况需要经过20次磁盘IO（因为mysql是将数据存在磁盘上的），性能也会构成很大的问题。所以主要比较的还是B树和B+树。</p>
<ol>
<li>由于B树在非叶子节点也会存储具体数据，所以查到即可返回，而B+树必须查到叶子节点，在同等高度下，B树的查找效率更高；</li>
<li>由于B+树的所有数据都在叶子节点，且叶子节点间使用双向链表，所以在查找大于或小于某个元素的数据时B+树只需要沿着链表遍历，而B树还需要遍历节点搜索；</li>
<li>由于页的大小是有限的，B树的每个节点都存主键和具体数据，B+树只需要存储主键，那么B+树每个节点能够存储的主键信息肯定会比B树要多，这样同样数据量的情况下，B树的深度会更大，这回增大查询时的磁盘IO数，进而影响到查询效率。</li>
</ol>
<h3 id="15-MySQL索引结构？为什么使用这种数据结构？"><a href="#15-MySQL索引结构？为什么使用这种数据结构？" class="headerlink" title="15. MySQL索引结构？为什么使用这种数据结构？"></a>15. MySQL索引结构？为什么使用这种数据结构？</h3><p>​        MySQL使用B+树的索引结构。使用这种数据结构的原因是：</p>
<p>​        先说明一下为什么不使用其他的数据结构。hash的存储格式是数组+链表，这种存储方式对hash算法的要求较高，因为发生hash冲突的时候需要对链表数据中的值进行遍历，并且数据查询时，需要将所有数据拿到内存中查询，堆内存压力较大；二叉搜索树的结构在极端情况下会退化成链表的形式；而平衡二叉搜索树需要保证左右子树高度差不超过1，否则要旋转保持平衡，这个旋转的操作比较耗时。而B树因为每个节点都存储数据，而每个节点的空间都是有限的，因为数据库中的数据都存储在页里，页的大小是16k，所以对空间的利用率不高，并且会增大树的高度，这会导致IO操作变多，查询性能偏低。</p>
<p>​        B+树的非叶子节点不会存储实际的数据，只记录关键字，这样每个非叶子节点所能存储的关键字就能大大增加；由于叶子节点存储所有父节点的数据，那么所有数据必须要到叶子节点才能得到，这样使得数据查询的次数是稳定的；并且B+树的叶子节点间是类似双向链表的结构，因为B+树能够保证左边的数据一定会大于右边的数据，也就是说叶子节点的数据从左到右是升序存储的，这样查找大于或小于某个元素的数据就可以直接沿着链表搜索。</p>
<h3 id="16-垂直切分与水平切分"><a href="#16-垂直切分与水平切分" class="headerlink" title="16. 垂直切分与水平切分"></a>16. 垂直切分与水平切分</h3><p>​        说到切分，指的一般是数据库的切分。</p>
<p>​        垂直切分是根据业务切分，同一类业务的表会被拆分到一个数据库中，比如商品表和产品表可以切分到网站系统的库中，而库存表和供货表可以切分到仓库系统的库中。垂直切分的好处是可以降低单点数据库的负载，当所有表在一个库中，所有的读写请求肯定也都在这个库中进行，如果将库拆分，就可以有效降低每个数据库的负载。但是垂直切分无法缩表，也就是无论商品表被分到哪个数据库中，本身的数据量都不会发生改变。</p>
<p>​        水平切分是按照某个字段的某种规则，将一张表中的数据切分到多个表中。这就起到了缩表的效果。但是水平切分的切分规则比较复杂，需要根据实际业务来决定，所以在选择字段的时候就需要选择切分规则比较丰富的字段。并且应用系统各模块的耦合度较高，可能会对后期数据的迁移和拆分造成一定的困难。</p>
<p>​        一般来说，数据库中的表很难通过某一个或少数几个字段全部关联起来，所以仅仅通过水平切分很难解决所有问题；而对于垂直切分，如果是一些数据量非常大的表，即使仅仅单个表可能都无法通过单台数据库主机来承担。所以必须结合水平切分和垂直切分。顺序是先水平切分再垂直切分，因为过早的对数据库进行垂直切分，势必要重新构建若干独立的业务系统，工作量太大，而水平切分不需要业务系统做大幅度的更改，理论上，冷热数据分离以后，水平切分的方式可以维持很长一段时间，数据量再大也不怕，定期归档就行。</p>
<h3 id="17-MyISAM和InnoDB的区别"><a href="#17-MyISAM和InnoDB的区别" class="headerlink" title="17. MyISAM和InnoDB的区别"></a>17. MyISAM和InnoDB的区别</h3><ol>
<li><p>InnoDB支持事务，MyISAM不支持。InnoDB默认每一条SQL语句都是一个事务，自动提交，这样会影响速度，可以使用 <code>begin... commit</code> 将多条sql语句组成一个事务。</p>
</li>
<li><p>InnoDB支持外键，MyISAM不支持，对一个包含外键的InnoDB的表转换为MyISAM会失败。</p>
</li>
<li><p>InnoDB和MyISAM都使用B+树作为索引的结构，不同的是，InnoDB使用聚集索引，MyISAM使用非聚集索引。</p>
<p>​        InnoDB的数据文件与主键索引是绑在一起的，B+树的叶子节点用于存储实际的数据文件，主键索引是必须创建的，且应该是自增的。如果主键不是有序增加的，那么当插入一条ID小于已经存在的ID的记录时，就会进行排序，那么后面的值都会在数据区移动，这个移动过程会消耗IO，移动的数据越大，消耗的就越多。所以如果不创建主键，系统会自动寻找一个可以作为主键的列，否则会隐性的创建一个作为主键的列。InnoDB的普通索引的叶子节点用于存放主键ID，这些ID会在进行普通索引搜索时返回，返回后再到主键索引中进行查询。所以如果InnoDB不使用主键索引进行查询，就会出现二次遍历，第一次遍历普通索引，第二次遍历主键索引。</p>
<p>​        MyISAM的数据文件与索引是分离的，主键索引和普通索引的叶子节点都存储实际数据文件的地址指针。二者的区别在于，主键索引不可重复，普通索引可以重复。</p>
</li>
<li><p>InnoDB不保存表的具体行数，执行 <code>select count(*)</code> 操作会扫描全表；MyISAM使用一个变量保存具体的行数，执行 <code>select count(*)</code> 操作会直接返回该变量，速度很快。</p>
</li>
<li><p>InnoDB的表很难被压缩，MyISAM的表可以被压缩。</p>
</li>
<li><p>InnoDB支持表级锁和行级锁，默认为行级锁；MyISAM仅支持表级锁。但是InnoDB的行级锁是实现在索引上而不受物理记录上，所以如果访问没有命中索引，也无法使用行级锁。</p>
</li>
<li><p>InnoDB必须要有唯一索引，比如主键；MyISAM可以没有。</p>
</li>
<li><p>InnoDB存储的文件有 <code>frm</code> 表定义文件和 <code>ibd</code> 数据文件；MyISAM有 <code>frm</code> 表定义文件、<code>myd</code> 数据文件和 <code>myi</code> 索引文件。</p>
</li>
</ol>
<p>如何选择：</p>
<ol>
<li>如果需要支持事务，肯定选择InnoDB；</li>
<li>如果表中绝大部分只是读查询，可以考虑MyISAM；如果读写都有，还是使用InnoDB；因为MyISAM的动态表包含变长字段，频繁更新和删除容易产生碎片，需要定期清理，并且出现故障时恢复困难。</li>
</ol>
<h3 id="18-where和having的用法区别"><a href="#18-where和having的用法区别" class="headerlink" title="18. where和having的用法区别"></a>18. where和having的用法区别</h3><p>where和having都用于筛选，不同的是，where不能用在group by后面，并且where语句后不能跟聚合函数，如sum、avg等；而having可以跟在group by后面，此时作用相当于where，并且having后可以跟聚合函数。</p>
<h3 id="19-常用的增删改查命令"><a href="#19-常用的增删改查命令" class="headerlink" title="19. 常用的增删改查命令"></a>19. 常用的增删改查命令</h3><ol>
<li>增：create表，insert、replace数据；</li>
<li>删：delete数据，truncate、drop表；</li>
<li>改：update数据，alter修改数据结构；</li>
<li>查：select数据，show、desc。</li>
</ol>
<h3 id="20-sql语句的执行顺序"><a href="#20-sql语句的执行顺序" class="headerlink" title="20. sql语句的执行顺序"></a>20. sql语句的执行顺序</h3><p>from -&gt; join -&gt; on -&gt; where -&gt; group by -&gt; 聚合函数 -&gt; having -&gt; select -&gt; distinct -&gt; order by -&gt; limit。</p>
<h3 id="21-大表优化"><a href="#21-大表优化" class="headerlink" title="21. 大表优化"></a>21. 大表优化</h3><ol>
<li>字段优化：尽量使用tinyint、smallint而不是int，如果非负加上unsigned；varchar的长度只分配真正需要的空间；尽量使用timestamp代替datetime；单表不要有太多字段，最好20以内；避免使用null字段。</li>
<li>索引优化：索引应该根据查询有针对性的创建，考虑在where和order by上涉及的列建立索引；尽量避免在where中进行null判断，否则会导致引擎放弃索引而使用全表扫描；值分布稀少的不适合建索引，比如性别字段；不用外键，有程序保证约束；尽量不用unique，由程序进行约束。</li>
<li>查询优化：不做列运算，如select id where age + 1 &#x3D; 10，任何对列的操作都会导致全表扫描，查询时应该尽可能将操作放到等号右边；sql语句尽量简单，一条sql只在一个cpu运算，应该将大语句拆分成小语句，减少锁的时间，避免一个大sql堵死整个库；不用select *；将or改成in，or的效率是O(n)级别，in的效率是O(logn)级别，in的个数应该控制在200以内；避免%式查询；少用join；使用同类型比较，如字符和字符比，整型和整型比；尽量避免在 where 中使用 !&#x3D; 或 &lt;&gt;，会导致全表扫描；对于连续数值，使用between and而不是 in；取数据时不要拿全表，应使用limit分页，并且每页数据量不要太大。</li>
<li>单表优化：一般除非数据量在未来会有不断上涨，否则不要一开始就考虑拆分，拆分会带来逻辑、部署、运维等各种复杂的问题，一般以整型值为主的千万一下、字符型为主的五百万以下是没有问题的。</li>
</ol>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="1-文件系统的原理，特别是-inode-和-block。数据恢复原理。"><a href="#1-文件系统的原理，特别是-inode-和-block。数据恢复原理。" class="headerlink" title="1. 文件系统的原理，特别是 inode 和 block。数据恢复原理。"></a>1. 文件系统的原理，特别是 inode 和 block。数据恢复原理。</h3><h3 id="2-硬链接与软链接的区别。"><a href="#2-硬链接与软链接的区别。" class="headerlink" title="2. 硬链接与软链接的区别。"></a>2. 硬链接与软链接的区别。</h3><h3 id="3-能够使用常用的命令，比如-cat-文件内容查看、find-搜索文件，以及-cut、sort-等管线命令。了解-grep-和-awk-的作用。"><a href="#3-能够使用常用的命令，比如-cat-文件内容查看、find-搜索文件，以及-cut、sort-等管线命令。了解-grep-和-awk-的作用。" class="headerlink" title="3. 能够使用常用的命令，比如 cat 文件内容查看、find 搜索文件，以及 cut、sort 等管线命令。了解 grep 和 awk 的作用。"></a>3. 能够使用常用的命令，比如 cat 文件内容查看、find 搜索文件，以及 cut、sort 等管线命令。了解 grep 和 awk 的作用。</h3><p>grep主要用于文本的查找，sed主要用于文本的编辑，awk主要用于文本的分析。</p>
<h3 id="4-僵尸进程与孤儿进程的区别，从-SIGCHLD-分析产生僵尸进程的原因。"><a href="#4-僵尸进程与孤儿进程的区别，从-SIGCHLD-分析产生僵尸进程的原因。" class="headerlink" title="4.  僵尸进程与孤儿进程的区别，从 SIGCHLD 分析产生僵尸进程的原因。"></a>4.  僵尸进程与孤儿进程的区别，从 SIGCHLD 分析产生僵尸进程的原因。</h3><p>​        孤儿进程就是当父进程退出，它的子进程还在运行，这些子进程就被称为孤儿进程，这些孤儿进程会被init进程，也就是进程号为1的进程收养，并由init进程完成对它们的状态收集工作；孤儿进程不会对系统造成影响。</p>
<p>​        僵尸进程是当子进程退出，父进程没有调用wait或waipid方法时，这些子进程的进程描述符就会一直存在系统中，持续占用该进程号，这是僵尸进程。</p>
<p>以下再减：</p>
<p>为什么要有僵尸进程<br>unix 提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息，就可以得到。这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号 the process ID ,退出状态 the termination status of the process, 运行时间 the amount of CPU time taken by the process 等)。直到父进程通过 wait &#x2F; waitpid 来取时才释放。父进程调用 wait 或 waitpid 时就可以得到这些信息。</p>
<p>僵尸进程的危害<br>一个进程如果只 fork 子进程而不负责对子进程进行 wait() 或是 waitpid() 调用来释放其所占有资源的话，那么就会产生很多的僵死进程。保留的那段信息不会释放，其进程号会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p>
<h3 id="5-find和grep的用法区别"><a href="#5-find和grep的用法区别" class="headerlink" title="5. find和grep的用法区别"></a>5. find和grep的用法区别</h3><p>find根据文件的属性查找，grep根据文件内容查找。如：</p>
<p>find &#x2F; -name abc.txt  - 是查找根目录下名称为 abc.txt 的文件。</p>
<p>grep “test” d* - 是显示所有以 d 开头的文件中包含 test 内容的行。</p>
<h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h2><h3 id="1-udp会丢包，是什么原因造成的"><a href="#1-udp会丢包，是什么原因造成的" class="headerlink" title="1. udp会丢包，是什么原因造成的"></a>1. udp会丢包，是什么原因造成的</h3><h3 id="2-OSI七层网络模型、TCP-x2F-IP分层模型、五层网络模型（每一层解决什么问题）"><a href="#2-OSI七层网络模型、TCP-x2F-IP分层模型、五层网络模型（每一层解决什么问题）" class="headerlink" title="2. OSI七层网络模型、TCP&#x2F;IP分层模型、五层网络模型（每一层解决什么问题）"></a>2. OSI七层网络模型、TCP&#x2F;IP分层模型、五层网络模型（每一层解决什么问题）</h3><p>首先了解OSI七层模型：</p>
<p>从下往上分别为：</p>
<ol>
<li>物理层：传输的单位是比特，用于解决两个硬件之间的通信，比如双绞线、网线等；</li>
<li>数据链路层：定义数据的格式化传输和对物理介质访问的控制，链路层通常还会提供纠错功能保证数据的可靠传输；</li>
<li>网络层：如果有多台计算机，怎么找到想要发的那台？或者说A要给D发消息，中间可能存在很多步骤，怎么找到最佳的路径呢？于是有了网络层，也就是路由器、交换机这些具有寻址功能的设备所实现的功能，这一层定义了IP地址，通过IP地址寻址，所以产生了IP协议；</li>
<li>运输层：如果发送大量数据，比如一个视频格式，可能需要很长时间，中间很容易产生网络中断，想要保证传输大文件时的准确性，需要堆数据进行封装，然后像发快递一样，一个一个发，这就是运输层，比如tcp、udp协议；</li>
<li>会话层：建立和管理应用程序之间的通信；</li>
<li>表示层：解决不同系统之间的通信语法问题；</li>
<li>应用层：通过应用进程之间的交互来完成特定的网络应用，定义的是应用进程间通信和交互的规则，比如HTTP、FTP协议。</li>
</ol>
<p>TCP&#x2F;IP四层模型从下往上是：</p>
<ol>
<li>网络接口层，指的是物理层和数据两路层；</li>
<li>网际层，用于解决不同网络之间的互连问题；</li>
<li>运输层；</li>
<li>应用层。</li>
</ol>
<p>五层协议模型综合了OSI和TCP&#x2F;IP的优点，既简洁又能将概念阐述清晰。它从下往上分别是：</p>
<ol>
<li>物理层；</li>
<li>数据链路层；</li>
<li>网络层；</li>
<li>运输层；</li>
<li>应用层，将OSI中的会话层、表示层和应用层都包含进去。</li>
</ol>
<h3 id="3-TCP和UDP的区别"><a href="#3-TCP和UDP的区别" class="headerlink" title="3. TCP和UDP的区别"></a>3. TCP和UDP的区别</h3><p>1）TCP是面向连接的，而UDP是面向无连接即发送数据前不需要建立连接；<br>2）TCP提供可靠的服务，而UDP无法保证；<br>3）TCP面向字节流，UDP面向报文；<br>4）TCP数据传输慢，UDP的数据传输快。</p>
<h3 id="5-http和https的区别"><a href="#5-http和https的区别" class="headerlink" title="5. http和https的区别"></a>5. http和https的区别</h3><p>http是超文本传输协议，它是通过明文的方式发送内容，没有任何的加密，比如我们访问一个网站，我们可能需要在这个网站输入密码，之后账号和密码就会发送到网站的服务器上，但要是有人在中途截取了信息，这些信息很容易就会暴露，为了解决http在传输过程中不加密的问题，又增加了一个SSL协议，这个协议简单说就是提供数据安全和完整性的协议，也就是负责网络连接的加密，比如访问一个https的网站，电脑就会先和服务器建立一个安全的连接通道，然后服务器会先发送一份网站的证书信息到电脑，就相当于是告诉电脑，你访问的服务器没有问题，确认了信息之后，我们的服务器就会生成一个加锁的箱子，但是这把锁有两把不一样的钥匙，一把给电脑，一把自留，然后服务器就会把没有上锁的箱子和钥匙发给电脑，我们把信息放在箱子里面之后，用钥匙锁上，再发给服务器，服务器再用自己的钥匙打开箱子，来保证信息的安全，在这个过程中，即使箱子被人拦截，因为没有钥匙，以目前的技术来讲，还是很难打开箱子的，所以一些大的网站尤其是购物网站，或者是需要登录的网站，基本都是https的。</p>
<h3 id="7-TCP怎么流量控制？怎么拥塞控制？"><a href="#7-TCP怎么流量控制？怎么拥塞控制？" class="headerlink" title="7. TCP怎么流量控制？怎么拥塞控制？"></a>7. TCP怎么流量控制？怎么拥塞控制？</h3><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>​        所谓流量控制，就是让发送端不要发送的太快，让接收端能够来得及接收。假设没有流量控制，发送端会根据实际的情况发送数据，然后接收端使用接受数据缓存区来接收数据。当发送的速度太快，导致缓存区很快被占满了，这时候发送端继续发送数据，接收端处理不过来，就会将这些还没有被接收的数据全都丢弃，这就会触发发送端的重发机制，造成网络流量的无端浪费。</p>
<p>​        所以TCP提出了流量控制机制，让发送端根据接收端的接收能力控制发送的数据量。TCP利用滑动窗口实现流量控制机制，而窗口的大小通过TCP首部的16位窗口大小字段来传输。这个窗口大小实际上指的是缓冲区中剩余的空间，发送端会根据接收端传过来的窗口大小来灵活控制发送的数据量。</p>
<p>​        具体的操作流程是：A向B发送数据，接收端在确认应答发送ACK报文时，将窗口大小填入，跟随ACK报文一起被传送给发送端，而发送端接收到窗口值后灵活改变自己的发送速度。当接收端缓冲区为0，发送端不再发送数据，直到接收端重新发送新的窗口值为止。</p>
<p>​        这里会产生一个问题：当发送零窗口后，缓冲区有了多余的缓存空间，然后接收端会向发送端发送新的窗口值，如果这个报文在发送过程中丢失了，就会进入死锁局面：即发送端一直等待接收端发送非零窗口值，接收端也一直等待发送端发送数据，如果没有其他措施，就会一直互相等待下去。</p>
<p>​        为了解决这个问题，TCP为每个连接设置一个持续计时器，只要发送端接收到零窗口通知，就会启动持续计时器，当设置的时间到了，就发送一个零窗口探测字段，这个字段仅携带一个字节的数据，当接收端确认这个探测字段时给出当前的窗口值，如果窗口仍为0，发送端会重新设置持续计时器，否则开始发送数据。</p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>​        在某段时间，若<strong>对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏</strong>，这种情况就叫做<strong>网络拥塞</strong>。若<strong>出现拥塞而不进行控制</strong>，整个网络的<strong>吞吐量将随输入负荷的增大而下降</strong>。当前网络正朝着高速化的方向发展，很容易出现缓存不够大而造成分组的丢失，分组的丢失就是网络发生拥塞的征兆。也因为网络拥塞时路由器就会丢失分组，因此只要发送方没有按时收到确认报文，也就是只要超时了，就可以猜想网络可能出现了拥塞，即判断网络拥塞的依据就是出现了超时。</p>
<p>​        TCP提供了四种网络拥塞算法：慢开始、拥塞避免、快重传、快恢复。我们先假定：</p>
<ol>
<li>数据的单向传递的，反方向只传送确认报文；</li>
<li>接收方总是有足够大的缓存空间，保证发送窗口的大小由网络拥塞的程度决定。</li>
</ol>
<h5 id="1-慢开始算法"><a href="#1-慢开始算法" class="headerlink" title="1. 慢开始算法"></a>1. 慢开始算法</h5><p>​        慢开始算法的思路是由小到大逐渐增大拥塞窗口（cwnd）的数值。下面使用报文段的个数作为窗口大小的单位，具体说明一个简单的慢开始算法的过程。</p>
<p>​        一开始发送方先设置 <code>cwnd=1</code>，发送第一个报文段M1，接收方收到后确认M1；发送方收到对M1的确认后，cwnd增大到2，于是发送方接着发送M2、M3两个报文段，接收方收到后发回对M2、M3的确认。以此类推，发送方每收到一个对新报文段的确认就会给cwnd增加1，因此发送方收到两个确认后将cwnd从2增加到4，并可发送M4~M7四个报文段。每经过一个传输轮次，拥塞窗口cwnd就会加倍。一个传输轮次经历的时间指的就是往返时间。当然实际运行中是不需要等这个轮次中所有的确认都受到才能发送新的报文段的。</p>
<h5 id="2-拥塞避免算法"><a href="#2-拥塞避免算法" class="headerlink" title="2. 拥塞避免算法"></a>2. 拥塞避免算法</h5><p>​        为了防止拥塞窗口增长过大引起网络拥塞，设置一个慢开始门限值，当cwnd小于这个值就使用慢开始算法，大于这个值就使用拥塞避免算法，等于这个值两个算法都可以用。</p>
<p>​        拥塞避免算法的思路是线性加一，也就是每经过一个传输轮次才会给cwnd加一。相比于慢开始算法的倍数递增，拥塞避免算法的线性递增使网络比较不容易出现拥塞。假设cwnd到16开始执行拥塞避免算法，直到cwnd&#x3D;24，出现了超时的现象，发送方判断出现网络拥塞，于是调整门限值为当前cwnd的一半，并设置cwnd为1，执行慢开始算法。</p>
<h5 id="3-快重传算法"><a href="#3-快重传算法" class="headerlink" title="3. 快重传算法"></a>3. 快重传算法</h5><p>​        有时，个别报文段在网络丢失，但实际上并没有发生网络拥塞，如果发送方迟迟没有收到确认就会产生超时，就会被误认为发生了拥塞。就会导致发送方错误的开启慢开始算法，把拥塞窗口置1，因而降低了传输的效率。</p>
<p>​        快重传可以让发送方尽早知道发生个别报文段的丢失。下面简单说明一下过程：发送方发送M1，接收方接收到M1后发回对M1的确认，在收到M1的确认前，发送方可以将M2发送出去，接收方接收到M2后确认M2，在M2的确认到达之前发送方可以发送M3。假设发送M3的报文丢失，接收方就不会发送M3的确认报文给发送方，此时发送方发送M4，接收方收到后发现不是按序到达的报文段M3，就会发回给发送方M2的重复确认，表明现在希望收到的是M3，而不是未按序到达的报文段，发送方还可以将M5发送，接收方收到后发现不是M3，又会发回M2的重复确认，发送方还可以将发送窗口的最后一个报文段M6发送，然后接收方又发回一个M2的重复确认。此时，发送方已经收到累计3个M2的重复确认，快重传算法规定，发送方只要一连收到3个重复确认，就要立刻重传，因此发送方会立刻重传M3，接收方收到后发回M6的确认，表明到M6为止的报文都收到了，这样就不会出现超时。</p>
<h5 id="4-快恢复算法"><a href="#4-快恢复算法" class="headerlink" title="4. 快恢复算法"></a>4. 快恢复算法</h5><p>​        发送方知道现在只是丢失了个别报文段，于是不启动慢开始算法，而是快恢复算法。也就是将门限值和cwnd都设置为当前cwnd的一半，并开始执行拥塞避免算法。有的快恢复实现会将cwnd在扩大一些，比如上面的例子就扩大了3个报文段的长度。因为发送方既然收到三个重复确认，就表示已经有三个分组离开了网络，不再消耗网络资源而是停留在接收方的缓存中，可见现在网络病逝堆积了分组而是减少了三个分组，因此可以适当把拥塞窗口扩大一些。</p>
<p>​        拥塞避免阶段，cwnd线性增大，被称为加法增大AI，快恢复阶段设置门限值为当前cwnd的一半，被称为乘法减小MD，二者合在一起就是所谓的<strong>AIMD算法</strong>。</p>
<h3 id="8-三次握手（建立TCP的链接）、四次挥手（释放TCP的链接）"><a href="#8-三次握手（建立TCP的链接）、四次挥手（释放TCP的链接）" class="headerlink" title="8. 三次握手（建立TCP的链接）、四次挥手（释放TCP的链接）"></a>8. 三次握手（建立TCP的链接）、四次挥手（释放TCP的链接）</h3><p>建立TCP需要三次握手才能建立，而断开连接则需要四次握手。</p>
<h4 id="三次握手："><a href="#三次握手：" class="headerlink" title="三次握手："></a>三次握手：</h4><p>第一次握手，主机A通过向主机B发送一个含有同步序列号的标志位的数据段给主机B，向主机B请求建立连接，通过这个数据段，主机A对主机B说：我想与你通信，你可以用哪个序列号作为其实数据段来回应我；<br>第二次握手，主机B收到主机A的请求后，用一个带有确认应答（ACK）和同步序列号（SYN）标志位的数据段响应主机A，也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用这个序列号作为起始数据段来回应我；<br>第三次握手，主机A收到这个数据段后，再发送一个确认应答，确认已收到主机B的数据段：”我已收到回复，我现在要开始传输实际数据了。</p>
<h4 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h4><p>第一次： 当主机A完成数据传输后,将控制位FIN置1，提出停止TCP连接的请求；<br>第二次： 主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将关闭,将ACK置1；<br>第三次： 由B 端再提出反方向的关闭请求,将FIN置1 ；<br>第四次： 主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束。</p>
<h3 id="9-事实表与维度表？事实表有哪些种类？"><a href="#9-事实表与维度表？事实表有哪些种类？" class="headerlink" title="9. 事实表与维度表？事实表有哪些种类？"></a>9. 事实表与维度表？事实表有哪些种类？</h3><p>维度表一般是对事实的描述信息，一张维表对应了现实世界的一个对象或概念。维表的特征是范围广、内容相对固定。比如地域维表就包含省份名称、省份编码、地市编码等。</p>
<p>事实表的每行数据都代表了一个业务事件，如下单、退款等。事实表的特征是内容相对较窄、数据量会很大、内容更新频繁。</p>
<p>事实表包括事务型事实表、周期型快照事实表和累积型快照事实表。</p>
<ol>
<li>事务型事实表以每个事务或时间为单位，比如一条销售记录、订单记录等，数据被提交就不能再被更改，更新方式为增量更新；</li>
<li>周期快照事实表存储固定时间间隔的 数据，例如每天或每月的销售额；</li>
<li>累积型快照事实表存储不确定周期的数据，会完全覆盖一个事务或产品的生命周期，通常具有多个日期字段，用来记录整个生命周期中的关键时间点。在加载完数据后依然可以更新数据，来补充之后才能知道的信息。比如存储购物交货的信息，一般会有购买日期、预定交货日期、实际发货日期等，其中实际发货日期是不能马上确定的，可以用表示未知的代理关键字代替，直到能够确定结果。</li>
</ol>
<h3 id="10-操作系统死锁？死锁条件？怎么破坏？"><a href="#10-操作系统死锁？死锁条件？怎么破坏？" class="headerlink" title="10. 操作系统死锁？死锁条件？怎么破坏？"></a>10. 操作系统死锁？死锁条件？怎么破坏？</h3><h4 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h4><p>当有两个或两个以上的进程运行时，因为争夺资源而导致互相等待，如果没有外力作用，这些进程无法继续推进下去，就会导致斯通出现死锁状态。</p>
<h3 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h3><p>有四个。</p>
<ol>
<li>互斥条件：只有对必须互斥使用的资源的争夺才会产生死锁；</li>
<li>不剥夺条件：当一个进程占用资源的时候，其他进程不能强行剥夺，只能主动释放；</li>
<li>请求和保持条件：一个进程占用一个资源，同时它想请求另一个资源，这个资源正被其他进程占用，这个进程无法成功获得这个资源，但是也不会释放已经占用的资源；</li>
<li>循环等待条件：存在一种进程资源的循环等待链，其中的每一个进程都占有下一个进程所需的资源。</li>
</ol>
<h4 id="破坏死锁的条件"><a href="#破坏死锁的条件" class="headerlink" title="破坏死锁的条件"></a>破坏死锁的条件</h4><ol>
<li>想要破坏互斥条件，可以将互斥资源转换为共享资源，但是不是所有的资源都能共享使用，在更多情况下还需要保证这些资源的互斥性；</li>
<li>想要破坏不剥夺条件，有两种方式，第一种是如果进程无法成功获取资源，它要立刻释放自己所持有的所有资源；第二种是当进程想要请求的资源被其他进程占用，操作系统可以帮助这个进程强行剥夺这个资源。这两种方式实现起来会比较复杂，而且释放已经占有的进程可能会导致之前的工作运行失败，频繁的获取和释放资源也会造成很大的系统开销；</li>
<li>想要破坏请求和保持条件，可以使用静态分配的方式，在进程执行之前给他分配好所有需要的资源，这样在整个程序运行的期间都不需要再获取资源了。但是如果进程的整个生命周期很长，但是对某些资源只使用很短的一段时间，那么很容易造成资源的浪费；</li>
<li>想要破坏循环等待条件，可以使用顺序分配法，也就是给每个资源分配编号，让所有进程按照编号递增的顺序来获取资源。但是这种方式如果想要新增资源就需要重新分配编号，并且无法保证进程使用资源的顺序会与编号的顺序一致，也很容易导致资源的浪费。</li>
</ol>
<h3 id="11-telnet的默认端口号"><a href="#11-telnet的默认端口号" class="headerlink" title="11. telnet的默认端口号"></a>11. telnet的默认端口号</h3><p>23，可以通过使用 netstat -a -n来查看。</p>
<h2 id="一些面经-中兴"><a href="#一些面经-中兴" class="headerlink" title="一些面经 - 中兴"></a>一些面经 - 中兴</h2><p><a href="https://www.nowcoder.com/discuss/660801?type=2&order=0&pos=2&page=1&source_id=discuss_tag_nctrack&channel=-1&ncTraceId=44b95a713e9442b19e190965da36ad9c.406.16434563011824714&gio_id=E30D9748681AD7BB6D8E8BBBB13EBA9E-1643456301844">中兴 java岗 社招 面筋</a></p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>linux</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 面试题</title>
    <url>/2021/11/15/Java-%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1-Java语言的特点"><a href="#1-Java语言的特点" class="headerlink" title="1. Java语言的特点"></a>1. Java语言的特点</h2><p>Java语言的主要特点有：</p>
<span id="more"></span>

<ol>
<li>面向对象：Java是一门面向对象的高级编程语言，所谓的面向对象实际上是一种思考的模式，通过模拟现实世界来解决现实问题。</li>
<li>简单性：首先Java具有自动内存管理机制，比如c语言中会有析构函数如delete、free等，在内存使用完毕需要手动去释放内存，但是Java语言在内存使用完成后就不用再管，内存会被自动回收，这样不容易造成内存溢出；其次，Java借鉴了一些老牌编程语言的特性，简化了流程的处理，同时也简化了Java过程中的语义，比如goto这些在Java中就被顶替掉了，通过其他的方式在语义清晰的情况下达到原有的目的。</li>
<li>跨平台：指的是软件可以在任意计算机环境中正常运行，而不需要考虑计算机硬件和操作系统的约束，实现了Java一次编译到处运行的目标。因为Java会将源码编译为字节码，字节码是无关平台的，任意平台上的JVM都会向Java编译器提供一个相同的接口用来获取字节码，所以Java语言是具有跨平台性的。</li>
</ol>
<p>​        具体说到字节码，就肯定要先知道机器码。我们当前使用的大部分语言都是高级语言，而这些语言使用的源码，都由英文和符号组成，这种代码是无法被计算机直接识别的，我们需要将其翻译为机器码交由计算机执行。翻译的过程有两种形式：编译和解释。编译指的是在程序运行前，将源码全部翻译为机器码，再交由计算机执行；解释指的是在程序运行时，将代码解释一行，交由计算机执行一行。编译的好处是执行的效率会很高，但是由于不同计算机的机器码不同，所以可以执行很低，面对不同的计算机，就需要重新编译源代码，甚至额能要修改部分源码；而解释的效率会比较低，但是可移植性高，不同计算机的解释器和机器码是一致的，所以只需要使用一份源码交给不同的解释器执行就可以。<br>​        而Java语言使用先编译后解释的方式，其中就引出了字节码。Java语言先将源码编译为字节码文件，然后将字节码提交给计算机，在程序运行时解释i解码文件。因为字节码也是二进制文件，与机器码很像，所以从字节码转换为机器码就会更快一点。综上，Java语言相较于纯的编译型语言，可移植性更高，相较于解释型语言，解释的效率也会更高。</p>
<hr>
<h3 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h3><h3 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h3><p>就是分析出系统中应包含哪些对象，以及它们之间的关系，再用特定的语法来描述这些对象和关系。</p>
<p>比如，使用面向对象的思想来说一下上课的过程。有电瓶车和司机，司机开电瓶车，我要坐电瓶车去上课，然后有学生，上课的点有许多学生要上车，还有教学楼，乘车到目的的教学楼然后下车前往教室上课。</p>
<h2 id="2-面向对象的三大特征"><a href="#2-面向对象的三大特征" class="headerlink" title="2. 面向对象的三大特征"></a>2. 面向对象的三大特征</h2><p>三大特征为：封装、继承、多态。</p>
<ol>
<li>封装：指属性私有化，隐藏具体实现的细节，仅提供setter和getter方法来访问属性，用于提高数据安全性，类和方法也属于封装；</li>
<li>继承：指将多个相同的属性和方法提取出来，新建为一个父类，子类可以重写其中的方法，用于代码复用；</li>
<li>多态：分为两种，编译时多态和运行时多态，编译时多态即重载，方法名相同而参数不同；运行时多态即重写，子类重写父类方法，用于增强代码的灵活度。</li>
</ol>
<h2 id="3-数据结构相关"><a href="#3-数据结构相关" class="headerlink" title="3. 数据结构相关"></a>3. 数据结构相关</h2><h3 id="常见的8种数据结构"><a href="#常见的8种数据结构" class="headerlink" title="常见的8种数据结构"></a>常见的8种数据结构</h3><h4 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组 Array"></a>数组 Array</h4><p>数组在内存中使用连续空间存储，因为使用下标定位元素，所以查询和遍历都很方便，缺点是创建之后无法扩容，只能存储一种类型的元素，插入和删除元素比较耗时。</p>
<h4 id="链表-Linked-List（ArrayList的底层是数组，本身不属于数据结构）"><a href="#链表-Linked-List（ArrayList的底层是数组，本身不属于数据结构）" class="headerlink" title="链表 Linked List（ArrayList的底层是数组，本身不属于数据结构）"></a>链表 Linked List（ArrayList的底层是数组，本身不属于数据结构）</h4><p>包含单向链表和双向链表，和数组相比，在内存中不需要连续的空间存储，只需要每个节点能够记录下一个节点的引用，就可以通过指针查找下一个节点。所以对链表进行插入和删除的时间复杂度都是O(1)的，不需要确定容量大小，可以添加任何类型的元素。缺点是大量的引用会占用大量的堆空间，执行查找需要遍历整个链表。</p>
<h4 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈 Stack"></a>栈 Stack</h4><p>依据先进后出的原则存储数据。</p>
<h4 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h4><p>依据先进先出的原则存储数据。</p>
<h4 id="树"><a href="#树" class="headerlink" title="树"></a>树</h4><p>是有限个节点组成的具有层次关系的集合，每个节点有有限个子节点或没有子节点，有且仅有一个没有父节点的节点，叫根节点，每个非根节点只有一个父节点。可以使用链表或数组来存储。常见的就是二叉树，最多只有两个子节点。</p>
<p>二叉树中特殊的，包括满二叉树，叶子节点都在最底层；完全二叉树，叶子节点都在最底的两层，且最底层的叶子节点都在左侧；平衡二叉树，左右子树的高度差不超过1；二叉查找树，左子节点的值不会大于当前节点，右子节点的值不会小于当前节点。</p>
<p>其中，平衡二叉树因为要保证左右子树的高度差不超过1，经常需要通过左旋或右旋的方式保持平衡。</p>
<p>B树和B+树也比较常见，可以看成是平衡二叉树的矮胖版本。</p>
<h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>可以看成是存储结构为数组的完全二叉树，每个节点的值都不大于或不小于它的父节点。根节点最大的堆叫大根堆，根节点最小的堆叫小根堆。</p>
<h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><p>是复杂的非线性结构，由顶点和边组成，节点之间的关系是任意的。这个数据结构没有使用过。</p>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>使用键值对的形式存储数据，可以快速的实现元素的查找、插入和删除。</p>
<h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>常见的算法包括快速排序、归并排序、堆排序、冒泡排序、深度优先遍历、广度优先遍历、动态规划、二分查找、贪心法等。</p>
<h2 id="4-设计模式相关"><a href="#4-设计模式相关" class="headerlink" title="4. 设计模式相关"></a>4. 设计模式相关</h2><h3 id="设计模式的原则"><a href="#设计模式的原则" class="headerlink" title="设计模式的原则"></a>设计模式的原则</h3><ol>
<li><p>单一原则：</p>
<p>​    即一个类只有一个职责；</p>
</li>
<li><p>开闭原则：</p>
<p>​    软件实体可扩展，但不可修改。</p>
<p>​    就好比“一国两制”，一个国家有两种制度，没有修改原有的管理制度，而是增加了一种新的制度。对于扩展是开放的，对于更改是封闭的。</p>
</li>
<li><p>里氏代换原则：</p>
<p>​    子类型必须能够替换掉它们的父类型。</p>
<p>​    举个例子，假如现在父类是鸟类，有个属性是可以飞，子类有个企鹅类，那么很明显企鹅类不能继承鸟类，因为鸟类有会飞的属性，如果子类企鹅类继承父类鸟类，则企鹅必须会飞。</p>
</li>
<li><p>依赖倒置原则：</p>
<p>​    针对接口编程，不要针对实现编程。</p>
<p>​    举个例子，就好比你的电脑，如果CPU、内存、硬盘都需要依赖具体的主板，主板坏了，所有的部件都不能用了，这显然是不合理的。</p>
<p>​    换句话说，即谁也不要依赖谁，除了约定的接口，大家都可以灵活自如。</p>
</li>
<li><p>接口隔离原则：</p>
<p>​    应该使用多个专门的接口，而不使用单一的总接口。</p>
<p>​    比如有一个学生成绩管理程序，包含插入成绩、删除成绩、修改成绩、打印成绩等功能，这些功能全都放到一个统一的接口中显然是不合理的，正确的作法应该是分为输入、打印等模块进行处理。</p>
</li>
<li><p>迪米特原则：</p>
<p>​    尽量减少对象之间的交互，可以引入一个合理的第三方来降低现有对象之间的耦合度。</p>
<p>​    比如体育老师上课前清点人数，他让体育委员来替他清点人数，之后再由体育委员告知结果即可，老师本身并没有接触到其他学生。</p>
</li>
<li><p>合成&#x2F;聚合复用原则</p>
<p>​    尽量使用合成&#x2F;聚合，尽量不要使用类继承。</p>
<p>​    合成表示一种强的“拥有”关系，体现了严格的部分与整体的关系，他们的生命周期相同；而聚合表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。</p>
<p>​    这里再举个简单的例子，大雁与翅膀是合成关系；而每只大雁都属于一个雁群，即一个雁群可以有多只大雁，所以大雁和雁群是聚合关系。</p>
</li>
</ol>
<h3 id="（1）-单例模式"><a href="#（1）-单例模式" class="headerlink" title="（1） 单例模式"></a>（1） 单例模式</h3><p>使用单一的类创建对象，它只有一个实例，必须自己创建。</p>
<p>懒汉式 - 线程不安全：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton Instance;</span><br><span class="line">    <span class="comment">//私有构造方法，保证外界无法直接实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">if</span>( Instance == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            Tnstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式延迟实例化，好处是没有用到该类，就不会实例化Instance，从而节约资源；坏处是线程不安全，多线程情况下会多次创建实例。</p>
<p>懒汉式 - 线程安全：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton Instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( Instance == <span class="keyword">null</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            Instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对静态代码 <code>getInstance()</code> 加锁，以确保多线程环境下只会创建一个实例。</p>
<p>饿汉式 - 线程安全：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Singleton Instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接实例化，不会产生线程不安全的问题，但是这也丢失了延迟实例化带来的节约资源的好处。</p>
<p>双重校验锁 - 线程安全：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton Instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( Instance == <span class="keyword">null</span> )<span class="comment">//为了提高代码执行效率，如果已经创建了实例就不需要再竞争锁了。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>( Singleton.class )<span class="comment">// 类锁，表示只能进入一个实例</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>( Instance == <span class="keyword">null</span> )<span class="comment">//防止二次创建实例</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>内存中只有一个实例，减少了内存开支。</li>
<li>避免对资源的多重占用，比如写文件操作，只有一个实例时，避免对同一个资源文件同时写操作。</li>
</ul>
<p>缺点：</p>
<ul>
<li>没有接口，不能继承，与单一职责冲突。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>应用程序的日志应用一般使用单例模式实现，因为共享的日志文件一般会一直处于打开状态，所以只能有一个实例取操作，否则内容不好追加；</li>
<li>操作系统的文件系统也是使用单例模式操作的，因为一个操作系统只能有一个文件系统。</li>
</ul>
<h4 id="此处可能会询问volatile的好处"><a href="#此处可能会询问volatile的好处" class="headerlink" title="此处可能会询问volatile的好处"></a>此处可能会询问volatile的好处</h4><p>​        Instance 采用 volatile 关键字修饰也是很有必要的， <code>Instance = new Singleton();</code> 这段代码其实是分为三步执行：分配内存、初始化、指向分配的地址。由于JVM具有指令重排的特性，执行顺序可能会改变，指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 抢占了 T1 的资源，调用 geteInstance() 后发现 Instance 不为空，因此返回 Instance，但此时 Instance 还未被初始化。</p>
<p>​        使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<h3 id="（2）工厂模式"><a href="#（2）工厂模式" class="headerlink" title="（2）工厂模式"></a>（2）工厂模式</h3><p>工厂模式的用意是定义一个创建产品对象的工厂接口，将实际创建性工作推迟到子类中。工厂模式可分为简单工厂、工厂方法和抽象工厂模式。</p>
<ol>
<li><p>简单工厂</p>
<p>简单工厂的实现思路是，定义一个工厂类，根据传入的参数不同返回不同的实例，被创建的实例具有共同的父类或接口。简单工厂的适用场景是：</p>
<ul>
<li>需要创建的对象较少。</li>
<li>客户端不关心对象的创建过程。</li>
</ul>
<p><strong>实例：</strong></p>
<p>创建一个可以绘制不同形状的绘图工具，可以绘制圆形，正方形，三角形，每个图形都会有一个draw()方法用于绘图。</p>
<p>由题可知圆形，正方形，三角形都属于一种图形，并且都具有draw方法，所以首先可以定义一个接口或者抽象类，作为这三个图像的公共父类，并在其中声明一个公共的draw方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承公共父类，编写具体图形：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//圆形</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">circleShape</span> <span class="keyword">implements</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">circleShape</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CircleShape:created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw: circleShape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正方形</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RectShape</span> <span class="keyword">implements</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RectShape</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RectShape: created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw: rectShape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//三角形</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">triangleShape</span> <span class="keyword">implements</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TriangleShape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TriangleShape: created&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw: TriangleShape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是工厂类的具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">shapeFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title">getShape</span><span class="params">( String type )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Shape shape = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>( type.equalsIgnoreCase( <span class="string">&quot;circle&quot;</span> ) )</span><br><span class="line">        &#123;</span><br><span class="line">            shape = <span class="keyword">new</span> circleShape();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( type.equalsIgnoreCase( <span class="string">&quot;rect&quot;</span> ) )</span><br><span class="line">        &#123;</span><br><span class="line">            shape = <span class="keyword">new</span> rectShape();</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            shape = <span class="keyword">new</span> triangleShape();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shape;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>工厂方法</p>
<p>工厂方法模式是简单工厂的进一步深化， 在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说每个对象都有一个与之对应的工厂。</p>
<p>工厂方法的实现思路是，定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。</p>
<p><strong>实例：</strong></p>
<p>以简单工厂的实例来实现工厂方法模式：</p>
<p>首先编写一个公共的接口来draw：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为每个图形实现 draw() 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">circleShape</span> <span class="keyword">implements</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw: circleShape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">rectShape</span> <span class="keyword">implements</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw: rectShape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">triangleShape</span> <span class="keyword">implements</span> <span class="title">Shape</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;draw: triangleShape&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着定义一个抽象的工厂接口shapeFactory：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">shapeFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">Shape <span class="title">getShape</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getShape()</code> 方法用于返回shape类，每个</p>
</li>
<li><p>抽象工厂</p>
<p>​    工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。</p>
</li>
</ol>
<h3 id="（3）观察者模式"><a href="#（3）观察者模式" class="headerlink" title="（3）观察者模式"></a>（3）观察者模式</h3><p>观察者模式很好理解，类似于订阅模式，属于行为型模式的一种，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p>
<p>在观察者模式中有如下角色：</p>
<ol>
<li>Subject：抽象主题（抽象被观察者），定义增删观察者接口和通知观察者更新的接口。</li>
<li>ConcreteSubject：具体主题（具体被观察者），创建存储观察者的集合，并实现抽象主题的内容。</li>
<li>Observer：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li>
<li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li>
</ol>
<p>这种发布-订阅的形式我们可以拿微信公众号来举例，假设微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了这个公众号，当这个公众号更新时就会通知这些订阅的微信用户。</p>
<p>具体实例如下：</p>
<ol>
<li>抽象观察者：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>具体观察者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeixinUser</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 微信用户名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeixinUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;-&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>抽象主题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加订阅者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除订阅者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知订阅者更新消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体主题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriptionSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">//储存订阅公众号的微信用户</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;WeixinUser&gt; weixinUserlist = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(WeixinUser u)</span> </span>&#123;</span><br><span class="line">        weixinUserlist.add(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(WeixinUser u)</span> </span>&#123;</span><br><span class="line">        weixinUserlist.remove(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (WeixinUser u : weixinUserlist) &#123;</span><br><span class="line">            u.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SubscriptSubject sub = <span class="keyword">new</span> SubscriptSubject();</span><br><span class="line">        WechatUser a = <span class="keyword">new</span> WechatUser(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        WechatUser b = <span class="keyword">new</span> WechatUser(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">        sub.attach(a);</span><br><span class="line">        sub.attach(b);</span><br><span class="line">        sub.notify(<span class="string">&quot;你们订阅的内容更新了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">杨影枫-刘望舒的专栏更新了</span><br><span class="line">月眉儿-刘望舒的专栏更新了</span><br><span class="line">紫轩-刘望舒的专栏更新了</span><br></pre></td></tr></table></figure></li>
</ol>
<p>优点：</p>
<ul>
<li>观察者和被观察者是抽象耦合的</li>
<li>建立了一套触发机制</li>
</ul>
<p>缺点：</p>
<ul>
<li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间</li>
<li>如果观察者和观察目标间有循环依赖，可能导致系统崩溃</li>
<li>没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的</li>
</ul>
<p>使用场景：</p>
<ul>
<li>关联行为场景</li>
<li>事件多级触发场景</li>
<li>跨系统的消息变换场景，如消息队列的处理机制</li>
</ul>
<h3 id="（4）装饰模式"><a href="#（4）装饰模式" class="headerlink" title="（4）装饰模式"></a>（4）装饰模式</h3><p>定义：动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。</p>
<p>下面以一个例子来简单说明：</p>
<p>比如我买了一个机器人，它本身有一个对话的功能。我希望它能在此基础上还能帮我扫地。有两种方式实现：</p>
<ol>
<li>第一种方式，可以打电话给厂家，让他们可以研制新的产品，在第一代产品的基础上加两条胳膊，扩展这个功能；</li>
<li>第二种方式是直接给第一代产品加一个箱子，在这个箱子上面加两条胳膊，这样它也拥有了扫地的功能，这种方式更为灵活，不需要去重新研发设计。</li>
</ol>
<p>上述这两种方式都可以实现给一个类或对象增加新的功能，第一种是继承机制，就是继承一个现有的类，然后在子类进行扩展功能；第二种被称为关联机制，是把一个类的对象嵌入到另一个类的对象中，相当于把机器人嵌入到箱子中，给它套一个壳子，扩展出扫地的功能，这个壳子就是装饰器，第二种方式也被称为装饰器模式。</p>
<p>在开发过程中，这两种方式都经常被使用，他们主要的区别在于：对于继承模式来说，这种方式是静态的，一定要实现一个新的子类来对类层级进行扩展；装饰器模式是动态的，我们拿到一个对象就可以对其进行扩展，不需要修改原有类逻辑。</p>
<p>下面使用代码来实现上述例子：</p>
<ol>
<li><p>创建抽象组件，代表被装饰的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建组件实现类，实现第一代机器人：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">firstRobot</span> <span class="keyword">implements</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建装饰器对第一代机器人扩展：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">robotDecorator</span> <span class="keyword">implements</span> <span class="title">Robot</span> </span>&#123;</span><br><span class="line">    <span class="comment">//因为要关联使用机器人，所有要定义一个机器人对象</span></span><br><span class="line">    <span class="keyword">private</span> Robot robot;</span><br><span class="line">    <span class="comment">//接着要传这个对象进来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">robotDecorator</span><span class="params">(Robot robot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.robot = robot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接着实现机器人该有的方法，使用机器人对象实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        robot.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//需要扩展功能，新加扫地的功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doMorething</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        robot.doSomething();</span><br><span class="line">        System.out.println(<span class="string">&quot;扫地&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> robotDecorator(<span class="keyword">new</span> firstRobot()).doMorething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对话</span><br><span class="line">扫地</span><br></pre></td></tr></table></figure></li>
</ol>
<p>优点：</p>
<ul>
<li>装饰类和被装饰类可以独立发展，而不会相互耦合。它有效地把类的核心职责和装饰功能分开了</li>
<li>装饰模式是继承关系的一个替代方案</li>
<li>装饰模式可以动态地扩展一个实现类的功能</li>
</ul>
<p>缺点：</p>
<p>多层装饰比较复杂。比如我们现在有很多层装饰，出了问题，就需要一层一层检查，工作量很大。</p>
<p>使用场景：</p>
<ul>
<li>需要扩展一个类的功能时</li>
<li>需要动态地给一个对象增加功能，并可以动态地撤销时</li>
<li>需要为一批的兄弟类进行改装或加装功能时</li>
</ul>
<h3 id="（5）代理模式"><a href="#（5）代理模式" class="headerlink" title="（5）代理模式"></a>（5）代理模式</h3><p>代理模式就是为其他对象提供一种代理以控制对这个对象的访问。常见的例子就是Windows的快捷方式，通过快捷方式，我们可以访问某个文件夹下的exe文件，这就是一个典型的代理模式，它将接口提供了出来，我们只需点击快捷方式，它会帮我们运行指定目录下的指定程序。</p>
<p>包括如下角色：</p>
<ul>
<li>Subject是抽象主题角色，定义了RealSubject和Proxy的共同接口，即应该提供什么服务；</li>
<li>RealSubject是具体主题角色，定义了Proxy所代表的真实实体；</li>
<li>Proxy为代理主题角色，保存对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ul>
<p>例子：购买机票不一定要去机场买，可以在相关的代售软件上购买。这里的软件就是代理角色。</p>
<p>下面具体实现这个例子：</p>
<ol>
<li><p>定义公共接口，实现购票方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现具体主题角色，也就是机场：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">realSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;机场买机票&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现代理角色，也就是购票网站：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">proxySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> realSubject subject;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxySubject</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        subject = <span class="keyword">new</span> realSubject();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;购票网站购买机票&quot;</span>);</span><br><span class="line">        subject.buyTicket();</span><br><span class="line">        System.out.println(<span class="string">&quot;成功购买&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> proxySubject().buyTicket();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">购票网站购买机票</span><br><span class="line">机场买机票</span><br><span class="line">成功购买</span><br></pre></td></tr></table></figure></li>
</ol>
<p>从上述代码中可以看出，代理模式和装饰器模式很像，二者的区别是：装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类（proxy class）可以对它的客户隐藏真实对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建真实对象的实例；当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。</p>
<p>优点：</p>
<ul>
<li>职责清晰。真实的角色就是实现实际的业务逻辑，不用担心其他非本职责的事务</li>
<li>高扩展性。代理类完全可以在不做任何修改的情况下使用</li>
<li>智能化。比如动态代理，动态代理就是使用反射机制在运行时创建代理类</li>
</ul>
<p>缺点：</p>
<ul>
<li>有些类型的代理模式可能会造成请求的处理速度变慢</li>
<li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂</li>
</ul>
<p>使用场景：</p>
<ul>
<li>远程代理。为一个对象在不同的地址空间提供局部代表</li>
<li>虚拟代理。根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象</li>
<li>安全代理。用来控制真实对象访问时的权限</li>
<li>智能指引，当调用真实的对象时，代理处理另外一些事</li>
</ul>
<h4 id="扩展：静态代理和动态代理"><a href="#扩展：静态代理和动态代理" class="headerlink" title="扩展：静态代理和动态代理"></a>扩展：静态代理和动态代理</h4><p>代理模式分为静态代理和动态代理。上述例子实现的是静态代理，下面使用动态代理实现上面的例子：</p>
<p>动态代理是通过实现反射机制下的 <code>InvocationHandler</code> 接口来创建自己的调用处理器。</p>
<ol>
<li><p>实现抽象接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现具体主题角色，也就是机场：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">realSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;机场买机票&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现 InvocationHandler 接口创建一个针对这个具体角色的动态代理调用处理程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">proxySubjectHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    realSubject subject = <span class="keyword">new</span> realSubject();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;购票网站购买机票&quot;</span>);</span><br><span class="line">        Object res = method.invoke(subject, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;成功购买&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Subject <span class="title">getProxyInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Subject)Proxy.newProxyInstance(subject.getClass().getClassLoader(), subject.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        proxySubjectHandler subject = <span class="keyword">new</span> proxySubjectHandler();</span><br><span class="line">        subject.getProxyInstance().buyTicket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">购票网站购买机票</span><br><span class="line">机场买机票</span><br><span class="line">成功购买</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="InvocationHandler-和-Proxy"><a href="#InvocationHandler-和-Proxy" class="headerlink" title="InvocationHandler 和 Proxy"></a>InvocationHandler 和 Proxy</h4><p>InvocationHandler是动态代理类的调用处理程序必须实现的接口。</p>
<p>​        从 <code>Proxy.newProxyInstance</code> 开始方法看，它用来创建一个代理类对象，接收三个参数：具体主题角色的类加载器、具体主题角色实现的所有接口、以及需要关联到的 InvocationHandler 对象实例，也就是上述例子中的 <code>proxySubjectHandler</code> 这个类的实例，如果是在这个类中执行的这个方法，可以使用 <code>this</code> 来表示这个类的实例。</p>
<p>​        这个方法返回的就是一个代理角色，通过这个代理角色调用方法，会被转发到实现 InvocationHandler接口的类的 invoke 方法中调用。</p>
<h2 id="5-集合相关"><a href="#5-集合相关" class="headerlink" title="5. 集合相关"></a>5. 集合相关</h2><p>常用的集合包括两个接口：Collection和Map，Collection又包括List和Set。</p>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>元素按插入顺序有序保存，可以重复。</p>
<p>包含ArrayList、LinkedList、Vector。三者都用于处理可变长数组，可以存储任何类型的元素，ArrayList与Vector的结构大致相同，底层都由数组实现，不同的是，Vector使用synchronized关键字，是线程安全的，ArrayList是线程不安全的，默认在单一线程下运行；LinkedList的底层是双向链表，线程不安全。</p>
<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>内部是无序的，元素不可重复。</p>
<p>包含HashSet、LinkedHashSet、TreeSet。</p>
<h2 id="2-JDK、JRE和JVM的区别和联系"><a href="#2-JDK、JRE和JVM的区别和联系" class="headerlink" title="2. JDK、JRE和JVM的区别和联系"></a>2. JDK、JRE和JVM的区别和联系</h2><p>​        JDK是Java标准开发包，包括编译以及运行Java程序所需的各种工具和资源，比如Java编译器、Java运行时环境、常用的Java类库等。</p>
<p>​        JRE是Java运行时环境，用于解释和执行字节码文件，普通用户只需要运行Java程序安装JRE就好，如果要编译和调试程序需要安装JDK。</p>
<p>​        JVM即Java虚拟机，是JRE的一部分，是Java跨平台最核心的部分，用于解释和执行字节码文件。所有平台的JVM虚拟机都向Java编译器提供一个相同的接口，Java编译器只需要面向JVM，生成虚拟机能够识别的字节码，就可以实现跨平台运行。</p>
<h2 id="3-类和对象"><a href="#3-类和对象" class="headerlink" title="3. 类和对象"></a>3. 类和对象</h2><p>类可以相当于设计图，用于描述一批对象的信息，它是抽象的，不是具体的实例；</p>
<p>对象是具体的，是根据类的描述，由JVM创建出来的一个实例，这个过程叫实例化；</p>
<p>类是自定义的数据类型，通过这个类创建对象，实际上就是初始化这种类型的变量。</p>
<h2 id="5-修饰符"><a href="#5-修饰符" class="headerlink" title="5. 修饰符"></a>5. 修饰符</h2><p>分为访问修饰符和非访问修饰符。</p>
<p><strong>访问修饰符有：</strong></p>
<ol>
<li>public：对所有的类都可见；</li>
<li>protected：对同一个包可见，如果父类和子类不同包，对不同包的子类可见；</li>
<li>default：对同一个包可见；</li>
<li>private：对同一个类可见。</li>
</ol>
<p><strong>非访问修饰符有：</strong></p>
<ol>
<li>static：声明的对象初始化后不能再修改；</li>
<li>final：修饰的类不能被继承，修饰的方法不能重新定义，修饰的变量为常量；</li>
<li>synchronized：用于多线程同步；</li>
<li>abstract：用来创建抽象类和方法。</li>
</ol>
<h2 id="6-Object类的常用方法"><a href="#6-Object类的常用方法" class="headerlink" title="6. Object类的常用方法"></a>6. Object类的常用方法</h2><ol>
<li>equals() - 判断相等</li>
<li>hashCode() - 返回散列值；</li>
<li>toString() - 返回对象的字符串表示；</li>
<li>clone() - 创建并返回对象的克隆对象，一般子类会重写该方法；</li>
<li>finalized() - 当垃圾收集确定对象没有更多的引用时，由该对象的垃圾收集器调用；</li>
<li>getClass() - 返回此对象的运行时class类对象；</li>
<li>notify() - 唤醒正在此对象监视器上等待的某个线程，主要用于多线程通信，需配合wait()方法使用；</li>
<li>notifyAll() - 唤醒正在此对象监视器上等待的全部线程；</li>
<li>wait() - 导致当前线程等待，直到另一个对象调用该对象的notify() 或 notifyAll() 方法；</li>
<li>wait(long timeout) - 导致当前线程等待，直到另一个对象调用该对象的 <code>notify()</code> 或 <code>notifyAll()</code> 方法，或经过指定的timeout时间；</li>
<li>wait(long timeout, int nanos) - 导致当前线程等待，直到另一个对象调用当前对象的 <code>notify()</code> 或 <code>notifyAll()</code> 或经过指定的timeout时间或被其他线程中断当前线程。其中timeout参数是毫秒值，nanos参数是毫微秒值，二者之和用于指定超时时间。</li>
</ol>
<h2 id="7-字符型常量和字符串常量的区别"><a href="#7-字符型常量和字符串常量的区别" class="headerlink" title="7. 字符型常量和字符串常量的区别"></a>7. 字符型常量和字符串常量的区别</h2><ol>
<li>字符型用单引号，字符串用双引号；</li>
<li>字符型相当于一个ascii值，可以直接参与计算，字符串是一个地址值，代表该字符串在内存中存放的位置；</li>
<li>Java中字符型占两个字节，字符串占若干字节，其中每个字符占一个字节，字节数由其中的字符数决定。</li>
</ol>
<h2 id="8-常见的关键字"><a href="#8-常见的关键字" class="headerlink" title="8. 常见的关键字"></a>8. 常见的关键字</h2><p>private、default、public、protected、static初始化后不再更改、this表示当前类的对象引用、final避免重写等。</p>
<h2 id="9-标识符和关键字的区别"><a href="#9-标识符和关键字的区别" class="headerlink" title="9. 标识符和关键字的区别"></a>9. 标识符和关键字的区别</h2><p>标识符是用户编程时创建的名称，关键字是具有特殊含义的单词。</p>
<h2 id="10-泛型和泛型擦除"><a href="#10-泛型和泛型擦除" class="headerlink" title="10. 泛型和泛型擦除"></a>10. 泛型和泛型擦除</h2><p>​        参数化类型被称为泛型，泛型允许在创建集合时指定元素的类型，则集合中只保存这种类型的元素。泛型的作用是在发生编译时，提供安全检查机制。</p>
<p>​        泛型类允许在定义接口、类、方法时声明类型形参，该类型形参在整个接口、类、方法中可以作为普通类型使用，直到声明变量、创建对象或调用方法时再动态的指定实际的参数类型。如果要定义泛型类的子类，因为此时是在使用父类了，所以必须传入实参，或者不传参。</p>
<p>​        在定义泛型的时候也可以指定类型形参的上限，如 <code>class A&lt;T extends B&gt;</code> ，该声明表示，传入的实参为类型 <code>B</code> 及其子类。</p>
<p>​        而泛型擦除是指，当把一个具有泛型信息的对象赋值给一个没有泛型的对象，就会把尖括号之间的所有泛型信息都扔掉，比如List&lt;Integer&gt; 类型会转换为 List 类型，则该 List 元素的类型就会变成该类型变量的上限。如果反过来，就是泛型转换。</p>
<h2 id="11-x3D-x3D-和-equals-的区别，以及hashCode-和-euqlas"><a href="#11-x3D-x3D-和-equals-的区别，以及hashCode-和-euqlas" class="headerlink" title="11. &#x3D;&#x3D; 和 equals() 的区别，以及hashCode() 和 euqlas()"></a>11. &#x3D;&#x3D; 和 equals() 的区别，以及hashCode() 和 euqlas()</h2><ol>
<li><p>&#x3D;&#x3D; 和 equals() 的区别：&#x3D;&#x3D;比较基本类型会判断两个值是否相同，比较引用类型会判断两个地址是否相同；equals只会判断引用类型的两个地址是否相同。</p>
</li>
<li><p>hashCode() 和 equals() 的区别和联系：</p>
<p>（1）HashCode()返回的值是一个对象在hash表中的位置，这个位置是依据特定的hash算法得到的，所以，两个不同的对象有可能有相同的hash code；<br>（2）相同的hash code，equals()返回的值不一定是true；equals返回值为true的，hash code一定相同；</p>
</li>
</ol>
<p>（3）hashcode()和equals()常被组合用于排序，在大型排序中，常会重写hashcode()和equals()方法，让具有相同hashcode的对象执行equals()方法，以提高排序的效率。</p>
<h2 id="12-基本的数据类型有哪些？自动装箱和拆箱？"><a href="#12-基本的数据类型有哪些？自动装箱和拆箱？" class="headerlink" title="12. 基本的数据类型有哪些？自动装箱和拆箱？"></a>12. 基本的数据类型有哪些？自动装箱和拆箱？</h2><ol>
<li>Java支持的数据类型有两种：基本数据类型和引用类型。</li>
</ol>
<p>（1）基本数据类型有8个：int、short、double、float、byte、char、long、boolean；</p>
<p>（2）引用类型比如 String、Integer等。</p>
<ol start="2">
<li><p>自动装箱和拆箱：</p>
<p>​        自动装箱和拆箱是基本类型和包装器类型之间的转换，比如是 <code>int</code> 和 <code>Integer</code> 之间的转换，自动装箱将 <code>int</code> 转换为 <code>Integer </code>，拆箱反之。</p>
<p>​        装箱和拆箱的实现过程是：装箱通过调用包装器的 <code>valueOf</code> 方法实现，拆箱通过调用包装器的 <code>xxxValue</code> 实现，如 <code>intValue</code> 。</p>
</li>
<li><p>引申问题①：<strong>Integer i &#x3D; new Integer(10)</strong> 和 <strong>Integer i &#x3D; 10</strong> 的区别</p>
<p>（1）第一种方式不会触发自动装箱，第二种会；</p>
<p>（2）一般情况下，第二种方式的执行效率和资源占比会比第一种方式高，但不是绝对的。</p>
</li>
<li><p>引申问题②：下面程序的输出结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer i1 = <span class="number">100</span>;</span><br><span class="line">    Integer i2 = <span class="number">100</span>;</span><br><span class="line">    Integer i3 = <span class="number">200</span>;</span><br><span class="line">    Integer i4 = <span class="number">200</span>;</span><br><span class="line">   </span><br><span class="line">    System.out.println(i1 == i2);</span><br><span class="line">    System.out.println(i3 == i4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：</p>
<blockquote>
<p>true</p>
<p>false</p>
</blockquote>
<p><strong>因为Integer的范围是：-128 ~ 127</strong> 。Integer、Short、Byte、Character、Long这几个类的 <code>valueOf</code> 是类似的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Double i1 = <span class="number">100.0</span>;</span><br><span class="line">    Double i2 = <span class="number">100.0</span>;</span><br><span class="line">    Double i3 = <span class="number">200.0</span>;</span><br><span class="line">    Double i4 = <span class="number">200.0</span>;</span><br><span class="line">   </span><br><span class="line">    System.out.println(i1 == i2);</span><br><span class="line">    System.out.println(i3 == i4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：</p>
<blockquote>
<p>false</p>
<p>false</p>
</blockquote>
<p><strong>因为在某个范围整形是有限的，而浮点数不是</strong> 。Double、Float的 <code>valueOf</code> 是类似的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Boolean i1 = <span class="keyword">false</span>;</span><br><span class="line">    Boolean i2 = <span class="keyword">false</span>;</span><br><span class="line">    Boolean i3 = <span class="keyword">true</span>;</span><br><span class="line">    Boolean i4 = <span class="keyword">true</span>;</span><br><span class="line">   </span><br><span class="line">    System.out.println(i1 == i2);</span><br><span class="line">    System.out.println(i3 == i4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：</p>
<blockquote>
<p>true</p>
<p>true</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="number">1</span>;</span><br><span class="line">    Integer b = <span class="number">2</span>;</span><br><span class="line">    Integer c = <span class="number">3</span>;</span><br><span class="line">    Long g = <span class="number">3L</span>;</span><br><span class="line">    Long h = <span class="number">2L</span>;</span><br><span class="line">   </span><br><span class="line">    System.out.println(c==(a+b)); <span class="comment">//1</span></span><br><span class="line">    System.out.println(c.equals(a+b)); <span class="comment">//2</span></span><br><span class="line">    System.out.println(g==(a+b)); <span class="comment">//3</span></span><br><span class="line">    System.out.println(g.equals(a+b)); <span class="comment">//4</span></span><br><span class="line">    System.out.println(g.equals(a+h)); <span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答：</p>
<blockquote>
<p>true<br>true<br>true<br>false<br>true</p>
</blockquote>
<p>首先我们需要知道：</p>
<p>（1）算术运算符仅对于基本数据类型，所以包装器类型进行运算的时候会自动拆箱；</p>
<p>（2）<code>equals</code> 会比较两个对象的类型和值。</p>
<p>所以可以得知 <code>1</code> 、<code>2</code> 和 <code>3</code> 都是 <code>true</code> ，<code>4</code> 因为 <code>Integer</code> 和 <code>Long</code> 类型不同所以是 <code>false</code>，<code>5</code> 因为 <code>h</code> 是 <code>Long</code> 类型，<code>Long</code> 比 <code>Integer</code> 的范围广泛，所以相加后自动装箱会转换为 <code>Long</code> ，之后比较值是相等的，所以是相等的。</p>
</li>
</ol>
<h2 id="13-重载和重写？深拷贝和浅拷贝？"><a href="#13-重载和重写？深拷贝和浅拷贝？" class="headerlink" title="13. 重载和重写？深拷贝和浅拷贝？"></a>13. 重载和重写？深拷贝和浅拷贝？</h2><ol>
<li>重载和重写：重载是方法名相同参数不同；重写是继承父类方法并重写它。</li>
<li>深拷贝和浅拷贝：浅拷贝是拷贝原对象的引用值；深拷贝是根据原对象创建一个新对象。</li>
</ol>
<h2 id="14-方法的四种类型"><a href="#14-方法的四种类型" class="headerlink" title="14. 方法的四种类型"></a>14. 方法的四种类型</h2><p>无参无返回值、无参有返回值、有参无返回值、有参有返回值。</p>
<h2 id="15-常见设计模式"><a href="#15-常见设计模式" class="headerlink" title="15. 常见设计模式"></a>15. 常见设计模式</h2><h2 id="16-List、Set、Map三者的联系和区别"><a href="#16-List、Set、Map三者的联系和区别" class="headerlink" title="16. List、Set、Map三者的联系和区别"></a>16. List、Set、Map三者的联系和区别</h2><p><code>List</code> 和 <code>Set</code> 接口都属于 <code>Collection</code> 接口， <code>Map</code> 接口与 <code>Collection</code> 接口同级。</p>
<p>其中：</p>
<ol>
<li>List中的元素可重复，具有有序性；</li>
<li>Set中的元素不可重复，具有无序性；</li>
<li>Map采用key-value的形式存储元素，key值不可重复。</li>
</ol>
<h2 id="17-HashMap-和-HashTable、HashSet、TreeMap-的区别"><a href="#17-HashMap-和-HashTable、HashSet、TreeMap-的区别" class="headerlink" title="17. HashMap 和 HashTable、HashSet、TreeMap 的区别"></a>17. HashMap 和 HashTable、HashSet、TreeMap 的区别</h2><ol>
<li>HashMap底层由 <code>链表 + 数组 + 红黑树</code> 实现，当链表长度 <code>&gt;=8</code> 、数组长度 <code>超过64</code> 时转换为红黑树，非线程安全，可以存储 <code>null</code> 键和 <code>null</code> 值，初始 <code>size = 16</code> ，扩容方式为 <code>newsize = oldsize * 2</code> 先插入再扩容；</li>
<li>HashTable底层由 <code>链表 + 数组</code> 实现，通过在方法和对象前添加 <code>syncronized</code> 关键字来保证线程安全，不可以存储 <code>null</code> 键 <code>null</code> 值，初始 <code>size = 11</code> ，扩容方式为 <code>newsize = olesize * 2 + 1</code> 先扩容再插入；</li>
<li>HashSet底层由HashMap实现，其中的HashMap仅存在key，value都是同一个object，非线程安全；</li>
<li>TreeMap底层由红黑树实现，是有序的 <code>key-value</code> 组合，非线程安全，存入TreeMap的元素应该实现Comparable或Comparator接口，会按照排序后的顺序迭代元素，元素插入时对元素自动排序，迭代输出就按顺序输出。</li>
</ol>
<h2 id="18-HashMap的底层原理"><a href="#18-HashMap的底层原理" class="headerlink" title="18. HashMap的底层原理"></a>18. HashMap的底层原理</h2><p>HashMap的底层由数组+链表+红黑树的形式实现，数组中的元素为内部类Node节点。</p>
<p>具体实现如下：</p>
<ol>
<li>首先对key值进行二次哈希，然后将结果对数组长度取模，存入对应下标；</li>
<li>如果没有哈希冲突，直接创建Node存入下标对应的位置；</li>
<li>如果存在哈希冲突，先equals查看是否有相同元素，有则更新，没有则判断链表高度插入链表，如果链表高度到8、数组长度超过64转变为红黑树存储，长度低于6转变为链表存储。</li>
</ol>
<p>当数组长度不够，需要进行扩容的时候，会根据扩容因子new一个新的数组，再将旧数组的元素放入新数组使用，扩容因子默认是0.75。</p>
<p>其中提出的二次哈希，是为了对key的hashCode进行扰动计算，防止不同hashCode的高位不同但低位相同导致的hash冲突。简单来说就是把高位的特征和低位的特征组合起来，降低哈希冲突的概率，尽量做到任何一位的变化都对最终的结果产生影响。</p>
<h2 id="19-ConcurrentHashMap与HashTable的区别"><a href="#19-ConcurrentHashMap与HashTable的区别" class="headerlink" title="19. ConcurrentHashMap与HashTable的区别"></a>19. ConcurrentHashMap与HashTable的区别</h2><p>有两个区别：</p>
<ol>
<li><p>底层数据结构：HashTable由 <code>数组 + 链表</code> 组成，ConcurrentHashMap 由 <code>数组 + 链表 + 红黑树</code> 组成；</p>
</li>
<li><p>实现线程安全的方式：</p>
<p>（1）HashTable使用 <code>Syncronized</code> 关键字实现线程安全，将所有方法和对象都上了锁，在高并发的情况下，同一时刻只能有一个线程操作，其他线程会被阻塞等待，并发度低；</p>
<p>（2）ConcurrentHashMap采用了更细粒度的锁来提高并发情况下的效率，ConcurrentHashMap将hash表默认分为16个桶，每个桶可以看作是一个hashtable，诸如get、put、remove等写操作只需要锁当前需要的桶，在理想状态下，原来同一时刻只能进入一个线程，现在能同时进入16个，并发性的提升显而易见；因为在读取的大多数情况不需要锁，所以读取操作几乎是完全的并发操作。</p>
</li>
</ol>
<h2 id="20-ConcurrentHashMap底层原理"><a href="#20-ConcurrentHashMap底层原理" class="headerlink" title="20. ConcurrentHashMap底层原理"></a>20. ConcurrentHashMap底层原理</h2><p>​        首先了解为什么使用ConcurrentHashMap。在并发编程下使用HashMap可能导致死循环，而使用线程安全的HashTable效率又非常低下，于是引出了ConcurrentHashMap。HashTable效率低的原因很明显，因为HashTable使用Synchronized关键字，所以在并发时只能运行一个线程，而将其他线程阻塞等待；HashMap导致死循环的原因是put操作扩容，假设有两个线程A和B要同时进行扩容，此时数组中下标为1对应的链表指向是 a - b - c，扩容需要将他们迁移到新数组，这里假设abc迁移后在同一下标4，进行扩容操作有两个指针 e 和 next，A先执行，假设当 e &#x3D; a，next &#x3D; b 的时候cpu时间片用完，会暂停A的执行，由B开始执行，因为是头插法，插入的顺序是将e.next &#x3D; newtable[4]，newtable[4] &#x3D; e,e &#x3D; next。B会将 abc 全都放到newtable[4]的空间中，然后时间片用完，A继续执行，在B线程将 b 指向 a，在这里又将 a 指向 b，此时就产生了死循环。</p>
<p>​         而ConcurrentHashMap应用在多线程的优点在于它的数据结构。</p>
<p>​        在JDK1.7底层采用：segment + HashEntry数组结构组成，实现的思路是先将数据分成一段一段地存储，然后给每一段数据配一把锁，这样当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问，这就是锁分段技术。其中Segment继承了ReetrantLock可重入锁接口，所以自带了锁的功能，让每一个片段都有了锁；HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构。一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁。</p>
<p>​        JDK1.8底层与HashMap底层结构一致，将锁的粒度调整到每个数组元素加锁，并且定位节点的hash算法被简化，导致hash冲突加剧，因此在链表长度大于8时，会将链表转换为红黑树存储，这样一来，查询的时间复杂度就从O(n)转变为O(logn)。</p>
<p>​        对于锁的设计，JDK1.8取消了Segment分段锁，采用了CAS+Synchronized来保证并发安全。当执行<code>put</code>方法插入数据时，定义一个Node节点 <code>f</code>，如果 <code>f == null</code>，则相应位置的<code>Node</code>还未初始化，通过CAS插入相应的数据；如果 <code>f.hash == -1</code>，说明当前有其他线程正在扩容，则一起进行扩容操作；如果是其余情况就是把新的node节点按照链表或红黑树的方式插入到合适的位置，其中有一个binCount变量用于判断当前链表长度是否&gt;&#x3D;8。</p>
<p>​        JDK1.8中还使用一个volatile类型的变量baseCount记录元素的个数，用于判断是否扩容，当插入新数据或删除元素时，会通过 <code>addCount()</code> 方法更新 <code>baseCount</code> 。具体的实现过程是：先利用CAS方法更新baseCount的值，然后检查是否需要扩容，默认check&#x3D;1时需要检查；如果满足扩容条件，即 <code>map.size() &gt;= sizeCTL</code>，此处 <code>sizeCtl</code> 为扩容阈值，判断当前是否正在扩容，如果是正在扩容就一起扩容，如果不在扩容就将 <code>sizeCtl</code> 更新为负数，并进行扩容处理。</p>
<h2 id="21-Comparable-和-Comparator-的区别"><a href="#21-Comparable-和-Comparator-的区别" class="headerlink" title="21. Comparable 和 Comparator 的区别"></a>21. Comparable 和 Comparator 的区别</h2><ol>
<li>Comparable是内部比较器，实现该接口意味着该类支持排序，不需要额外实现比较器，比较简单，但是需要修改源代码；</li>
<li>Comparator是外部比较器，当需要控制某个类的次序，而该类本身不支持排序，可以自定义一个该类的比较器进行排序，好处是不需要修改源代码，只需要自定义一个比较器。</li>
</ol>
<h2 id="23-HashSet如何检查重复"><a href="#23-HashSet如何检查重复" class="headerlink" title="23. HashSet如何检查重复"></a>23. HashSet如何检查重复</h2><p>当对象 <code>add</code> 到 <code>HashSet</code> 中，首先获取对应的HashCode，判断对象插入的位置，如果没有相同HashCode的对象存在，则成功加入，否则调用 <code>equals</code> 方法判断两个 <code>HashCode</code> 相同的对象是否真的相等，如果相等，加入失败。</p>
<h2 id="24-静态编译和动态编译"><a href="#24-静态编译和动态编译" class="headerlink" title="24. 静态编译和动态编译"></a>24. 静态编译和动态编译</h2><ol>
<li>静态编译：一次编译，在程序运行前将所有模块全都编译进去；</li>
<li>动态编译：按需编译，在程序运行过程中，需要用到哪个模块再编译哪个模块。</li>
</ol>
<h2 id="25-反射机制"><a href="#25-反射机制" class="headerlink" title="25. 反射机制"></a>25. 反射机制</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>反射的概念是在运行状态中，对于任何一个类，都能知道它的所有属性和方法；对于任何一个对象，都能调用它的任意一个方法和属性。这种动态获取信息和动态调用对象方法的功能叫做反射机制。</p>
<h3 id="为什么使用反射"><a href="#为什么使用反射" class="headerlink" title="为什么使用反射"></a>为什么使用反射</h3><p>先抛开概念化的定义，看下面的两段代码：</p>
<p>例子：实现创建一个动物对象 <code>cat</code> 并调用 <code>run</code> 方法计算它跑两公里的距离。</p>
<p>不用反射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal cat = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="keyword">double</span> distance = cat.run(<span class="number">2d</span>);</span><br></pre></td></tr></table></figure>

<p>用反射：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取动物类的反射对象</span></span><br><span class="line">Class clz = Class.forName(<span class="string">&quot;com.self.example.Animal&quot;</span>);</span><br><span class="line"><span class="comment">// 获取奔跑方法的反射对象</span></span><br><span class="line">Method met = clz.getMathod(<span class="string">&quot;run&quot;</span>, <span class="keyword">double</span>.class);</span><br><span class="line"><span class="comment">// 获取构造方法的反射对象</span></span><br><span class="line">Constructor cons = clz.getConstructor();</span><br><span class="line"><span class="comment">// 通过反射实例化对象</span></span><br><span class="line">Object obj = cons.newInstance();</span><br><span class="line"><span class="comment">//通过反射调用奔跑方法</span></span><br><span class="line">Object distance = met.invoke(obj, <span class="number">2d</span>);</span><br></pre></td></tr></table></figure>

<p>看起来，反射将两行代码可以解决的问题扩展到了五行代码解决，将简单的事情写复杂化了，但是反射传入的是字符串，如果将字符串提出来，比如放到配置文件中，或者在程序运行的时候传参，这样的程序就会变得非常动态了。</p>
<p>已知Java程序要运行，需要先将源代码通过javac转变为字节码，然后通过Java解释和执行字节码。Java是静态语言，变量的类型在编译前就需要确定，否则编译不能通过，这样限制了程序的灵活性，所以许多静态语言扩展出了动态的反射机制，以能够动态的获取对象信息和调用对象的方法。</p>
<h3 id="反射的基本使用"><a href="#反射的基本使用" class="headerlink" title="反射的基本使用"></a>反射的基本使用</h3><p>首先创建一个 <code>Hello</code> 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bonnie.example;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2022/1/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello &quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着在 <code>resource</code> 文件夹下创建一个属性文件 <code>property.properties</code> 存放 <code>hello</code> 类的信息，以便能够动态修改：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">className</span>=<span class="string">com.bonnie.example.Hello</span></span><br><span class="line"><span class="attr">methodName</span>=<span class="string">sayHello</span></span><br></pre></td></tr></table></figure>

<p>最后反射该类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bonnie.example;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2022/1/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">reflectTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reflect</span><span class="params">(String name )</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取配置文件内容</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        ClassLoader classLoader = reflectTest.class.getClassLoader();</span><br><span class="line">        InputStream inputStream = classLoader.getResourceAsStream(<span class="string">&quot;property.properties&quot;</span>);</span><br><span class="line">        pro.load(inputStream);</span><br><span class="line">        String classname = pro.getProperty(<span class="string">&quot;className&quot;</span>);</span><br><span class="line">        String methodname = pro.getProperty(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 获取类对象</span></span><br><span class="line">        Class clz = Class.forName(classname);</span><br><span class="line">        <span class="comment">// 3. 获取实例对象</span></span><br><span class="line">        Object obj = clz.getConstructor().newInstance();</span><br><span class="line">        <span class="comment">// 3. 调用set方法存数据</span></span><br><span class="line">        Method set_method = clz.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        set_method.invoke(obj, <span class="keyword">new</span> Object[]&#123;name&#125;);</span><br><span class="line">        <span class="comment">// 4. 调用 methodname 对应的方法显示</span></span><br><span class="line">        Method get_method = clz.getMethod(methodname);</span><br><span class="line">        get_method.invoke(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        reflectTest reflect = <span class="keyword">new</span> reflectTest();</span><br><span class="line">        reflect.reflect(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>Class</code> 类是 <code>Reflection API</code> 中的核心类，主要方法如下：</p>
<ul>
<li>getName()：获得类的完整名字。 getFields()：获得类的public类型的属性。</li>
<li>getDeclaredFields()：获得类的所有属性。</li>
<li>getMethods()：获得类的public类型的方法。</li>
<li>getDeclaredMethods()：获得类的所有方法。</li>
<li>getMethod(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes参数指定方法的参数类型。</li>
<li>getConstrutors()：获得类的public类型的构造方法。</li>
<li>getConstrutor(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes参数指定构造方法的参数类型。</li>
<li>newInstance()：通过类的不带参数的构造方法创建这个类的一个对象。</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点有：</p>
<ol>
<li><p>增加程序的灵活性，避免将程序写死在代码里；</p>
<p>比如一个接口中有若干个实现类，这些类在程序中被频繁使用，可以编写配置文件放接口和实现类，如果改动只需要修改配置文件，就可以利用 <code>Class.forName(class_name).newInstance()</code> 反射获取对应实例。</p>
</li>
<li><p>提高代码的复用率，外部调用方便；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.yonyong.reflection.testdemo;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span> </span>&#123; <span class="comment">//水果接口</span></span><br><span class="line">　 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>; <span class="comment">//吃水果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123; <span class="comment">//定义苹果</span></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　　　System.out.println(<span class="string">&quot;**吃苹果。&quot;</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　　　System.out.println(<span class="string">&quot;**吃橘子。&quot;</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Fruit <span class="title">getInstance</span><span class="params">(String className)</span></span>&#123;</span><br><span class="line">　　　　Fruit fruit = <span class="keyword">null</span> ;</span><br><span class="line">　　　　<span class="keyword">try</span>&#123;</span><br><span class="line">　　　　　　fruit = (Fruit) Class.forName(className).newInstance() ;</span><br><span class="line">　　　　&#125;<span class="keyword">catch</span>(Exception e )&#123;</span><br><span class="line">　　　　　　e.printStackTrace() ;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　<span class="keyword">return</span> fruit ;</span><br><span class="line">　 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryDemo</span></span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">　　<span class="comment">//通过工厂类取得接口实例，传入完整的包.类名称</span></span><br><span class="line">　　　　Fruit f = Factory.getInstance(<span class="string">&quot;cn.yonyong.reflection.testdemo.Apple&quot;</span>) ;</span><br><span class="line">　　　　<span class="keyword">if</span>(f!=<span class="keyword">null</span>)&#123; <span class="comment">//判断是否取得接口实例</span></span><br><span class="line">　　　　　　f.eat() ;</span><br><span class="line">　　　&#125;</span><br><span class="line">　 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要添加一个西瓜类，就只需要在 <code>FactoryDemo</code> 中的 <code>getInstance</code> 反射对应的名称即可。</p>
</li>
<li><p>对于任意一个类，都能知道它的所有属性和方法，对于任意一个对象，都能调用它的所有方法。</p>
</li>
</ol>
<p>缺点如下：</p>
<ol>
<li>性能问题：反射包含了一些动态类型，这些部分是不能被JVM优化的，所以反射操作的效率会比非反射操作的效率低很多，应该避免在经常被执行的代码和对性能要求较高的场景中使用；</li>
<li>安全限制：通常反射需要程序的运行没有安全方面的限制，因为反射可以获取类中的任意信息，包括私有信息；</li>
<li>程序健壮性：反射允许代码执行一些正常情况不被允许的操作，比如访问私有属性和方法，所以使用反射可能会导致代码出现功能上的错误、降低可移植性等副作用。</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol>
<li>应用于反编译，将.class文件转变为.java文件；</li>
<li>常用的一些框架，如Spring的配置化就是利用反射机制来动态加载对象；</li>
<li>编译器，比如IDEA会有自动联想类的方法或属性的功能。</li>
</ol>
<h2 id="26-Java中的引用类型有哪些？"><a href="#26-Java中的引用类型有哪些？" class="headerlink" title="26. Java中的引用类型有哪些？"></a>26. Java中的引用类型有哪些？</h2><p>Java中对象的引用分为四种级别，这四种级别由高到低依次为:强引用、软引用、弱引用和虚引用。</p>
<ol>
<li><p>强引用</p>
<p>Java中默认声明的就是强引用，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object obj = new Object(); //只要obj还指向Object对象，Object对象就不会被回收</span><br><span class="line">obj = null;  //手动置null</span><br></pre></td></tr></table></figure>

<p>只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显式的将强引用赋值为null。</p>
<p>Java的对象是位于heap 中的, heap中对象从强到弱有强可及对象、软可及对象、弱可及对象、虚可及对象和不可到<br>达对象。对于对象是属于哪种可及的对象，由他的最强的引用决定。看如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String abc=<span class="keyword">new</span> string ( <span class="string">&quot;abc&quot;</span>); <span class="comment">//1</span></span><br><span class="line">SoftReference&lt;string&gt; softRef=<span class="keyword">new</span> SoftReference&lt;string&gt; (abc); <span class="comment">//2</span></span><br><span class="line">WeakReference&lt;string&gt; weakRef = <span class="keyword">new</span> WeakReference&lt;string&gt;(abc); <span class="comment">//3</span></span><br><span class="line">abc=<span class="keyword">null</span>; <span class="comment">//4</span></span><br><span class="line">softRef.clear();<span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<p>第一行在heap堆中创建内容为“abc”的对象，并建立abc到该对象的强引用，该对象是强可及的。<br>第二行和第三行分别建立对 heap中对象的软引用和弱引用，此时 heap 中的abc对象已经有3个用，显然此时abc 对象仍是强可及的。<br>第四行之后heap 中对象不再是强可及的，变成软可及的。<br>第五行执行之后变成弱可及的。</p>
</li>
<li><p>软引用</p>
<p>软引用是用来描述一些非必需但仍有用的对象。<strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong>。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。<br>在 JDK1.2 之后，用java.lang.ref.SoftReference类来表示软引用。垃圾收集器只在真正 “需要” 内存时才收集软引用对象。</p>
</li>
<li><p>弱引用</p>
<p>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong>。在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用。</p>
</li>
<li><p>虚引用</p>
<p>虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，虚引用主要用来跟踪对象被垃圾回收的活动。在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p>
</li>
<li><p>引用队列</p>
<p>引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。</p>
</li>
</ol>
<h2 id="27-JVM内存分配与回收"><a href="#27-JVM内存分配与回收" class="headerlink" title="27. JVM内存分配与回收"></a>27. JVM内存分配与回收</h2><h3 id="1-首先了解一下JVM的内存模型。"><a href="#1-首先了解一下JVM的内存模型。" class="headerlink" title="1. 首先了解一下JVM的内存模型。"></a>1. 首先了解一下JVM的内存模型。</h3><p>​        JVM的整体架构主要分为三个部分：类加载子系统、运行时数据区、执行引擎。其中类加载子系统用于把描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型；运行时数据区是将内存划分为若干个区域管理；执行引擎用于执行JVM字节码命令，主要有两种方式：编译执行和解释执行。编译执行是先一次性编译完再执行，启动慢，执行效率高；解释执行是在执行时解释一行执行一行，启动快，执行效率低。垃圾回收器用于自动管理运行时数据区的内存，将无用的内存占用清除，释放内存资源。除了上述三个部分，还有本地方法库和本地库接口，用于调用本地方法。</p>
<p>​        下面仔细说明运行时数据区的内容。</p>
<p>​        JVM启动时会向系统申请一块内存，它将这块内存划分为若干个子区域存放不同形式的数据，大致分为三个大区域：堆、栈、方法区。</p>
<ol>
<li><p>堆</p>
<p>（1）堆用来存储引用类型的数据；</p>
<p>（2）堆中的数据是无序的；</p>
<p>（3）堆中数据可以反复使用，这是设置堆的初衷；</p>
<p>（4）JVM会定时清理堆中的垃圾数据，即不会再被使用的数据，这被称为垃圾回收。</p>
</li>
<li><p>栈</p>
<p>（1）栈以方法为单元存放数据，这样的单元叫做方法栈桢；</p>
<p>（2）栈中存放的数据的有序的，遵循先进后出的规则；</p>
<p>（3）方法调用结束后，它占有的方法会被立即释放。</p>
</li>
<li><p>方法区</p>
<p>方法区是线程共享的，它存储已经被虚拟机加载的类信息如类型标志（该类是类类型还是接口类型）、常量、静态变量、即时编译（也就是静态编译）后的代码等等。</p>
</li>
</ol>
<h3 id="2-JVM内存分配："><a href="#2-JVM内存分配：" class="headerlink" title="2. JVM内存分配："></a>2. JVM内存分配：</h3><p>这里具体以一个例子来说明JVM的内存分配过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Car c = <span class="keyword">new</span> Car();</span><br><span class="line">	c.brand = <span class="string">&quot;奔驰&quot;</span>;</span><br><span class="line">	c.color = <span class="string">&quot;红色&quot;</span>;</span><br><span class="line">	c.maxSpeed = <span class="number">500</span>;</span><br><span class="line">	c.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>main</code> 栈帧入栈；</p>
</li>
<li><p><code>Car c = new Car()</code> ，因为赋值操作从右往左，先执行 <code>new Car()</code> 操作，在堆中开辟一块内存来存储这个对象，然后将变量 <code>c</code> 存储到 <code>main</code> 栈帧中，然后执行 <code>=</code> 操作；</p>
</li>
<li><p>后续三个赋值操作访问了成员变量，通过 <code>c.</code> 找到堆中的相应成员变量，进行赋值；</p>
</li>
<li><p><code>c.sun()</code> 操作将 <code>run()</code> 方法入栈。</p>
</li>
</ol>
<h3 id="3-JVM内存回收"><a href="#3-JVM内存回收" class="headerlink" title="3. JVM内存回收"></a>3. JVM内存回收</h3><h4 id="判断对象是否可以被回收（引用计数法和可达性分析算法）"><a href="#判断对象是否可以被回收（引用计数法和可达性分析算法）" class="headerlink" title="判断对象是否可以被回收（引用计数法和可达性分析算法）"></a>判断对象是否可以被回收（引用计数法和可达性分析算法）</h4><h4 id="1-引用计数法"><a href="#1-引用计数法" class="headerlink" title="1. 引用计数法"></a>1. 引用计数法</h4><p>就是给对象添加一个引用计数器，每当有一个地方引用到它就加一，引用失效就减一，任何时刻计数器为0的对象就是不能再被使用的。引用计数法实现简单，判定效率也很高，但是它很难解决对象间循环引用的问题。比如以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigsize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB]; <span class="comment">// 这个成员属性的唯一意义就是占点内存，方便在GC日志冲查看是否被回收过</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        demo objA = <span class="keyword">new</span> demo();</span><br><span class="line">        demo objB = <span class="keyword">new</span> demo();</span><br><span class="line">        </span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中的 <code>objA</code> 和 <code>objB</code> 两个对象实际上已经不可能再被访问，但是由于它们互相引用对方，导致引用计数器都无法归零，于是引用计数器都无法同之GC收集器回收他们。</p>
<h4 id="2-可达性分析算法"><a href="#2-可达性分析算法" class="headerlink" title="2. 可达性分析算法"></a>2. 可达性分析算法</h4><p>当前主流的商用语言的内存管理子系统，都是 通过可达性分析（Reachability Analysis）算法来判定对象是否存活的。这个算法的基本思路就是通过 一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过 程所走过的路径称为“引用链”（Reference Chain），如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
<p>在java语言中，常见的可作为GC Roots的对象包括下面几种：</p>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li>
<li>方法区中类静态属性引用的对象；</li>
<li>方法区中常量引用的对象；</li>
<li>本地方法栈中JNI（即一般所说的Native方法）引用的对象。</li>
</ol>
<p>这种方式可找到所以得垃圾对象，并且完美解决对象之间循环引用的问题。但是不可避免地要遍历全局所有对象，导致搜索效率不高。</p>
<h3 id="4-垃圾收集算法"><a href="#4-垃圾收集算法" class="headerlink" title="4. 垃圾收集算法"></a>4. 垃圾收集算法</h3><p>有四种垃圾收集算法。</p>
<ol>
<li><strong>标记清除算法</strong>：包括“标记”和“清除”两个过程 - 先标记出所有需要回收的对象，再统一清除掉所有被标记的对象。这种方法有两个缺点：（1）标记和清除的过程的效率都不高；（2）标记清除后可能会产生大量不连续的内存，这样在程序运行过程中，需要分配较大的对象时无法找到足够的连续内存而不得不提前触发再一次的垃圾收集操作。</li>
<li><strong>复制算法</strong>：是为了解决标记清除算法的效率问题产生的。它将内存等分为两个部分，每次只使用其中的一块。当这块内存用完了，将还存活的对象复制到另一边，然后把已使用过的这一部分全部清理掉。这种方式因为每次只对一个部分回收，内存分配就不需要考虑内存碎片的复杂情况，只需要移动堆顶指针，按顺序分配内存即可，简单高效；缺点是一次只使用一半的内存，代价太高；</li>
<li><strong>标记整理算法</strong>：如果对象存活率较高，使用复制算法需要进行多次复制，效率不高。可以使用标记整理算法，它的标记过程与标记清除算法一样，只是后续不是直接对可回收对象进行处理，而是先将所有存活对象向一端移动，然后直接清理掉除了端边界以外的所有内存；</li>
<li><strong>分代收集算法</strong>：当代商业虚拟机的垃圾收集都是采用该方法。该算法根据生命周期的不同将内存划分，一般是将堆划分为新生代和老生代，然后根据不同生代的特点选择合适的算法处理。新生代的特点是大批对象死亡，少量对象存活，可以使用复制算法，以少量存活对象的复制成本就可以完成采集；老生代因为存活率较高，没有多余的空间进行分配担保，所以使用标记清除算法或标记整理算法处理。</li>
</ol>
<h3 id="5-垃圾收集器"><a href="#5-垃圾收集器" class="headerlink" title="5. 垃圾收集器"></a>5. 垃圾收集器</h3><p>有七种垃圾收集器，其中，<code>Serial、Parallel Scavenge、Parnew</code> 是新生代收集器，<code>Serial Old、Parallel Old、CMS</code> 是老生代收集器，G1是整堆收集器，对老生代和新生代都适用。</p>
<ol>
<li><p><strong>Serial</strong>：</p>
<p>以串行的方式运行，使用复制算法，是单线程收集器，工作时其他线程会停止工作，使用复制算法收集新生代垃圾。优点是简单高效，在单个CPU环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率，是Client场景下默认的新生代垃圾收集器；</p>
</li>
<li><p><strong>ParNew</strong>：</p>
<p>是Serial的多线程版本，使用复制算法，是Server场景下的默认新生代收集器，除了性能原因外，主要是因为除了Serial，只有ParNew能与CMS配合使用；</p>
</li>
<li><p><strong>Parallel Scavenge</strong>：</p>
<p>​        它的诸多特性与ParNew非常相似，不同的地方在于，它的目标是实现可控制的吞吐量。这里的吞吐量指的是处理器用于运行用户代码的时间与处理器总消耗时间的比值，而处理器总消耗时间是处理器处理用户代码的时间和用于处理垃圾回收的时间之和。<br>$$<br>吞吐量 &#x3D;<br>\frac{处理器运行用户代码的时间}{处理器运行用户代码的时间 + 运行垃圾收集的时间}<br>$$<br>​        高吞吐量可以最高效率的利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务。Parallel Scavenge提供了两个参数用于精确控制吞吐量：MaxGCPauseMillis用于控制最大垃圾收集停顿时间、GCTimeRatio用于直接设置吞吐量大小。这里关于MaxGCPauseMillis参数有一个误区，并不是这个参数设置是值越小，就会使得垃圾收集的速度更快，垃圾收集的停顿时间是以吞吐量和新生代空间为代价换取的，系统将新生代空间调小了，垃圾收集的频率也就变高了。</p>
<p>​        Parallel Scavenge还有一个参数是区别于ParNew的重要特性：UseAdeptiveSizePolicy，启动这个参数，虚拟机就可以动态调整相关参数以提供最合适或最大的吞吐量，这种方式被称为自动调节策略，开启这个开关后，只需要设置上述两个参数之一来设置一个优化目标即可。</p>
</li>
<li><p><strong>Serial Old</strong>：</p>
<p>​        Serial Old是Serial收集器的老年代版本，也是单线程收集器，使用标记-整理算法。主要意义也是提供client模式下的虚拟机使用，在server模式下，也有两种用法：可以跟Parallel Scavenge搭配使用，不过它本身就有一个PS MarkSweep收集器供老年代使用，与Serial Old的实现几乎一样；也可以作为CMS收集器失败时的后备预案，在并发收集发生故障时使用。</p>
</li>
<li><p><strong>Parallel Old</strong>：</p>
<p>​        是Parallel Scavenge的老年代版本，支持多线程并发收集，基于标记-整理算法实现，在一些注重吞吐量或处理器资源比较稀缺的场景中，可以使用Parallel Scavenge + Parallel Old的组合。</p>
</li>
<li><p><strong>CMS</strong>：</p>
<p>​        是一种以获取最短回收停顿时间为目标的收集器，主要适用于较为关注服务响应速度、希望系统停顿时间尽可能短、以给用户带来良好的交互体验的应用。它的运作过程分为四个步骤：初始标记、并发标记、重新标记、并发清除。其中初始标记、重新标记仍然需要STW机制（STW机制就是stop the world机制，指GC过程中会产生应用程序的停顿）。</p>
<p><strong>1）初始标记</strong>：</p>
<p>​        用于标记GC Roots以及它们直接关联到的对象，从根节点出发，哪些对象被引用了，我们就认为这些对象是存活的，把它们标记上。</p>
<p>​        在这个过程之前，用户线程在正常运行，如果要GC，由于初始标记的过程是要暂停所有用户线程的，这些用户线程就需要找一个安全点（safepoint）停下来，这个所谓的安全点，就是对象引用关系不会再发生变化，但是如果有的线程正在休眠，比如线程1正在休眠，这个时候就没有办法判断这个线程有没有执行到安全点，这里就引入了安全区的概念，所谓的安全区，就是在这个代码区域内，对象的引用关系都不会发生改变，也就是说如果线程1在休眠之前进入安全区域，会标识自己进入了安全区域，当初始标记时，就不用管这个线程，当线程向从安全区域出去的时候，先看初始标记的过程是否结束，如果没有结束，就等到结束后才能从安全区域出来。</p>
<p>​        常见的GC Roots有五种：Java虚拟机栈所引用的对象、Java native栈锁引用的对象、类静态属性锁引用的对象、常量所引用的对象、以及synchronized锁引用的对象。</p>
<p><strong>2）并发标记</strong>：</p>
<p>​        初始标记阶段结束后，线程继续运行，同时并发标记也在并发运行，这里，我们引出了三色标记法的概念。</p>
<p>​        三色标记法利用三种颜色将GC对象分为三种情况：白色是没有搜索到的对象，会被判定为垃圾对象，灰色是正在搜索的对象，黑色是已经搜索完成的对象，这种对象不会被当成垃圾对象。</p>
<p>​        并发标记的过程从GC Roots直接关联的对象出发，遍历整个对象图，利用三色标记法对对象进行标记。这个过程因为是和用户线程同时跑的，所以不会有停顿现象，但是这个过程会引发另一个问题：用户线程是可以修改引用关系的。这时候，有三种情况，一种是原有的已经被标记成黑色的对象的引用关系断掉了，这种浮动垃圾可以不用管，下次再回收就行；第二种情况是对黑色的对象直接新建了一个引用关系，就做一个记录，表示这个引用是新建立的，不要去收集它；最后一种情况是灰色对象引用的一个还没有遍历到的白色对象，这个引用关系断掉了，然而黑色对象直接引用了这个白色对象，因为黑色对象不会再被遍历，所以这个白色对象被直接认为是垃圾，但是这个白色对象还没有被遍历过。这种情况有两种解决方案：增量，即把这个黑色节点变成灰色节点，重新扫描一次，CMS就是用这个方式；还有一种方式是，因为这个白色对象是从灰色节点断开的，但是我记下了原来的关系，还是按照原来的关联关系去扫描，G1收集器就是用这种方式。</p>
<p>​        并发标记的过程，指的是对这些关系作一个记录，并不会重新扫描它，这个阶段还是一次性扫描完，然后把有更改的部分记录下来，然后在到下一个安全点的时候，开始重新标记更改的部分。</p>
<p><strong>3）重新标记</strong>：</p>
<p>​        这个过程就是重新扫描标记一遍并发标记过程出现变化的对象。</p>
<p><strong>4）并发清除</strong>：</p>
<p>​        重新标记结束后，就启动清理线程，和其他用户线程并发执行，将被标记清除的对象一次性清除掉。</p>
<p><strong>CMS有以下缺点：</strong></p>
<p>1）CMS收集器对CPU资源非常敏感,在并发阶段虽然不会导致用户线程停顿，但是会占用一部分CPU资源，如果在CPU资源不足的情况下应用会有明显的卡顿。</p>
<p>2）无法处理浮动垃圾：在执行‘并发清理’步骤时，用户线程也会同时产生一部分可回收对象，但是这部分可回收对象只能在下次执行清理时才会被回收。如果在清理过程中预留给用户线程的内存不足就会出现‘Concurrent Mode Failure’,一旦出现此错误时便会切换到SerialOld收集方式。<br>3）使用标记清除算法会导致每次垃圾回收后产生大量空间碎片，这给大对象的分配带来很大的问题，往往会出现老年代还有很多剩余空间，但就是不能找到足够的连续空间来存储连续对象。</p>
</li>
<li><p><strong>G1</strong>：</p>
<p>​        为了解决CMS算法产生空间碎片以及一系列的问题，提出了G1收集器，该收集器使用 UseG1GC 参数来启用，主要应用于多CPU大内存的场景，在满足高吞吐量的同时，尽可能的缩短STW的时间，也就是垃圾回收的停顿时间。</p>
<p>​        G1仍然遵循分代收集的理论，但内部不再坚持固定大小和数量的划分，而是把JAVA内存空间划分为多个大小相等的独立区域region，每个region都可以根据需要，扮演新生代的Eden空间、Survivor空间、老年代空间或特殊的Humorous区域，这个Humorous区域用于存储大对象，G1认为只要大小超过一个region容量一半以上的对象就被判定为大对象，直接在新的一至多个region中分配，标记为H区，在大多数情况下，G1会把H区当作O区，也就是老年代空间的一部分看。收集器对不同类型的region采用不同的方式处理，这样无论是新创建的对象还是已经存活一段时间、熬过多次收集的旧对象都能取得很好的收集效果。其中每个region的大小可以通过设置参数 G1HeapRegionSize 设定，取值范围是 1~32MB 的2的幂次方值。</p>
<p>​        G1中的新生代和老年代都是一系列不需要连续的动态集合，它将region作为单次回收的最小单元，这样可以有计划的避免在整个Java堆中进行全区域的垃圾收集。更具体的思路就是让G1跟踪每个region里垃圾堆积的“价值”大小，价值即回收获得的空间大小以及回收所需时间的经验值，然后在后台维护一张优先级列表，每次根据用户设定允许的停顿时间，有限处理回收价值最大的region，这也是G1名字的由来。这种使用region划分内存空间，以及具有优先级的区域回收方式，保证了G1在有限的时间内获取尽可能高的收集效率。</p>
<p>​        G1的运作过程与CMS大致相同，分为以下四个步骤：</p>
<p>1）初始标记：仅标记GC Roots直接关联到的对象，并且修改tams指针的值，让下一阶段用户线程并发运行时，能正确的在可用的region上分配对象。这个阶段需要停顿线程，但耗时较短，而且是借用进行Minor GC的时候同步完成的，所以这个阶段实际上并没有额外的停顿。上述提到的tams指针是为了解决GC与用户线程并发运行时，GC回收过程中产生新对象的问题而设计的，有两个tams指针，从region区域划出一部分空间用于记录并发回收过程中出现的新对象，这样的对象被认为是存活的，不纳入垃圾收集的范围。而MinorGC是新生代的垃圾收集，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</p>
<p>2）并发标记：从GC Roots开始对堆中对象进行可达性分析，递归遍历整个堆的对象，找出要回收的对象，这个阶段与用户程序并发执行；</p>
<p>3）最终标记：对用户线程作一个短暂的停顿，用于标记并发阶段变化的部分；</p>
<p>4）筛选回收：负责更新region的统计数据，对各个region的回收价值和成本进行排序，根据用户所期望的停顿时间来指定回收计划，可以自由选择任意多个region构成回收集，然后把决定回收的这一部分region的存活对象复制到空的region中，再清理整个旧region空间。这里的操作涉及存活对象的移动，必须暂停所有用户线程，由多条收集器线程并发完成。</p>
</li>
</ol>
<p>​        G1和CMS之间的比较如下：</p>
<p>1）与CMS的标记清除算法不同，G1使用标记整理算法，但从局部的两个region上看又是基于复制算法实现的，这两种算法都让G1在运行期间不会产生空间碎片，垃圾收集后能提供规整的可用内存，这种特性有利于程序的长时间运行，不会因为大对象无法得到分配而提前进行下一次垃圾收集。</p>
<p>2）从内存占用上，G1和CMS都使用卡表来处理跨代指针（卡表用于记录年代之间的引用），但G1的卡表更复杂，且每个region都有一份，这导致G1的记忆集可能会占整个堆容量的20%甚至更多空间；而CMS的卡表只有一份，且只需要处理老年代到新生代的引用，反过来不需要，由于新生代具有朝生夕死的不稳定性，引用变化频繁，能省下这个区域的维护开销是划算的。</p>
<p>3）相比起CMS的增量更新算法，原始快照算法能减少并发标记和重新标记阶段的消耗，避免CMS那样在最终标记阶段停顿时间过长的缺点， 但是在用户程序运行过程中确实会产生由跟踪引用变化带来的额外负担。</p>
<h2 id="28-进程和线程的区别和联系"><a href="#28-进程和线程的区别和联系" class="headerlink" title="28. 进程和线程的区别和联系"></a>28. 进程和线程的区别和联系</h2><ol>
<li>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</li>
<li>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的 实时性，实现进程内部的并发；</li>
<li>一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；</li>
<li>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。</li>
</ol>
<h2 id="29-并行与并发"><a href="#29-并行与并发" class="headerlink" title="29. 并行与并发"></a>29. 并行与并发</h2><p><strong>1. 并发：</strong></p>
<p>指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是利用系统CPU的时间分片功能，使多个进程快速交替的执行。</p>
<p><strong>2. 并行：</strong></p>
<p>指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。</p>
<p><strong>3. 场景分析：</strong></p>
<p>一个应用程序可以是并发的，但不能是并行的，这意味着它可以同时处理多个任务，但是没有两个任务可以同时执行。</p>
<p>一个应用程序可以是并行的，但不能是并发的，这意味着它可以同时处理多核CPU中一个任务的多个子任务。</p>
<p>一个应用程序既不能是并行的，也不能是并发的，这意味着它一次顺序地处理所有任务。</p>
<p>一个应用程序可以是并行的，也可以是并发的，这意味着它可以同时在多核CPU中同时处理多个任务。</p>
<h2 id="30-线程的生命周期和状态"><a href="#30-线程的生命周期和状态" class="headerlink" title="30. 线程的生命周期和状态"></a>30. 线程的生命周期和状态</h2><p>线程一共有五种状态：新生态、就绪态、运行态、阻塞态、死亡态。这五种状态统称线程的生命周期。线程在同一时刻只会处于一种状态。下面简述这五种状态：</p>
<ol>
<li><p>新生态：当线程对象创建后，就进入了新生状态：Thread t &#x3D; new Thread();</p>
</li>
<li><p>就绪态：当调用线程对象的 <code>start()</code> 方法，就进入了就绪状态。处于就绪状态的线程，只是说明词线程已经做好准备，随时等待CPU调度执行，并不是说调用了 <code>start()</code> 方法线程就会立即执行；</p>
</li>
<li><p>运行态：当CPU开始调度处于就绪状态的线程时，该线程真正开始执行，想要进入运行态，就绪态是唯一的入口；</p>
</li>
<li><p>阻塞态：处于运行态的线程因为某种原因暂时放弃了CPU的使用权，停止执行，进入阻塞状态，阻塞态可用分为三种：</p>
<p>（1）等待阻塞：运行态中的线程调用 <code>wait()</code> 方法，使线程进入等待阻塞状态；</p>
<p>（2）同步阻塞：线程获取Synchronized锁失败，因为此时该锁被其他线程占用，该线程进入同步阻塞状态；</p>
<p>（3）其他阻塞：调用线程的 <code>sleep()</code> 或 <code>join()</code> 方法或发出I&#x2F;O请求时，会使得线程进入阻塞状态，当 <code>sleep()</code> 超时或 <code>join()</code> 等待线程终止或超时、或I&#x2F;O处理完毕，线程会重新进入就绪态；</p>
</li>
<li><p>死亡态：线程执行完毕或异常退出，该线程结束生命周期。</p>
</li>
</ol>
<p><strong>允许状态的转换：</strong></p>
<ol>
<li>就绪态转换为运行态：线程得到CPU资源；</li>
<li>运行态转换为就绪态：线程主动调用 <code>yield()</code> 方法或在运行过程中失去CPU资源；</li>
<li>运行态转换为死亡态：线程执行完毕或出现异常</li>
</ol>
<h2 id="31-线程死锁"><a href="#31-线程死锁" class="headerlink" title="31. 线程死锁"></a>31. 线程死锁</h2><ol>
<li><p>概念：死锁指的是两个线程互相拥有对方所需要的资源，由于synchronized的特性，一个线程持有一个资源，或者说获得了一个锁，在该线程释放这个锁之前，其他线程是获取不到这个锁的，并会一直等下去，这就造成了死锁。</p>
</li>
<li><p>死锁产生的必要条件：</p>
<p>（1）互斥条件：一个锁只能被一个线程占用，当一个线程占用一个锁，该锁在被该线程释放前，其他线程都不能获取这个锁；</p>
<p>（2）不剥夺条件：锁只能由当前占用的线程释放，不能由其他的线程强行剥夺；</p>
<p>（3）请求和保持条件：线程已经获得一个锁，再获取另一个锁的过程中，即使获取不到也不会释放已经获得的锁；</p>
<p>（4）循环等待条件：两个线程互相拥有对方需要的锁。</p>
</li>
<li><p>如何避免死锁：</p>
<p>（1）加锁顺序：线程按照相同的顺序加锁；</p>
<p>（2）加锁时限：线程获取锁的过程限制等待的时间，这需要用到锁的一些API。</p>
<p>（3）死锁检测：是一种更好的死锁预防机制，针对前两种方法解决不了的情况。当一个线程获得了锁，会在线程和锁相关的数据结构中记下，比如map，除此之外，每当有线程请求锁，也会记录在这个数据结构中，当一个线程获取锁失败，就可以遍历这个数据结构查看是否有死锁发生。</p>
</li>
</ol>
<h2 id="32-线程池的原理及使用"><a href="#32-线程池的原理及使用" class="headerlink" title="32. 线程池的原理及使用"></a>32. 线程池的原理及使用</h2><p>​        线程池就是在系统启动或者实例化线程池的时候创建一些空间线程，等待工作调度，执行完任务后，这些线程不会被立即销毁，而是重新处于空闲状态，等待下一次调度。由于线程的创建和销毁需要消耗大量资源，这种方式就可以节省很多不必要的花销，而且响应快，不用等待创建，需要的时候自取就可以了。</p>
<p>​        Java中常见的线程池有四种：</p>
<ol>
<li>newSingleThreadExecutor()单一线程池：内部只有一个线程工作，可用保证程序的执行顺序；</li>
<li>newCachedThreadExecutor()可缓存线程池：如果线程池中有可用的线程，就使用，没有就新建。可缓存线程池的最大线程数是Integer类型变量的最大值，通常用它来运行一些执行时间较短且经常用到的任务；</li>
<li>newFixedThreadPool(int nThread)定长线程池：可用控制线程的最大并发数，超出的线程在队列等待；</li>
<li>newScheduledThreadPool(int corePoolSize)定长线程池：支持定时及周期性任务执行；</li>
<li>也可以创建一个自定义线程池，使用ThreadPoolExecutor类创建。</li>
</ol>
<p>​        线程池的工作机制是：任务首先提交给线程池，由线程池寻找空闲的线程来执行任务，如果没有空闲的线程，就将任务放进等待队列中，等待空闲线程，如果超出了线程池最大接受的工作量，就会触发拒绝策略。</p>
<p>​        其中拒绝策略有四个：</p>
<ol>
<li>AbortPolicy()：直接抛出RejectedExecutionException异常；</li>
<li>CallerRunsPolicy()：调用run方法阻塞执行；</li>
<li>DiscardPolicy()：直接丢弃后来的任务；</li>
<li>DiscardOldestPolicy()：丢弃队列中队首的任务。</li>
</ol>
<p>线程池具体的执行流程如下：</p>
<p>​        提交任务以后，首先查看线程池内的核心线程数有没有满，这个核心线程数指的是线程池中即使没有任何任务也会有指定数量的线程在等待调度，没有满就创建线程执行任务；如果满了，就判断等待队列有没有满，没有满就将任务放进等待队列等待；如果满了，再判断线程池有没有满，没有满，就创建线程执行任务；如果还是满了，就启动拒绝策略处理。</p>
<p>​        线程池的具体使用如下：</p>
<p>先创建一个 <code>myThread</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bonnie;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2022/1/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在进行......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如使用 newCachedThreadExecutor 线程池处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bonnie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * created by Bonnie on 2022/1/24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">cachedThreadExecutorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> myThread();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> myThread();</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> myThread();</span><br><span class="line"></span><br><span class="line">        pool.execute(t1);</span><br><span class="line">        pool.execute(t2);</span><br><span class="line">        pool.execute(t3);</span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pool-1-thread-2正在进行......</span><br><span class="line">pool-1-thread-3正在进行......</span><br><span class="line">pool-1-thread-1正在进行......</span><br></pre></td></tr></table></figure>



<h2 id="33-互斥、自旋、读写、悲观、乐观锁"><a href="#33-互斥、自旋、读写、悲观、乐观锁" class="headerlink" title="33. 互斥、自旋、读写、悲观、乐观锁"></a>33. 互斥、自旋、读写、悲观、乐观锁</h2><ol>
<li>互斥锁：一个线程访问共享资源前会对线程访问的这段代码加锁，加锁之后没有释放锁，其他想要访问临界资源的线程会被阻塞睡眠，直到解锁，如果阻塞了多个线程，解锁的时候，这些线程都转换为就绪状态，第一个变为就绪态的线程获取资源的使用权，其他线程继续阻塞等待；</li>
<li>读写锁：也叫共享互斥锁，读模式共享，写模式互斥，即只有一个线程能占有写模式的读写锁，可以有多个线程占用读模式的读写锁。在写加锁模式下，任何线程进行写加锁操作都会被阻塞，直到解锁；在读加锁模式下，任何线程都可以进行读加锁操作，但全部试图进行写加锁的线程都会被阻塞，直到全部读加锁的线程释放锁，可是当读线程太多，写线程一直被阻塞也不行，因此一个线程想加锁的时候，会阻塞之后的读加锁的请求，让写线程先加锁；</li>
<li>自旋锁：自旋锁和互斥锁很像，唯一不同的是自旋锁访问加锁资源时，会循环查看是否释放锁，这种方式比互斥锁更有效率，但是有两个问题：一是会一直占用CPU的资源，所以适用于多核的CPU；二是自旋锁递归调用容易造成死锁，所以得慎重使用自旋锁；</li>
<li>乐观锁：总是假设最好的情况，每次拿数据都认为其他线程不会修改，所以不会上锁，但在更新的时候会判断一下在词期间其他线程有没有更新这个数据，可用使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可用提高吞吐量；</li>
<li>悲观锁：总是假设最坏的情况，每次拿数据都会认为其他线程会修改，所以在拿数据的时候都会上锁，想获取这个锁的线程会被阻塞直到当前线程释放锁。</li>
</ol>
<h2 id="34-Synchronized锁源码"><a href="#34-Synchronized锁源码" class="headerlink" title="34. Synchronized锁源码"></a>34. Synchronized锁源码</h2><p>首先介绍两个概念：</p>
<h4 id="1-cas"><a href="#1-cas" class="headerlink" title="1. cas"></a>1. cas</h4><p>CAS算法的原理：</p>
<p>​        CAS算法的全称是比较和交换，可以看成是一个自旋锁。下面以一个例子来说明：</p>
<p>​        假设有多线程任务，2个线程同时完成对一个共享变量 <code>i</code> 的减法，假设该算法只有三个步骤：<code>get共享变量的值、更新值、将更新的值put回共享变量</code>，不使用CAS算法的运行过程中，可能将前两个步骤完成，然后在要执行第三个步骤的时候被CPU的时间片切出去，第二个线程开始执行，这时候由于两个线程 <code>get</code> 的值一样，最终所得的结果肯定也是一样的；如果使用CAS算法，可以简单的使用 <code>atomic</code> 变量来保证多线程环境下能无锁进行原子操作，接着在 <code>get</code> 方法设置一个E值，即旧的值，计算步骤完成后，将E值和共享变量内的值比较，如果相同，交换共享变量内的值为更新的值，否则线程再运行一遍，重新获取值进行运算，这也可以称为自旋锁。这个atomic变量保证了这个CAS算法不会存在多线程问题，因为这个变量的核心函数是CPU本地提供的，而CPU都是一行一行执行的，不会存在并行过程。</p>
<p>CAS机制的问题：</p>
<p>​        ABA问题 - 即假设有两个线程对一个共享变量进行操作，这个值初始为A，第一个线程首先将值修改成了B，然后又改回了A，第二个线程因为比较慢，它获取的E值是A，最后比较的时候第一个线程已经完成了两次修改，共享变量的值还是A，所以对第二个线程来说，共享变量值没有被其他线程改动，是安全的。</p>
<p>​        这种可能有两种情况：如果共享变量是基本数据类型，是否改动是不重要的；如果是引用类型，其中的属性可能会发生变化。</p>
<p>​        解决方案：加版本号或时间戳来区分。</p>
<p>​        但是这种方式比较繁琐，不如使用加锁机制。比如有多个线程要进行一个业务操作，只要有一个线程获得这个锁进行业务操作，其他线程发现这个锁被占用了，就会阻塞，但是不是让线程自旋等待，而是等到这个锁被释放了，这个锁会通知所有等待该锁的线程它被释放了。</p>
<p>​        目前CAS在jdk中主要应用于Atomic相关类中，比如AtomicInteger、AtomicLong等。</p>
<h4 id="2-对象头"><a href="#2-对象头" class="headerlink" title="2. 对象头"></a>2. 对象头</h4><p>虚拟机中，对象在内存中存储的布局分为三个部分：对象头、实例数据和对齐填充。</p>
<p>其中对象头包含两部分信息：</p>
<p>（1）mark word：用于存储运行时数据，比如hashcode、GC分代年龄等；</p>
<p>（2）klass pointer：是对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p>
<p>当对象是数组时，对象头中还需要包含数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但无法确定数组长度的大小。</p>
<p>Synchronized源码使用mark word来标识对象的加锁状态。</p>
<h4 id="synchronized锁实现原理"><a href="#synchronized锁实现原理" class="headerlink" title="synchronized锁实现原理"></a>synchronized锁实现原理</h4><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，临界区指的是一个用于访问共享资源的代码块，它保证同一时刻只有一个线程访问，同时synchronized关键字还可以保证共享变量的内存可见性。</p>
<p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p>
<ol>
<li><strong>普通同步方法，锁是当前实例对象；</strong></li>
<li><strong>静态同步方法，锁是当前类的class对象；</strong></li>
<li><strong>同步方法块，锁是括号里面的对象。</strong></li>
</ol>
<p>其中同步代码块是使用monitorenter和monitorexit指令实现的，同步方法依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。</p>
<p><strong>同步代码块：</strong></p>
<p>　　monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；</p>
<p><strong>同步方法</strong></p>
<p>　　会被翻译成普通方法的调用和返回指令，在JVM字节码层面并没有任何特别的指令来表示这个方法被synchronized修饰的方法，而是在Class文件的方法表中将该方法的<strong>accessflags字段中的synchronized标志位置1</strong>。</p>
<p>JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。 </p>
<p>首先是自旋锁，列举一个场景，如果线程频繁的进行阻塞和唤醒，会给系统带来很大的压力，同时很多锁的持有状态只会存在很短的一段时间，为了这一段很短的时间频繁的阻塞和唤醒线程是不值得的，于是引入了自旋锁。就是让一个线程去等待一段时间，这段时间内会进行无意义的循环操作，而不会立即被挂起，会不断查看持有锁的线程有没有释放，如果释放了就可以尝试获得锁。自旋锁在jdk1.4中引用，是默认关闭的，可以使用参数开启，在jdk1.6中默认开启，同时自旋次数默认是十次，这个也可以通过参数调整。</p>
<p>​        但是无论怎么调整，都不可能知道具体是多少次，不可能满足所有的情况，所以jdk1.6引入了适应性自旋。适应性自旋锁与自旋锁的区别在于它的自旋次数是会变的，如果线程上次自旋成功了，获得了锁，那么这次自旋的次数就会增加，因为虚拟机认为如果上次成功了，这次成功的可能性会很大；反之如果自旋成功的次数很少，那么之后的自旋次数就会减少，甚至直接忽略掉自旋的过程，以免浪费处理器的资源。</p>
<p>​        接着是锁消除。比如在一个方法里用了锁，但是JVM检测到这个方法里面不存在共享数据竞争的问题，也就是共享数据在这个方法里面是线程安全的，所以就没有必要加锁，加了锁反而会影响程序的性能。所以JVM检测到这个问题之后，就会将这个锁消除。</p>
<p>​        然后是锁粗化，在使用锁的时候，应该要让锁作用的程序范围越小越好，这是为了让在锁内执行的代码尽可能少，缩短持有锁的时间，让等待锁的线程能尽快拿到锁，在大多数情况下，这样的作法是正确的，但是在某些情况下，这样的做法是不对的。比如在一段程序内，持续的进行加锁，这个时候它的加锁操作和解锁操作就会特别频繁，而且被锁住的代码都是在一块的，就会导致很多没必要的性能消耗。比如是在一个for循环内加锁，那么每次for循环都要去抢锁和释放锁，那对性能的影响是非常大的，这个时候如果把锁放到for循环外，这个时候，只要抢到锁就可以进入for循环，存粹的for循环和在for循环内加锁，二者的效率肯定会差很多。这就是锁粗化的作用。</p>
<p>​        下面说明一下synchronized锁升级的过程。从无锁状态会升级到偏向锁状态，当我们创建一个对象的时候，这个对象有一个mark word，里面存储一些数据，比如是否是偏向锁，以及它的锁标志位等，如果锁的标志位是0，说明这个对象没有被加上偏向锁，如果是1，就说明这个对象被加上了偏向锁。偏向锁可以理解成是一个偏心的锁，意思就是这个锁会偏向于第一个获得它的线程，然后在接下来的执行过程中，假如这个锁没有被其他线程竞争，那么持有偏向锁的线程就永远不需要进行同步操作；一旦有其他线程进入锁，这个时候才会撤销这个偏向锁。</p>
<p>​        偏向锁的撤销，会先到达一个全局的安全点，也就是当前没有字节码运行的一个状态，然后暂停拥有偏向锁的线程，然后判断这个线程是否存活，如果这个线程不存活，或者这个线程存活，但是已经执行完同步代码，就会将对象恢复成无锁状态；否则就将对象升级为轻量级锁状态。线程是否存活可以查看JVM中的所有线程，如果存在这个线程，这个线程就是存活的。偏向锁的撤销过程会使锁的效率大大降低，所以如果运行时存在大量多线程竞争，偏向锁会导致性能下降。这个时候应该要禁用这个偏向锁，如果不禁用，它的抢锁和撤销锁的过程会非常消耗资源。可以使用 UsebiasedLocking参数关闭偏向锁。</p>
<p>​        然后是轻量级锁。偏向锁升级之后会变成轻量级锁，轻量级锁的竞争方式是在这个mark word中使用cas算法竞争这个锁。轻量级锁就是自旋锁和适应性自旋锁，如果在自旋的这段时间里，没有获得这个锁，就会升级成重量级锁，也就是锁膨胀。</p>
<p>​        重量级锁依赖于对象内部的monitor，而monitor依赖于操作系统的互斥锁实现，所以重量级锁也被称为互斥锁。互斥锁的开销非常大，主要是因为当系统检测到这个锁是重量级锁后，会把想要获取这个锁的其他线程阻塞，被阻塞的线程是不会消耗cpu的，但是阻塞和唤醒的过程都需要操作系统帮忙，这个时候就需要从用户态转换为内核态，转换状态是非常耗时的，有可能比用户执行代码的时间还要长，所以重量级锁的开销非常大。</p>
<p>​        总结上述整个流程，偏向锁和轻量级锁都是乐观锁，而重量级锁是悲观锁，一个对象刚开始实例化的时候是没有任何线程访问的，它可以是偏向的，所以当第一个线程访问的时候，它就获得了一个偏向锁，一旦有第二个线程来访问这个对象，因为偏向锁不会主动释放，所以第二个线程就可以看到这个对象是偏向锁的状态，表明这个时候已经存在锁竞争的问题了。要竞争锁的线程，需要检查原持有锁的线程是否存活，如果不存活，就将对象转换为无锁状态，重新进行偏向锁的持有，如果原来的线程存活，就马上执行线程的操作栈，检查这个对象的使用情况，如果仍然需要持有这个偏向锁，这个时候偏向锁就会升级为轻量级锁，如果不存在这个对象的使用，就可以把这个对象恢复成无锁状态，重新进行偏向锁的竞争，然后轻量级锁会进行自旋的操作，如果超出了一定的自旋次数，还没有获取到这个锁，就会升级到重量级锁，此时除了拥有锁的这个线程的其他线程都是阻塞状态。</p>
<p>​        锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<h2 id="35-volatile、threadlocal"><a href="#35-volatile、threadlocal" class="headerlink" title="35. volatile、threadlocal"></a>35. volatile、threadlocal</h2><p> 首先应该知道并发编程的三个概念：</p>
<ol>
<li>原子性：即一个或多个操作，要不全部执行，要不全部不执行；</li>
<li>可见性：即多个线程访问一个变量，一个线程修改了这个变量，其他线程能够立即看到这个修改；</li>
<li>有序性：即程序执行的顺序按照代码的先后顺序执行。</li>
</ol>
<h3 id="1-ThreadLocal"><a href="#1-ThreadLocal" class="headerlink" title="1. ThreadLocal"></a>1. ThreadLocal</h3><p>ThreadLocal是局部变量，是线程内独享的，在进程中定义的一个变量需要在每个线程中进行拷贝，独立操作，互不干扰。</p>
<p>线程内部有个ThreadLocalMap变量，首先根据当前线程对象get到该线程的ThreadLocalMap对象，这个map定义了Entry，用于存储ThreadLocal对象以及对应的值。</p>
<p>一个线程拥有一个ThreadLocalMap对象，一个ThreadLocalMap对象可用存储多个线程的局部变量。</p>
<h3 id="2-volatile"><a href="#2-volatile" class="headerlink" title="2. volatile"></a>2. volatile</h3><p>volatile是修饰符关键字，用于修饰变量，被volatile修饰的变量意味着：</p>
<ol>
<li>一个线程对于这个变量的修改，对其他线程来说是可见的；</li>
<li>禁止编译器的重排序，对于该变量操作之前和操作之后的代码顺序不会变；</li>
<li>volatile关键字只能保变量的可见性，不能保证针对该变量的原子性。</li>
</ol>
<h2 id="36-String-和StringBuffer和-StringBuilder的区别"><a href="#36-String-和StringBuffer和-StringBuilder的区别" class="headerlink" title="36. String 和StringBuffer和 StringBuilder的区别"></a>36. String 和StringBuffer和 StringBuilder的区别</h2><p>String是字符串常量，长度不可变，用于存放字符的数组是 final 类型，所以只能赋值一次，每次更改都是new了一个对象，操作频繁会带来比较大的开销；</p>
<p>StringBuffer是线程安全的字符串变量，可以对内容进行修改，但由于使用Synchronized锁，会产生不可避免的开销；</p>
<p>StringBuilder是线程不安全的字符串变量，也可以对内容进行修改，但是非线程安全，所以可以避免锁的开销。</p>
<h2 id="37-几种线程创建方式"><a href="#37-几种线程创建方式" class="headerlink" title="37. 几种线程创建方式"></a>37. 几种线程创建方式</h2><h2 id="38-NIO和BIO"><a href="#38-NIO和BIO" class="headerlink" title="38. NIO和BIO"></a>38. NIO和BIO</h2><h3 id="39-wait和sleep用法异同"><a href="#39-wait和sleep用法异同" class="headerlink" title="39. wait和sleep用法异同"></a>39. wait和sleep用法异同</h3><h3 id="40-java中char能存放汉字吗"><a href="#40-java中char能存放汉字吗" class="headerlink" title="40. java中char能存放汉字吗"></a>40. java中char能存放汉字吗</h3><p>能。在Java中，默认使用Unicode编码方式，及每个字符占两个字节，所以可以存储中文。</p>
<p>String是由char组成，但是它采用更为灵活的方式存储：英文占一个字节，中文占两个字节。这种存储方式可以减少存储的空间，提高存储效率。</p>
<p>所以可以使用如下方式判断String中是否包含中文：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (str.getBytes().length == str.length()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;无汉字&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;有汉字&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="41-HashMap在多线程怎么实现线程安全"><a href="#41-HashMap在多线程怎么实现线程安全" class="headerlink" title="41. HashMap在多线程怎么实现线程安全"></a>41. HashMap在多线程怎么实现线程安全</h3><p>可以使用ConcurrentHashMap。</p>
<h3 id="42-String可以继承吗"><a href="#42-String可以继承吗" class="headerlink" title="42. String可以继承吗"></a>42. String可以继承吗</h3><p>不可以，因为String有final修饰符。</p>
<h3 id="43-接口中可以有构造函数吗"><a href="#43-接口中可以有构造函数吗" class="headerlink" title="43. 接口中可以有构造函数吗"></a>43. 接口中可以有构造函数吗</h3><p>因为接口不允许实例化，所以不可以有构造函数。接口只能实现，不能继承。</p>
<h3 id="44-线程安全的理解和实现"><a href="#44-线程安全的理解和实现" class="headerlink" title="44. 线程安全的理解和实现"></a>44. 线程安全的理解和实现</h3><p>​        当多个线程访问一个对象时，如果不要进行额外的同步控制或协调操作，调用这个对象的行为都可以获得正确的结果，我们就说这个对象是线程安全的。</p>
<p>​        实现线程安全的方式有很多种，常见的方式就是使用synchronized关键字给代码块或方法加锁，如StringBuffer内部就使用了Synchronized修饰。</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
